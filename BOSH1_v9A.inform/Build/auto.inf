!% -s
!% $ALLOC_CHUNK_SIZE=32000
!% $MAX_ARRAYS=10000
!% $MAX_CLASSES=200
!% $MAX_VERBS=255
!% $MAX_LABELS=200000
!% $MAX_ZCODE_SIZE=500000
!% $MAX_STATIC_DATA=180000
!% $MAX_PROP_TABLE_SIZE=200000
!% $MAX_INDIV_PROP_TABLE_SIZE=20000
!% $MAX_STACK_SIZE=65536
!% $MAX_SYMBOLS=20000
!% $MAX_EXPRESSION_NODES=256
!% $MAX_LOCAL_VARIABLES=256
!% $MAX_OBJ_PROP_COUNT=128



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Other Configuration
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant Grammar__Version 2;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Identification
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! This file was compiled by Inform 7: the build number and version of the
! I6 template layer used are as follows.
Constant NI_BUILD_COUNT "6M62";

Constant LibSerial = "080126";
Constant LibRelease = "6/12N";
Constant LIBRARY_VERSION = 612;

Constant PLUGIN_FILES;


Array UUID_ARRAY string "UUID://F61EFB05-03A9-4894-B076-9E767F9163A8//";

Global Story = BC_0;
Constant Headline BC_1;
Constant Story_Author BC_2;
Release 1;
Serial "230518";

Default Story 0;
Default Headline 0;

[ ShowExtensionVersions ;
    print "Standard Rules version 3/120430 by Graham Nelson^";
    print "Epistemology version 9 by Eric Eve^";
    print "Conversation Framework version 12 by Eric Eve^";
    print "Conversation Responses version 7 by Eric Eve^";
    print "Conversational Defaults version 3 by Eric Eve^";
    print "Formatting Capture version 2/221014 by Daniel Stelzer (based on Text Capture by Eric Eve)^";
    print "Essentials by Philip Riley^";
    print "Facts by Philip Riley^";
    print "Phones by Philip Riley^";
    print "Commerce by Philip Riley^";
    print "Furniture by Philip Riley^";
    print "Third Person Narration by Philip Riley^";
    print "Door Utils by Philip Riley^";
    print "Real People by Philip Riley^";
    print "Polish by Philip Riley^";
    print "Choices by Philip Riley^";
    print "New Light by Philip Riley^";
    print "Early Declarations by Philip Riley^";
    print "Basics by Philip Riley^";
    print "Memories by Philip Riley^";
    print "Simple Conversation by Philip Riley^";
    print "Hyperspace by Philip Riley^";
    print "BOSH Facts by Philip Riley^";
    print "Image Strip by Philip Riley^";
    print "Swamp Park by Philip Riley^";
    print "Conversations General by Philip Riley^";
    print "Margaret by Philip Riley^";
    print "Enigma Lake by Philip Riley^";
    print "Gender Options version 3/210331 by Nathanael Nerode^";
    print "Hearing by Philip Riley^";
    print "PBR Common version 2 by Philip Riley^";
    print "Walls version 1 by Philip Riley^";
    print "Floors by Philip Riley^";
    print "Ceilings version 1 by Philip Riley^";
    print "Can't Go That Way version 1/230318 by Philip Riley^";
    print "Can't Take That version 1/230318 by Philip Riley^";
    print "Exit Lister version 11 by Eric Eve^";
    print "Options Paragraph by Philip Riley^";
    print "Door Varieties by Philip Riley^";
    print "Two-Sided Doors by Philip Riley^";
];
[ ShowFullExtensionVersions ;
    print "Standard Rules version 3/120430 by Graham Nelson^";
    print "English Language version 1 by Graham Nelson^";
    print "Epistemology version 9 by Eric Eve^";
    print "Conversation Framework version 12 by Eric Eve^";
    print "Conversation Responses version 7 by Eric Eve^";
    print "Conversational Defaults version 3 by Eric Eve^";
    print "Basic Screen Effects version 7/140425 by Emily Short^";
    print "Punctuation Removal version 5 by Emily Short^";
    print "Glulx Text Effects version 5/140516 by Emily Short^";
    print "Formatting Capture version 2/221014 by Daniel Stelzer (based on Text Capture by Eric Eve)^";
    print "Essentials by Philip Riley^";
    print "Facts by Philip Riley^";
    print "Phones by Philip Riley^";
    print "Commerce by Philip Riley^";
    print "Furniture by Philip Riley^";
    print "Third Person Narration by Philip Riley^";
    print "Door Utils by Philip Riley^";
    print "Real People by Philip Riley^";
    print "Visible Rooms by Philip Riley^";
    print "Polish by Philip Riley^";
    print "Choices by Philip Riley^";
    print "New Light by Philip Riley^";
    print "Early Declarations by Philip Riley^";
    print "Basics by Philip Riley^";
    print "Memories by Philip Riley^";
    print "Simple Conversation by Philip Riley^";
    print "Hyperspace by Philip Riley^";
    print "BOSH Facts by Philip Riley^";
    print "Image Strip by Philip Riley^";
    print "Swamp Park by Philip Riley^";
    print "Conversations General by Philip Riley^";
    print "Margaret by Philip Riley^";
    print "Enigma Lake by Philip Riley^";
    print "Gender Options version 3/210331 by Nathanael Nerode^";
    print "Hearing by Philip Riley^";
    print "PBR Common version 2 by Philip Riley^";
    print "Walls version 1 by Philip Riley^";
    print "Floors by Philip Riley^";
    print "Ceilings version 1 by Philip Riley^";
    print "Can't Go That Way version 1/230318 by Philip Riley^";
    print "Can't Take That version 1/230318 by Philip Riley^";
    print "Complex Listing version 9 by Emily Short^";
    print "Exit Lister version 11 by Eric Eve^";
    print "Options Paragraph by Philip Riley^";
    print "Glulx Entry Points version 10/140425 by Emily Short^";
    print "Door Varieties by Philip Riley^";
    print "Two-Sided Doors by Philip Riley^";
];
[ ShowOneExtension 
    id ! Implied call parameter
    ;
    if (id == 1) print "Standard Rules version 3/120430 by Graham Nelson";
    if (id == 2) print "English Language version 1 by Graham Nelson";
    if (id == 3) print "Epistemology version 9 by Eric Eve";
    if (id == 4) print "Conversation Framework version 12 by Eric Eve";
    if (id == 5) print "Conversation Responses version 7 by Eric Eve";
    if (id == 6) print "Conversational Defaults version 3 by Eric Eve";
    if (id == 7) print "Basic Screen Effects version 7/140425 by Emily Short";
    if (id == 8) print "Punctuation Removal version 5 by Emily Short";
    if (id == 9) print "Glulx Text Effects version 5/140516 by Emily Short";
    if (id == 10) print "Formatting Capture version 2/221014 by Daniel Stelzer (based on Text Capture by Eric Eve)";
    if (id == 11) print "Essentials by Philip Riley";
    if (id == 12) print "Facts by Philip Riley";
    if (id == 13) print "Phones by Philip Riley";
    if (id == 14) print "Commerce by Philip Riley";
    if (id == 15) print "Furniture by Philip Riley";
    if (id == 16) print "Third Person Narration by Philip Riley";
    if (id == 17) print "Door Utils by Philip Riley";
    if (id == 18) print "Real People by Philip Riley";
    if (id == 19) print "Visible Rooms by Philip Riley";
    if (id == 20) print "Polish by Philip Riley";
    if (id == 21) print "Choices by Philip Riley";
    if (id == 22) print "New Light by Philip Riley";
    if (id == 23) print "Early Declarations by Philip Riley";
    if (id == 24) print "Basics by Philip Riley";
    if (id == 25) print "Memories by Philip Riley";
    if (id == 26) print "Simple Conversation by Philip Riley";
    if (id == 27) print "Hyperspace by Philip Riley";
    if (id == 28) print "BOSH Facts by Philip Riley";
    if (id == 29) print "Image Strip by Philip Riley";
    if (id == 30) print "Swamp Park by Philip Riley";
    if (id == 31) print "Conversations General by Philip Riley";
    if (id == 32) print "Margaret by Philip Riley";
    if (id == 33) print "Enigma Lake by Philip Riley";
    if (id == 34) print "Gender Options version 3/210331 by Nathanael Nerode";
    if (id == 35) print "Hearing by Philip Riley";
    if (id == 36) print "PBR Common version 2 by Philip Riley";
    if (id == 37) print "Walls version 1 by Philip Riley";
    if (id == 38) print "Floors by Philip Riley";
    if (id == 39) print "Ceilings version 1 by Philip Riley";
    if (id == 40) print "Can't Go That Way version 1/230318 by Philip Riley";
    if (id == 41) print "Can't Take That version 1/230318 by Philip Riley";
    if (id == 42) print "Complex Listing version 9 by Emily Short";
    if (id == 43) print "Exit Lister version 11 by Eric Eve";
    if (id == 44) print "Options Paragraph by Philip Riley";
    if (id == 45) print "Glulx Entry Points version 10/140425 by Emily Short";
    if (id == 46) print "Door Varieties by Philip Riley";
    if (id == 47) print "Two-Sided Doors by Philip Riley";
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Use options
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! Use option:
 Constant DynamicMemoryAllocation = 8192; 
! Use option:
 Constant TEXT_TY_BufferSize = 1024+3; 
! Use option:
 Constant MAX_FIGURE_THUMBNAILS_IN_INDEX = 50; 
! Use option:
 Constant MATCH_LIST_WORDS = 100; 
! Use option:
 Constant ESCAPE_CODE = 167; 
! Use option:
 Constant CAPTURE_BUFFER_LEN = 256; 


#Ifndef USE_SCORING;
Constant USE_SCORING = 0;
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Constants
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: VM Target Constants
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifndef WORDSIZE; ! compiling with Z-code only compiler
Constant TARGET_ZCODE;
Constant WORDSIZE 2;
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Wordsize-Dependent Definitions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Iftrue (WORDSIZE == 2);
Constant NULL = $ffff;
Constant WORD_HIGHBIT = $8000;
Constant WORD_NEXTTOHIGHBIT = $4000;
Constant IMPROBABLE_VALUE = $7fe3;
Constant MAX_POSITIVE_NUMBER 32767;
Constant MIN_NEGATIVE_NUMBER -32768;
Constant REPARSE_CODE = 10000;
#Endif;

#Iftrue (WORDSIZE == 4);
Constant NULL = $ffffffff;
Constant WORD_HIGHBIT = $80000000;
Constant WORD_NEXTTOHIGHBIT = $40000000;
Constant IMPROBABLE_VALUE = $deadce11;
Constant MAX_POSITIVE_NUMBER 2147483647;
Constant MIN_NEGATIVE_NUMBER -2147483648;
Constant REPARSE_CODE = $40000000;
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Z-Machine Definitions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef TARGET_ZCODE;

Global max_z_object;

Constant INDIV_PROP_START 64;

! Offsets into Z-machine header:

Constant HDR_ZCODEVERSION     = $00;     ! byte
Constant HDR_TERPFLAGS        = $01;     ! byte
Constant HDR_GAMERELEASE      = $02;     ! word
Constant HDR_HIGHMEMORY       = $04;     ! word
Constant HDR_INITIALPC        = $06;     ! word
Constant HDR_DICTIONARY       = $08;     ! word
Constant HDR_OBJECTS          = $0A;     ! word
Constant HDR_GLOBALS          = $0C;     ! word
Constant HDR_STATICMEMORY     = $0E;     ! word
Constant HDR_GAMEFLAGS        = $10;     ! word
Constant HDR_GAMESERIAL       = $12;     ! six ASCII characters
Constant HDR_ABBREVIATIONS    = $18;     ! word
Constant HDR_FILELENGTH       = $1A;     ! word
Constant HDR_CHECKSUM         = $1C;     ! word
Constant HDR_TERPNUMBER       = $1E;     ! byte
Constant HDR_TERPVERSION      = $1F;     ! byte
Constant HDR_SCREENHLINES     = $20;     ! byte
Constant HDR_SCREENWCHARS     = $21;     ! byte
Constant HDR_SCREENWUNITS     = $22;     ! word
Constant HDR_SCREENHUNITS     = $24;     ! word
Constant HDR_FONTWUNITS       = $26;     ! byte
Constant HDR_FONTHUNITS       = $27;     ! byte
Constant HDR_ROUTINEOFFSET    = $28;     ! word
Constant HDR_STRINGOFFSET     = $2A;     ! word
Constant HDR_BGCOLOUR         = $2C;     ! byte
Constant HDR_FGCOLOUR         = $2D;     ! byte
Constant HDR_TERMCHARS        = $2E;     ! word
Constant HDR_PIXELSTO3        = $30;     ! word
Constant HDR_TERPSTANDARD     = $32;     ! two bytes
Constant HDR_ALPHABET         = $34;     ! word
Constant HDR_EXTENSION        = $36;     ! word
Constant HDR_UNUSED           = $38;     ! two words
Constant HDR_INFORMVERSION    = $3C;     ! four ASCII characters

#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Glulx Definitions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF TARGET_GLULX;

Global unicode_gestalt_ok; ! Set if interpreter supports Unicode

! Offsets into Glulx header and start of ROM:

Constant HDR_MAGICNUMBER      = $00;     ! long word
Constant HDR_GLULXVERSION     = $04;     ! long word
Constant HDR_RAMSTART         = $08;     ! long word
Constant HDR_EXTSTART         = $0C;     ! long word
Constant HDR_ENDMEM           = $10;     ! long word
Constant HDR_STACKSIZE        = $14;     ! long word
Constant HDR_STARTFUNC        = $18;     ! long word
Constant HDR_DECODINGTBL      = $1C;     ! long word
Constant HDR_CHECKSUM         = $20;     ! long word
Constant ROM_INFO             = $24;     ! four ASCII characters
Constant ROM_MEMORYLAYOUT     = $28;     ! long word
Constant ROM_INFORMVERSION    = $2C;     ! four ASCII characters
Constant ROM_COMPVERSION      = $30;     ! four ASCII characters
Constant ROM_GAMERELEASE      = $34;     ! short word
Constant ROM_GAMESERIAL       = $36;     ! six ASCII characters

#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Powers of Two
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array PowersOfTwo_TB
  --> $$100000000000
      $$010000000000
      $$001000000000
      $$000100000000
      $$000010000000
      $$000001000000
      $$000000100000
      $$000000010000
      $$000000001000
      $$000000000100
      $$000000000010
      $$000000000001;

Array IncreasingPowersOfTwo_TB
  --> $$0000000000000001
      $$0000000000000010
      $$0000000000000100
      $$0000000000001000
      $$0000000000010000
      $$0000000000100000
      $$0000000001000000
      $$0000000010000000
      $$0000000100000000
      $$0000001000000000
      $$0000010000000000
	  $$0000100000000000
	  $$0001000000000000
	  $$0010000000000000
	  $$0100000000000000
	  $$1000000000000000;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Text Styles
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant NORMAL_VMSTY     = 0;
Constant HEADER_VMSTY     = 3;
Constant SUBHEADER_VMSTY  = 4;
Constant ALERT_VMSTY      = 5;
Constant NOTE_VMSTY       = 6;
Constant BLOCKQUOTE_VMSTY = 7;
Constant INPUT_VMSTY      = 8;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Colour Numbers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant CLR_DEFAULT = 1;
Constant CLR_BLACK   = 2;
Constant CLR_RED     = 3;
Constant CLR_GREEN   = 4;
Constant CLR_YELLOW  = 5;
Constant CLR_BLUE    = 6;
Constant CLR_MAGENTA = 7; Constant CLR_PURPLE  = 7;
Constant CLR_CYAN    = 8; Constant CLR_AZURE   = 8;
Constant CLR_WHITE   = 9;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Window Numbers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant WIN_ALL     = 0; ! Both windows at once
Constant WIN_STATUS  = 1;
Constant WIN_MAIN    = 2;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Paragraphing Flags
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant PARA_COMPLETED          = 1;
Constant PARA_PROMPTSKIP         = 2;
Constant PARA_SUPPRESSPROMPTSKIP = 4;
Constant PARA_NORULEBOOKBREAKS   = 8;
Constant PARA_CONTENTEXPECTED    = 16;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Descriptors in the Language of Play
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant POSSESS_PK  = $100;
Constant DEFART_PK   = $101;
Constant INDEFART_PK = $102;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Run-Time Problem Numbers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RTP_BACKDROP                = 1;
Constant RTP_EXITDOOR                = 2;
Constant RTP_NOEXIT                  = 3;
Constant RTP_CANTCHANGE              = 4;
Constant RTP_IMPREL                  = 5;
Constant RTP_RULESTACK               = 6; ! Now out of use
Constant RTP_TOOMANYRULEBOOKS        = 7;
Constant RTP_TOOMANYEVENTS           = 8;
Constant RTP_BADPROPERTY             = 9;
Constant RTP_UNPROVIDED              = 10;
Constant RTP_UNSET                   = 11;
Constant RTP_TOOMANYACTS             = 12;
Constant RTP_CANTABANDON             = 13;
Constant RTP_CANTEND                 = 14;
Constant RTP_CANTMOVENOTHING         = 15;
Constant RTP_CANTREMOVENOTHING       = 16;
Constant RTP_DIVZERO                 = 17;
Constant RTP_BADVALUEPROPERTY        = 18;
Constant RTP_NOTBACKDROP             = 19;
Constant RTP_TABLE_NOCOL             = 20;
Constant RTP_TABLE_NOCORR            = 21;
Constant RTP_TABLE_NOROW             = 22;
Constant RTP_TABLE_NOENTRY           = 23;
Constant RTP_TABLE_NOTABLE           = 24;
Constant RTP_TABLE_NOMOREBLANKS      = 25;
Constant RTP_TABLE_NOROWS            = 26;
Constant RTP_TABLE_CANTSORT          = 27;
Constant RTP_NOTINAROOM              = 28;
Constant RTP_BADTOPIC                = 29;
Constant RTP_ROUTELESS               = 30;
Constant RTP_PROPOFNOTHING           = 31;
Constant RTP_DECIDEONWRONGKIND       = 32;
Constant RTP_DECIDEONNOTHING         = 33;
Constant RTP_TABLE_CANTSAVE          = 34;
Constant RTP_TABLE_WONTFIT           = 35;
Constant RTP_TABLE_BADFILE           = 36;
Constant RTP_LOWLEVELERROR           = 37;
Constant RTP_DONTIGNORETURNSEQUENCE  = 38;
Constant RTP_SAYINVALIDSNIPPET       = 39;
Constant RTP_SPLICEINVALIDSNIPPET    = 40;
Constant RTP_INCLUDEINVALIDSNIPPET   = 41;
Constant RTP_LISTWRITERMEMORY        = 42;
Constant RTP_CANTREMOVEPLAYER        = 43;
Constant RTP_CANTREMOVEDOORS         = 44;
Constant RTP_CANTCHANGEOFFSTAGE      = 45;
Constant RTP_MSTACKMEMORY            = 46;
Constant RTP_TYPECHECK               = 47;
Constant RTP_FILEIOERROR             = 48;
Constant RTP_HEAPERROR               = 49;
Constant RTP_LISTRANGEERROR          = 50;
Constant RTP_REGEXPSYNTAXERROR       = 51;
Constant RTP_NOGLULXUNICODE          = 52;
Constant RTP_BACKDROPONLY            = 53;
Constant RTP_NOTTHING                = 54;
Constant RTP_SCENEHASNTSTARTED       = 55;
Constant RTP_SCENEHASNTENDED         = 56;
Constant RTP_NEGATIVEROOT            = 57;
Constant RTP_TABLE_CANTRUNTHROUGH    = 58;
Constant RTP_CANTITERATE             = 59;
Constant RTP_WRONGASSIGNEDKIND       = 60;
Constant RTP_CANTBEOFFSTAGE          = 61;
Constant RTP_RELKINDVIOLATION        = 62;
Constant RTP_CANTMAKEPART       	 = 63;
Constant RTP_TEXTTOKENTOOHARD        = 64;
Constant RTP_TABLE_NOTABLE2          = 65;
Constant RTP_RELATIONCHANGEIMPOSSIBLE = 66;
Constant RTP_RELMINIMAL              = 67;
Constant RTP_LISTSIZENEGATIVE        = 68;
Constant RTP_REGIONSNOTADJACENT      = 69;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Template Activities
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant PRINTING_THE_NAME_ACT           = 0;
Constant PRINTING_THE_PLURAL_NAME_ACT    = 1;
Constant PRINTING_A_NUMBER_OF_ACT        = 2;
Constant PRINTING_ROOM_DESC_DETAILS_ACT  = 3;
Constant PRINTING_INVENTORY_DETAILS_ACT  = 4;
Constant LISTING_CONTENTS_ACT            = 5;
Constant GROUPING_TOGETHER_ACT           = 6;
Constant WRITING_A_PARAGRAPH_ABOUT_ACT   = 7;
Constant LISTING_NONDESCRIPT_ITEMS_ACT   = 8;

Constant PRINTING_NAME_OF_DARK_ROOM_ACT  = 9;
Constant PRINTING_DESC_OF_DARK_ROOM_ACT  = 10;
Constant PRINTING_NEWS_OF_DARKNESS_ACT   = 11;
Constant PRINTING_NEWS_OF_LIGHT_ACT      = 12;
Constant REFUSAL_TO_ACT_IN_DARK_ACT      = 13;

Constant CONSTRUCTING_STATUS_LINE_ACT    = 14;
Constant PRINTING_BANNER_TEXT_ACT        = 15;

Constant READING_A_COMMAND_ACT           = 16;
Constant DECIDING_SCOPE_ACT              = 17;
Constant DECIDING_CONCEALED_POSSESS_ACT  = 18;
Constant DECIDING_WHETHER_ALL_INC_ACT    = 19;
Constant CLARIFYING_PARSERS_CHOICE_ACT   = 20;
Constant ASKING_WHICH_DO_YOU_MEAN_ACT    = 21;
Constant PRINTING_A_PARSER_ERROR_ACT     = 22;
Constant SUPPLYING_A_MISSING_NOUN_ACT    = 23;
Constant SUPPLYING_A_MISSING_SECOND_ACT  = 24;
Constant IMPLICITLY_TAKING_ACT           = 25;
Constant STARTING_VIRTUAL_MACHINE_ACT    = 26;

Constant AMUSING_A_VICTORIOUS_PLAYER_ACT = 27;
Constant PRINTING_PLAYERS_OBITUARY_ACT   = 28;
Constant DEALING_WITH_FINAL_QUESTION_ACT = 29;

Constant PRINTING_LOCALE_DESCRIPTION_ACT = 30;
Constant CHOOSING_NOTABLE_LOCALE_OBJ_ACT = 31;
Constant PRINTING_LOCALE_PARAGRAPH_ACT   = 32;

Constant PRINTING_RESPONSE_ACT           = 33;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Template Rulebooks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant STARTUP_RB                      = 0;
Constant TURN_SEQUENCE_RB                = 1;
Constant SHUTDOWN_RB                     = 2;

Constant WHEN_PLAY_BEGINS_RB             = 4;
Constant WHEN_PLAY_ENDS_RB               = 5;
Constant WHEN_SCENE_BEGINS_RB            = 6;
Constant WHEN_SCENE_ENDS_RB              = 7;

Constant ACTION_PROCESSING_RB            = 9;
Constant SETTING_ACTION_VARIABLES_RB     = 10;
Constant SPECIFIC_ACTION_PROCESSING_RB   = 11;

Constant ACCESSIBILITY_RB                = 13;
Constant REACHING_INSIDE_RB              = 14;
Constant REACHING_OUTSIDE_RB             = 15;
Constant VISIBLE_RB                      = 16;

Constant PERSUADE_RB                     = 17;
Constant UNSUCCESSFUL_ATTEMPT_RB         = 18;

Constant AFTER_RB                        = 23;
Constant REPORT_RB                       = 24;

Constant MULTIPLE_ACTION_PROCESSING_RB   = 26;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Kind IDs
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant UNKNOWN_TY = -2147483602;
Constant VALUE_TY = 2;
Constant POINTER_VALUE_TY = 3;
Constant WORD_VALUE_TY = 4;
Constant ARITHMETIC_VALUE_TY = 5;
Constant REAL_ARITHMETIC_VALUE_TY = 6;
Constant ENUMERATED_VALUE_TY = 7;
Constant SAYABLE_VALUE_TY = 8;
Constant COMBINED_VALUE_TY = 9;
Constant OBJECT_TY = 10;
Constant NUMBER_TY = 11;
Constant REAL_NUMBER_TY = 12;
Constant TRUTH_STATE_TY = 13;
Constant TEXT_TY = 14;
Constant UNICODE_CHARACTER_TY = 15;
Constant USE_OPTION_TY = 16;
Constant RESPONSE_TY = 17;
Constant VERB_TY = 18;
Constant SNIPPET_TY = 19;
Constant TABLE_TY = 20;
Constant EQUATION_TY = 21;
Constant RULEBOOK_OUTCOME_TY = 22;
Constant UNDERSTANDING_TY = 23;
Constant INTERMEDIATE_TY = 24;
Constant NIL_TY = 25;
Constant KIND_VARIABLE_TY = 26;
Constant PHRASE_TY = 27;
Constant TUPLE_ENTRY_TY = 28;
Constant VARIABLE_TY = 29;
Constant RELATION_TY = 30;
Constant RULE_TY = 31;
Constant RULEBOOK_TY = 32;
Constant ACTIVITY_TY = 33;
Constant LIST_OF_TY = 34;
Constant DESCRIPTION_OF_TY = 35;
Constant PROPERTY_TY = 36;
Constant TABLE_COLUMN_TY = 37;
Constant COMBINATION_TY = 38;
Constant DESCRIPTION_OF_ACTION_TY = 39;
Constant STORED_ACTION_TY = 40;
Constant ACTION_NAME_TY = 41;
Constant TIME_TY = 42;
Constant SCENE_TY = 43;
Constant FIGURE_NAME_TY = 44;
Constant SOUND_NAME_TY = 45;
Constant EXTERNAL_FILE_TY = 46;
Constant BASE_KIND_HWM = 73; ! Base kind high-water-mark



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Parser Error Numbers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant STUCK_PE         = 1;
Constant UPTO_PE          = 2;
Constant NUMBER_PE        = 3;
Constant ANIMA_PE         = 4;
Constant CANTSEE_PE       = 5;
Constant TOOLIT_PE        = 6;
Constant NOTHELD_PE       = 7;
Constant MULTI_PE         = 8;
Constant MMULTI_PE        = 9;
Constant VAGUE_PE         = 10;
Constant EXCEPT_PE        = 11;
Constant VERB_PE          = 12;
Constant SCENERY_PE       = 13;
Constant ITGONE_PE        = 14;
Constant JUNKAFTER_PE     = 15;
Constant TOOFEW_PE        = 16;
Constant NOTHING_PE       = 17;
Constant ASKSCOPE_PE      = 18;
Constant NOTINCONTEXT_PE  = 19;
Constant BLANKLINE_PE     = 20; ! Not formally a parser error, but used by I7 as if
Constant ANIMAAGAIN_PE    = 21;
Constant COMMABEGIN_PE    = 22;
Constant MISSINGPERSON_PE = 23;
Constant ANIMALISTEN_PE   = 24;
Constant TOTALK_PE        = 25;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Scope Searching Reasons
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant PARSING_REASON       = 0;
Constant TALKING_REASON       = 1;
Constant EACH_TURN_REASON     = 2;
Constant LOOPOVERSCOPE_REASON = 5;
Constant TESTSCOPE_REASON     = 6;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Token Types
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant ILLEGAL_TT         = 0;    ! Types of grammar token: illegal
Constant ELEMENTARY_TT      = 1;    !     (one of those below)
Constant PREPOSITION_TT     = 2;    !     e.g. 'into'
Constant ROUTINE_FILTER_TT  = 3;    !     e.g. noun=CagedCreature
Constant ATTR_FILTER_TT     = 4;    !     e.g. edible
Constant SCOPE_TT           = 5;    !     e.g. scope=Spells
Constant GPR_TT             = 6;    !     a general parsing routine

Constant NOUN_TOKEN         = 0;    ! The elementary grammar tokens, and
Constant HELD_TOKEN         = 1;    ! the numbers compiled by I6 to
Constant MULTI_TOKEN        = 2;    ! encode them
Constant MULTIHELD_TOKEN    = 3;
Constant MULTIEXCEPT_TOKEN  = 4;
Constant MULTIINSIDE_TOKEN  = 5;
Constant CREATURE_TOKEN     = 6;
Constant SPECIAL_TOKEN      = 7;
Constant NUMBER_TOKEN       = 8;
Constant TOPIC_TOKEN        = 9;
Constant ENDIT_TOKEN        = 15;   ! Value used to mean "end of grammar line"


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: GPR Return Values
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant GPR_FAIL           = -1;   ! Return values from General Parsing
Constant GPR_PREPOSITION    = 0;    ! Routines
Constant GPR_NUMBER         = 1;
Constant GPR_MULTIPLE       = 2;
Constant GPR_REPARSE        = REPARSE_CODE;
Constant GPR_NOUN           = -256; ! Reparse, but as |NOUN_TOKEN| this time
Constant GPR_HELD           = GPR_NOUN + 1; ! And so on
Constant GPR_MULTI          = GPR_NOUN + 2;
Constant GPR_MULTIHELD      = GPR_NOUN + 3;
Constant GPR_MULTIEXCEPT    = GPR_NOUN + 4;
Constant GPR_MULTIINSIDE    = GPR_NOUN + 5;
Constant GPR_CREATURE       = GPR_NOUN + 6;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: List Styles
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant NEWLINE_BIT        = $$0000000000000001; ! New-line after each entry
Constant INDENT_BIT         = $$0000000000000010; ! Indent each entry by depth
Constant FULLINV_BIT        = $$0000000000000100; ! Full inventory information after entry
Constant ENGLISH_BIT        = $$0000000000001000; ! English sentence style, with commas and and
Constant RECURSE_BIT        = $$0000000000010000; ! Recurse downwards with usual rules
Constant ALWAYS_BIT         = $$0000000000100000; ! Always recurse downwards
Constant TERSE_BIT          = $$0000000001000000; ! More terse English style
Constant PARTINV_BIT        = $$0000000010000000; ! Only brief inventory information after entry
Constant DEFART_BIT         = $$0000000100000000; ! Use the definite article in list
Constant WORKFLAG_BIT       = $$0000001000000000; ! At top level (only), only list objects
                                                  ! which have the "workflag" attribute
Constant ISARE_BIT          = $$0000010000000000; ! Print " is" or " are" before list
Constant CONCEAL_BIT        = $$0000100000000000; ! Omit objects with "concealed" or "scenery":
                                                  ! if WORKFLAG_BIT also set, then does not
                                                  ! apply at top level, but does lower down
Constant NOARTICLE_BIT      = $$0001000000000000; ! Print no articles, definite or not
Constant EXTRAINDENT_BIT    = $$0010000000000000; ! New in I7: extra indentation of 1 level
Constant CFIRSTART_BIT      = $$0100000000000000; ! Capitalise first article in list


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Lengths Of Time
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant QUARTER_HOUR = 15;
Constant HALF_HOUR = 30;
Constant ONE_HOUR = 60;
Constant TWELVE_HOURS = 720;
Constant TWENTY_FOUR_HOURS = 1440;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Empty Text
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant EMPTY_TEXT_PACKED "";
Array EMPTY_TEXT_VALUE --> CONSTANT_PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Empty Table
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array TheEmptyTable --> 0 0;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Empty Set
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Prop_Falsity reason obj; return 0; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Score and Rankings Table
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


#Ifndef MAX_SCORE;
Global MAX_SCORE = 0;
#Endif;


Attribute absent; ! Used to mark objects removed from play
Attribute animate; ! I6-level marker for I7 kind "person"
Attribute clothing; ! = I7 "wearable"
Attribute concealed; ! = I7 "undescribed"
Attribute container; ! I6-level marker for I7 kind "container"
Attribute door; ! I6-level marker for I7 kind "door"
Attribute edible; ! = I7 "edible" vs "inedible"
Attribute enterable; ! = I7 "enterable"
Attribute light; ! = I7 "lighted" vs "dark"
Attribute lockable; ! = I7 "lockable"
Attribute locked; ! = I7 "locked"
Attribute moved; ! = I7 "handled"
Attribute on; ! = I7 "switched on" vs "switched off"
Attribute open; ! = I7 "open" vs "closed"
Attribute openable; ! = I7 "openable"
Attribute scenery; ! = I7 "scenery"
Attribute static; ! = I7 "fixed in place" vs "portable"
Attribute supporter; ! I6-level marker for I7 kind "supporter"
Attribute switchable; ! I6-level marker for I7 kind "device"
Attribute talkable; ! Not currently used by I7, but retained for possible future use
Attribute transparent; ! = I7 "transparent" vs "opaque"
Attribute visited; ! = I7 "visited"
Attribute worn; ! marks that an object tree edge represents wearing

Attribute male; ! not directly used by I7, but available for languages with genders
Attribute female; ! = I7 "female" vs "male"
Attribute neuter; ! = I7 "neuter"
Attribute nomale;
Attribute pluralname; ! = I7 "plural-named"
Attribute ambigpluralname; ! = I7 "ambiguously plural"
Attribute proper; ! = I7 "proper-named"
Attribute remove_proper; ! remember to remove proper again when using ChangePlayer next

Attribute privately_named; ! New in I7
Attribute mentioned; ! New in I7
Attribute pushable; ! New in I7

Attribute mark_as_room; ! Used in I7 to speed up testing "ofclass K1_room"
Attribute mark_as_thing; ! Used in I7 to speed up testing "ofclass K2_thing"

Attribute workflag; ! = I7 "marked for listing", but basically temporary workspace 
Attribute workflag2; ! new in I7 and also temporary workspace
Constant list_filter_permits = privately_named; ! another I7 listwriter convenience

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Template Attributes (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Template Properties
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Property add_to_scope; ! used as in I6 to place component parts in scope
Property article "a"; ! used as in I6 to implement articles
Property capacity 100; ! = I7 "carrying capacity"
Property component_child; ! new in I7: forest structure holding "part of" relation
Property component_parent; ! new in I7
Property component_sibling; ! new in I7
Property description; ! = I7 "description"
Property door_dir; ! used to implement two-sided doors, but holds direction object, not a property
Property door_to; ! used as in I6 to implement two-sided doors
Property found_in; ! used as in I6 to implement two-sided doors and backdrops
Property initial; ! = I7 "initial description"
Property list_together; ! used as in I6 to implement "grouping together" activity
Property map_region; ! new in I7
Property parse_name 0; ! used as in I6 to implement "Understand... as..." grammars
Property plural; ! used as in I6 to implement plural names for duplicate objects
Property regional_found_in; ! new in I7
Property room_index; ! new in I7: storage for route-finding
Property short_name 0; ! = I7 "printed name"
Property vector; ! new in I7: storage for route-finding
Property with_key; ! = I7 "matching key"

Property KD_Count; ! Instance count of the kind of the current object
Property IK1_Count; ! These are instance counts within kinds K1, K2, ...
Property IK2_Count; ! and it is efficient to declare the common ones with Property
Property IK4_Count; ! since this results in a slightly smaller story file
Property IK5_Count;
Property IK6_Count;
Property IK8_Count;

Property IK1_link; ! These are for linked lists used to make searches faster
Property IK2_link; ! and again it's memory-efficient to declare the common ones
Property IK5_link; ! 
Property IK6_link; ! 
Property IK8_link; ! 

Property articles; ! not used by I7, but an interesting hook in the parser
Property grammar; ! not used by I7, but an interesting hook in the parser
Property inside_description; ! not used by I7, but an interesting hook in the locale code
Property short_name_indef 0; ! not used by I7, but an interesting hook in the listmaker


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Loss of Life
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant life = NULL;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Action Count
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant ActionCount = 112;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Fake Actions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Fake_Action ListMiscellany;
Fake_Action Miscellany;
Fake_Action PluralFound;
Fake_Action TheSame;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Definitions.i6t: Formal Parameters
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global formal_rv;
Global formal_par0;
Global formal_par1;
Global formal_par2;
Global formal_par3;
Global formal_par4;
Global formal_par5;
Global formal_par6;
Global formal_par7;
Global unicode_temp;

	Constant RUCKSACK_CLASS = K16_player_s_holdall;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Global Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! [1]
Global location = InformLibrary; ! does not = I7 "location": see below
Global sline1; Global sline2;

! [2]
Global say__p = 1; Global say__pc = 0; Global say__pc_save = 0;
Global say__n; Global say__comp;
Global los_rv = false;
Global parameter_object; ! = I7 "parameter-object" = I7 "container in question"
Global parameter_value; ! not typesafe in I7
Array deferred_calling_list --> 27;
Global property_to_be_totalled; ! used to implement "total P of..."
Global property_loop_sign; ! $+1$ for increasing order, $-1$ for decreasing
Global suppress_scope_loops;
Global temporary_value; ! can be used anywhere side-effects can't occur

#ifdef TARGET_ZCODE;
Constant BLOCKV_STACK_SIZE = 224;
#ifnot;
Constant BLOCKV_STACK_SIZE = DynamicMemoryAllocation/4;
#endif;

Array blockv_stack --> BLOCKV_STACK_SIZE;
Global I7SFRAME;

Global TEXT_TY_RE_Err = 0;

Array LocalParking --> 64;

! [3]
Global standard_interpreter = 0;
Global undo_flag;

! [4]
Global deadflag = 0;
Global story_complete = 0;
Global resurrect_please = false;

! [5]
Global not_yet_in_play = true; ! set false when first command received
Global turns = 1; ! = I7 "turn count"
Global the_time = NULL; ! = I7 "time of day"
Global time_rate = 1;

Constant NUMBER_SCENES_CREATED = 4;
Constant SCENE_ARRAY_SIZE = (NUMBER_SCENES_CREATED+2);
Array scene_started --> SCENE_ARRAY_SIZE;
Array scene_ended --> SCENE_ARRAY_SIZE;
Array scene_status --> SCENE_ARRAY_SIZE;
Array scene_endings --> SCENE_ARRAY_SIZE;
Array scene_latest_ending --> SCENE_ARRAY_SIZE;

! [6]
Global score; ! = I7 "score"
Global last_score; ! = I7 "last notified score"
Global notify_mode = 1; ! score notification on or off
Global left_hand_status_line = T_SL_Location; ! = I7 "left hand status line"
Global right_hand_status_line = T_SL_Score_Moves; ! = I7 "right hand status line"

! [7]
Global player; ! = I7 "player"
Global real_location; ! = I7 "location"
Global visibility_ceiling; ! highest object in tree visible to player
Global visibility_levels; ! distance in tree to that

Global SACK_OBJECT; ! current player's holdall item in use

! [8]
Global act_requester;
Global actor; ! = I7 "person asked" = I7 "person reaching"
Global actors_location; ! like real_location, but for the actor
Global actor_location; ! = I7 "actor-location"
Global action;
Global meta; ! action is out of world
Global inp1;
Global inp2;
Array  multiple_object --> MATCH_LIST_WORDS; ! multiple-object list (I6 table array)
Global toomany_flag; ! multiple-object list overflowed
Global multiflag; ! multiple-object being processed
Global multiple_object_item; ! item currently being processed in multiple-object list
Global noun; ! = I7 "noun"
Global second; ! = I7 "second noun"
Global keep_silent; ! true if current action is being tried silently
Global etype; ! parser error number if command not recognised
Global trace_actions = 0;

Global untouchable_object;
Global untouchable_silence;
Global touch_persona;

Global special_word; ! dictionary address of first word in "[text]" token
Global consult_from; ! word number of start of "[text]" token
Global consult_words; ! number of words in "[text]" token
Global parsed_number; ! value from any token not an object
Global special_number1; ! first value, if token not an object
Global special_number2; ! second value, if token not an object

Array  parser_results --> 16; ! for parser to write its results in
Global parser_trace = 0; ! normally 0, but 1 to 5 traces parser workings
Global pronoun_word; ! records which pronoun ("it", "them", ...) caused an error
Global pronoun_obj; ! and what object it was thought to refer to

Global players_command = 100; ! = I7 "player's command"
Global matched_text; ! = I7 "matched text"
Global reason_the_action_failed; ! = I7 "reason the action failed"
Global understand_as_mistake_number; ! which form of "Understand... as a mistake"
Global particular_possession; ! = I7 "particular possession"

! [9]
Global parser_action; ! written by the parser for the benefit of GPRs
Global parser_one;
Global parser_two;
Global parameters; ! number of I7 tokens parsed on the current line
Global action_to_be; ! (if the current line were accepted)
Global action_reversed; ! (parameters would be reversed in order)
Global wn; ! word number within "parse" buffer (from 1)
Global num_words; ! number of words in buffer
Global verb_word; ! dictionary address of command verb
Global verb_wordnum; ! word number of command verb

! [10]
Global scope_reason = PARSING_REASON; ! current reason for searching scope
Global scope_token; ! for "scope=Routine" grammar tokens
Global scope_error;
Global scope_stage; ! 1, 2 then 3
Global advance_warning; ! what a later-named thing will be
Global reason_code = NULL; ! for the I6 veneer

Global ats_flag = 0; ! for AddToScope routines
Global ats_hls;

! [11]
Global move_pushing;
Global move_from;
Global move_to;
Global move_by;
Global move_through;

! [12]
#Ifdef DEFAULT_BRIEF_DESCRIPTIONS;
Global lookmode = 1; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
#Ifdef DEFAULT_VERBOSE_DESCRIPTIONS; 
Global lookmode = 2; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
#Ifdef DEFAULT_SUPERBRIEF_DESCRIPTIONS; 
Global lookmode = 3; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
#Ifndef lookmode;
Global lookmode = 2; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
Global c_style; ! current list-writer style
Global c_depth; ! current recursion depth
Global c_iterator; ! current iteration function
Global lt_value = EMPTY_TEXT_VALUE; ! common value of list_together
Global listing_together; ! object number of one member of a group being listed together
Global listing_size; ! size of such a group
Global c_margin; ! current level of indentation printed by WriteListFrom()
Global inventory_stage = 1; ! 1 or 2 according to the context in which list_together uses
Global prior_named_noun; ! for adaptive text generation
Global prior_named_list; ! ditto: length of list of items
Global prior_named_list_gender; ! ditto: common gender of list of items, or -1
Global story_tense = 1; ! ditto: present tense
Global story_viewpoint = 2; ! ditto: second person singular

! [13]
Global clr_fg = 1; ! foreground colour
Global clr_bg = 1; ! background colour
Global clr_fgstatus = 1; ! foreground colour of statusline
Global clr_bgstatus = 1; ! background colour of statusline
Global clr_on; ! has colour been enabled by the player?
Global statuswin_current; ! if writing to top window

! [14]
Global statuswin_cursize = 0;
Global statuswin_size = 1;

! [16]
Global debug_flag = 0;
Global debug_rules = 0;
Global debug_scenes = 0;
Global debug_rule_nesting;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: VM-Specific Code
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef TARGET_GLULX;


   [ IdentifyGlkObject phase type ref rock;
      if (phase == 0) { ! Zero out references to our objects.
	 if (FollowRulebook( 538 ) && RulebookSucceeded()) { rtrue; }
      }

      if (phase == 1) { ! Reset our windows, streams and filerefs.
	(Global_Vars-->51) = rock;
	(Global_Vars-->52) = ref;
         switch (type) {
            0: ! it's a window 
               	FollowRulebook( 539 );
	 1 : ! it's a stream
               	FollowRulebook( 540 );
    	   2 : ! it's a file reference
               	FollowRulebook( 541 );
         }
         return;
      }

      if (phase == 2) { ! Update our objects.
         if (FollowRulebook( 542 ) && RulebookSucceeded()) { rtrue; }
      }

   ];

 Array evGlobal --> 4;  

  [ HandleGlkEvent ev context abortres newcmd cmdlen i ;
      for (i=0:i<3:i++) evGlobal-->i = ev-->i;
      (Global_Vars-->54) = context;
      return (PHR_1291_r0 ()) ;
  ];

  

Constant GG_PICWIN_ROCK = 200;
Global gg_picwin = 0; 
Constant GG_HIDEWIN_ROCK = 204;
Global gg_hidewin = 0; 


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Summary
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Variables and Arrays
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array gg_event --> 4;
Array gg_arguments buffer 28;
Global gg_mainwin = 0;
Global gg_statuswin = 0;
Global gg_quotewin = 0;
Global gg_scriptfref = 0;
Global gg_scriptstr = 0;
Global gg_savestr = 0;
Global gg_commandstr = 0;
Global gg_command_reading = 0;      ! true if gg_commandstr is being replayed
Global gg_foregroundchan = 0;
Global gg_backgroundchan = 0;

Constant GLK_NULL 0;

Constant INPUT_BUFFER_LEN = 260;    ! No extra byte necessary
Constant MAX_BUFFER_WORDS = 20;
Constant PARSE_BUFFER_LEN = 61;

Array  buffer    buffer INPUT_BUFFER_LEN;
Array  buffer2   buffer INPUT_BUFFER_LEN;
Array  buffer3   buffer INPUT_BUFFER_LEN;
Array  parse     --> PARSE_BUFFER_LEN;
Array  parse2    --> PARSE_BUFFER_LEN;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Infglk
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! infglk.h -- auto-generated by parse_dispatch.py.
! Generated for Glk API version 0.7.4

Constant evtype_Arrange = 5;
Constant evtype_CharInput = 2;
Constant evtype_Hyperlink = 8;
Constant evtype_LineInput = 3;
Constant evtype_MouseInput = 4;
Constant evtype_None = 0;
Constant evtype_Redraw = 6;
Constant evtype_SoundNotify = 7;
Constant evtype_Timer = 1;
Constant evtype_VolumeNotify = 9;
Constant filemode_Read = 2;
Constant filemode_ReadWrite = 3;
Constant filemode_Write = 1;
Constant filemode_WriteAppend = 5;
Constant fileusage_BinaryMode = 0;
Constant fileusage_Data = 0;
Constant fileusage_InputRecord = 3;
Constant fileusage_SavedGame = 1;
Constant fileusage_TextMode = 256;
Constant fileusage_Transcript = 2;
Constant fileusage_TypeMask = 15;
Constant gestalt_CharInput = 1;
Constant gestalt_CharOutput = 3;
Constant gestalt_CharOutput_ApproxPrint = 1;
Constant gestalt_CharOutput_CannotPrint = 0;
Constant gestalt_CharOutput_ExactPrint = 2;
Constant gestalt_DateTime = 20;
Constant gestalt_DrawImage = 7;
Constant gestalt_Graphics = 6;
Constant gestalt_GraphicsCharInput = 23;
Constant gestalt_GraphicsTransparency = 14;
Constant gestalt_HyperlinkInput = 12;
Constant gestalt_Hyperlinks = 11;
Constant gestalt_LineInput = 2;
Constant gestalt_LineInputEcho = 17;
Constant gestalt_LineTerminatorKey = 19;
Constant gestalt_LineTerminators = 18;
Constant gestalt_MouseInput = 4;
Constant gestalt_ResourceStream = 22;
Constant gestalt_Sound = 8;
Constant gestalt_Sound2 = 21;
Constant gestalt_SoundMusic = 13;
Constant gestalt_SoundNotify = 10;
Constant gestalt_SoundVolume = 9;
Constant gestalt_Timer = 5;
Constant gestalt_Unicode = 15;
Constant gestalt_UnicodeNorm = 16;
Constant gestalt_Version = 0;
Constant imagealign_InlineCenter = 3;
Constant imagealign_InlineDown = 2;
Constant imagealign_MarginLeft = 4;
Constant imagealign_MarginRight = 5;
Constant imagealign_InlineUp = 1;
Constant keycode_Delete = 4294967289;
Constant keycode_Down = 4294967291;
Constant keycode_End = 4294967283;
Constant keycode_Escape = 4294967288;
Constant keycode_Func1 = 4294967279;
Constant keycode_Func10 = 4294967270;
Constant keycode_Func11 = 4294967269;
Constant keycode_Func12 = 4294967268;
Constant keycode_Func2 = 4294967278;
Constant keycode_Func3 = 4294967277;
Constant keycode_Func4 = 4294967276;
Constant keycode_Func5 = 4294967275;
Constant keycode_Func6 = 4294967274;
Constant keycode_Func7 = 4294967273;
Constant keycode_Func8 = 4294967272;
Constant keycode_Func9 = 4294967271;
Constant keycode_Home = 4294967284;
Constant keycode_Left = 4294967294;
Constant keycode_MAXVAL = 28;
Constant keycode_PageDown = 4294967285;
Constant keycode_PageUp = 4294967286;
Constant keycode_Return = 4294967290;
Constant keycode_Right = 4294967293;
Constant keycode_Tab = 4294967287;
Constant keycode_Unknown = 4294967295;
Constant keycode_Up = 4294967292;
Constant seekmode_Current = 1;
Constant seekmode_End = 2;
Constant seekmode_Start = 0;
Constant style_Alert = 5;
Constant style_BlockQuote = 7;
Constant style_Emphasized = 1;
Constant style_Header = 3;
Constant style_Input = 8;
Constant style_NUMSTYLES = 11;
Constant style_Normal = 0;
Constant style_Note = 6;
Constant style_Preformatted = 2;
Constant style_Subheader = 4;
Constant style_User1 = 9;
Constant style_User2 = 10;
Constant stylehint_BackColor = 8;
Constant stylehint_Indentation = 0;
Constant stylehint_Justification = 2;
Constant stylehint_NUMHINTS = 10;
Constant stylehint_Oblique = 5;
Constant stylehint_ParaIndentation = 1;
Constant stylehint_Proportional = 6;
Constant stylehint_ReverseColor = 9;
Constant stylehint_Size = 3;
Constant stylehint_TextColor = 7;
Constant stylehint_Weight = 4;
Constant stylehint_just_Centered = 2;
Constant stylehint_just_LeftFlush = 0;
Constant stylehint_just_LeftRight = 1;
Constant stylehint_just_RightFlush = 3;
Constant winmethod_Above = 2;
Constant winmethod_Below = 3;
Constant winmethod_Border = 0;
Constant winmethod_BorderMask = 256;
Constant winmethod_DirMask = 15;
Constant winmethod_DivisionMask = 240;
Constant winmethod_Fixed = 16;
Constant winmethod_Left = 0;
Constant winmethod_NoBorder = 256;
Constant winmethod_Proportional = 32;
Constant winmethod_Right = 1;
Constant wintype_AllTypes = 0;
Constant wintype_Blank = 2;
Constant wintype_Graphics = 5;
Constant wintype_Pair = 1;
Constant wintype_TextBuffer = 3;
Constant wintype_TextGrid = 4;

[ glk_exit _vararg_count;
  ! glk_exit()
  @glk 1 _vararg_count 0;
  return 0;
];

[ glk_tick _vararg_count;
  ! glk_tick()
  @glk 3 _vararg_count 0;
  return 0;
];

[ glk_gestalt _vararg_count ret;
  ! glk_gestalt(uint, uint) => uint
  @glk 4 _vararg_count ret;
  return ret;
];

[ glk_gestalt_ext _vararg_count ret;
  ! glk_gestalt_ext(uint, uint, uintarray, arraylen) => uint
  @glk 5 _vararg_count ret;
  return ret;
];

[ glk_window_iterate _vararg_count ret;
  ! glk_window_iterate(window, &uint) => window
  @glk 32 _vararg_count ret;
  return ret;
];

[ glk_window_get_rock _vararg_count ret;
  ! glk_window_get_rock(window) => uint
  @glk 33 _vararg_count ret;
  return ret;
];

[ glk_window_get_root _vararg_count ret;
  ! glk_window_get_root() => window
  @glk 34 _vararg_count ret;
  return ret;
];

[ glk_window_open _vararg_count ret;
  ! glk_window_open(window, uint, uint, uint, uint) => window
  @glk 35 _vararg_count ret;
  return ret;
];

[ glk_window_close _vararg_count;
  ! glk_window_close(window, &{uint, uint})
  @glk 36 _vararg_count 0;
  return 0;
];

[ glk_window_get_size _vararg_count;
  ! glk_window_get_size(window, &uint, &uint)
  @glk 37 _vararg_count 0;
  return 0;
];

[ glk_window_set_arrangement _vararg_count;
  ! glk_window_set_arrangement(window, uint, uint, window)
  @glk 38 _vararg_count 0;
  return 0;
];

[ glk_window_get_arrangement _vararg_count;
  ! glk_window_get_arrangement(window, &uint, &uint, &window)
  @glk 39 _vararg_count 0;
  return 0;
];

[ glk_window_get_type _vararg_count ret;
  ! glk_window_get_type(window) => uint
  @glk 40 _vararg_count ret;
  return ret;
];

[ glk_window_get_parent _vararg_count ret;
  ! glk_window_get_parent(window) => window
  @glk 41 _vararg_count ret;
  return ret;
];

[ glk_window_clear _vararg_count;
  ! glk_window_clear(window)
  @glk 42 _vararg_count 0;
  return 0;
];

[ glk_window_move_cursor _vararg_count;
  ! glk_window_move_cursor(window, uint, uint)
  @glk 43 _vararg_count 0;
  return 0;
];

[ glk_window_get_stream _vararg_count ret;
  ! glk_window_get_stream(window) => stream
  @glk 44 _vararg_count ret;
  return ret;
];

[ glk_window_set_echo_stream _vararg_count;
  ! glk_window_set_echo_stream(window, stream)
  @glk 45 _vararg_count 0;
  return 0;
];

[ glk_window_get_echo_stream _vararg_count ret;
  ! glk_window_get_echo_stream(window) => stream
  @glk 46 _vararg_count ret;
  return ret;
];

[ glk_set_window _vararg_count;
  ! glk_set_window(window)
  @glk 47 _vararg_count 0;
  return 0;
];

[ glk_window_get_sibling _vararg_count ret;
  ! glk_window_get_sibling(window) => window
  @glk 48 _vararg_count ret;
  return ret;
];

[ glk_stream_iterate _vararg_count ret;
  ! glk_stream_iterate(stream, &uint) => stream
  @glk 64 _vararg_count ret;
  return ret;
];

[ glk_stream_get_rock _vararg_count ret;
  ! glk_stream_get_rock(stream) => uint
  @glk 65 _vararg_count ret;
  return ret;
];

[ glk_stream_open_file _vararg_count ret;
  ! glk_stream_open_file(fileref, uint, uint) => stream
  @glk 66 _vararg_count ret;
  return ret;
];

[ glk_stream_open_memory _vararg_count ret;
  ! glk_stream_open_memory(nativechararray, arraylen, uint, uint) => stream
  @glk 67 _vararg_count ret;
  return ret;
];

[ glk_stream_close _vararg_count;
  ! glk_stream_close(stream, &{uint, uint})
  @glk 68 _vararg_count 0;
  return 0;
];

[ glk_stream_set_position _vararg_count;
  ! glk_stream_set_position(stream, int, uint)
  @glk 69 _vararg_count 0;
  return 0;
];

[ glk_stream_get_position _vararg_count ret;
  ! glk_stream_get_position(stream) => uint
  @glk 70 _vararg_count ret;
  return ret;
];

[ glk_stream_set_current _vararg_count;
  ! glk_stream_set_current(stream)
  @glk 71 _vararg_count 0;
  return 0;
];

[ glk_stream_get_current _vararg_count ret;
  ! glk_stream_get_current() => stream
  @glk 72 _vararg_count ret;
  return ret;
];

[ glk_stream_open_resource _vararg_count ret;
  ! glk_stream_open_resource(uint, uint) => stream
  @glk 73 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_temp _vararg_count ret;
  ! glk_fileref_create_temp(uint, uint) => fileref
  @glk 96 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_by_name _vararg_count ret;
  ! glk_fileref_create_by_name(uint, string, uint) => fileref
  @glk 97 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_by_prompt _vararg_count ret;
  ! glk_fileref_create_by_prompt(uint, uint, uint) => fileref
  @glk 98 _vararg_count ret;
  return ret;
];

[ glk_fileref_destroy _vararg_count;
  ! glk_fileref_destroy(fileref)
  @glk 99 _vararg_count 0;
  return 0;
];

[ glk_fileref_iterate _vararg_count ret;
  ! glk_fileref_iterate(fileref, &uint) => fileref
  @glk 100 _vararg_count ret;
  return ret;
];

[ glk_fileref_get_rock _vararg_count ret;
  ! glk_fileref_get_rock(fileref) => uint
  @glk 101 _vararg_count ret;
  return ret;
];

[ glk_fileref_delete_file _vararg_count;
  ! glk_fileref_delete_file(fileref)
  @glk 102 _vararg_count 0;
  return 0;
];

[ glk_fileref_does_file_exist _vararg_count ret;
  ! glk_fileref_does_file_exist(fileref) => uint
  @glk 103 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_from_fileref _vararg_count ret;
  ! glk_fileref_create_from_fileref(uint, fileref, uint) => fileref
  @glk 104 _vararg_count ret;
  return ret;
];

[ glk_put_char _vararg_count;
  ! glk_put_char(uchar)
  @glk 128 _vararg_count 0;
  return 0;
];

[ glk_put_char_stream _vararg_count;
  ! glk_put_char_stream(stream, uchar)
  @glk 129 _vararg_count 0;
  return 0;
];

[ glk_put_string _vararg_count;
  ! glk_put_string(string)
  @glk 130 _vararg_count 0;
  return 0;
];

[ glk_put_string_stream _vararg_count;
  ! glk_put_string_stream(stream, string)
  @glk 131 _vararg_count 0;
  return 0;
];

[ glk_put_buffer _vararg_count;
  ! glk_put_buffer(nativechararray, arraylen)
  @glk 132 _vararg_count 0;
  return 0;
];

[ glk_put_buffer_stream _vararg_count;
  ! glk_put_buffer_stream(stream, nativechararray, arraylen)
  @glk 133 _vararg_count 0;
  return 0;
];

[ glk_set_style _vararg_count;
  ! glk_set_style(uint)
  @glk 134 _vararg_count 0;
  return 0;
];

[ glk_set_style_stream _vararg_count;
  ! glk_set_style_stream(stream, uint)
  @glk 135 _vararg_count 0;
  return 0;
];

[ glk_get_char_stream _vararg_count ret;
  ! glk_get_char_stream(stream) => int
  @glk 144 _vararg_count ret;
  return ret;
];

[ glk_get_line_stream _vararg_count ret;
  ! glk_get_line_stream(stream, nativechararray, arraylen) => uint
  @glk 145 _vararg_count ret;
  return ret;
];

[ glk_get_buffer_stream _vararg_count ret;
  ! glk_get_buffer_stream(stream, nativechararray, arraylen) => uint
  @glk 146 _vararg_count ret;
  return ret;
];

[ glk_char_to_lower _vararg_count ret;
  ! glk_char_to_lower(uchar) => uchar
  @glk 160 _vararg_count ret;
  return ret;
];

[ glk_char_to_upper _vararg_count ret;
  ! glk_char_to_upper(uchar) => uchar
  @glk 161 _vararg_count ret;
  return ret;
];

[ glk_stylehint_set _vararg_count;
  ! glk_stylehint_set(uint, uint, uint, int)
  @glk 176 _vararg_count 0;
  return 0;
];

[ glk_stylehint_clear _vararg_count;
  ! glk_stylehint_clear(uint, uint, uint)
  @glk 177 _vararg_count 0;
  return 0;
];

[ glk_style_distinguish _vararg_count ret;
  ! glk_style_distinguish(window, uint, uint) => uint
  @glk 178 _vararg_count ret;
  return ret;
];

[ glk_style_measure _vararg_count ret;
  ! glk_style_measure(window, uint, uint, &uint) => uint
  @glk 179 _vararg_count ret;
  return ret;
];

[ glk_select _vararg_count;
  ! glk_select(&{uint, window, uint, uint})
  @glk 192 _vararg_count 0;
  return 0;
];

[ glk_select_poll _vararg_count;
  ! glk_select_poll(&{uint, window, uint, uint})
  @glk 193 _vararg_count 0;
  return 0;
];

[ glk_request_line_event _vararg_count;
  ! glk_request_line_event(window, nativechararray, arraylen, uint)
  @glk 208 _vararg_count 0;
  return 0;
];

[ glk_cancel_line_event _vararg_count;
  ! glk_cancel_line_event(window, &{uint, window, uint, uint})
  @glk 209 _vararg_count 0;
  return 0;
];

[ glk_request_char_event _vararg_count;
  ! glk_request_char_event(window)
  @glk 210 _vararg_count 0;
  return 0;
];

[ glk_cancel_char_event _vararg_count;
  ! glk_cancel_char_event(window)
  @glk 211 _vararg_count 0;
  return 0;
];

[ glk_request_mouse_event _vararg_count;
  ! glk_request_mouse_event(window)
  @glk 212 _vararg_count 0;
  return 0;
];

[ glk_cancel_mouse_event _vararg_count;
  ! glk_cancel_mouse_event(window)
  @glk 213 _vararg_count 0;
  return 0;
];

[ glk_request_timer_events _vararg_count;
  ! glk_request_timer_events(uint)
  @glk 214 _vararg_count 0;
  return 0;
];

[ glk_image_get_info _vararg_count ret;
  ! glk_image_get_info(uint, &uint, &uint) => uint
  @glk 224 _vararg_count ret;
  return ret;
];

[ glk_image_draw _vararg_count ret;
  ! glk_image_draw(window, uint, int, int) => uint
  @glk 225 _vararg_count ret;
  return ret;
];

[ glk_image_draw_scaled _vararg_count ret;
  ! glk_image_draw_scaled(window, uint, int, int, uint, uint) => uint
  @glk 226 _vararg_count ret;
  return ret;
];

[ glk_window_flow_break _vararg_count;
  ! glk_window_flow_break(window)
  @glk 232 _vararg_count 0;
  return 0;
];

[ glk_window_erase_rect _vararg_count;
  ! glk_window_erase_rect(window, int, int, uint, uint)
  @glk 233 _vararg_count 0;
  return 0;
];

[ glk_window_fill_rect _vararg_count;
  ! glk_window_fill_rect(window, uint, int, int, uint, uint)
  @glk 234 _vararg_count 0;
  return 0;
];

[ glk_window_set_background_color _vararg_count;
  ! glk_window_set_background_color(window, uint)
  @glk 235 _vararg_count 0;
  return 0;
];

[ glk_schannel_iterate _vararg_count ret;
  ! glk_schannel_iterate(schannel, &uint) => schannel
  @glk 240 _vararg_count ret;
  return ret;
];

[ glk_schannel_get_rock _vararg_count ret;
  ! glk_schannel_get_rock(schannel) => uint
  @glk 241 _vararg_count ret;
  return ret;
];

[ glk_schannel_create _vararg_count ret;
  ! glk_schannel_create(uint) => schannel
  @glk 242 _vararg_count ret;
  return ret;
];

[ glk_schannel_destroy _vararg_count;
  ! glk_schannel_destroy(schannel)
  @glk 243 _vararg_count 0;
  return 0;
];

[ glk_schannel_create_ext _vararg_count ret;
  ! glk_schannel_create_ext(uint, uint) => schannel
  @glk 244 _vararg_count ret;
  return ret;
];

[ glk_schannel_play_multi _vararg_count ret;
  ! glk_schannel_play_multi(schannelarray, arraylen, uintarray, arraylen, uint) => uint
  @glk 247 _vararg_count ret;
  return ret;
];

[ glk_schannel_play _vararg_count ret;
  ! glk_schannel_play(schannel, uint) => uint
  @glk 248 _vararg_count ret;
  return ret;
];

[ glk_schannel_play_ext _vararg_count ret;
  ! glk_schannel_play_ext(schannel, uint, uint, uint) => uint
  @glk 249 _vararg_count ret;
  return ret;
];

[ glk_schannel_stop _vararg_count;
  ! glk_schannel_stop(schannel)
  @glk 250 _vararg_count 0;
  return 0;
];

[ glk_schannel_set_volume _vararg_count;
  ! glk_schannel_set_volume(schannel, uint)
  @glk 251 _vararg_count 0;
  return 0;
];

[ glk_sound_load_hint _vararg_count;
  ! glk_sound_load_hint(uint, uint)
  @glk 252 _vararg_count 0;
  return 0;
];

[ glk_schannel_set_volume_ext _vararg_count;
  ! glk_schannel_set_volume_ext(schannel, uint, uint, uint)
  @glk 253 _vararg_count 0;
  return 0;
];

[ glk_schannel_pause _vararg_count;
  ! glk_schannel_pause(schannel)
  @glk 254 _vararg_count 0;
  return 0;
];

[ glk_schannel_unpause _vararg_count;
  ! glk_schannel_unpause(schannel)
  @glk 255 _vararg_count 0;
  return 0;
];

[ glk_set_hyperlink _vararg_count;
  ! glk_set_hyperlink(uint)
  @glk 256 _vararg_count 0;
  return 0;
];

[ glk_set_hyperlink_stream _vararg_count;
  ! glk_set_hyperlink_stream(stream, uint)
  @glk 257 _vararg_count 0;
  return 0;
];

[ glk_request_hyperlink_event _vararg_count;
  ! glk_request_hyperlink_event(window)
  @glk 258 _vararg_count 0;
  return 0;
];

[ glk_cancel_hyperlink_event _vararg_count;
  ! glk_cancel_hyperlink_event(window)
  @glk 259 _vararg_count 0;
  return 0;
];

[ glk_buffer_to_lower_case_uni _vararg_count ret;
  ! glk_buffer_to_lower_case_uni(uintarray, arraylen, uint) => uint
  @glk 288 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_upper_case_uni _vararg_count ret;
  ! glk_buffer_to_upper_case_uni(uintarray, arraylen, uint) => uint
  @glk 289 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_title_case_uni _vararg_count ret;
  ! glk_buffer_to_title_case_uni(uintarray, arraylen, uint, uint) => uint
  @glk 290 _vararg_count ret;
  return ret;
];

[ glk_buffer_canon_decompose_uni _vararg_count ret;
  ! glk_buffer_canon_decompose_uni(uintarray, arraylen, uint) => uint
  @glk 291 _vararg_count ret;
  return ret;
];

[ glk_buffer_canon_normalize_uni _vararg_count ret;
  ! glk_buffer_canon_normalize_uni(uintarray, arraylen, uint) => uint
  @glk 292 _vararg_count ret;
  return ret;
];

[ glk_put_char_uni _vararg_count;
  ! glk_put_char_uni(uint)
  @glk 296 _vararg_count 0;
  return 0;
];

[ glk_put_string_uni _vararg_count;
  ! glk_put_string_uni(unicode)
  @glk 297 _vararg_count 0;
  return 0;
];

[ glk_put_buffer_uni _vararg_count;
  ! glk_put_buffer_uni(uintarray, arraylen)
  @glk 298 _vararg_count 0;
  return 0;
];

[ glk_put_char_stream_uni _vararg_count;
  ! glk_put_char_stream_uni(stream, uint)
  @glk 299 _vararg_count 0;
  return 0;
];

[ glk_put_string_stream_uni _vararg_count;
  ! glk_put_string_stream_uni(stream, unicode)
  @glk 300 _vararg_count 0;
  return 0;
];

[ glk_put_buffer_stream_uni _vararg_count;
  ! glk_put_buffer_stream_uni(stream, uintarray, arraylen)
  @glk 301 _vararg_count 0;
  return 0;
];

[ glk_get_char_stream_uni _vararg_count ret;
  ! glk_get_char_stream_uni(stream) => int
  @glk 304 _vararg_count ret;
  return ret;
];

[ glk_get_buffer_stream_uni _vararg_count ret;
  ! glk_get_buffer_stream_uni(stream, uintarray, arraylen) => uint
  @glk 305 _vararg_count ret;
  return ret;
];

[ glk_get_line_stream_uni _vararg_count ret;
  ! glk_get_line_stream_uni(stream, uintarray, arraylen) => uint
  @glk 306 _vararg_count ret;
  return ret;
];

[ glk_stream_open_file_uni _vararg_count ret;
  ! glk_stream_open_file_uni(fileref, uint, uint) => stream
  @glk 312 _vararg_count ret;
  return ret;
];

[ glk_stream_open_memory_uni _vararg_count ret;
  ! glk_stream_open_memory_uni(uintarray, arraylen, uint, uint) => stream
  @glk 313 _vararg_count ret;
  return ret;
];

[ glk_stream_open_resource_uni _vararg_count ret;
  ! glk_stream_open_resource_uni(uint, uint) => stream
  @glk 314 _vararg_count ret;
  return ret;
];

[ glk_request_char_event_uni _vararg_count;
  ! glk_request_char_event_uni(window)
  @glk 320 _vararg_count 0;
  return 0;
];

[ glk_request_line_event_uni _vararg_count;
  ! glk_request_line_event_uni(window, uintarray, arraylen, uint)
  @glk 321 _vararg_count 0;
  return 0;
];

[ glk_set_echo_line_event _vararg_count;
  ! glk_set_echo_line_event(window, uint)
  @glk 336 _vararg_count 0;
  return 0;
];

[ glk_set_terminators_line_event _vararg_count;
  ! glk_set_terminators_line_event(window, uintarray, arraylen)
  @glk 337 _vararg_count 0;
  return 0;
];

[ glk_current_time _vararg_count;
  ! glk_current_time(&{int, uint, int})
  @glk 352 _vararg_count 0;
  return 0;
];

[ glk_current_simple_time _vararg_count ret;
  ! glk_current_simple_time(uint) => int
  @glk 353 _vararg_count ret;
  return ret;
];

[ glk_time_to_date_utc _vararg_count;
  ! glk_time_to_date_utc(&{int, uint, int}, &{int, int, int, int, int, int, int, int})
  @glk 360 _vararg_count 0;
  return 0;
];

[ glk_time_to_date_local _vararg_count;
  ! glk_time_to_date_local(&{int, uint, int}, &{int, int, int, int, int, int, int, int})
  @glk 361 _vararg_count 0;
  return 0;
];

[ glk_simple_time_to_date_utc _vararg_count;
  ! glk_simple_time_to_date_utc(int, uint, &{int, int, int, int, int, int, int, int})
  @glk 362 _vararg_count 0;
  return 0;
];

[ glk_simple_time_to_date_local _vararg_count;
  ! glk_simple_time_to_date_local(int, uint, &{int, int, int, int, int, int, int, int})
  @glk 363 _vararg_count 0;
  return 0;
];

[ glk_date_to_time_utc _vararg_count;
  ! glk_date_to_time_utc(&{int, int, int, int, int, int, int, int}, &{int, uint, int})
  @glk 364 _vararg_count 0;
  return 0;
];

[ glk_date_to_time_local _vararg_count;
  ! glk_date_to_time_local(&{int, int, int, int, int, int, int, int}, &{int, uint, int})
  @glk 365 _vararg_count 0;
  return 0;
];

[ glk_date_to_simple_time_utc _vararg_count ret;
  ! glk_date_to_simple_time_utc(&{int, int, int, int, int, int, int, int}, uint) => int
  @glk 366 _vararg_count ret;
  return ret;
];

[ glk_date_to_simple_time_local _vararg_count ret;
  ! glk_date_to_simple_time_local(&{int, int, int, int, int, int, int, int}, uint) => int
  @glk 367 _vararg_count ret;
  return ret;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Rocks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant GG_MAINWIN_ROCK        201;
Constant GG_STATUSWIN_ROCK      202;
Constant GG_QUOTEWIN_ROCK       203;
Constant GG_SAVESTR_ROCK        301;
Constant GG_SCRIPTSTR_ROCK      302;
Constant GG_COMMANDWSTR_ROCK    303;
Constant GG_COMMANDRSTR_ROCK    304;
Constant GG_SCRIPTFREF_ROCK     401;
Constant GG_FOREGROUNDCHAN_ROCK 410;
Constant GG_BACKGROUNDCHAN_ROCK 411;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Stubs
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Stub HandleGlkEvent    2;
#Stub IdentifyGlkObject 4;
#Stub InitGlkWindow     1;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Starting Up
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_PreInitialise res;
    @gestalt 4 2 res; ! Test if this interpreter has Glk...
    if (res == 0) quit; ! ...without which there would be nothing we could do

	unicode_gestalt_ok = false;
	if (glk_gestalt(gestalt_Unicode, 0))
		unicode_gestalt_ok = true;

    ! Set the VM's I/O system to be Glk.
    @setiosys 2 0;
];

[ VM_Initialise res sty i;
    @gestalt 4 2 res; ! Test if this interpreter has Glk...
    if (res == 0) quit; ! ...without which there would be nothing we could do

    ! First, we must go through all the Glk objects that exist, and see
    ! if we created any of them. One might think this strange, since the
    ! program has just started running, but remember that the player might
    ! have just typed "restart".

    GGRecoverObjects();

	! Sound channel initialisation, and RNG fixing, must be done now rather
	! than later in case InitGlkWindow() returns a non-zero value.

	if (glk_gestalt(gestalt_Sound, 0)) {
		if (gg_foregroundchan == 0)
			gg_foregroundchan = glk_schannel_create(GG_FOREGROUNDCHAN_ROCK);
		if (gg_backgroundchan == 0)
			gg_backgroundchan = glk_schannel_create(GG_BACKGROUNDCHAN_ROCK);
	}

	#ifdef FIX_RNG;
	@random 10000 i;
	i = -i-2000;
	print "[Random number generator seed is ", i, "]^";
	@setrandom i;
	#endif; ! FIX_RNG

    res = InitGlkWindow(0);
    if (res ~= 0) return;

    ! Now, gg_mainwin and gg_storywin might already be set. If not, set them.

    if (gg_mainwin == 0) {
        ! Open the story window.
        res = InitGlkWindow(GG_MAINWIN_ROCK);
        if (res == 0) {
        	! Left-justify the header style
			glk_stylehint_set(wintype_TextBuffer, style_Header, stylehint_Justification, 0);
			! Try to make emphasized type in italics and not boldface
			glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Weight, 0);
			glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Oblique, 1);
            gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK);
		}
        if (gg_mainwin == 0) quit; ! If we can't even open one window, give in
    } else {
        ! There was already a story window. We should erase it.
        glk_window_clear(gg_mainwin);
    }

    if (gg_statuswin == 0) {
        res = InitGlkWindow(GG_STATUSWIN_ROCK);
        if (res == 0) {
            statuswin_cursize = statuswin_size;
			for (sty=0: sty<style_NUMSTYLES: sty++)
				glk_stylehint_set(wintype_TextGrid, sty, stylehint_ReverseColor, 1);
            gg_statuswin =
            	glk_window_open(gg_mainwin, winmethod_Fixed + winmethod_Above,
            		statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK);
        }
    }
    ! It's possible that the status window couldn't be opened, in which case
    ! gg_statuswin is now zero. We must allow for that later on.

    glk_set_window(gg_mainwin);

    InitGlkWindow(1);
    
    ! Empty the parse buffer (see bug 0001451)
    buffer3-->0 = 0;
];

[ GGRecoverObjects id;
    ! If GGRecoverObjects() has been called, all these stored IDs are
    ! invalid, so we start by clearing them all out.
    ! (In fact, after a restoreundo, some of them may still be good.
    ! For simplicity, though, we assume the general case.)
    gg_mainwin = 0;
    gg_statuswin = 0;
    gg_quotewin = 0;
    gg_scriptfref = 0;
    gg_scriptstr = 0;
    gg_savestr = 0;
    statuswin_cursize = 0;
    gg_foregroundchan = 0;
    gg_backgroundchan = 0;
    #Ifdef DEBUG;
    gg_commandstr = 0;
    gg_command_reading = false;
    #Endif; ! DEBUG
    ! Also tell the game to clear its object references.
    IdentifyGlkObject(0);

    id = glk_stream_iterate(0, gg_arguments);
    while (id) {
        switch (gg_arguments-->0) {
            GG_SAVESTR_ROCK: gg_savestr = id;
            GG_SCRIPTSTR_ROCK: gg_scriptstr = id;
            #Ifdef DEBUG;
            GG_COMMANDWSTR_ROCK: gg_commandstr = id;
                                 gg_command_reading = false;
            GG_COMMANDRSTR_ROCK: gg_commandstr = id;
                                 gg_command_reading = true;
            #Endif; ! DEBUG
            default: IdentifyGlkObject(1, 1, id, gg_arguments-->0);
        }
        id = glk_stream_iterate(id, gg_arguments);
    }

    id = glk_window_iterate(0, gg_arguments);
    while (id) {
        switch (gg_arguments-->0) {
            GG_MAINWIN_ROCK: gg_mainwin = id;
            GG_STATUSWIN_ROCK: gg_statuswin = id;
            GG_QUOTEWIN_ROCK: gg_quotewin = id;
            default: IdentifyGlkObject(1, 0, id, gg_arguments-->0);
        }
        id = glk_window_iterate(id, gg_arguments);
    }

    id = glk_fileref_iterate(0, gg_arguments);
    while (id) {
        switch (gg_arguments-->0) {
            GG_SCRIPTFREF_ROCK: gg_scriptfref = id;
            default: IdentifyGlkObject(1, 2, id, gg_arguments-->0);
        }
        id = glk_fileref_iterate(id, gg_arguments);
    }

	if (glk_gestalt(gestalt_Sound, 0)) {
		id = glk_schannel_iterate(0, gg_arguments);
		while (id) {
			switch (gg_arguments-->0) {
				GG_FOREGROUNDCHAN_ROCK: gg_foregroundchan = id;
				GG_BACKGROUNDCHAN_ROCK: gg_backgroundchan = id;
				default: IdentifyGlkObject(1, 3, id, gg_arguments-->0);
			}
			id = glk_schannel_iterate(id, gg_arguments);
		}
		if (gg_foregroundchan ~= 0) { glk_schannel_stop(gg_foregroundchan); }
		if (gg_backgroundchan ~= 0) { glk_schannel_stop(gg_backgroundchan); }
	}

    ! Tell the game to tie up any loose ends.
    IdentifyGlkObject(2);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Enable Acceleration
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ENABLE_GLULX_ACCEL_R addr res;
	@gestalt 9 0 res;
	if (res == 0) return;
	addr = #classes_table;
	@accelparam 0 addr;
	@accelparam 1 INDIV_PROP_START;
	@accelparam 2 Class;
	@accelparam 3 Object;
	@accelparam 4 Routine;
	@accelparam 5 String;
	addr = #globals_array + WORDSIZE * #g$self;
	@accelparam 6 addr;
	@accelparam 7 NUM_ATTR_BYTES;
	addr = #cpv__start;
	@accelparam 8 addr;
	@accelfunc 1 Z__Region;
	@accelfunc 2 CP__Tab;
	@accelfunc 3 RA__Pr;
	@accelfunc 4 RL__Pr;
	@accelfunc 5 OC__Cl;
	@accelfunc 6 RV__Pr;
	@accelfunc 7 OP__Pr;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Release Number
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Describe_Release i;
	print "Release ";
	@aloads ROM_GAMERELEASE 0 i;
	print i;
	print " / Serial number ";
	for (i=0 : i<6 : i++) print (char) ROM_GAMESERIAL->i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Keyboard Input
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_KeyChar win nostat done res ix jx ch;
    jx = ch; ! squash compiler warnings
    if (win == 0) win = gg_mainwin;
    if (gg_commandstr ~= 0 && gg_command_reading ~= false) {
        done = glk_get_line_stream(gg_commandstr, gg_arguments, 31);
        if (done == 0) {
            glk_stream_close(gg_commandstr, 0);
            gg_commandstr = 0;
            gg_command_reading = false;
            ! fall through to normal user input.
        } else {
            ! Trim the trailing newline
            if (gg_arguments->(done-1) == 10) done = done-1;
            res = gg_arguments->0;
            if (res == '\') {
                res = 0;
                for (ix=1 : ix<done : ix++) {
                    ch = gg_arguments->ix;
                    if (ch >= '0' && ch <= '9') {
                        @shiftl res 4 res;
                        res = res + (ch-'0');
                    } else if (ch >= 'a' && ch <= 'f') {
                        @shiftl res 4 res;
                        res = res + (ch+10-'a');
                    } else if (ch >= 'A' && ch <= 'F') {
                        @shiftl res 4 res;
                        res = res + (ch+10-'A');
                    }
                }
            }
       		jump KCPContinue;
        }
    }
    done = false;
    glk_request_char_event(win);
    while (~~done) {
        glk_select(gg_event);
        switch (gg_event-->0) {
          5: ! evtype_Arrange
            if (nostat) {
                glk_cancel_char_event(win);
                res = $80000000;
                done = true;
                break;
            }
            FollowRulebook(549);
            DrawStatusLine();
          2: ! evtype_CharInput
            if (gg_event-->1 == win) {
                res = gg_event-->2;
                done = true;
                }
        }
        ix = HandleGlkEvent(gg_event, 1, gg_arguments);
        if (ix == 2) {
            res = gg_arguments-->0;
            done = true;
        } else if (ix == -1)  done = false;
    }
    if (gg_commandstr ~= 0 && gg_command_reading == false) {
        if (res < 32 || res >= 256 || (res == '\' or ' ')) {
            glk_put_char_stream(gg_commandstr, '\');
            done = 0;
            jx = res;
            for (ix=0 : ix<8 : ix++) {
                @ushiftr jx 28 ch;
                @shiftl jx 4 jx;
                ch = ch & $0F;
                if (ch ~= 0 || ix == 7) done = 1;
                if (done) {
                    if (ch >= 0 && ch <= 9) ch = ch + '0';
                    else                    ch = (ch - 10) + 'A';
                    glk_put_char_stream(gg_commandstr, ch);
                }
            }
        } else {
            glk_put_char_stream(gg_commandstr, res);
        }
        glk_put_char_stream(gg_commandstr, 10); ! newline
    }
  .KCPContinue;
    return res;
];

[ VM_KeyDelay tenths  key done ix;
    glk_request_char_event(gg_mainwin);
    glk_request_timer_events(tenths*100);
    while (~~done) {
        glk_select(gg_event);
        ix = HandleGlkEvent(gg_event, 1, gg_arguments);
        if (ix == 2) {
            key = gg_arguments-->0;
            done = true;
        }
        else if (ix >= 0 && gg_event-->0 == 1 or 2) {
            key = gg_event-->2;
            done = true;
        }
    }
    glk_cancel_char_event(gg_mainwin);
    glk_request_timer_events(0);
    return key;
];

[ VM_ReadKeyboard  a_buffer a_table done ix;
    if (gg_commandstr ~= 0 && gg_command_reading ~= false) {
        done = glk_get_line_stream(gg_commandstr, a_buffer+WORDSIZE,
        	(INPUT_BUFFER_LEN-WORDSIZE)-1);
        if (done == 0) {
            glk_stream_close(gg_commandstr, 0);
            gg_commandstr = 0;
            gg_command_reading = false;
        }
        else {
            ! Trim the trailing newline
            if ((a_buffer+WORDSIZE)->(done-1) == 10) done = done-1;
            a_buffer-->0 = done;
            VM_Style(INPUT_VMSTY);
            glk_put_buffer(a_buffer+WORDSIZE, done);
            VM_Style(NORMAL_VMSTY);
            print "^";
            jump KPContinue;
        }
    }
    done = false;
    glk_request_line_event(gg_mainwin, a_buffer+WORDSIZE, INPUT_BUFFER_LEN-WORDSIZE, 0);
    while (~~done) {
        glk_select(gg_event);
        switch (gg_event-->0) {
          5: ! evtype_Arrange
            FollowRulebook(549);
            DrawStatusLine();
          3: ! evtype_LineInput
            if (gg_event-->1 == gg_mainwin) {
                a_buffer-->0 = gg_event-->2;
                done = true;
            }
        }
        ix = HandleGlkEvent(gg_event, 0, a_buffer);
        if (ix == 2) done = true;
        else if (ix == -1) done = false;
    }
    if (gg_commandstr ~= 0 && gg_command_reading == false) {
        glk_put_buffer_stream(gg_commandstr, a_buffer+WORDSIZE, a_buffer-->0);
        glk_put_char_stream(gg_commandstr, 10); ! newline
    }
  .KPContinue;
    VM_Tokenise(a_buffer,a_table);
    ! It's time to close any quote window we've got going.
    if (gg_quotewin) {
        glk_window_close(gg_quotewin, 0);
        gg_quotewin = 0;
    }
    #ifdef ECHO_COMMANDS;
    print "** ";
    for (ix=WORDSIZE: ix<(a_buffer-->0)+WORDSIZE: ix++) print (char) a_buffer->ix;
    print "^";
    #endif; ! ECHO_COMMANDS
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Buffer Functions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_CopyBuffer bto bfrom i;
    for (i=0: i<INPUT_BUFFER_LEN: i++) bto->i = bfrom->i;
];

[ VM_PrintToBuffer buf len a b c;
    if (b) {
        if (metaclass(a) == Object && a.#b == WORDSIZE
            && metaclass(a.b) == String)
            buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a.b);
		else if (metaclass(a) == Routine)
			buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a, b, c);
        else
            buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a, b);
    }
    else if (metaclass(a) == Routine)
        buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a, b, c);
    else
		buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a);
    if (buf-->0 > len) buf-->0 = len;
    return buf-->0;
];

[ VM_Tokenise buf tab
    cx numwords len bx ix wx wpos wlen val res dictlen entrylen;
    len = buf-->0;
    buf = buf+WORDSIZE;

    ! First, split the buffer up into words. We use the standard Infocom
    ! list of word separators (comma, period, double-quote).

    cx = 0;
    numwords = 0;
    while (cx < len) {
        while (cx < len && buf->cx == ' ') cx++;
        if (cx >= len) break;
        bx = cx;
        if (buf->cx == '.' or ',' or '"') cx++;
        else {
            while (cx < len && buf->cx ~= ' ' or '.' or ',' or '"') cx++;
        }
        tab-->(numwords*3+2) = (cx-bx);
        tab-->(numwords*3+3) = WORDSIZE+bx;
        numwords++;
        if (numwords >= MAX_BUFFER_WORDS) break;
    }
    tab-->0 = numwords;

    ! Now we look each word up in the dictionary.

    dictlen = #dictionary_table-->0;
    entrylen = DICT_WORD_SIZE + 7;

    for (wx=0 : wx<numwords : wx++) {
        wlen = tab-->(wx*3+2);
        wpos = tab-->(wx*3+3);

        ! Copy the word into the gg_tokenbuf array, clipping to DICT_WORD_SIZE
        ! characters and lower case.
        if (wlen > DICT_WORD_SIZE) wlen = DICT_WORD_SIZE;
        cx = wpos - WORDSIZE;
        for (ix=0 : ix<wlen : ix++) gg_tokenbuf->ix = VM_UpperToLowerCase(buf->(cx+ix));
        for (: ix<DICT_WORD_SIZE : ix++) gg_tokenbuf->ix = 0;

        val = #dictionary_table + WORDSIZE;
        @binarysearch gg_tokenbuf DICT_WORD_SIZE val entrylen dictlen 1 1 res;
        tab-->(wx*3+1) = res;
    }
];

[ LTI_Insert i ch  b y;

    ! Protect us from strict mode, as this isn't an array in quite the
    ! sense it expects
    b = buffer;

    ! Insert character ch into buffer at point i.
    ! Being careful not to let the buffer possibly overflow:
    y = b-->0;
    if (y > INPUT_BUFFER_LEN) y = INPUT_BUFFER_LEN;

    ! Move the subsequent text along one character:
    for (y=y+WORDSIZE : y>i : y--) b->y = b->(y-1);
    b->i = ch;

    ! And the text is now one character longer:
    if (b-->0 < INPUT_BUFFER_LEN) (b-->0)++;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Dictionary Functions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_InvalidDictionaryAddress addr;
	if (addr < 0) rtrue;
	rfalse;
];

[ VM_DictionaryAddressToNumber w; return w; ];
[ VM_NumberToDictionaryAddress n; return n; ];

Array gg_tokenbuf -> DICT_WORD_SIZE;

[ GGWordCompare str1 str2 ix jx;
    for (ix=0 : ix<DICT_WORD_SIZE : ix++) {
        jx = (str1->ix) - (str2->ix);
        if (jx ~= 0) return jx;
    }
    return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: SHOWVERB support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef DEBUG;
[ DebugAction a str;
    if (a >= 4096) { print "<fake action ", a-4096, ">"; return; }
    if (a < 0 || a >= #identifiers_table-->7) print "<invalid action ", a, ">";
    else {
        str = #identifiers_table-->6;
        str = str-->a;
        if (str) print (string) str; else print "<unnamed action ", a, ">";
    }
];

[ DebugAttribute a str;
    if (a < 0 || a >= NUM_ATTR_BYTES*8) print "<invalid attribute ", a, ">";
    else {
        str = #identifiers_table-->4;
        str = str-->a;
        if (str) print (string) str; else print "<unnamed attribute ", a, ">";
    }
];
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Command Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_CommandTableAddress i;
	return (#grammar_table)-->(i+1);
];

[ VM_PrintCommandWords i wd j dictlen entrylen;
    dictlen = #dictionary_table-->0;
    entrylen = DICT_WORD_SIZE + 7;
    for (j=0 : j<dictlen : j++) {
        wd = #dictionary_table + WORDSIZE + entrylen*j;
        if (DictionaryWordToVerbNum(wd) == i)
            print "'", (address) wd, "' ";
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Random Number Generator
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Seed_RNG n;
	@setrandom n;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Memory Allocation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_AllocateMemory amount i;
	@gestalt 7 0 i;
	if (i == 0) return i;
	@malloc amount i;
	return i;
];

[ VM_FreeMemory address i;
	@gestalt 7 0 i;
	if (i == 0) return;
	@mfree address;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Audiovisual Resources
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Picture resource_ID;
	if (glk_gestalt(gestalt_Graphics, 0)) {
		glk_image_draw(gg_mainwin, resource_ID, imagealign_InlineCenter, 0);
	} else {
		print "[Picture number ", resource_ID, " here.]^";
	}
];

[ VM_SoundEffect resource_ID;
	if (glk_gestalt(gestalt_Sound, 0)) {
		glk_schannel_play(gg_foregroundchan, resource_ID);
	} else {
		print "[Sound effect number ", resource_ID, " here.]^";
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Typography
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Style sty;
	switch (sty) {
		NORMAL_VMSTY:     glk_set_style(style_Normal);
		HEADER_VMSTY:     glk_set_style(style_Header);
		SUBHEADER_VMSTY:  glk_set_style(style_Subheader);
		NOTE_VMSTY:       glk_set_style(style_Note);
		ALERT_VMSTY:      glk_set_style(style_Alert);
		BLOCKQUOTE_VMSTY: glk_set_style(style_BlockQuote);
		INPUT_VMSTY:      glk_set_style(style_Input);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Character Casing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_UpperToLowerCase c; return glk_char_to_lower(c); ];
[ VM_LowerToUpperCase c; return glk_char_to_upper(c); ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Glulx-Only Printing Routines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! Glulx_PrintAnything()                    <nothing printed>
! Glulx_PrintAnything(0)                   <nothing printed>
! Glulx_PrintAnything("string");           print (string) "string";
! Glulx_PrintAnything('word')              print (address) 'word';
! Glulx_PrintAnything(obj)                 print (name) obj;
! Glulx_PrintAnything(obj, prop)           obj.prop();
! Glulx_PrintAnything(obj, prop, args...)  obj.prop(args...);
! Glulx_PrintAnything(func)                func();
! Glulx_PrintAnything(func, args...)       func(args...);

[ Glulx_PrintAnything _vararg_count obj mclass;
    if (_vararg_count == 0) return;
    @copy sp obj;
    _vararg_count--;
    if (obj == 0) return;

    if (obj->0 == $60) {
        ! Dictionary word. Metaclass() can't catch this case, so we do it manually
        print (address) obj;
        return;
    }

    mclass = metaclass(obj);
    switch (mclass) {
      nothing:
        return;
      String:
        print (string) obj;
        return;
      Routine:
        ! Call the function with all the arguments which are already
        ! on the stack.
        @call obj _vararg_count 0;
        return;
      Object:
        if (_vararg_count == 0) {
            print (name) obj;
        }
        else {
            ! Push the object back onto the stack, and call the
            ! veneer routine that handles obj.prop() calls.
            @copy obj sp;
            _vararg_count++;
            @call CA__Pr _vararg_count 0;
        }
        return;
    }
];

[ Glulx_PrintAnyToArray _vararg_count arr arrlen str oldstr len;
    @copy sp arr;
    @copy sp arrlen;
    _vararg_count = _vararg_count - 2;

    oldstr = glk_stream_get_current();
    str = glk_stream_open_memory(arr, arrlen, 1, 0);
    if (str == 0) return 0;

    glk_stream_set_current(str);

    @call Glulx_PrintAnything _vararg_count 0;

    glk_stream_set_current(oldstr);
    @copy $ffffffff sp;
    @copy str sp;
    @glk $0044 2 0; ! stream_close
    @copy sp len;
    @copy sp 0;
    return len;
];

Constant GG_ANYTOSTRING_LEN 66;
Array AnyToStrArr -> GG_ANYTOSTRING_LEN+1;

[ Glulx_ChangeAnyToCString _vararg_count ix len;
    ix = GG_ANYTOSTRING_LEN-2;
    @copy ix sp;
    ix = AnyToStrArr+1;
    @copy ix sp;
    ix = _vararg_count+2;
    @call Glulx_PrintAnyToArray ix len;
    AnyToStrArr->0 = $E0;
    if (len >= GG_ANYTOSTRING_LEN)
        len = GG_ANYTOSTRING_LEN-1;
    AnyToStrArr->(len+1) = 0;
    return AnyToStrArr;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: The Screen
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_ClearScreen window;
    if (window == WIN_ALL or WIN_MAIN) {
        glk_window_clear(gg_mainwin);
        if (gg_quotewin) {
            glk_window_close(gg_quotewin, 0);
            gg_quotewin = 0;
        }
    }
    if (gg_statuswin && window == WIN_ALL or WIN_STATUS) glk_window_clear(gg_statuswin);
];

[ VM_ScreenWidth  id;
    id=gg_mainwin;
    if (gg_statuswin && statuswin_current) id = gg_statuswin;
    glk_window_get_size(id, gg_arguments, 0);
    return gg_arguments-->0;
];

[ VM_ScreenHeight;
    glk_window_get_size(gg_mainwin, 0, gg_arguments);
    return gg_arguments-->0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Window Colours
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_SetWindowColours f b window doclear  i fwd bwd swin;
    if (clr_on && f && b) {
        if (window) swin = 5-window; ! 4 for TextGrid, 3 for TextBuffer

        fwd = MakeColourWord(f);
        bwd = MakeColourWord(b);
        for (i=0 : i<style_NUMSTYLES: i++) {
            if (f == CLR_DEFAULT || b == CLR_DEFAULT) {  ! remove style hints
                glk_stylehint_clear(swin, i, stylehint_TextColor);
                glk_stylehint_clear(swin, i, stylehint_BackColor);
            } else {
                glk_stylehint_set(swin, i, stylehint_TextColor, fwd);
                glk_stylehint_set(swin, i, stylehint_BackColor, bwd);
            }
        }

        ! Now re-open the windows to apply the hints
        if (gg_statuswin) glk_window_close(gg_statuswin, 0);
        gg_statuswin = 0;

        if (doclear || ( window ~= 1 && (clr_fg ~= f || clr_bg ~= b) ) ) {
            glk_window_close(gg_mainwin, 0);
            gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK);
            if (gg_scriptstr ~= 0)
                glk_window_set_echo_stream(gg_mainwin, gg_scriptstr);
        }

        gg_statuswin =
        	glk_window_open(gg_mainwin, winmethod_Fixed + winmethod_Above,
        		statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK);
        if (statuswin_current && gg_statuswin) VM_MoveCursorInStatusLine(); else VM_MainWindow();

        if (window ~= 2) {
            clr_fgstatus = f;
            clr_bgstatus = b;
        }
        if (window ~= 1) {
            clr_fg = f;
            clr_bg = b;
        }
    }
];

[ VM_RestoreWindowColours; ! used after UNDO: compare I6 patch L61007
    if (clr_on) { ! check colour has been used
        VM_SetWindowColours(clr_fg, clr_bg, 2); ! make sure both sets of variables are restored
        VM_SetWindowColours(clr_fgstatus, clr_bgstatus, 1, true);
        VM_ClearScreen();
    }
];

[ MakeColourWord c;
    if (c > 9) return c;
    c = c-2;
    return $ff0000*(c&1) + $ff00*(c&2 ~= 0) + $ff*(c&4 ~= 0);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Main Window
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_MainWindow;
    glk_set_window(gg_mainwin); ! set_window
    statuswin_current=0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Status Line
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_StatusLineHeight hgt;
    if (gg_statuswin == 0) return;
    if (hgt == statuswin_cursize) return;
    glk_window_set_arrangement(glk_window_get_parent(gg_statuswin), $12, hgt, 0);
    statuswin_cursize = hgt;
];

[ VM_MoveCursorInStatusLine line column;
    if (gg_statuswin == 0) return;
    glk_set_window(gg_statuswin);
    if (line == 0) { line = 1; column = 1; }
    glk_window_move_cursor(gg_statuswin, column-1, line-1);
    statuswin_current=1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Quotation Boxes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Box__Routine maxwid arr ix lines lastnl parwin;
    maxwid = 0; ! squash compiler warning
    lines = arr-->0;

    if (gg_quotewin == 0) {
        gg_arguments-->0 = lines;
        ix = InitGlkWindow(GG_QUOTEWIN_ROCK);
        if (ix == 0)
            gg_quotewin =
            	glk_window_open(gg_mainwin, winmethod_Fixed + winmethod_Above,
            		lines, wintype_TextBuffer, GG_QUOTEWIN_ROCK);
    } else {
        parwin = glk_window_get_parent(gg_quotewin);
        glk_window_set_arrangement(parwin, $12, lines, 0);
    }

    lastnl = true;
    if (gg_quotewin) {
        glk_window_clear(gg_quotewin);
        glk_set_window(gg_quotewin);
        lastnl = false;
    }

	VM_Style(BLOCKQUOTE_VMSTY);
    for (ix=0 : ix<lines : ix++) {
        print (string) arr-->(ix+1);
        if (ix < lines-1 || lastnl) new_line;
    }
	VM_Style(NORMAL_VMSTY);

    if (gg_quotewin) glk_set_window(gg_mainwin);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: GlkList Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef DEBUG;
[ GlkListSub id val;
    id = glk_window_iterate(0, gg_arguments);
    while (id) {
        print "Window ", id, " (", gg_arguments-->0, "): ";
        val = glk_window_get_type(id);
        switch (val) {
          1: print "pair";
          2: print "blank";
          3: print "textbuffer";
          4: print "textgrid";
          5: print "graphics";
          default: print "unknown";
        }
        val = glk_window_get_parent(id);
        if (val) print ", parent is window ", val;
        else     print ", no parent (root)";
        val = glk_window_get_stream(id);
        print ", stream ", val;
        val = glk_window_get_echo_stream(id);
        if (val) print ", echo stream ", val;
        print "^";
        id = glk_window_iterate(id, gg_arguments);
    }
    id = glk_stream_iterate(0, gg_arguments);
    while (id) {
        print "Stream ", id, " (", gg_arguments-->0, ")^";
        id = glk_stream_iterate(id, gg_arguments);
    }
    id = glk_fileref_iterate(0, gg_arguments);
    while (id) {
        print "Fileref ", id, " (", gg_arguments-->0, ")^";
        id = glk_fileref_iterate(id, gg_arguments);
    }
    if (glk_gestalt(gestalt_Sound, 0)) {
        id = glk_schannel_iterate(0, gg_arguments);
        while (id) {
            print "Soundchannel ", id, " (", gg_arguments-->0, ")^";
            id = glk_schannel_iterate(id, gg_arguments);
        }
    }
];

Verb meta 'glklist'

    *                                           -> Glklist;
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Undo
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Undo result_code;
	@restoreundo result_code;
	return (~~result_code);
];

[ VM_Save_Undo result_code;
    @saveundo result_code;
    if (result_code == -1) { GGRecoverObjects(); return 2; }
    return (~~result_code);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Quit The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ QUIT_THE_GAME_R;
	if (actor ~= player) rfalse;
	if ((actor == player) && (untouchable_silence == false))
		QUIT_THE_GAME_RM('A');
	if (YesOrNo()~=0) quit;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Restart The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RESTART_THE_GAME_R;
	if (actor ~= player) rfalse;
	RESTART_THE_GAME_RM('A');
	if (YesOrNo()~=0) {
		@restart;
		RESTART_THE_GAME_RM('B'); new_line;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Restore The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RESTORE_THE_GAME_R res fref;
	if (actor ~= player) rfalse;
	fref = glk_fileref_create_by_prompt($01, $02, 0);
	if (fref == 0) jump RFailed;
	gg_savestr = glk_stream_open_file(fref, $02, GG_SAVESTR_ROCK);
	glk_fileref_destroy(fref);
	if (gg_savestr == 0) jump RFailed;
	@restore gg_savestr res;
	glk_stream_close(gg_savestr, 0);
	gg_savestr = 0;
	.RFailed;
	RESTORE_THE_GAME_RM('A'); new_line;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Save The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SAVE_THE_GAME_R res fref;
	if (actor ~= player) rfalse;
	fref = glk_fileref_create_by_prompt($01, $01, 0);
	if (fref == 0) jump SFailed;
	gg_savestr = glk_stream_open_file(fref, $01, GG_SAVESTR_ROCK);
	glk_fileref_destroy(fref);
	if (gg_savestr == 0) jump SFailed;
	@save gg_savestr res;
	if (res == -1) {
		! The player actually just typed "restore". We first have to recover
		! all the Glk objects; the values in our global variables are all wrong.
		GGRecoverObjects();
		glk_stream_close(gg_savestr, 0); ! stream_close
		gg_savestr = 0;
		RESTORE_THE_GAME_RM('B'); new_line;
		rtrue;
	}
	glk_stream_close(gg_savestr, 0); ! stream_close
	gg_savestr = 0;
	if (res == 0) { SAVE_THE_GAME_RM('B'); new_line; rtrue; }
	.SFailed;
	SAVE_THE_GAME_RM('A'); new_line;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Verify The Story File Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VERIFY_THE_STORY_FILE_R res;
	if (actor ~= player) rfalse;
	@verify res;
	if (res == 0) { VERIFY_THE_STORY_FILE_RM('A'); new_line; rtrue; }
	VERIFY_THE_STORY_FILE_RM('B'); new_line;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Switch Transcript On Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SWITCH_TRANSCRIPT_ON_R;
	if (actor ~= player) rfalse;
	if (gg_scriptstr ~= 0) { SWITCH_TRANSCRIPT_ON_RM('A'); new_line; rtrue; }
	if (gg_scriptfref == 0) {
		gg_scriptfref = glk_fileref_create_by_prompt($102, $05, GG_SCRIPTFREF_ROCK);
		if (gg_scriptfref == 0) jump S1Failed;
	}
	! stream_open_file
	gg_scriptstr = glk_stream_open_file(gg_scriptfref, $05, GG_SCRIPTSTR_ROCK);
	if (gg_scriptstr == 0) jump S1Failed;
	glk_window_set_echo_stream(gg_mainwin, gg_scriptstr);
	SWITCH_TRANSCRIPT_ON_RM('B'); new_line;
	VersionSub();
	return;
	.S1Failed;
	SWITCH_TRANSCRIPT_ON_RM('C'); new_line;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Switch Transcript Off Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SWITCH_TRANSCRIPT_OFF_R;
	if (actor ~= player) rfalse;
	if (gg_scriptstr == 0) { SWITCH_TRANSCRIPT_OFF_RM('A'); new_line; rtrue; }
	SWITCH_TRANSCRIPT_OFF_RM('B'); new_line;
	glk_stream_close(gg_scriptstr, 0); ! stream_close
	gg_scriptstr = 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Announce Story File Version Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ANNOUNCE_STORY_FILE_VERSION_R ix;
	if (actor ~= player) rfalse;
	Banner();
	print "Identification number: ";
	for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
	print "^";
	@gestalt 1 0 ix;
	print "Interpreter version ", ix / $10000, ".", (ix & $FF00) / $100,
	".", ix & $FF, " / ";
	@gestalt 0 0 ix;
	print "VM ", ix / $10000, ".", (ix & $FF00) / $100, ".", ix & $FF, " / ";
	print "Library serial number ", (string) LibSerial, "^";
	#Ifdef LanguageVersion;
	print (string) LanguageVersion, "^";
	#Endif; ! LanguageVersion
	ShowExtensionVersions();
	say__p = 1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Descend To Specific Action Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DESCEND_TO_SPECIFIC_ACTION_R;
	indirect(#actions_table-->(action+1));
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Glulx.i6t: Veneer
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Unsigned__Compare x y;
	@jleu x y ?lesseq;
	return 1;
	.lesseq;
	@jeq x y ?equal;
	return -1;
	.equal;
	return 0;
];

[ RT__ChLDW x y;
	@aload x y sp;
	@return sp;
];

[ RT__ChLDB x y;
	@aloadb x y sp;
	@return sp;
];

#Endif;

#Ifdef TARGET_ZCODE;

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Summary
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Variables and Arrays
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global top_object; ! largest valid number of any tree object
Global xcommsdir; ! true if command recording is on
Global transcript_mode; ! true if game scripting is on

Constant INPUT_BUFFER_LEN = 120; ! Length of buffer array

Array  buffer    -> 123;            ! Buffer for parsing main line of input
Array  buffer2   -> 123;            ! Buffers for supplementary questions
Array  buffer3   -> 123;            ! Buffer retaining input for "again"
Array  parse     buffer 63;         ! Parse table mirroring it
Array  parse2    buffer 63;         !

Global dict_start;
Global dict_entry_size;
Global dict_end;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Starting Up
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Initialise i;
	standard_interpreter = HDR_TERPSTANDARD-->0;
	transcript_mode = ((HDR_GAMEFLAGS-->0) & 1);

	dict_start = HDR_DICTIONARY-->0;
	dict_entry_size = dict_start->(dict_start->0 + 1);
	dict_start = dict_start + dict_start->0 + 4;
	dict_end = dict_start + ((dict_start - 2)-->0) * dict_entry_size;

	buffer->0  = INPUT_BUFFER_LEN;
	buffer2->0 = INPUT_BUFFER_LEN;
	buffer3->0 = INPUT_BUFFER_LEN;
	parse->0   = 15;
	parse2->0  = 15;

	top_object = #largest_object-255;

	#ifdef FIX_RNG;
	@random 10000 -> i;
	i = -i-2000;
	print "[Random number generator seed is ", i, "]^";
	@random i -> i;
	#endif; ! FIX_RNG	
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Enable Acceleration
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ENABLE_GLULX_ACCEL_R;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Release Number
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Describe_Release i;
	print "Release ", (HDR_GAMERELEASE-->0) & $03ff, " / Serial number ";
	for (i=0 : i<6 : i++) print (char) HDR_GAMESERIAL->i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Keyboard Input
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_KeyChar win  key;
    if (win) @set_window win;
    @read_char 1 -> key;
    return key;
];

[ VM_KeyDelay tenths  key;
    @read_char 1 tenths VM_KeyDelay_Interrupt -> key;
    return key;
];
[ VM_KeyDelay_Interrupt; rtrue; ];

[ VM_ReadKeyboard  a_buffer a_table i;
    read a_buffer a_table;
    #ifdef ECHO_COMMANDS;
    print "** ";
    for (i=2: i<=(a_buffer->1)+1: i++) print (char) a_buffer->i;
    print "^";
    #ifnot;
    i=0;  ! suppress compiler warning
    #endif;

    #Iftrue (#version_number == 6);
    @output_stream -1;
    @loadb a_buffer 1 -> sp;
    @add a_buffer 2 -> sp;
    @print_table sp sp;
    new_line;
    @output_stream 1;
    #Endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Buffer Functions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_CopyBuffer bto bfrom i;
    for (i=0: i<INPUT_BUFFER_LEN: i++) bto->i = bfrom->i;
];

[ VM_PrintToBuffer buf len a b c;
    @output_stream 3 buf;
    switch (metaclass(a)) {
		String: print (string) a;
		Routine: a(b, c);
		Object, Class: if (b) PrintOrRun(a, b, true); else print (name) a;
    }
    @output_stream -3;
    if (buf-->0 > len) print "Error: Overflow in VM_PrintToBuffer.^";
    return buf-->0;
];

[ VM_Tokenise b p; b->(2 + b->1) = 0; @tokenise b p; ];

[ LTI_Insert i ch  b y;
    ! Protect us from strict mode, as this isn't an array in quite the
    ! sense it expects
    b = buffer;

    ! Insert character ch into buffer at point i.
    ! Being careful not to let the buffer possibly overflow:
    y = b->1;
    if (y > b->0) y = b->0;

    ! Move the subsequent text along one character:
    for (y=y+2 : y>i : y--) b->y = b->(y-1);
    b->i = ch;

    ! And the text is now one character longer:
    if (b->1 < b->0) (b->1)++;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Dictionary Functions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_InvalidDictionaryAddress addr;
    if ((UnsignedCompare(addr, dict_start) < 0) ||
		(UnsignedCompare(addr, dict_end) >= 0) ||
		((addr - dict_start) % dict_entry_size ~= 0)) rtrue;
	rfalse;
];

[ VM_DictionaryAddressToNumber w; return (w-(HDR_DICTIONARY-->0 + 7))/9; ];
[ VM_NumberToDictionaryAddress n; return HDR_DICTIONARY-->0 + 7 + 9*n; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Command Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_CommandTableAddress i;
	return (HDR_STATICMEMORY-->0)-->i;
];

[ VM_PrintCommandWords i da j;
    da = HDR_DICTIONARY-->0;
    for (j=0 : j<(da+5)-->0 : j++)
        if (da->(j*9 + 14) == $ff-i)
        	print "'", (address) VM_NumberToDictionaryAddress(j), "' ";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: SHOWVERB support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef DEBUG;
[ DebugAction a anames;
    if (a >= 4096) { print "<fake action ", a-4096, ">"; return; }
    anames = #identifiers_table;
    anames = anames + 2*(anames-->0) + 2*48;
    print (string) anames-->a;
];

[ DebugAttribute a anames;
    if (a < 0 || a >= 48) print "<invalid attribute ", a, ">";
    else {
        anames = #identifiers_table; anames = anames + 2*(anames-->0);
        print (string) anames-->a;
    }
];
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: RNG
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Seed_RNG n;
	if (n > 0) n = -n;
	@random n -> n;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Memory Allocation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_AllocateMemory amount;
	return 0;
];

[ VM_FreeMemory address;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Audiovisual Resources
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Picture resource_ID;
	#IFTRUE #version_number == 6; ! Z-machine version 6
	@draw_picture resource_ID;
	#ENDIF;
];

[ VM_SoundEffect resource_ID;
	#IFTRUE #version_number == 6; ! Z-machine version 6
	@sound_effect resource_ID;
	#ENDIF;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Typography
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Style sty;
	switch (sty) {
		NORMAL_VMSTY, NOTE_VMSTY: style roman;
		HEADER_VMSTY, SUBHEADER_VMSTY, ALERT_VMSTY: style bold;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Character Casing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_UpperToLowerCase c;
   switch (c) {
		'A' to 'Z': c = c + 32;
		202, 204, 212, 214, 221: c--;
		217, 218: c = c - 2;
		158 to 160, 167 to 168, 208 to 210: c = c - 3;
		186 to 190, 196 to 200: c = c - 5 ;
		175 to 180: c = c - 6;
   }
   return c;
];

[ VM_LowerToUpperCase c;
   switch (c) {
		'a' to 'z': c = c - 32;
		201, 203, 211, 213, 220: c++;
		215, 216: c = c + 2;
		155 to 157, 164 to 165, 205 to 207: c = c + 3;
		181 to 185, 191 to 195: c = c + 5 ;
		169 to 174: c = c + 6;
   }
   return c;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: The Screen
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_ClearScreen window;
    switch (window) {
		WIN_ALL:    @erase_window -1; statuswin_cursize = 0;
		WIN_STATUS: @erase_window 1;
		WIN_MAIN:   @erase_window 0;
    }
];

#Iftrue (#version_number == 6);
[ VM_ScreenWidth  width charw;
    @get_wind_prop 1 3 -> width;
    @get_wind_prop 1 13 -> charw;
    charw = charw & $FF;
    return (width+charw-1) / charw;
];
#Ifnot;
[ VM_ScreenWidth; return (HDR_SCREENWCHARS->0); ];
#Endif;

[ VM_ScreenHeight; return (HDR_SCREENHLINES->0); ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Window Colours
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_SetWindowColours f b window;
    if (clr_on && f && b) {
        if (window == 0) {  ! if setting both together, set reverse
            clr_fgstatus = b;
            clr_bgstatus = f;
            }
        if (window == 1) {
            clr_fgstatus = f;
            clr_bgstatus = b;
        }
        if (window == 0 or 2) {
            clr_fg = f;
            clr_bg = b;
        }
        if (statuswin_current)
            @set_colour clr_fgstatus clr_bgstatus;
        else
            @set_colour clr_fg clr_bg;
    }
];

[ VM_RestoreWindowColours; ! compare I6 library patch L61007
    if (clr_on) { ! check colour has been used
        VM_SetWindowColours(clr_fg, clr_bg, 2); ! make sure both sets of variables are restored
        VM_SetWindowColours(clr_fgstatus, clr_bgstatus, 1, true);
        VM_ClearScreen();
    }
    #Iftrue (#version_number == 6); ! request screen update
    (0-->8) = (0-->8) | $$00000100;
    #Endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Main Window
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_MainWindow;
    if (statuswin_current) {
        if (clr_on && clr_bgstatus > 1) @set_colour clr_fg clr_bg;
        else style roman;
        @set_window 0;
    }
    statuswin_current = false;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Status Line
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_MoveCursorInStatusLine line column; ! 1-based position on text grid
    if (~~statuswin_current) {
         @set_window 1;
         if (clr_on && clr_bgstatus > 1) @set_colour clr_fgstatus clr_bgstatus;
         else                            style reverse;
    }
    if (line == 0) {
        line = 1;
        column = 1;
    }
    #Iftrue (#version_number == 6);
    Z6_MoveCursor(line, column);
    #Ifnot;
    @set_cursor line column;
    #Endif;
	statuswin_current = true;
];

#Iftrue (#version_number == 6);
[ Z6_MoveCursor line column  charw charh; ! 1-based position on text grid
	@get_wind_prop 1 13 -> charw; ! font size
	@log_shift charw $FFF8 -> charh;
	charw = charw / $100;
	line = 1 + charh*(line-1);
	column = 1 + charw*(column-1);
	@set_cursor line column;
];
#Endif;

#Iftrue (#version_number == 6);
[ VM_StatusLineHeight height  wx wy x y charh;
    ! Split the window. Standard 1.0 interpreters should keep the window 0
    ! cursor in the same absolute position, but older interpreters,
    ! including Infocom's don't - they keep the window 0 cursor in the
    ! same position relative to its origin. We therefore compensate
    ! manually.
    @get_wind_prop 0 0 -> wy; @get_wind_prop 0 1 -> wx;
    @get_wind_prop 0 13 -> charh; @log_shift charh $FFF8 -> charh;
    @get_wind_prop 0 4 -> y; @get_wind_prop 0 5 -> x;
    height = height * charh;
    @split_window height;
    y = y - height + wy - 1;
    if (y < 1) y = 1;
    x = x + wx - 1;
    @set_cursor y x 0;
    statuswin_cursize = height;
];
#Ifnot;
[ VM_StatusLineHeight height;
    if (statuswin_cursize ~= height)
        @split_window height;
    statuswin_cursize = height;
];
#Endif;

#Iftrue (#version_number == 6);
[ Z6_DrawStatusLine width x charw scw;
	(0-->8) = (0-->8) &~ $$00000100;
	@push say__p; @push say__pc;
	BeginActivity(CONSTRUCTING_STATUS_LINE_ACT);
	VM_StatusLineHeight(statuswin_size);
	! Now clear the window. This isn't totally trivial. Our approach is to select the
	! fixed space font, measure its width, and print an appropriate
	! number of spaces. We round up if the screen isn't a whole number
	! of characters wide, and rely on window 1 being set to clip by default.
	VM_MoveCursorInStatusLine(1, 1);
	@set_font 4 -> x;
	width = VM_ScreenWidth();
	spaces width;
	ClearParagraphing(8);
	if (ForActivity(CONSTRUCTING_STATUS_LINE_ACT) == false) {
		! Back to standard font for the display. We use output_stream 3 to
		! measure the space required, the aim being to get 50 characters
		! worth of space for the location name.
		VM_MoveCursorInStatusLine(1, 2);
		@set_font 1 -> x;
		TEXT_TY_Say(left_hand_status_line);
		@get_wind_prop 1 3 -> width;
		@get_wind_prop 1 13 -> charw;
		charw = charw & $FF;
		@output_stream 3 StorageForShortName;
		TEXT_TY_Say(right_hand_status_line);
		@output_stream -3; scw = HDR_PIXELSTO3-->0 + charw;
		x = 1+width-scw;
		@set_cursor 1 x; TEXT_TY_Say(right_hand_status_line);
	}
	! Reselect roman, as Infocom's interpreters go funny if reverse is selected twice.
	VM_MainWindow();
	ClearParagraphing(8);
	EndActivity(CONSTRUCTING_STATUS_LINE_ACT);
	@pull say__pc; @pull say__p;
];
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Quotation Boxes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Undo
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VM_Undo result_code;
	@restore_undo result_code;
	return result_code;
];

[ VM_Save_Undo result_code;
    @save_undo result_code;
	return result_code;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Quit The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ QUIT_THE_GAME_R;
	if (actor ~= player) rfalse;
	QUIT_THE_GAME_RM('A');
	if (YesOrNo()~=0) quit;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Restart The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RESTART_THE_GAME_R;
	if (actor ~= player) rfalse;
	RESTART_THE_GAME_RM('A');
	if (YesOrNo()~=0) {
		@restart;
		RESTART_THE_GAME_RM('B'); new_line;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Restore The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RESTORE_THE_GAME_R;
	if (actor ~= player) rfalse;
	restore Rmaybe;
	RESTORE_THE_GAME_RM('A'); new_line;
	rtrue;
	.RMaybe; RESTORE_THE_GAME_RM('B'); new_line;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Save The Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SAVE_THE_GAME_R flag;
	if (actor ~= player) rfalse;
	#IFV5;
	@save -> flag;
	switch (flag) {
		0: SAVE_THE_GAME_RM('A'); new_line;
		1: SAVE_THE_GAME_RM('B'); new_line;
		2: RESTORE_THE_GAME_RM('B'); new_line;
	}
	#IFNOT;
	save Smaybe;
	SAVE_THE_GAME_RM('A'); new_line; rtrue;
	.SMaybe; SAVE_THE_GAME_RM('B'); new_line;
	#ENDIF;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Verify The Story File Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VERIFY_THE_STORY_FILE_R;
	if (actor ~= player) rfalse;
	@verify ?Vmaybe;
	jump Vwrong;
	.Vmaybe; VERIFY_THE_STORY_FILE_RM('A'); new_line; rtrue;
	.Vwrong;
	VERIFY_THE_STORY_FILE_RM('B'); new_line;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Switch Transcript On Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SWITCH_TRANSCRIPT_ON_R;
	if (actor ~= player) rfalse;
	transcript_mode = ((0-->8) & 1);
	if (transcript_mode) { SWITCH_TRANSCRIPT_ON_RM('A'); new_line; rtrue; }
	@output_stream 2;
	if (((0-->8) & 1) == 0) { SWITCH_TRANSCRIPT_ON_RM('C'); new_line; rtrue; }
	SWITCH_TRANSCRIPT_ON_RM('B'); new_line; VersionSub();
	transcript_mode = true;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Switch Transcript Off Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SWITCH_TRANSCRIPT_OFF_R;
	if (actor ~= player) rfalse;
	transcript_mode = ((0-->8) & 1);
	if (transcript_mode == false) { SWITCH_TRANSCRIPT_OFF_RM('A'); new_line; rtrue; }
	SWITCH_TRANSCRIPT_OFF_RM('B'); new_line;
	@output_stream -2;
	if ((0-->8) & 1) { SWITCH_TRANSCRIPT_ON_RM('C'); new_line; rtrue; }
	transcript_mode = false;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Announce Story File Version Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ANNOUNCE_STORY_FILE_VERSION_R ix;
	if (actor ~= player) rfalse;
	Banner();
	print "Identification number: ";
	for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
	print "^";
	ix = 0; ! shut up compiler warning
	if (standard_interpreter > 0) {
		print "Standard interpreter ",
			standard_interpreter/256, ".", standard_interpreter%256,
			" (", HDR_TERPNUMBER->0;
		#Iftrue (#version_number == 6);
		print (char) '.', HDR_TERPVERSION->0;
		#Ifnot;
		print (char) HDR_TERPVERSION->0;
		#Endif;
		print ") / ";
	} else {
		print "Interpreter ", HDR_TERPNUMBER->0, " Version ";
		#Iftrue (#version_number == 6);
		print HDR_TERPVERSION->0;
		#Ifnot;
		print (char) HDR_TERPVERSION->0;
		#Endif;
		print " / ";
	}
	print "Library serial number ", (string) LibSerial, "^";
	#Ifdef LanguageVersion;
	print (string) LanguageVersion, "^";
	#Endif; ! LanguageVersion
	#ifdef ShowExtensionVersions;
	ShowExtensionVersions();
	#endif;
	say__p = 1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Descend To Specific Action Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DESCEND_TO_SPECIFIC_ACTION_R;
	indirect(#actions_table-->action);
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ZMachine.i6t: Veneer
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ OC__Cl obj cla j a n objflag;

	@jl obj 1 ?NotObj;
	@jg obj max_z_object ?NotObj;
	@inc objflag;
	@je cla K1_room ?~NotRoom;
	@test_attr obj mark_as_room ?rtrue;
	@rfalse;
	.NotRoom;
	@je cla K2_thing ?~NotObj;
	@test_attr obj mark_as_thing ?rtrue;
	@rfalse;
	.NotObj;

	@je cla Object Class ?ObjOrClass;
	@je cla Routine String ?RoutOrStr;

	@jin cla 1 ?~Mistake;

	@jz objflag ?rfalse;
	@get_prop_addr obj 2 -> a;
	@jz a ?rfalse;
	@get_prop_len a -> n;

	@div n 2 -> n;
	.Loop;
	@loadw a j -> sp;
	@je sp cla ?rtrue;
	@inc j;
	@jl j n ?Loop;
	@rfalse;

	.ObjOrClass;
	@jz objflag ?rfalse;
	@je cla Object ?JustObj;

	! So now cla is Class
	@jg obj String ?~rtrue;
	@jin obj Class ?rtrue;
	@rfalse;

	.JustObj;
	! So now cla is Object
	@jg obj String ?~rfalse;
	@jin obj Class ?rfalse;
	@rtrue;

	.RoutOrStr;
	@jz objflag ?~rfalse;
	@call_2s Z__Region obj -> sp;
	@inc sp;
	@je sp cla ?rtrue;
	@rfalse;

	.Mistake;
	RT__Err("apply 'ofclass' for", cla, -1);
	rfalse;
];

[ Unsigned__Compare x y u v;
	@je x y ?rfalse; ! i.e., return 0
	@jl x 0 ?XNegative;
	! So here x >= 0 and x ~= y
	@jl y 0 ?XPosYNeg;

	! Here x >=0, y >= 0, x ~= y

	@jg x y ?rtrue; ! i.e., return 1
	@ret -1;

	.XPosYNeg;
	! Here x >= 0, y < 0, x ~= y
	@ret -1;

	.XNegative;
	@jl y 0 ?~rtrue; ! if x < 0, y >= 0, return 1
	
	! Here x < 0, y < 0, x ~= y
	@jg x y ?rtrue;
	@ret -1;
];

[ RT__ChLDW base offset;
    @loadw base offset -> sp;
    @ret sp;
];

#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Compass
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Object Compass "compass" has concealed;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Language of Play
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Vocabulary
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant AGAIN1__WD     = 'again';
Constant AGAIN2__WD     = 'g//';
Constant AGAIN3__WD     = 'again';
Constant OOPS1__WD      = 'oops';
Constant OOPS2__WD      = 'o//';
Constant OOPS3__WD      = 'oops';
Constant UNDO1__WD      = 'undo';
Constant UNDO2__WD      = 'undo';
Constant UNDO3__WD      = 'undo';

Constant ALL1__WD       = 'all';
Constant ALL2__WD       = 'each';
Constant ALL3__WD       = 'every';
Constant ALL4__WD       = 'everything';
Constant ALL5__WD       = 'both';
Constant AND1__WD       = 'and';
Constant AND2__WD       = 'and';
Constant AND3__WD       = 'and';
Constant BUT1__WD       = 'but';
Constant BUT2__WD       = 'except';
Constant BUT3__WD       = 'but';
Constant ME1__WD        = 'me';
Constant ME2__WD        = 'myself';
Constant ME3__WD        = 'self';
Constant OF1__WD        = 'of';
Constant OF2__WD        = 'of';
Constant OF3__WD        = 'of';
Constant OF4__WD        = 'of';
Constant OTHER1__WD     = 'another';
Constant OTHER2__WD     = 'other';
Constant OTHER3__WD     = 'other';
Constant THEN1__WD      = 'then';
Constant THEN2__WD      = 'then';
Constant THEN3__WD      = 'then';

Constant NO1__WD        = 'n//';
Constant NO2__WD        = 'no';
Constant NO3__WD        = 'no';
Constant YES1__WD       = 'y//';
Constant YES2__WD       = 'yes';
Constant YES3__WD       = 'yes';

Constant AMUSING__WD    = 'amusing';
Constant FULLSCORE1__WD = 'fullscore';
Constant FULLSCORE2__WD = 'full';
Constant QUIT1__WD      = 'q//';
Constant QUIT2__WD      = 'quit';
Constant RESTART__WD    = 'restart';
Constant RESTORE__WD    = 'restore';



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Gender Options replacement for Language.i6t: Pronouns
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array LanguagePronouns table

  ! word        possible GNAs                   connected
  !             to follow:                      to:
  !             a       i  
  !             s   p   s   p 
  !             mfnbmfnbmfnbmfnb

    'it'         	$$0010000000100000                    NULL
    'him'    	$$1000000010000000                    NULL
    'her'     	$$0100000001000000                    NULL
    'them'    	$$0001111100011111                    NULL;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Pronouns (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Descriptors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array LanguageDescriptors table

  ! word        possible GNAs   descriptor      connected
  !             to follow:      type:           to:
  !             a     i
  !             s  p  s  p
  !             mfnmfnmfnmfn

    'my'      $$111111111111    POSSESS_PK      0
    'this'    $$111111111111    POSSESS_PK      0
    'these'   $$000111000111    POSSESS_PK      0
    'that'    $$111111111111    POSSESS_PK      1
    'those'   $$000111000111    POSSESS_PK      1
    'his'     $$111111111111    POSSESS_PK      'him'
    'her'     $$111111111111    POSSESS_PK      'her'
    'their'   $$111111111111    POSSESS_PK      'them'
    'its'     $$111111111111    POSSESS_PK      'it'
    'the'     $$111111111111    DEFART_PK       NULL
    'a//'     $$111000111000    INDEFART_PK     NULL
    'an'      $$111000111000    INDEFART_PK     NULL
    'some'    $$000111000111    INDEFART_PK     NULL
    'lit'     $$111111111111    light           NULL
    'lighted' $$111111111111    light           NULL
    'unlit'   $$111111111111    (-light)        NULL;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Numbers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array LanguageNumbers table
    'one' 1 'two' 2 'three' 3 'four' 4 'five' 5
    'six' 6 'seven' 7 'eight' 8 'nine' 9 'ten' 10
    'eleven' 11 'twelve' 12 'thirteen' 13 'fourteen' 14 'fifteen' 15
    'sixteen' 16 'seventeen' 17 'eighteen' 18 'nineteen' 19 'twenty' 20
    'twenty-one' 21 'twenty-two' 22 'twenty-three' 23 'twenty-four' 24
	'twenty-five' 25 'twenty-six' 26 'twenty-seven' 27 'twenty-eight' 28
	'twenty-nine' 29 'thirty' 30
;

[ LanguageNumber n f;
    if (n == 0)    { print "zero"; rfalse; }
    if (n < 0)     { print "minus "; n = -n; }
#Iftrue (WORDSIZE == 4);
    if (n >= 1000000000) {
        if (f == 1) print ", ";
    	print (LanguageNumber) n/1000000000, " billion"; n = n%1000000000; f = 1;
    }
    if (n >= 1000000) {
        if (f == 1) print ", ";
    	print (LanguageNumber) n/1000000, " million"; n = n%1000000; f = 1;
    }
#Endif;
    if (n >= 1000) {
        if (f == 1) print ", ";
    	print (LanguageNumber) n/1000, " thousand"; n = n%1000; f = 1;
    }
    if (n >= 100)  {
        if (f == 1) print ", ";
        print (LanguageNumber) n/100, " hundred"; n = n%100; f = 1;
    }
    if (n == 0) rfalse;
    #Ifdef DIALECT_US;
    if (f == 1) print " ";
    #Ifnot;
    if (f == 1) print " and ";
    #Endif;
    switch (n) {
      1:    print "one";
      2:    print "two";
      3:    print "three";
      4:    print "four";
      5:    print "five";
      6:    print "six";
      7:    print "seven";
      8:    print "eight";
      9:    print "nine";
      10:   print "ten";
      11:   print "eleven";
      12:   print "twelve";
      13:   print "thirteen";
      14:   print "fourteen";
      15:   print "fifteen";
      16:   print "sixteen";
      17:   print "seventeen";
      18:   print "eighteen";
      19:   print "nineteen";
      20 to 99: switch (n/10) {
        2:  print "twenty";
        3:  print "thirty";
        4:  print "forty";
        5:  print "fifty";
        6:  print "sixty";
        7:  print "seventy";
        8:  print "eighty";
        9:  print "ninety";
        }
        if (n%10 ~= 0) print "-", (LanguageNumber) n%10;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Time
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LanguageTimeOfDay hours mins i;
    i = hours%12;
    if (i == 0) i = 12;
    if (i < 10) print " ";
    print i, ":", mins/10, mins%10;
    if ((hours/12) > 0) print " pm"; else print " am";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Directions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LanguageDirection d;
	print (name) d;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Translation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LanguageToInformese; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Articles
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant LanguageAnimateGender   = male;
Constant LanguageInanimateGender = neuter;

Constant LanguageContractionForms = 2;     ! English has two:
                                           ! 0 = starting with a consonant
                                           ! 1 = starting with a vowel

[ LanguageContraction text;
    if (text->0 == 'a' or 'e' or 'i' or 'o' or 'u'
                or 'A' or 'E' or 'I' or 'O' or 'U') return 1;
    return 0;
];

Array LanguageArticles -->

 !   Contraction form 0:     Contraction form 1:
 !   Cdef   Def    Indef     Cdef   Def    Indef

     "The " "the " "a "      "The " "the " "an "          ! Articles 0
     "The " "the " "some "   "The " "the " "some ";       ! Articles 1

                   !             a           i
                   !             s     p     s     p
                   !             m f n m f n m f n m f n

Array LanguageGNAsToArticles --> 0 0 0 1 1 1 0 0 0 1 1 1;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Language.i6t: Commands
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LanguageVerb i;
    switch (i) {
      'i//','inv','inventory':
               print "take inventory";
      'l//':   print "look";
      'x//':   print "examine";
      'z//':   print "wait";
      default: rfalse;
    }
    rtrue;
];

[ LanguageVerbLikesAdverb w;
    if (w == 'look' or 'go' or 'push' or 'walk')
        rtrue;
    rfalse;
];

[ LanguageVerbMayBeName w;
    if (w == 'long' or 'short' or 'normal' or 'brief' or 'full' or 'verbose')
        rtrue;
    rfalse;
];


Default LanguageCases 1;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: The Old Library
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Darkness
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Object thedark "(darkness object)";


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Light Measurement
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ OffersLight obj j;
    while (obj) {
		if (obj has light) rtrue;
		objectloop (j in obj) if (HasLightSource(j)) rtrue;
		if ((obj has container) && (obj hasnt open) && (obj hasnt transparent)) rfalse;
		if ((obj provides component_parent) && (obj.component_parent))
			obj = obj.component_parent;
		else
			obj = parent(obj);
	}
    rfalse;
];

[ HasLightSource i j ad sr po;
	if (i == 0) rfalse;
    if (i has light) rtrue;
    if ((IsSeeThrough(i)) && (~~(HidesLightSource(i))))
        objectloop (j in i)
            if (HasLightSource(j)) rtrue;
    ad = i.&add_to_scope;
    if (parent(i) ~= 0 && ad ~= 0) {
        if (metaclass(ad-->0) == Routine) {
            ats_hls = 0; ats_flag = 1;
            sr = scope_reason; po = parser_one;
            scope_reason = LOOPOVERSCOPE_REASON; parser_one = 0;
            RunRoutines(i, add_to_scope);
            scope_reason = sr; parser_one = po;
            ats_flag = 0; if (ats_hls == 1) rtrue;
        }
        else {
            for (j=0 : (WORDSIZE*j)<i.#add_to_scope : j++)
                if ((ad-->j) && (HasLightSource(ad-->j) == 1)) rtrue;
        }
    }
    if (ComponentHasLight(i)) rtrue;
    rfalse;
];

[ ComponentHasLight o obj next_obj;
	if (o provides component_child) {
		obj = o.component_child;
		while (obj) {
			next_obj = obj.component_sibling;
			if (obj has light) rtrue;
			if (HasLightSource(obj)) rtrue;
			if ((obj provides component_child) && (ComponentHasLight(obj))) rtrue;
			obj = next_obj;
		}
	}
	rfalse;
];

[ HidesLightSource obj;
    if (obj == player) rfalse;
    if (obj has transparent or supporter) rfalse;
    if (obj has animate) rfalse;
    if (obj has container) return (obj hasnt open);
    return (obj hasnt enterable);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Invariant
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global lightflag = false;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Adjust Light Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ADJUST_LIGHT_R previous_light_condition;
    previous_light_condition = lightflag;
    lightflag = OffersLight(parent(player));

    if ((previous_light_condition == false) && (lightflag == false)) {
    	location = thedark;
    	rfalse;
    }

    if ((previous_light_condition == false) && (lightflag == true)) {
        location = real_location;
        CarryOutActivity(PRINTING_NEWS_OF_LIGHT_ACT);
        rfalse;
    }

    if ((previous_light_condition == true) && (lightflag == false)) {
        location = thedark;
		DivideParagraphPoint();
		BeginActivity(PRINTING_NEWS_OF_DARKNESS_ACT);
		if (ForActivity(PRINTING_NEWS_OF_DARKNESS_ACT) == false) {
			ADJUST_LIGHT_RM('A'); new_line;
		}
		EndActivity(PRINTING_NEWS_OF_DARKNESS_ACT);
		rfalse;
    }

    if ((previous_light_condition == true) && (lightflag == true)) {
    	location = real_location;
    	rfalse;
    }

    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Silent Light Consideration
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SilentlyConsiderLight;
    lightflag = OffersLight(parent(player));
	if (lightflag) location = real_location; else location = thedark;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Translucency
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IsSeeThrough obj;
    if ((obj has supporter)
    	|| (obj has transparent)
    	|| (obj has animate)
    	|| ((obj has container) && (obj has open)))
        rtrue;
   rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Visibility Parent
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VisibilityParent o;
    if (o && (o has container) && (o hasnt open) && (o hasnt transparent)) return nothing;
	if (o) o = CoreOfParentOfCoreOf(o);
    return o;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Find Visibility Levels
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FindVisibilityLevels lc up;
	if (location == thedark) {
		visibility_ceiling = thedark;
		visibility_levels = 0;	
	} else {
		visibility_ceiling = player;
		while (true) {
			up = VisibilityParent(visibility_ceiling);
			if (up == 0) break;
			visibility_ceiling = up;
			lc++;
		}
		visibility_levels = lc;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Touchability Ceiling
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TouchabilityCeiling original o p;
	o = original;
	while (o) {
	    p = CoreOfParentOfCoreOf(o);
	    if (p ofclass K1_room) return p;
	    if (p == nothing) return o;
	    if ((FollowRulebook(REACHING_OUTSIDE_RB, p)) && (RulebookFailed()))
	    	return p;
	    o = p;
	}
	return o;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Scope Ceiling
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ScopeCeiling pos c;
	if (pos == player && location == thedark) return thedark;
	c = parent(pos);
	if (c == 0) return pos;
	while (VisibilityParent(c)) c = VisibilityParent(c);
	return c;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Object Is Untouchable
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ObjectIsUntouchable item silent_flag p save_sp decision moving x;
	if (LocationOf(p) ~= real_location) {
		for (x = CoreOf(item): x: x = CoreOfParentOfCoreOf(x)) {
			if (x ofclass K4_door or K7_backdrop) {
				moving = true;
				MoveFloatingObjects(LocationOf(p));
				break;
			}
		}
	}
	untouchable_object = item; untouchable_silence = silent_flag;
	touch_persona = p; if (p == actor) touch_persona = 0;
	save_sp = say__p; say__p = 0;
	@push actor; actor = p;
	if (FollowRulebook(ACCESSIBILITY_RB, 0, true)) {
		if (RulebookSucceeded()) decision = false;
		else decision = true;
	} else decision = false;
	@pull actor;
	if (say__p == false) say__p = save_sp;
	if (moving) MoveFloatingObjects();
	untouchable_silence = 0;
	return decision;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Access Through Barriers Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ACCESS_THROUGH_BARRIERS_R ancestor i j external p;
	p = touch_persona; if (p == 0) p = actor;

	ancestor = CommonAncestor(p, untouchable_object);
	if ((ancestor == 0) && (LocationOf(untouchable_object) == nothing)
		&& ((untouchable_object ofclass K4_door or K7_backdrop) == false)) {
		if (touch_persona == 0) {
			if ((actor == player) && (untouchable_silence == false)) {
				ACCESS_THROUGH_BARRIERS_RM('A', untouchable_object);
				new_line;
			}
		}
		RulebookFails();
		rtrue;
	}

	! First, a barrier between the player and the ancestor.

	if (CoreOf(p) ~= ancestor) {
		i = parent(CoreOf(p)); j = CoreOf(i); external = false;
		if (j ~= i) { i = j; external = true; }
		while (i~=ancestor && i) {
			if ((external == false)
				&& (FollowRulebook(REACHING_OUTSIDE_RB, i))
				&& (RulebookFailed())) rtrue; ! Barrier
			i = parent(CoreOf(i)); external = false;
			if (~~(i ofclass K5_container)) {
				j = CoreOf(i);
				if (j ~= i) { i = j; external = true; }
			}
		}
	}

	! Second, a barrier between the item and the ancestor.

	if (CoreOf(untouchable_object) ~= ancestor) {
		! We can always get to the core of the item.
		i = CoreOf(untouchable_object);
		! This will be on the inside of its parent, if its parent is a
		! container, so there should be no exemption.
		i = parent(i); external = false;
		while (i~=ancestor && i) {
			if ((external == false) &&
				(FollowRulebook(REACHING_INSIDE_RB, i)) &&
				(RulebookFailed())) rtrue; ! Barrier
			i = CoreOf(i);
			if (i == ancestor) break;
			i = parent(i); external = false;
			if (~~(i ofclass K5_container)) {
				j = CoreOf(i);
				if (j ~= i) { i = j; external = true; }
			}
		}
	}

	RulebookSucceeds(); ! No barrier
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Can't Reach Inside Closed Containers Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CANT_REACH_INSIDE_CLOSED_R;
	if (parameter_value has container && parameter_value hasnt open) {
		if (touch_persona == 0) {
			if ((actor == player) && (untouchable_silence == false)) {
				CANT_REACH_INSIDE_CLOSED_RM('A', parameter_value);
				new_line;
			}
		}
		RulebookFails(); rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Can't Reach Outside Closed Containers Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CANT_REACH_OUTSIDE_CLOSED_R;
	if (parameter_value has container && parameter_value hasnt open) {
		if (touch_persona == 0) {
			if ((actor == player) && (untouchable_silence == false)) {
				CANT_REACH_OUTSIDE_CLOSED_RM('A', parameter_value);
				new_line;
			}
		}
		RulebookFails(); rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Light.i6t: Can't Reach Inside Rooms Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CANT_REACH_INSIDE_ROOMS_R;
	if (parameter_value && parameter_value ofclass K1_room) {
		if (touch_persona == 0) {
			if ((actor == player) && (untouchable_silence == false)) {
				CANT_REACH_INSIDE_ROOMS_RM('A', parameter_value);
				new_line;
			}
		}
		RulebookFails(); rtrue;
	}
	rfalse;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Specification
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Memory
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant REQUISITION_STACK_SIZE = 3*266;
Array requisition_stack --> REQUISITION_STACK_SIZE;
Global requisition_stack_pointer = 0;

[ RequisitionStack len top addr;
	top = requisition_stack_pointer + len;
	if (top > REQUISITION_STACK_SIZE) return false;
	addr = requisition_stack + requisition_stack_pointer*WORDSIZE;
	! print "Allocating ", addr, " at pointer ", requisition_stack_pointer, "^";
	requisition_stack_pointer = top;
	return addr;
];

[ FreeStack addr;
	if (addr == 0) return;
	requisition_stack_pointer = (addr - requisition_stack)/WORDSIZE;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: WriteListOfMarkedObjects
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global MarkedObjectArray = 0;
Global MarkedObjectLength = 0;

[ WriteListOfMarkedObjects style
	obj common_parent first mixed_parentage length g gc;

	gc = -2;
	objectloop (obj ofclass Object && obj has workflag2) {
		length++;
		if (first == nothing) { first = obj; common_parent = parent(obj); }
		else { if (parent(obj) ~= common_parent) mixed_parentage = true; }
		g = GetGNAOfObject(obj); g = g%3;
		if (gc == -2) gc = g;
		else if (gc ~= g) gc = -1;
	}
	if (mixed_parentage) common_parent = nothing;

	if (length == 0) {
    	if (style & ISARE_BIT ~= 0) LIST_WRITER_INTERNAL_RM('W');
    	else if (style & CFIRSTART_BIT ~= 0) LIST_WRITER_INTERNAL_RM('X');
		else LIST_WRITER_INTERNAL_RM('Y');
	} else {
		@push MarkedObjectArray; @push MarkedObjectLength;
		MarkedObjectArray = RequisitionStack(length);
		MarkedObjectLength = length;
		if (MarkedObjectArray == 0) return RunTimeProblem(RTP_LISTWRITERMEMORY); 

		if (common_parent) {
			ObjectTreeCoalesce(child(common_parent));
			length = 0;
			objectloop (obj in common_parent) ! object tree order
				if (obj has workflag2) MarkedObjectArray-->length++ = obj;
		} else {
			length = 0;
			objectloop (obj ofclass Object) ! object number order
				if (obj has workflag2) MarkedObjectArray-->length++ = obj;
		}

		WriteListFrom(first, style, 0, false, MarkedListIterator);

		FreeStack(MarkedObjectArray);
		@pull MarkedObjectLength; @pull MarkedObjectArray;
	}
	prior_named_list = length;
	prior_named_list_gender = gc;
	return;
];




[ RegardingMarkedObjects
	obj length g gc;
	gc = -2;
	objectloop (obj ofclass Object && obj has workflag2) {
		length++;
		g = GetGNAOfObject(obj); g = g%3;
		if (gc == -2) {
			gc = g;
			prior_named_noun = obj;
		} else if (gc ~= g) gc = -1;
	}
	prior_named_list = length;
	prior_named_list_gender = gc;
	if (length == 0) { prior_named_noun = nothing; prior_named_list_gender = -1; }
	return;	
];

[ RegardingSingleObject obj;
	prior_named_list = 1;
	prior_named_list_gender = -1;
	prior_named_noun = obj;
];

[ RegardingNumber n;
	prior_named_list = n;
	prior_named_list_gender = -1;
	prior_named_noun = nothing;
];

[ PNToVP ; ! gna;
    if (prior_named_list >= 2) return 6;
    if (prior_named_noun) {
      if ((prior_named_noun provides most_recent_reference) && prior_named_noun.most_recent_reference  == I392_pronominal) {
        if (prior_named_noun.third_singular_pronoun && prior_named_noun.third_singular_pronoun has pluralname) return 6;
        return 3;
      }
      if (prior_named_noun has pluralname) return 6;
    }
	return 3;
];

[ PrintVerbAsValue vb;
	if (vb == 0) print "(no verb)";
	else { print "verb "; vb(1); }
];

[ VerbIsMeaningful vb;
	if ((vb) && (BlkValueCompare(vb(CV_MEANING), Rel_Record_0) ~= 0)) rtrue;
	rfalse;
];

[ VerbIsModal vb;
	if ((vb) && (vb(CV_MODAL))) rtrue;
	rfalse;
];

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: List Number and Gender (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: List Writer Regard Storage
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array LWI_Storage --> 1 (-1) nothing;
[ SetLWI a b c;
	LWI_Storage-->0 = a;
	LWI_Storage-->1 = b;
	LWI_Storage-->2 = c;
];
[ RegardingLWI;
	prior_named_list = LWI_Storage-->0;
	prior_named_list_gender = LWI_Storage-->1;
	prior_named_noun = LWI_Storage-->2;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Response Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ResponseViaActivity R;
	@push prior_named_noun; @push prior_named_list; @push prior_named_list_gender;
	RegardingSingleObject(nothing);
	CarryOutActivity(PRINTING_RESPONSE_ACT, R);
	@pull prior_named_list_gender; @pull prior_named_list; @pull prior_named_noun;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: About Iterator Functions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant SEEK_ITF = 0;
Constant ADVANCE_ITF = 1;
Constant COALESCE_ITF = 2;
Constant START_ITF = 3;

! Constant DBLW; ! Uncomment this to provide debugging information at run-time


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Marked List Iterator
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MarkedListIterator obj depth required_lt function i;
    if (obj == nothing) return nothing;
    if (required_lt == 0) required_lt = EMPTY_TEXT_VALUE;
	switch(function) {
    	START_ITF: return MarkedObjectArray-->0;
    	COALESCE_ITF: return MarkedListCoalesce();
    	SEEK_ITF, ADVANCE_ITF:
			for (i=0: i<MarkedObjectLength: i++)
				if (MarkedObjectArray-->i == obj) {
					if (function == ADVANCE_ITF) i++;
					for (:i<MarkedObjectLength: i++) {
						obj = MarkedObjectArray-->i;
						if ((LT_Compare(required_lt, EMPTY_TEXT_VALUE) ~= 0) &&
							(LT_Compare(obj.list_together, required_lt) ~= 0)) continue;
						if ((c_style & WORKFLAG_BIT) && (depth==0) && (obj hasnt workflag))
							continue;
						if ((c_style & CONCEAL_BIT) && (ConcealedFromLists(obj))) continue;
						return obj;
					}
					return nothing;
				}
	}
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Concealment
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ConcealedFromLists obj c;
	if ((obj has concealed) || (obj has scenery)) rtrue;
	c = parent(obj);
	if ((c) && (c ofclass K5_container or K6_supporter) && (TestConcealment(c, obj))) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Coalesce Marked List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MarkedListCoalesce o i lt l swap m;
	for (i=0: i<MarkedObjectLength: i++) {
		lt = (MarkedObjectArray-->i).list_together;
		if (LT_Compare(lt, EMPTY_TEXT_VALUE) ~= 0) {
			! Find first object in list after contiguous run with this list_together value:
			for (i++: (i<MarkedObjectLength) &&
				(LT_Compare((MarkedObjectArray-->i).list_together, lt) == 0): i++) ;
			! If the contiguous run extends to end of list, the list is now perfect:
			if (i == MarkedObjectLength) return MarkedObjectArray-->0;
			! And otherwise we look to see if any future entries belong in the earlier run:
			for (l=i+1: l<MarkedObjectLength: l++)
				if (LT_Compare((MarkedObjectArray-->l).list_together, lt) == 0) {
					! Yes, they do: so we perform a rotation to insert it before element i:
					swap = MarkedObjectArray-->l;
					for (m=l: m>i: m--) MarkedObjectArray-->m = MarkedObjectArray-->(m-1);
					MarkedObjectArray-->i = swap;
					! And now the run is longer:
					i++;
					if (i == MarkedObjectLength) return MarkedObjectArray-->0;
				}
			i--;
		}
	}
	return MarkedObjectArray-->0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Object Tree Iterator
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global list_filter_routine;

[ ObjectTreeIterator obj depth required_lt function;
    if ((obj == nothing) || (parent(obj) == nothing)) return nothing;
	if (function == START_ITF) obj = child(parent(obj));
	if (function == COALESCE_ITF) return ObjectTreeCoalesce(obj);
    if (function == ADVANCE_ITF) obj = sibling(obj);
    if (required_lt == 0) required_lt = EMPTY_TEXT_VALUE;
    for (:: obj = sibling(obj)) {
        if (obj == nothing) return nothing;
!if (function == ADVANCE_ITF) print "Considering ", (the) obj, ": ", (TEXT_TY_Say) obj.list_together, ": ", (TEXT_TY_Say) required_lt, ": ", ": ", (TEXT_TY_Say) lt_value, ": ", LT_Compare(obj.list_together, required_lt), "^";
		if ((LT_Compare(required_lt, EMPTY_TEXT_VALUE) ~= 0) &&
			(LT_Compare(obj.list_together, required_lt) ~= 0)) continue;
		if ((c_style & WORKFLAG_BIT) && (depth==0) && (obj hasnt workflag)) continue;
		if (obj hasnt list_filter_permits) continue;
		if ((c_style & CONCEAL_BIT) && (ConcealedFromLists(obj))) continue;
		return obj;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Coalesce Object Tree
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ObjectTreeCoalesce obj memb lt later;
	#Ifdef DBLW; print "^^Sorting out: "; DiagnoseSortList(obj); #Endif;
	.StartAgain;
	for (memb=obj: memb~=nothing: memb=sibling(memb)) {
		lt = memb.list_together;
		if (LT_Compare(lt, EMPTY_TEXT_VALUE) ~= 0) {
			! Find first object in list after contiguous run with this list_together value:
			for (memb=sibling(memb):
				(memb) && (LT_Compare(memb.list_together, lt) == 0): memb = sibling(memb)) ;
			! If the contiguous run extends to end of list, the list is now perfect:
			if (memb == 0) return obj;
			! And otherwise we look to see if any future entries belong in the earlier run:
			for (later=sibling(memb): later: later=sibling(later))
				if (LT_Compare(later.list_together, lt) == 0) {
					! Yes, they do: so we perform a regrouping of the list and start again:
					obj = GroupChildren(parent(obj), lt);
					#Ifdef DBLW; print "^^Sorted to: "; DiagnoseSortList(obj); #Endif;
					jump StartAgain;
				}
		}
	}
	return obj;
];
#Ifdef DBLW;
[ DiagnoseSortList obj memb;
    for (memb=child(obj): memb~=nothing: memb=sibling(memb)) print memb, " --> "; new_line;
];
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: WriteListFrom
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteListFrom first style depth noactivity iter a ol;
	@push c_iterator; @push c_style; @push c_depth; @push c_margin;
    if (iter) c_iterator = iter; else c_iterator = ObjectTreeIterator;
    c_style = style; c_depth = depth;
	c_margin = 0; if (style & EXTRAINDENT_BIT) c_margin = 1;

	objectloop (a ofclass Object) {
		give a list_filter_permits;
		if ((list_filter_routine) && (list_filter_routine(a) == false))
			give a ~list_filter_permits;
	}

    first = c_iterator(first, depth, 0, START_ITF);
	if (first == nothing) {
		if (style & ISARE_BIT ~= 0) LIST_WRITER_INTERNAL_RM('W');
        else LIST_WRITER_INTERNAL_RM('Y');
        if (style & NEWLINE_BIT ~= 0) new_line;
    } else {
		if ((noactivity) || (iter)) {
			WriteListR(first, c_depth, true);
			say__p = 1;
		} else {
			objectloop (ol provides list_together)
				BlkValueCopy(ol.list_together, EMPTY_TEXT_VALUE);
			CarryOutActivity(LISTING_CONTENTS_ACT, parent(first));
		}
	}

    @pull c_margin; @pull c_depth; @pull c_style; @pull c_iterator;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Standard Contents Listing Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STANDARD_CONTENTS_LISTING_R;
	WriteListFrom(child(parameter_value), c_style, c_depth, true);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Partitioning
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef DBLW;
Global DBLW_no_classes; Global DBLW_no_objs;
[ DebugPartition partition_class_sizes partition_classes first depth i k o;
	print "[Length of list is ", DBLW_no_objs, " with ", k, " plural.]^";
	print "[Partitioned into ", DBLW_no_classes, " equivalence classes.]^";
    for (i=1: i<=DBLW_no_classes : i++) {
    	print "Class ", i, " has size ", partition_class_sizes->i, "^";
	}
	for (k=0, o=first: k<DBLW_no_objs : k++, o = c_iterator(o, depth, lt_value, ADVANCE_ITF)) {
    	print "Entry ", k, " has class ", partition_classes->k,
    		" represented by ", o, " with L=", o.list_together, "^";
	}
];
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Partition List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PartitionList first no_objs depth partition_classes partition_class_sizes
	i k l n m;
    for (i=0: i<no_objs: i++) partition_classes->i = 0;
    n = 1;
    for (i=first, k=0: k<no_objs: i=c_iterator(i, depth, lt_value, ADVANCE_ITF), k++)
        if (partition_classes->k == 0) {
            partition_classes->k = n; partition_class_sizes->n = 1;
            for (l=c_iterator(i, depth, lt_value, ADVANCE_ITF), m=k+1:
            	(l~=0) && (m<no_objs):
            	l=c_iterator(l, depth, lt_value, ADVANCE_ITF), m++) {
                if ((partition_classes->m == 0) && (ListEqual(i, l))) {
                    if (partition_class_sizes->n < 255) (partition_class_sizes->n)++;
                    partition_classes->m = n;
                }
            }
            if (n < 255) n++;
        }
    n--;
	#Ifdef DBLW;
	DBLW_no_classes = n; DBLW_no_objs = no_objs;
	DebugPartition(partition_class_sizes, partition_classes, first, depth);
	#Endif;
    return n;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Equivalence Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ListEqual o1 o2;
	if ((o1.plural == 0) || (o2.plural == 0)) rfalse;
 	if (child(o1) ~= 0 && WillRecurs(o1) ~= 0) rfalse;
    if (child(o2) ~= 0 && WillRecurs(o2) ~= 0) rfalse;
    if (c_style & (FULLINV_BIT + PARTINV_BIT) ~= 0) {
        if ((o1 hasnt worn && o2 has worn) || (o2 hasnt worn && o1 has worn)) rfalse;
        if ((o1 hasnt light && o2 has light) || (o2 hasnt light && o1 has light)) rfalse;
        if (o1 has container) {
            if (o2 hasnt container) rfalse;
            if ((o1 has open && o2 hasnt open) || (o2 has open && o1 hasnt open))
                rfalse;
        }
        else if (o2 has container)
            rfalse;
    }
    return Identical(o1, o2);
];

[ WillRecurs o;
    if (c_style & ALWAYS_BIT ~= 0) rtrue;
    if (c_style & RECURSE_BIT == 0) rfalse;
    if ((o has supporter) || ((o has container) && (o has open or transparent))) rtrue;
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Grouping
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NumberOfGroupsInList o no_classes depth partition_classes partition_class_sizes
	no_groups cl memb k current_lt lt;
	current_lt = EMPTY_TEXT_VALUE;
	lt = EMPTY_TEXT_VALUE;
	no_groups = no_classes;
    for (cl=1, memb=o, k=0: cl<=no_classes: cl++) {
    	! Advance to first member of class number cl
        while (partition_classes->k ~= cl) {
            k++; memb = c_iterator(memb, depth, lt_value, ADVANCE_ITF);
        }
        if (memb) { ! In case of accidents, but should always happen
        	lt = memb.list_together;
        	if ((LT_Compare(lt, lt_value) ~= 0) &&
            	(LT_Compare(lt, EMPTY_TEXT_VALUE) ~= 0) &&
            	(LT_Compare(lt, current_lt) == 0)) {
            	no_groups--;
            }
            current_lt = lt;
        }
    }
 	#Ifdef DBLW; print "[There are ", no_groups, " groups.]^"; #Endif;
	return no_groups;
];

[ LT_Compare lt1 lt2;
	if (lt1 == lt2) return 0;
	if (lt1 == 0) lt1 = EMPTY_TEXT_VALUE;
	if (lt2 == 0) lt2 = EMPTY_TEXT_VALUE;
	if (TEXT_TY_IsSubstituted(lt1) == false) {
		if (TEXT_TY_IsSubstituted(lt2) == false) return (lt1-->1)-(lt2-->1);
		return -1;
	}
	if (TEXT_TY_IsSubstituted(lt2) == false) {
		return -1;
	}
	return BlkValueCompare(lt1, lt2);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Write List Recursively
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteListR o depth from_start
	partition_classes partition_class_sizes
	cl memb index k2 l m no_classes q groups_to_do current_lt;
    if (o == nothing) return; ! An empty list: no output

    if (from_start) {
    	o = c_iterator(o, depth, 0, COALESCE_ITF); ! Coalesce list and choose new start
	}
    o = c_iterator(o, depth, 0, SEEK_ITF); ! Find first entry in list from o
    if (o == nothing) return;

	! Count index = length of list
    for (memb=o, index=0: memb: memb=c_iterator(memb, depth, lt_value, ADVANCE_ITF)) index++;

    if (c_style & ISARE_BIT ~= 0) {
    	SetLWI(index, -1, o);
    	LIST_WRITER_INTERNAL_RM('V', o);
    	if (c_style & NEWLINE_BIT ~= 0)   print ":^";
        else                              print (char) ' ';
        c_style = c_style - ISARE_BIT;
    }

    partition_classes = RequisitionStack(index/WORDSIZE + 2);
    partition_class_sizes = RequisitionStack(index/WORDSIZE + 2);
    if ((partition_classes == 0) || (partition_class_sizes == 0))
    	return RunTimeProblem(RTP_LISTWRITERMEMORY);

	no_classes =
		PartitionList(o, index, depth, partition_classes, partition_class_sizes);

	groups_to_do =
		NumberOfGroupsInList(o, no_classes, depth, partition_classes, partition_class_sizes);

    for (cl=1, memb=o, index=0, current_lt=EMPTY_TEXT_VALUE: groups_to_do>0: cl++) {
		! Set memb to first object of partition class cl
        while (partition_classes->index ~= cl) {
        	index++; memb=c_iterator(memb, depth, lt_value, ADVANCE_ITF);
            if (memb==0) { print "*** Error in list-writer ***^"; return; }
        }

    	#Ifdef DBLW;
		! DebugPartition(partition_class_sizes, partition_classes, o, depth);
		print "^[Class ", cl, " of ", no_classes, ": first object ", memb,
			" (", memb.list_together, "); groups_to_do ", groups_to_do, ",
			current_lt=", current_lt, " listing_size=", listing_size,
			" lt_value=", lt_value, " memb.list_together=", memb.list_together, "]^";
    	#Endif;

		if ((LT_Compare(memb.list_together, lt_value) == 0) ||
        	(LT_Compare(memb.list_together, EMPTY_TEXT_VALUE) == 0)) current_lt = EMPTY_TEXT_VALUE;
		else {
            if (LT_Compare(memb.list_together, current_lt) == 0) continue;
            
            ! Otherwise this class begins a new group
            @push listing_size;
            q = memb; listing_size = 1; l = index; m = cl;
			while (m < no_classes &&
				(LT_Compare(q.list_together, memb.list_together) == 0)) {
				m++;
				while (partition_classes->l ~= m) {
					l++; q = c_iterator(q, depth, lt_value, ADVANCE_ITF);
				}
				if (LT_Compare(q.list_together, memb.list_together) == 0)
					listing_size++;
			}

			if (listing_size > 1) {
				! The new group contains more than one partition class
				WriteMultiClassGroup(cl, memb, depth, partition_class_sizes);
				current_lt = memb.list_together;
				jump GroupComplete;
			}
			current_lt = EMPTY_TEXT_VALUE;
			@pull listing_size;
		}

		WriteSingleClassGroup(cl, memb, depth, partition_class_sizes->cl);

		.GroupComplete;
		groups_to_do--;
        if (c_style & ENGLISH_BIT ~= 0) {
            if (groups_to_do == 1) {
            	#ifdef SERIAL_COMMA; if (cl > 1) print ","; #endif;
               LIST_WRITER_INTERNAL_RM('C');
            }
            if (groups_to_do > 1) print ", ";
        }
    }

    FreeStack(partition_class_sizes);
    FreeStack(partition_classes);
]; ! end of WriteListR


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Write Multiple Class Group
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteMultiClassGroup cl memb depth partition_class_sizes pv q k2 l;
	! Save the style, because the activity below is allowed to change it
	q = c_style;
	if (c_style & INDENT_BIT ~= 0) PrintSpaces(2*(depth+c_margin));

	BeginActivity(GROUPING_TOGETHER_ACT, memb);

	if (ForActivity(GROUPING_TOGETHER_ACT, memb)) {
		c_style = c_style &~ NEWLINE_BIT;
	} else {
		pv = memb.list_together;
		if (TEXT_TY_IsSubstituted(pv) == false) {
			inventory_stage = 1;
			parser_one = memb; parser_two = depth + c_margin;
			if ((pv-->1)() == 1) jump Omit__Sublist2;
		} else if (pv) {
			! Set k2 to the number of objects covered by the group
			k2 = 0;
			for (l=0 : l<listing_size : l++) k2 = k2 + partition_class_sizes->(l+cl);
			EnglishNumber(k2); print " ";
			print (TEXT_TY_Say) pv;
			if (c_style & ENGLISH_BIT ~= 0) print " (";
			if (c_style & INDENT_BIT ~= 0)  print ":^";
		}

		c_margin++;
		@push lt_value; @push listing_together; @push listing_size;
		
		lt_value = memb.list_together; listing_together = memb;
		#Ifdef DBLW; print "^^DOWN lt_value = ", lt_value, " listing_together = ", memb, "^^";
		@push DBLW_no_classes; @push DBLW_no_objs; #Endif;
		WriteListR(memb, depth, false); 
		#Ifdef DBLW; print "^^UP^^"; @pull DBLW_no_objs; @pull DBLW_no_classes; #Endif;

		@pull listing_size; @pull listing_together; @pull lt_value;
		c_margin--;
		
		pv = memb.list_together;
		if (TEXT_TY_IsSubstituted(pv) == false) {
			inventory_stage = 2;
			parser_one = memb; parser_two = depth+c_margin;
			(pv-->1)();
		} else if (LT_Compare(pv, EMPTY_TEXT_VALUE) ~= 0) {
			if (q & ENGLISH_BIT ~= 0) print ")";
		}
		.Omit__Sublist2;
	}
  
	EndActivity(GROUPING_TOGETHER_ACT, memb);

	! If the NEWLINE_BIT has been forced by the activity, act now
	! before it vanishes...
	if (q & NEWLINE_BIT ~= 0 && c_style & NEWLINE_BIT == 0) new_line;

	! ...when the original style is restored again:
	c_style = q;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Write Single Class Group
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteSingleClassGroup cl memb depth size q;
	q = c_style;
    if (c_style & INDENT_BIT) PrintSpaces(2*(depth+c_margin));
	if (size == 1) {
		if (c_style & NOARTICLE_BIT ~= 0) print (name) memb;
		else {
			if (c_style & DEFART_BIT) {
				if ((cl == 1) && (c_style & CFIRSTART_BIT)) print (The) memb;
				else print (the) memb;
			} else {
				if ((cl == 1) && (c_style & CFIRSTART_BIT)) print (CIndefArt) memb;
				else print (a) memb;
			}
		}
	} else {
		if (c_style & DEFART_BIT) {
			if ((cl == 1) && (c_style & CFIRSTART_BIT)) PrefaceByArticle(memb, 0, size);
			else PrefaceByArticle(memb, 1, size);
		}
		@push listing_size; listing_size = size;
		CarryOutActivity(PRINTING_A_NUMBER_OF_ACT, memb);
		@pull listing_size;
	}
	if ((size > 1) && (memb hasnt pluralname)) {
		give memb pluralname;
		WriteAfterEntry(memb, depth);
		give memb ~pluralname;
	} else WriteAfterEntry(memb, depth);
	c_style = q;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Write After Entry
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteAfterEntry o depth
    p recurse_flag parenth_flag eldest_child child_count combo;

    inventory_stage = 2;
    if (c_style & PARTINV_BIT) {
        BeginActivity(PRINTING_ROOM_DESC_DETAILS_ACT, o);
        if (ForActivity(PRINTING_ROOM_DESC_DETAILS_ACT, o) == false) {
			combo = 0;
			if (o has light && location hasnt light) combo=combo+1;
			if (o has container && o hasnt open)     combo=combo+2;
			if ((o has container && (o has open || o has transparent))
				&& (child(o)==0))                    combo=combo+4;
			if (combo) LIST_WRITER_INTERNAL_RM('A'); ! space and open bracket
			switch (combo) {
				1: LIST_WRITER_INTERNAL_RM('D', o);
				2: LIST_WRITER_INTERNAL_RM('E', o);
				3: LIST_WRITER_INTERNAL_RM('H', o);
				4: LIST_WRITER_INTERNAL_RM('F', o);
				5: LIST_WRITER_INTERNAL_RM('I', o);
				6: LIST_WRITER_INTERNAL_RM('G', o);
				7: LIST_WRITER_INTERNAL_RM('J', o);
			}
			if (combo) LIST_WRITER_INTERNAL_RM('B'); ! close bracket
		}
        EndActivity(PRINTING_ROOM_DESC_DETAILS_ACT, o);
    }   ! end of PARTINV_BIT processing

    if (c_style & FULLINV_BIT) {
        BeginActivity(PRINTING_INVENTORY_DETAILS_ACT, o);
        if (ForActivity(PRINTING_INVENTORY_DETAILS_ACT, o) == false) {
			if (o has light && o has worn) { LIST_WRITER_INTERNAL_RM('A'); LIST_WRITER_INTERNAL_RM('K', o);  parenth_flag = true; }
			else {
				if (o has light)           { LIST_WRITER_INTERNAL_RM('A'); LIST_WRITER_INTERNAL_RM('D', o);  parenth_flag = true; }
				if (o has worn)            { LIST_WRITER_INTERNAL_RM('A'); LIST_WRITER_INTERNAL_RM('L', o); parenth_flag = true; }
			}
	
			if (o has container)
				if (o has openable) {
					if (parenth_flag) {
						#Ifdef SERIAL_COMMA; print ","; #Endif;
						LIST_WRITER_INTERNAL_RM('C');
					} else            LIST_WRITER_INTERNAL_RM('A', o);
					if (o has open)
						if (child(o)) LIST_WRITER_INTERNAL_RM('M', o);
						else          LIST_WRITER_INTERNAL_RM('N', o);
					else
						if (o has lockable && o has locked) LIST_WRITER_INTERNAL_RM('P', o);
						else                                LIST_WRITER_INTERNAL_RM('O', o);
					parenth_flag = true;
				}
				else
					if (child(o)==0 && o has transparent)
						if (parenth_flag) { LIST_WRITER_INTERNAL_RM('C'); LIST_WRITER_INTERNAL_RM('F'); }
						else              { LIST_WRITER_INTERNAL_RM('A'); LIST_WRITER_INTERNAL_RM('F'); LIST_WRITER_INTERNAL_RM('B'); }
	
			if (parenth_flag) LIST_WRITER_INTERNAL_RM('B');
		}
        EndActivity(PRINTING_INVENTORY_DETAILS_ACT, o);
    }   ! end of FULLINV_BIT processing

	child_count = 0;
	eldest_child = nothing;
	objectloop (p in o)
		if ((c_style & CONCEAL_BIT == 0) || (ConcealedFromLists(p) == false))
			if (p has list_filter_permits) {
				child_count++;
				if (eldest_child == nothing) eldest_child = p;
			}

    if (child_count && (c_style & ALWAYS_BIT)) {
        if (c_style & ENGLISH_BIT) { print " "; LIST_WRITER_INTERNAL_RM('Q', o); print " "; }
        recurse_flag = true;
    }
    
    if (child_count && (c_style & RECURSE_BIT)) {
        if (o has supporter) {
            if (c_style & ENGLISH_BIT) {
                if (c_style & TERSE_BIT) {
                	LIST_WRITER_INTERNAL_RM('A', o);
                	LIST_WRITER_INTERNAL_RM('R', o);
                } else LIST_WRITER_INTERNAL_RM('S', o);
            }
            recurse_flag = true;
        }
        if (o has container && (o has open || o has transparent)) {
            if (c_style & ENGLISH_BIT) {
                if (c_style & TERSE_BIT) {
                	LIST_WRITER_INTERNAL_RM('A', o);
                	LIST_WRITER_INTERNAL_RM('T', o);
                } else LIST_WRITER_INTERNAL_RM('U', o);
            }
            recurse_flag = true;
        }
    }

    if (recurse_flag && (c_style & ENGLISH_BIT)) {
    	SetLWI(child_count, -1, eldest_child);
    	LIST_WRITER_INTERNAL_RM('V', o); print " ";
	}

    if (c_style & NEWLINE_BIT) new_line;

    if (recurse_flag) {
        o = child(o);
        @push lt_value; @push listing_together; @push listing_size;
        @push c_iterator;
        c_iterator = ObjectTreeIterator;
        lt_value = EMPTY_TEXT_VALUE; listing_together = 0; listing_size = 0;
        WriteListR(o, depth+1, true);
        @pull c_iterator;
        @pull listing_size; @pull listing_together; @pull lt_value;
        if (c_style & TERSE_BIT) LIST_WRITER_INTERNAL_RM('B');
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! ListWriter.i6t: Internal Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_WRITER_INTERNAL_R;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: Saying Phrases
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SayPhraseName closure;
	if (closure == 0) print "nothing";
	else print (string) closure-->2;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: Kinds
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ KindAtomic kind;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return kind;
	return kind-->0;
];

[ KindBaseArity kind;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return 0;
	return kind-->1;
];

[ KindBaseTerm kind n;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return UNKNOWN_TY;
	return kind-->(2+n);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: DigitToValue
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DigitToValue c n;
	n = c-'0';
	if ((n<0) || (n>9)) return -1;
	return n;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: GenerateRandomNumber
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GenerateRandomNumber n m s;
	if (n==m) return n;
	if (n>m) { s = n; n = m; m = s; }
	n--;
	return random(m-n) + n;
];
Constant R_DecimalNumber = GenerateRandomNumber;
Constant R_PrintTimeOfDay = GenerateRandomNumber;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: GroupChildren
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GroupChildren par value;
    while (child(par) ~= 0) {
        if (LT_Compare(child(par).list_together, value) ~= 0)
        	move child(par) to out_obj;
        else
        	move child(par) to in_obj;
    }
    while (child(in_obj) ~= 0)  move child(in_obj) to par;
    while (child(out_obj) ~= 0) move child(out_obj) to par;
    return child(par);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: PrintSpaces
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintSpaces n;
    while (n > 0) {
        print " ";
        n = n - 1;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: RunRoutines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RunRoutines obj prop;
    if (obj == thedark) obj = real_location;
    if ((obj.&prop == 0) && (prop >= INDIV_PROP_START)) rfalse;
    return obj.prop();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: SwapWorkflags
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SwapWorkflags obj lst;
	objectloop (obj ofclass Object) {
		lst = false;
		if (obj has workflag2) lst = true;
		give obj ~workflag2;
		if (obj has workflag) give obj workflag2;
		give obj ~workflag;
		if (lst) give obj workflag;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: TestUseOption
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant NO_USE_OPTIONS = 31;
[ TestUseOption 
    UO ! Implied call parameter
    ;
    if (UO == 1) rtrue;
    if (UO == 2) rtrue;
    if (UO == 3) rtrue;
    if (UO == 4) rtrue;
    if (UO == 28) rtrue;
    if (UO == 29) rtrue;
    rfalse;
];
[ PrintUseOption 
    UO ! Implied call parameter
    ;
    switch(UO) {
        0: print "ineffectual option";
        1: print "dynamic memory allocation option [8192]";
        2: print "maximum text length option [1024]";
        3: print "index figure thumbnails option [50]";
        4: print "maximum things understood at once option [100]";
        5: print "American dialect option";
        6: print "serial comma option";
        7: print "full-length room descriptions option";
        8: print "abbreviated room descriptions option";
        9: print "memory economy option";
        10: print "authorial modesty option";
        11: print "scoring option";
        12: print "no scoring option";
        13: print "engineering notation option";
        14: print "unabbreviated object names option";
        15: print "command line echoing option";
        16: print "manual pronouns option";
        17: print "undo prevention option";
        18: print "predictable randomisation option";
        19: print "fast route-finding option";
        20: print "slow route-finding option";
        21: print "numbered rules option";
        22: print "telemetry recordings option";
        23: print "no deprecated features option";
        24: print "gn testing version option";
        25: print "VERBOSE room descriptions option";
        26: print "BRIEF room descriptions option";
        27: print "SUPERBRIEF room descriptions option";
        28: print "escape code option [167]";
        29: print "maximum capture buffer length option [256]";
        30: print "direct event handling option";
    }
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: IntegerDivide
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IntegerDivide A B;
	if (B == 0) { RunTimeProblem(RTP_DIVZERO); rfalse; }
	return A/B;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: IntegerRemainder
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IntegerRemainder A B;
	if (B == 0) { RunTimeProblem(RTP_DIVZERO); rfalse; }
	return A%B;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: UnsignedCompare
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ UnsignedCompare x y u v;
	#Ifdef TARGET_GLULX;
	@jleu x y ?lesseq;
	return 1;
	.lesseq;
	@jeq x y ?equal;
	return -1;
	.equal;
	return 0;
	#Ifnot;
    if (x == y) return 0;
    if (x < 0 && y >= 0) return 1;
    if (x >= 0 && y < 0) return -1;
    u = x&~WORD_HIGHBIT; v= y&~WORD_HIGHBIT;
    if (u > v) return 1;
    return -1;
    #Endif;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: SignedCompare
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SignedCompare x y;
	if (x > y) return 1;
	if (x == y) return 0;
	return -1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: ZRegion
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ZRegion addr;
    switch (metaclass(addr)) {
		nothing: return 0;
		Object, Class: return 1;
		Routine: return 2;
		String: return 3;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: Memcpy
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Memcpy to_addr from_addr size  n;
#Ifdef TARGET_ZCODE;
	for (n = size/WORDSIZE: (n--) > 0: ) to_addr-->n = from_addr-->n;
	for (n = size: ((n--) % WORDSIZE ~= 0): ) to_addr->n = from_addr->n;
#Ifnot; ! TARGET_GLULX
    @mcopy size from_addr to_addr;
#Endif; ! TARGET_
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Utilities.i6t: Arrcpy
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Arrcpy to_array to_entry_size from_array from_entry_size no_entries  n val;
	if (to_entry_size == from_entry_size)
		Memcpy(to_array, from_array, to_entry_size*no_entries);
	else if ((to_entry_size == 2) && (from_entry_size == 4)) {
		for (n = 0: n<no_entries: n++) {
			val = from_array-->n;
			to_array->0 = (val/256)%256; to_array->1 = val%256;
			to_array = to_array + 2;
		}
	} else "*** Arrcpy doesn't support this ***";
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Parser
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Object InformParser "(Inform Parser)" has proper;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Grammar Line Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global best_etype;                  ! Preferred error number so far
Global nextbest_etype;              ! Preferred one, if ASKSCOPE_PE disallowed

Global parser_inflection;           ! A property (usually "name") to find object names in

Array pattern --> 32;               ! For the current pattern match
Global pcount;                      ! and a marker within it
Array pattern2 --> 32;              ! And another, which stores the best match
Global pcount2;                     ! so far

Array  line_ttype-->32;             ! For storing an analysed grammar line
Array  line_tdata-->32;
Array  line_token-->32;

Global nsns;                        ! Number of special_numbers entered so far

Global params_wanted;               ! Number of parameters needed (which may change in parsing)

Global inferfrom;                   ! The point from which the rest of the command must be inferred
Global inferword;                   ! And the preposition inferred
Global dont_infer;                  ! Another dull flag

Global cobj_flag = 0;

Global oops_from;                   ! The "first mistake" word number
Global saved_oops;                  ! Used in working this out
Array  oops_workspace -> 64;        ! Used temporarily by "oops" routine

Global held_back_mode;              ! Flag: is there some input from last time
Global hb_wn;                       ! left over?  (And a save value for wn.)
                                    ! (Used for full stops and "then".)

Global usual_grammar_after;         ! Point from which usual grammar is parsed (it may vary from
                                    ! the above if user's routines match multi-word verbs)


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Grammar Token Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant PATTERN_NULL = $ffff;      ! Entry for a token producing no text

Global found_ttype;                 ! Used to break up tokens into type
Global found_tdata;                 ! and data (by AnalyseToken)
Global token_filter;                ! For noun filtering by user routines

Global length_of_noun;              ! Set by NounDomain to no of words in noun

Global lookahead;                   ! The token after the one now being matched

Global multi_mode;                  ! Multiple mode
Global multi_wanted;                ! Number of things needed in multitude
Global multi_had;                   ! Number of things actually found
Global multi_context;               ! What token the multi-obj was accepted for

Global indef_mode;                  ! "Indefinite" mode - ie, "take a brick"
                                    ! is in this mode
Global indef_type;                  ! Bit-map holding types of specification
Global indef_wanted;                ! Number of items wanted (INDEF_ALL_WANTED for all)
Constant INDEF_ALL_WANTED = 32767;
Global indef_guess_p;               ! Plural-guessing flag
Global indef_owner;                 ! Object which must hold these items
Global indef_cases;                 ! Possible gender and numbers of them
Global indef_possambig;             ! Has a possibly dangerous assumption
                                    ! been made about meaning of a descriptor?
Global indef_nspec_at;              ! Word at which a number like "two" was parsed
                                    ! (for backtracking)
Global allow_plurals;               ! Whether plurals presently allowed or not

Global take_all_rule;               ! Slightly different rules apply to "take all" than other uses
                                    ! of multiple objects, to make adjudication produce more
                                    ! pragmatically useful results
                                    ! (Not a flag: possible values 0, 1, 2)

Global dict_flags_of_noun;          ! Of the noun currently being parsed
                                    ! (a bitmap in #dict_par1 format)
Global pronoun__word;               ! Saved value
Global pronoun__obj;                ! Saved value

Constant comma_word = 'comma,';     ! An "untypeable word" used to substitute
                                    ! for commas in parse buffers


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Match List Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array  match_list --> MATCH_LIST_WORDS;    ! An array of matched objects so far
Array  match_classes --> MATCH_LIST_WORDS; ! An array of equivalence classes for them
Array  match_scores --> MATCH_LIST_WORDS;  ! An array of match scores for them
Global number_matched;              ! How many items in it?  (0 means none)
Global number_of_classes;           ! How many equivalence classes?
Global match_length;                ! How many words long are these matches?
Global match_from;                  ! At what word of the input do they begin?


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Words
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef TARGET_ZCODE;
[ WordCount; return parse->1; ];
[ WordAddress wordnum; return buffer + parse->(wordnum*4+1); ];
[ WordLength wordnum; return parse->(wordnum*4); ];
#Ifnot;
[ WordCount; return parse-->0; ];
[ WordAddress wordnum; return buffer + parse-->(wordnum*3); ];
[ WordLength wordnum; return parse-->(wordnum*3-1); ];
#Endif;

[ WordFrom w p i j wc;
	#Ifdef TARGET_ZCODE; wc = p->1; i = w*2-1;
	#Ifnot; wc = p-->0; i = w*3-2; #Endif;
    if ((w < 1) || (w > wc)) return 0;
    j = p-->i;
    if (j == ',//') j = comma_word;
    if (j == './/') j = THEN1__WD;
    return j;
];

[ NextWord i j wc;
	#Ifdef TARGET_ZCODE; wc = parse->1; i = wn*2-1;
	#Ifnot; wc = parse-->0; i = wn*3-2; #Endif;
    wn++;
    if ((wn < 2) || (wn > wc+1)) return 0;
    j = parse-->i;
    if (j == ',//') j = comma_word;
    if (j == './/') j = THEN1__WD;
    return j;
];

[ NextWordStopped wc;
	#Ifdef TARGET_ZCODE; wc = parse->1; #Ifnot; wc = parse-->0; #Endif;
	if ((wn < 1) || (wn > wc)) { wn++; return -1; }
    return NextWord();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Snippets
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintSnippet snip from to i w1 w2;
	w1 = snip/100; w2 = w1 + (snip%100) - 1;
	if ((w2<w1) || (w1<1) || (w2>WordCount())) {
		if ((w1 == 1) && (w2 == 0)) rfalse;
		return RunTimeProblem(RTP_SAYINVALIDSNIPPET, w1, w2);
	}
	from = WordAddress(w1); to = WordAddress(w2) + WordLength(w2) - 1;
	for (i=from: i<=to: i++) print (char) i->0;
];

[ SpliceSnippet snip t i w1 w2 nextw at endsnippet newlen;
	w1 = snip/100; w2 = w1 + (snip%100) - 1;
	if ((w2<w1) || (w1<1)) {
		if ((w1 == 1) && (w2 == 0)) return;
		return RunTimeProblem(RTP_SPLICEINVALIDSNIPPET, w1, w2);
	}
	@push say__p; @push say__pc;
	nextw = w2 + 1;
	at = WordAddress(w1) - buffer;
	if (nextw <= WordCount()) endsnippet = 100*nextw + (WordCount() - nextw + 1);
	buffer2-->0 = 120;
	newlen = VM_PrintToBuffer(buffer2, 120, SpliceSnippet__TextPrinter, t, endsnippet);
	for (i=0: (i<newlen) && (at+i<120): i++) buffer->(at+i) = buffer2->(WORDSIZE+i);
	#Ifdef TARGET_ZCODE; buffer->1 = at+i; #ifnot; buffer-->0 = at+i; #endif;
	for (:at+i<120:i++) buffer->(at+i) = ' ';
	VM_Tokenise(buffer, parse);
	players_command = 100 + WordCount();
	@pull say__pc; @pull say__p;
];

[ SpliceSnippet__TextPrinter t endsnippet;
	TEXT_TY_Say(t);
	if (endsnippet) { print " "; PrintSnippet(endsnippet); }
];

[ SnippetIncludes test snippet w1 w2 wlen i j;
	w1 = snippet/100; w2 = w1 + (snippet%100) - 1;
	if ((w2<w1) || (w1<1)) {
		if ((w1 == 1) && (w2 == 0)) rfalse;
		return RunTimeProblem(RTP_INCLUDEINVALIDSNIPPET, w1, w2);
	}
	if (metaclass(test) == Routine) {
		wlen = snippet%100;
		for (i=w1, j=wlen: j>0: i++, j--) {
			if (((test)(i, 0)) ~= GPR_FAIL) return i*100+wn-i;
		}
	}
	rfalse;
];

[ SnippetMatches snippet topic_gpr rv;
	wn=1;
	if (topic_gpr == 0) rfalse;
	if (metaclass(topic_gpr) == Routine) {
		rv = (topic_gpr)(snippet/100, snippet%100);
		if (rv ~= GPR_FAIL) rtrue;
		rfalse;
	}
	RunTimeProblem(RTP_BADTOPIC);
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Unpacking Grammar Lines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ UnpackGrammarLine line_address i size;
    for (i=0 : i<32 : i++) {
        line_token-->i = ENDIT_TOKEN;
        line_ttype-->i = ELEMENTARY_TT;
        line_tdata-->i = ENDIT_TOKEN;
    }
#Ifdef TARGET_ZCODE;
    action_to_be = 256*(line_address->0) + line_address->1;
    action_reversed = ((action_to_be & $400) ~= 0);
    action_to_be = action_to_be & $3ff;
    line_address--;
    size = 3;
#Ifnot; ! GLULX
    @aloads line_address 0 action_to_be;
    action_reversed = (((line_address->2) & 1) ~= 0);
    line_address = line_address - 2;
    size = 5;
#Endif;
    params_wanted = 0;
    for (i=0 : : i++) {
        line_address = line_address + size;
        if (line_address->0 == ENDIT_TOKEN) break;
        line_token-->i = line_address;
        AnalyseToken(line_address);
        if (found_ttype ~= PREPOSITION_TT) params_wanted++;
        line_ttype-->i = found_ttype;
        line_tdata-->i = found_tdata;
    }
    return line_address + 1;
];

[ AnalyseToken token;
    if (token == ENDIT_TOKEN) {
        found_ttype = ELEMENTARY_TT;
        found_tdata = ENDIT_TOKEN;
        return;
    }
    found_ttype = (token->0) & $$1111;
    found_tdata = (token+1)-->0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Extracting Verb Numbers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DictionaryWordToVerbNum dword verbnum;
#Ifdef TARGET_ZCODE;
	verbnum = $ff-(dword->#dict_par2);
#Ifnot; ! GLULX
	dword = dword + #dict_par2 - 1;
    @aloads dword 0 verbnum;
    verbnum = $ffff-verbnum;
#Endif;
	return verbnum;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Keyboard Primitive
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ KeyboardPrimitive a_buffer a_table;
#Ifdef DEBUG; #Iftrue (5 > 0);
	return TestKeyboardPrimitive(a_buffer, a_table);
#Endif; #Endif;
	return VM_ReadKeyboard(a_buffer, a_table);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Reading the Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Keyboard  a_buffer a_table  nw i w w2 x1 x2;
	sline1 = score; sline2 = turns;

	while (true) {
		! Save the start of the buffer, in case "oops" needs to restore it
		for (i=0 : i<64 : i++) oops_workspace->i = a_buffer->i;
	
		! In case of an array entry corruption that shouldn't happen, but would be
		! disastrous if it did:
		#Ifdef TARGET_ZCODE;
		a_buffer->0 = INPUT_BUFFER_LEN;
		a_table->0 = 15;  ! Allow to split input into this many words
		#Endif; ! TARGET_
	
		! Print the prompt, and read in the words and dictionary addresses
		PrintPrompt();
		DrawStatusLine();
		KeyboardPrimitive(a_buffer, a_table);
	
		! Set nw to the number of words
		#Ifdef TARGET_ZCODE; nw = a_table->1; #Ifnot; nw = a_table-->0; #Endif;
	
		! If the line was blank, get a fresh line
		if (nw == 0) {
			@push etype; etype = BLANKLINE_PE;
			players_command = 100;
			BeginActivity(PRINTING_A_PARSER_ERROR_ACT);
			if (ForActivity(PRINTING_A_PARSER_ERROR_ACT) == false) {
				PARSER_ERROR_INTERNAL_RM('X', noun); new_line;
			}
			EndActivity(PRINTING_A_PARSER_ERROR_ACT);
			@pull etype;
			continue;
		}
	
		! Unless the opening word was OOPS, return
		! Conveniently, a_table-->1 is the first word on both the Z-machine and Glulx
	
		w = a_table-->1;
		if (w == OOPS1__WD or OOPS2__WD or OOPS3__WD) {
			if (oops_from == 0) { PARSER_COMMAND_INTERNAL_RM('A'); new_line; continue; }
			if (nw == 1) { PARSER_COMMAND_INTERNAL_RM('B'); new_line; continue; }
			if (nw > 2) { PARSER_COMMAND_INTERNAL_RM('C'); new_line; continue; }
		
			! So now we know: there was a previous mistake, and the player has
			! attempted to correct a single word of it.
		
			for (i=0 : i<INPUT_BUFFER_LEN : i++) buffer2->i = a_buffer->i;
			#Ifdef TARGET_ZCODE;
			x1 = a_table->9;  ! Start of word following "oops"
			x2 = a_table->8;  ! Length of word following "oops"
			#Ifnot; ! TARGET_GLULX
			x1 = a_table-->6; ! Start of word following "oops"
			x2 = a_table-->5; ! Length of word following "oops"
			#Endif; ! TARGET_
		
			! Repair the buffer to the text that was in it before the "oops"
			! was typed:
			for (i=0 : i<64 : i++) a_buffer->i = oops_workspace->i;
			VM_Tokenise(a_buffer,a_table);
		
			! Work out the position in the buffer of the word to be corrected:
			#Ifdef TARGET_ZCODE;
			w = a_table->(4*oops_from + 1); ! Start of word to go
			w2 = a_table->(4*oops_from);    ! Length of word to go
			#Ifnot; ! TARGET_GLULX
			w = a_table-->(3*oops_from);      ! Start of word to go
			w2 = a_table-->(3*oops_from - 1); ! Length of word to go
			#Endif; ! TARGET_
		
			! Write spaces over the word to be corrected:
			for (i=0 : i<w2 : i++) a_buffer->(i+w) = ' ';
		
			if (w2 < x2) {
				! If the replacement is longer than the original, move up...
				for (i=INPUT_BUFFER_LEN-1 : i>=w+x2 : i--)
					a_buffer->i = a_buffer->(i-x2+w2);
		
				! ...increasing buffer size accordingly.
				#Ifdef TARGET_ZCODE;
				a_buffer->1 = (a_buffer->1) + (x2-w2);
				#Ifnot; ! TARGET_GLULX
				a_buffer-->0 = (a_buffer-->0) + (x2-w2);
				#Endif; ! TARGET_
			}
		
			! Write the correction in:
			for (i=0 : i<x2 : i++) a_buffer->(i+w) = buffer2->(i+x1);
		
			VM_Tokenise(a_buffer, a_table);
			#Ifdef TARGET_ZCODE; nw = a_table->1; #Ifnot; nw = a_table-->0; #Endif;
		
			return nw;
		}

		! Undo handling
	
		if ((w == UNDO1__WD or UNDO2__WD or UNDO3__WD) && (nw==1)) {
			Perform_Undo();
			continue;
		}
		i = VM_Save_Undo();
		#ifdef PREVENT_UNDO; undo_flag = 0; #endif;
		#ifndef PREVENT_UNDO; undo_flag = 2; #endif;
		if (i == -1) undo_flag = 0;
		if (i == 0) undo_flag = 1;
		if (i == 2) {
			VM_RestoreWindowColours();
			VM_Style(SUBHEADER_VMSTY);
			SL_Location(); print "^";
			! print (name) location, "^";
			VM_Style(NORMAL_VMSTY);
			IMMEDIATELY_UNDO_RM('E'); new_line;
			continue;
		}
		return nw;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Proper
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Parser__parse
	syntax line num_lines line_address i j k token l m inferred_go;
	cobj_flag = 0;
	parser_results-->ACTION_PRES = 0;
	parser_results-->NO_INPS_PRES = 0;
	parser_results-->INP1_PRES = 0;
	parser_results-->INP2_PRES = 0;
	meta = false;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter A
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    if (held_back_mode) {
        held_back_mode = false; wn = hb_wn;
        if (verb_wordnum > 0) i = WordAddress(verb_wordnum); else i = WordAddress(1);
        j = WordAddress(wn);
        if (i<=j) for (: i<j : i++) i->0 = ' ';
        i = NextWord();
        if (i == AGAIN1__WD or AGAIN2__WD or AGAIN3__WD) {
            ! Delete the words "then again" from the again buffer,
            ! in which we have just realised that it must occur:
            ! prevents an infinite loop on "i. again"

            i = WordAddress(wn-2)-buffer;
            if (wn > num_words) j = INPUT_BUFFER_LEN-1;
            else j = WordAddress(wn)-buffer;
            for (: i<j : i++) buffer3->i = ' ';
        }

        VM_Tokenise(buffer, parse);
        jump ReParse;
    }

  .ReType;

	cobj_flag = 0;
	actors_location = ScopeCeiling(player);
    BeginActivity(READING_A_COMMAND_ACT); if (ForActivity(READING_A_COMMAND_ACT)==false) {
		Keyboard(buffer,parse);
		num_words = WordCount(); players_command = 100 + num_words;
    } if (EndActivity(READING_A_COMMAND_ACT)) jump ReType;

  .ReParse;

    parser_inflection = name;

    ! Initially assume the command is aimed at the player, and the verb
    ! is the first word

    num_words = WordCount(); players_command = 100 + num_words;
    wn = 1; inferred_go = false;

    #Ifdef LanguageToInformese;
    LanguageToInformese();
    ! Re-tokenise:
    VM_Tokenise(buffer,parse);
    #Endif; ! LanguageToInformese

    num_words = WordCount(); players_command = 100 + num_words;

    k=0;
    #Ifdef DEBUG;
    if (parser_trace >= 2) {
        print "[ ";
        for (i=0 : i<num_words : i++) {

            #Ifdef TARGET_ZCODE;
            j = parse-->(i*2 + 1);
            #Ifnot; ! TARGET_GLULX
            j = parse-->(i*3 + 1);
            #Endif; ! TARGET_
            k = WordAddress(i+1);
            l = WordLength(i+1);
            print "~"; for (m=0 : m<l : m++) print (char) k->m; print "~ ";

            if (j == 0) print "?";
            else {
                #Ifdef TARGET_ZCODE;
                if (UnsignedCompare(j, HDR_DICTIONARY-->0) >= 0 &&
                    UnsignedCompare(j, HDR_HIGHMEMORY-->0) < 0)
                     print (address) j;
                else print j;
                #Ifnot; ! TARGET_GLULX
                if (j->0 == $60) print (address) j;
                else print j;
                #Endif; ! TARGET_
            }
            if (i ~= num_words-1) print " / ";
        }
        print " ]^";
    }
    #Endif; ! DEBUG
    verb_wordnum = 1;
    actor = player;
    actors_location = ScopeCeiling(player);
    usual_grammar_after = 0;

  .AlmostReParse;

    scope_token = 0;
    action_to_be = NULL;

    ! Begin from what we currently think is the verb word

  .BeginCommand;

    wn = verb_wordnum;
    verb_word = NextWordStopped();

    ! If there's no input here, we must have something like "person,".

    if (verb_word == -1) {
        best_etype = STUCK_PE; jump GiveError;
    }
	if (verb_word == comma_word) {
		best_etype = COMMABEGIN_PE; jump GiveError;
	}

    ! Now try for "again" or "g", which are special cases: don't allow "again" if nothing
    ! has previously been typed; simply copy the previous text across

    if (verb_word == AGAIN2__WD or AGAIN3__WD) verb_word = AGAIN1__WD;
    if (verb_word == AGAIN1__WD) {
        if (actor ~= player) {
            best_etype = ANIMAAGAIN_PE;
			jump GiveError;
        }
        #Ifdef TARGET_ZCODE;
        if (buffer3->1 == 0) {
            PARSER_COMMAND_INTERNAL_RM('D'); new_line;
            jump ReType;
        }
        #Ifnot; ! TARGET_GLULX
        if (buffer3-->0 == 0) {
            PARSER_COMMAND_INTERNAL_RM('D'); new_line;
            jump ReType;
        }
        #Endif; ! TARGET_
        for (i=0 : i<INPUT_BUFFER_LEN : i++) buffer->i = buffer3->i;
        VM_Tokenise(buffer,parse);
		num_words = WordCount(); players_command = 100 + num_words;
    	jump ReParse;
    }

    ! Save the present input in case of an "again" next time

    if (verb_word ~= AGAIN1__WD)
        for (i=0 : i<INPUT_BUFFER_LEN : i++) buffer3->i = buffer->i;

    if (usual_grammar_after == 0) {
        j = verb_wordnum;
        i = RunRoutines(actor, grammar); 
        #Ifdef DEBUG;
        if (parser_trace >= 2 && actor.grammar ~= 0 or NULL)
            print " [Grammar property returned ", i, "]^";
        #Endif; ! DEBUG

        if ((i ~= 0 or 1) && (VM_InvalidDictionaryAddress(i))) {
            usual_grammar_after = verb_wordnum; i=-i;
        }

        if (i == 1) {
            parser_results-->ACTION_PRES = action;
            parser_results-->NO_INPS_PRES = 0;
            parser_results-->INP1_PRES = noun;
            parser_results-->INP2_PRES = second;
            if (noun) parser_results-->NO_INPS_PRES = 1;
            if (second) parser_results-->NO_INPS_PRES = 2;
            rtrue;
        }
        if (i ~= 0) { verb_word = i; wn--; verb_wordnum--; }
        else { wn = verb_wordnum; verb_word = NextWord(); }
    }
    else usual_grammar_after = 0;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter B
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    #Ifdef LanguageIsVerb;
    if (verb_word == 0) {
        i = wn; verb_word = LanguageIsVerb(buffer, parse, verb_wordnum);
        wn = i;
    }
    #Endif; ! LanguageIsVerb

    ! If the first word is not listed as a verb, it must be a direction
    ! or the name of someone to talk to

    if (verb_word == 0 || ((verb_word->#dict_par1) & 1) == 0) {

        ! So is the first word an object contained in the special object "compass"
        ! (i.e., a direction)?  This needs use of NounDomain, a routine which
        ! does the object matching, returning the object number, or 0 if none found,
        ! or REPARSE_CODE if it has restructured the parse table so the whole parse
        ! must be begun again...

        wn = verb_wordnum; indef_mode = false; token_filter = 0; parameters = 0;
        @push actor; @push action; @push action_to_be;
        actor = player; meta = false; action = ##Go; action_to_be = ##Go;
        l = NounDomain(compass, 0, 0);
        @pull action_to_be; @pull action; @pull actor;
        if (l == REPARSE_CODE) jump ReParse;

        ! If it is a direction, send back the results:
        ! action=GoSub, no of arguments=1, argument 1=the direction.

        if ((l~=0) && (l ofclass K3_direction)) {
            parser_results-->ACTION_PRES = ##Go;
            parser_results-->NO_INPS_PRES = 1;
            parser_results-->INP1_PRES = l;
            inferred_go = true;
            jump LookForMore;
        }

    } ! end of first-word-not-a-verb


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter C
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

	! Only check for a comma (a "someone, do something" command) if we are
	! not already in the middle of one.  (This simplification stops us from
	! worrying about "robot, wizard, you are an idiot", telling the robot to
	! tell the wizard that she is an idiot.)
	
	if (actor == player) {
		for (j=2 : j<=num_words : j++) {
			i=NextWord();
			if (i == comma_word) jump Conversation;
		}
	}
	jump NotConversation;
	
	! NextWord nudges the word number wn on by one each time, so we've now
	! advanced past a comma.  (A comma is a word all on its own in the table.)
	
	.Conversation;
	
	j = wn - 1;
	
	! Use NounDomain (in the context of "animate creature") to see if the
	! words make sense as the name of someone held or nearby
	
	wn = 1; lookahead = HELD_TOKEN;
	scope_reason = TALKING_REASON;
	l = NounDomain(player,actors_location,6);
	scope_reason = PARSING_REASON;
	if (l == REPARSE_CODE) jump ReParse;
	if (l == 0) {
		if (verb_word && ((verb_word->#dict_par1) & 1)) jump NotConversation;
		best_etype = MISSINGPERSON_PE; jump GiveError;
	}
	
	.Conversation2;
	
	! The object addressed must at least be "talkable" if not actually "animate"
	! (the distinction allows, for instance, a microphone to be spoken to,
	! without the parser thinking that the microphone is human).
	
	if (l hasnt animate && l hasnt talkable) {
 		best_etype = ANIMALISTEN_PE; noun = l; jump GiveError;
	}
	
	! Check that there aren't any mystery words between the end of the person's
	! name and the comma (eg, throw out "dwarf sdfgsdgs, go north").
	
	if (wn ~= j) {
		if (verb_word && ((verb_word->#dict_par1) & 1)) jump NotConversation;
		best_etype = TOTALK_PE; jump GiveError;
	}
	
	! The player has now successfully named someone.  Adjust "him", "her", "it":
	
	PronounNotice(l);
	
	! Set the global variable "actor", adjust the number of the first word,
	! and begin parsing again from there.
	
	verb_wordnum = j + 1;
	
	! Stop things like "me, again":
	
	if (l == player) {
		wn = verb_wordnum;
		if (NextWordStopped() == AGAIN1__WD or AGAIN2__WD or AGAIN3__WD) {
			best_etype = ANIMAAGAIN_PE;
			jump GiveError;
		}
	}
	
	actor = l;
	actors_location = ScopeCeiling(l);
	#Ifdef DEBUG;
	if (parser_trace >= 1)
		print "[Actor is ", (the) actor, " in ", (name) actors_location, "]^";
	#Endif; ! DEBUG
	jump BeginCommand;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter D
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

	.NotConversation;
	if (verb_word == 0 || ((verb_word->#dict_par1) & 1) == 0) {
		verb_word = UnknownVerb(verb_word);
		if (verb_word ~= 0) jump VerbAccepted;
		best_etype = VERB_PE;
		jump GiveError;
	}
	.VerbAccepted;

    ! We now definitely have a verb, not a direction, whether we got here by the
    ! "take ..." or "person, take ..." method.  Get the meta flag for this verb:

    meta = ((verb_word->#dict_par1) & 2)/2;

    ! You can't order other people to "full score" for you, and so on...

    if (meta == 1 && actor ~= player) {
        best_etype = VERB_PE;
        meta = 0;
        jump GiveError;
    }

    ! Now let i be the corresponding verb number...

    i = DictionaryWordToVerbNum(verb_word);

    ! ...then look up the i-th entry in the verb table, whose address is at word
    ! 7 in the Z-machine (in the header), so as to get the address of the syntax
    ! table for the given verb...

    #Ifdef TARGET_ZCODE;
    syntax = (HDR_STATICMEMORY-->0)-->i;
    #Ifnot; ! TARGET_GLULX
    syntax = (#grammar_table)-->(i+1);
    #Endif; ! TARGET_

    ! ...and then see how many lines (ie, different patterns corresponding to the
    ! same verb) are stored in the parse table...

    num_lines = (syntax->0) - 1;

    ! ...and now go through them all, one by one.
    ! To prevent pronoun_word 0 being misunderstood,

    pronoun_word = NULL; pronoun_obj = NULL;

    #Ifdef DEBUG;
    if (parser_trace >= 1)
    	print "[Parsing for the verb '", (address) verb_word, "' (", num_lines+1, " lines)]^";
    #Endif; ! DEBUG

    best_etype = STUCK_PE; nextbest_etype = STUCK_PE;
    multiflag = false;

    ! "best_etype" is the current failure-to-match error - it is by default
    ! the least informative one, "don't understand that sentence".
    ! "nextbest_etype" remembers the best alternative to having to ask a
    ! scope token for an error message (i.e., the best not counting ASKSCOPE_PE).
    ! multiflag is used here to prevent inappropriate MULTI_PE errors
    ! in addition to its unrelated duties passing information to action routines


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter E
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    line_address = syntax + 1;

    for (line=0 : line<=num_lines : line++) {

        ! Unpack the syntax line from Inform format into three arrays; ensure that
        ! the sequence of tokens ends in an ENDIT_TOKEN.

        line_address = UnpackGrammarLine(line_address);

        #Ifdef DEBUG;
        if (parser_trace >= 1) {
            if (parser_trace >= 2) new_line;
            print "[line ", line; DebugGrammarLine();
            print "]^";
        }
        #Endif; ! DEBUG

        ! We aren't in "not holding" or inferring modes, and haven't entered
        ! any parameters on the line yet, or any special numbers; the multiple
        ! object is still empty.

        inferfrom = 0;
        parameters = 0;
        nsns = 0; special_word = 0;
        multiple_object-->0 = 0;
        multi_context = 0;
        etype = STUCK_PE;

        ! Put the word marker back to just after the verb

        wn = verb_wordnum+1;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter F
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

        advance_warning = -1; indef_mode = false;
        for (i=0,m=false,pcount=0 : line_token-->pcount ~= ENDIT_TOKEN : pcount++) {
            scope_token = 0;

            if (line_ttype-->pcount ~= PREPOSITION_TT) i++;

            if (line_ttype-->pcount == ELEMENTARY_TT) {
                if (line_tdata-->pcount == MULTI_TOKEN) m = true;
                if (line_tdata-->pcount == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN  && i == 1) {
                    ! First non-preposition is "multiexcept" or
                    ! "multiinside", so look ahead.

                    #Ifdef DEBUG;
                    if (parser_trace >= 2) print " [Trying look-ahead]^";
                    #Endif; ! DEBUG

                    ! We need this to be followed by 1 or more prepositions.

                    pcount++;
                    if (line_ttype-->pcount == PREPOSITION_TT) {
                        ! skip ahead to a preposition word in the input
                        do {
                            l = NextWord();
                        } until ((wn > num_words) ||
                                 (l && (l->#dict_par1) & 8 ~= 0));
                        
                        if (wn > num_words) {
                            #Ifdef DEBUG;
                            if (parser_trace >= 2)
                                print " [Look-ahead aborted: prepositions missing]^";
                            #Endif;
                            jump EmptyLine;
                        }
                        
                        do {
                            if (PrepositionChain(l, pcount) ~= -1) {
                                ! advance past the chain
                                if ((line_token-->pcount)->0 & $20 ~= 0) {
                                    pcount++;
                                    while ((line_token-->pcount ~= ENDIT_TOKEN) &&
                                           ((line_token-->pcount)->0 & $10 ~= 0))
                                        pcount++;
                                } else {
                                    pcount++;
                                }
                            } else {
                                ! try to find another preposition word
                                do {
                                    l = NextWord();
                                } until ((wn >= num_words) ||
                                         (l && (l->#dict_par1) & 8 ~= 0));
                                
                                if (l && (l->#dict_par1) & 8) continue;
                                
                                ! lookahead failed
                                #Ifdef DEBUG;
                                if (parser_trace >= 2)
                                    print " [Look-ahead aborted: prepositions don't match]^";
                                #endif;
                                jump LineFailed;
                            }
                            if (wn <= num_words) l = NextWord();
                        } until (line_ttype-->pcount ~= PREPOSITION_TT);
                        
                        .EmptyLine;
                        ! put back the non-preposition we just read
                        wn--;

                        if ((line_ttype-->pcount == ELEMENTARY_TT) &&
                        	(line_tdata-->pcount == NOUN_TOKEN)) {
                            l = Descriptors();  ! skip past THE etc
                            if (l~=0) etype=l;  ! don't allow multiple objects
                        	k = parser_results-->INP1_PRES; @push k; @push parameters;
                        	parameters = 1; parser_results-->INP1_PRES = 0;
                            l = NounDomain(actors_location, actor, NOUN_TOKEN, true);
                            @pull parameters; @pull k; parser_results-->INP1_PRES = k;
                            #Ifdef DEBUG;
                            if (parser_trace >= 2) {
                                print " [Advanced to ~noun~ token: ";
                                if (l == REPARSE_CODE) print "re-parse request]^";
                                else {
                                	if (l == 1) print "but multiple found]^";
                                	if (l == 0) print "error ", etype, "]^";
                                	if (l >= 2) print (the) l, "]^";
                                }
                            }
                            #Endif; ! DEBUG
                            if (l == REPARSE_CODE) jump ReParse;
                            if (l >= 2) advance_warning = l;
                        }
                    }
                    break;
                }
            }
        }

        ! Slightly different line-parsing rules will apply to "take multi", to
        ! prevent "take all" behaving correctly but misleadingly when there's
        ! nothing to take.

        take_all_rule = 0;
        if (m && params_wanted == 1 && action_to_be == ##Take)
            take_all_rule = 1;

        ! And now start again, properly, forearmed or not as the case may be.
        ! As a precaution, we clear all the variables again (they may have been
        ! disturbed by the call to NounDomain, which may have called outside
        ! code, which may have done anything!).

        inferfrom = 0;
        parameters = 0;
        nsns = 0; special_word = 0;
        multiple_object-->0 = 0;
        etype = STUCK_PE;
        wn = verb_wordnum+1;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter G
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

		m = true;
        for (pcount=1 : : pcount++)
            if (line_token-->(pcount-1) == ENDIT_TOKEN) {
            	if (pcount >= 2) {
            		while ((((line_token-->(pcount-2))->0) & $10) ~= 0) pcount--;
            		AnalyseToken(line_token-->(pcount-2));
            		if (found_ttype == PREPOSITION_TT) {
            			l = -1;
            			while (true) {
            				m = NextWordStopped();
            				if (m == -1) break;
            				l = m;
            			}
            			if (PrepositionChain(l, pcount-2) == -1) {
            				m = false;
							#Ifdef DEBUG;
							if (parser_trace >= 2)
								print "[line rejected for not ending with correct preposition]^";
							#Endif; ! DEBUG
						} else m = true;
	           		}
            	}
            	break;
            }
		wn = verb_wordnum+1;

		if (m) for (pcount=1 : : pcount++) {
            pattern-->pcount = PATTERN_NULL; scope_token = 0;

            token = line_token-->(pcount-1);
            lookahead = line_token-->pcount;

            #Ifdef DEBUG;
            if (parser_trace >= 2)
                print " [line ", line, " token ", pcount, " word ", wn, " : ", (DebugToken) token,
                  "]^";
            #Endif; ! DEBUG

            if (token ~= ENDIT_TOKEN) {
                scope_reason = PARSING_REASON;
                AnalyseToken(token);

                l = ParseToken(found_ttype, found_tdata, pcount-1, token);
                while ((l >= GPR_NOUN) && (l < -1)) l = ParseToken(ELEMENTARY_TT, l + 256);
                scope_reason = PARSING_REASON;

                if (l == GPR_PREPOSITION) {
                    if (found_ttype~=PREPOSITION_TT && (found_ttype~=ELEMENTARY_TT ||
                        found_tdata~=TOPIC_TOKEN)) params_wanted--;
                    l = true;
                }
                else
                    if (l < 0) l = false;
                    else
                        if (l ~= GPR_REPARSE) {
                            if (l == GPR_NUMBER) {
                                if (nsns == 0) special_number1 = parsed_number;
                                else special_number2 = parsed_number;
                                nsns++; l = 1;
                            }
                            if (l == GPR_MULTIPLE) l = 0;
                            parser_results-->(parameters+INP1_PRES) = l;
                            parameters++;
                            pattern-->pcount = l;
                            l = true;
                        }

                #Ifdef DEBUG;
                if (parser_trace >= 3) {
                    print "  [token resulted in ";
                    if (l == REPARSE_CODE) print "re-parse request]^";
                    if (l == 0) print "failure with error type ", etype, "]^";
                    if (l == 1) print "success]^";
                }
                #Endif; ! DEBUG

                if (l == REPARSE_CODE) jump ReParse;
                if (l == false) break;
            }
            else {

                ! If the player has entered enough already but there's still
                ! text to wade through: store the pattern away so as to be able to produce
                ! a decent error message if this turns out to be the best we ever manage,
                ! and in the mean time give up on this line

                ! However, if the superfluous text begins with a comma or "then" then
                ! take that to be the start of another instruction

                if (wn <= num_words) {
                    l = NextWord();
                    if (l == THEN1__WD or THEN2__WD or THEN3__WD or comma_word) {
                        held_back_mode = true; hb_wn = wn-1;
                    } else {
                        for (m=0 : m<32 : m++) pattern2-->m = pattern-->m;
                        pcount2 = pcount;
                        etype = UPTO_PE;
                        break;
                    }
                }

                ! Now, we may need to revise the multiple object because of the single one
                ! we now know (but didn't when the list was drawn up).

                if (parameters >= 1) {
                	if (parser_results-->INP1_PRES == 0) {
                	    l = ReviseMulti(parser_results-->INP2_PRES);
                	    if (l ~= 0) { etype = l; parser_results-->ACTION_PRES = action_to_be; break; }
                	}
                }
                if (parameters >= 2) {
                	if (parser_results-->INP2_PRES == 0) {
            	        l = ReviseMulti(parser_results-->INP1_PRES);
                	    if (l ~= 0) { etype = l; break; }
                	} else {
                		k = parser_results-->INP1_PRES; l = parser_results-->INP2_PRES;
                		if (k && l) {
	                 		if ((multi_context==MULTIEXCEPT_TOKEN && k == l) ||
	                			((multi_context==MULTIINSIDE_TOKEN && k notin l && l notin k))) {
                				best_etype = NOTHING_PE;
                				parser_results-->ACTION_PRES = action_to_be; jump GiveError;
                			}
                		}
                	}
                }

                ! To trap the case of "take all" inferring only "yourself" when absolutely
                ! nothing else is in the vicinity...

                if (take_all_rule == 2 && parser_results-->INP1_PRES == actor) {
                    best_etype = NOTHING_PE;
                    jump GiveError;
                }

                #Ifdef DEBUG;
                if (parser_trace >= 1) print "[Line successfully parsed]^";
                #Endif; ! DEBUG

                ! The line has successfully matched the text.  Declare the input error-free...

                oops_from = 0;

                ! ...explain any inferences made (using the pattern)...

                if (inferfrom ~= 0) {
                	PrintInferredCommand(inferfrom);
                    ClearParagraphing(20);
                }

                ! ...copy the action number, and the number of parameters...

                parser_results-->ACTION_PRES = action_to_be;
                parser_results-->NO_INPS_PRES = parameters;

                ! ...reverse first and second parameters if need be...

                if (action_reversed && parameters == 2) {
                    i = parser_results-->INP1_PRES;
                    parser_results-->INP1_PRES = parser_results-->INP2_PRES;
                    parser_results-->INP2_PRES = i;
                    if (nsns == 2) {
                        i = special_number1; special_number1 = special_number2;
                        special_number2 = i;
                    }
                }

                ! ...and to reset "it"-style objects to the first of these parameters, if
                ! there is one (and it really is an object)...

                if (parameters > 0 && parser_results-->INP1_PRES >= 2)
                    PronounNotice(parser_results-->INP1_PRES);

                ! ...and return from the parser altogether, having successfully matched
                ! a line.

                if (held_back_mode) {
                    wn=hb_wn;
                    jump LookForMore;
                }
                rtrue;

            } ! end of if(token ~= ENDIT_TOKEN) else
        } ! end of for(pcount++)

        .LineFailed;
        ! The line has failed to match.
        ! We continue the outer "for" loop, trying the next line in the grammar.

        if (etype > best_etype) best_etype = etype;
        if (etype ~= ASKSCOPE_PE && etype > nextbest_etype) nextbest_etype = etype;

        ! ...unless the line was something like "take all" which failed because
        ! nothing matched the "all", in which case we stop and give an error now.

        if (take_all_rule == 2 && etype==NOTHING_PE) break;

    } ! end of for(line++)

    ! The grammar is exhausted: every line has failed to match.


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter H
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

  .GiveError;

    etype = best_etype;
    if (actor ~= player) {
        if (usual_grammar_after ~= 0) {
            verb_wordnum = usual_grammar_after;
            jump AlmostReParse;
        }
        wn = verb_wordnum;
        special_word = NextWord();
        if (special_word == comma_word) {
            special_word = NextWord();
            verb_wordnum++;
        }
        parser_results-->ACTION_PRES = ##Answer;
        parser_results-->NO_INPS_PRES = 2;
        parser_results-->INP1_PRES = actor;
        parser_results-->INP2_PRES = 1; special_number1 = special_word;
        actor = player;
        consult_from = verb_wordnum; consult_words = num_words-consult_from+1;
        rtrue;
    }


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter I
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! If the player was the actor (eg, in "take dfghh") the error must be printed,
    ! and fresh input called for.  In three cases the oops word must be jiggled.

    if ((etype ofclass Routine) || (etype ofclass String)) {
        if (ParserError(etype) ~= 0) jump ReType;
    } else {
		if (verb_wordnum == 0 && etype == CANTSEE_PE) etype = VERB_PE;
		players_command = 100 + WordCount(); ! The snippet variable "player's command"
        BeginActivity(PRINTING_A_PARSER_ERROR_ACT);
        if (ForActivity(PRINTING_A_PARSER_ERROR_ACT)) jump SkipParserError;
    }
    pronoun_word = pronoun__word; pronoun_obj = pronoun__obj;

    if (etype == STUCK_PE) {    PARSER_ERROR_INTERNAL_RM('A'); new_line; oops_from = 1; }
    if (etype == UPTO_PE) {
    	if (inferred_go) PARSER_ERROR_INTERNAL_RM('C');
    	else PARSER_ERROR_INTERNAL_RM('B');
        for (m=0 : m<32 : m++) pattern-->m = pattern2-->m;
        pcount = pcount2; PrintCommand(0);
        print ".^";
    }
    if (etype == NUMBER_PE) {   PARSER_ERROR_INTERNAL_RM('D'); new_line; }
    if (etype == CANTSEE_PE) {  PARSER_ERROR_INTERNAL_RM('E'); new_line; oops_from=saved_oops; }
    if (etype == TOOLIT_PE) {   PARSER_ERROR_INTERNAL_RM('F'); new_line; }
    if (etype == NOTHELD_PE) {  PARSER_ERROR_INTERNAL_RM('G'); new_line; oops_from=saved_oops; }
    if (etype == MULTI_PE) {    PARSER_ERROR_INTERNAL_RM('H'); new_line; }
    if (etype == MMULTI_PE) {   PARSER_ERROR_INTERNAL_RM('I'); new_line; }
    if (etype == VAGUE_PE) {    PARSER_ERROR_INTERNAL_RM('J'); new_line; }
    if (etype == ITGONE_PE) {
        if (pronoun_obj == NULL) { PARSER_ERROR_INTERNAL_RM('J'); new_line; }
        else { PARSER_ERROR_INTERNAL_RM('K', noun); new_line; }
    }
    if (etype == EXCEPT_PE) {   PARSER_ERROR_INTERNAL_RM('L'); new_line; }
    if (etype == ANIMA_PE) {    PARSER_ERROR_INTERNAL_RM('M'); new_line; }
    if (etype == VERB_PE) {     PARSER_ERROR_INTERNAL_RM('N'); new_line; }
    if (etype == SCENERY_PE) {  PARSER_ERROR_INTERNAL_RM('O'); new_line; }
    if (etype == JUNKAFTER_PE) {  PARSER_ERROR_INTERNAL_RM('P'); new_line; }
    if (etype == TOOFEW_PE) {  PARSER_ERROR_INTERNAL_RM('Q', multi_had); new_line; }
    if (etype == NOTHING_PE) {
    	if (parser_results-->ACTION_PRES == ##Remove &&
        	parser_results-->INP2_PRES ofclass Object) {
        	noun = parser_results-->INP2_PRES; ! ensure valid for messages
            if (noun has animate) { PARSER_N_ERROR_INTERNAL_RM('C', noun); new_line; }
            else if (noun hasnt container or supporter) { PARSER_N_ERROR_INTERNAL_RM('D', noun); new_line; }
            else if (noun has container && noun hasnt open)  { PARSER_N_ERROR_INTERNAL_RM('E', noun); new_line; }
            else if (children(noun)==0) { PARSER_N_ERROR_INTERNAL_RM('F', noun); new_line; }
            else parser_results-->ACTION_PRES = 0;
        }
        if (parser_results-->ACTION_PRES ~= ##Remove) {
            if (multi_wanted==100) { PARSER_N_ERROR_INTERNAL_RM('A'); new_line; }
            else                  {  PARSER_N_ERROR_INTERNAL_RM('B'); new_line; }
        }
    }
    if (etype == NOTINCONTEXT_PE) { PARSER_ERROR_INTERNAL_RM('R'); new_line; }
    if (etype == ANIMAAGAIN_PE) { PARSER_ERROR_INTERNAL_RM('S'); new_line; }
    if (etype == COMMABEGIN_PE) { PARSER_ERROR_INTERNAL_RM('T'); new_line; }
    if (etype == MISSINGPERSON_PE) { PARSER_ERROR_INTERNAL_RM('U'); new_line; }
    if (etype == ANIMALISTEN_PE) { PARSER_ERROR_INTERNAL_RM('V', noun); new_line; }
    if (etype == TOTALK_PE) { PARSER_ERROR_INTERNAL_RM('W'); new_line; }
    if (etype == ASKSCOPE_PE) {
        scope_stage = 3;
        if (indirect(scope_error) == -1) {
            best_etype = nextbest_etype;
            if (~~((etype ofclass Routine) || (etype ofclass String)))
            	EndActivity(PRINTING_A_PARSER_ERROR_ACT);
            jump GiveError;
        }
    }

    .SkipParserError;
    if ((etype ofclass Routine) || (etype ofclass String)) jump ReType;
    say__p = 1;
    EndActivity(PRINTING_A_PARSER_ERROR_ACT);


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter J
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! And go (almost) right back to square one...

    jump ReType;

    ! ...being careful not to go all the way back, to avoid infinite repetition
    ! of a deferred command causing an error.


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parser Letter K
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! At this point, the return value is all prepared, and we are only looking
    ! to see if there is a "then" followed by subsequent instruction(s).

  .LookForMore;

    if (wn > num_words) rtrue;

    i = NextWord();
    if (i == THEN1__WD or THEN2__WD or THEN3__WD or comma_word) {
        if (wn > num_words) {
           held_back_mode = false;
           return;
        }
        hb_wn = wn;
        held_back_mode = true;
       return;
    }
    best_etype = UPTO_PE;
    jump GiveError;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: End of Parser Proper
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

]; ! end of Parser__parse


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Internal Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PARSER_ERROR_INTERNAL_R; ];
[ PARSER_N_ERROR_INTERNAL_R; ];
[ PARSER_COMMAND_INTERNAL_R; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ParseTokenStopped x y;
	if (wn>WordCount()) return GPR_FAIL;
	return ParseToken(x,y);
];

Global parsetoken_nesting = 0;
[ ParseToken given_ttype given_tdata token_n token  i t rv;
	if (parsetoken_nesting > 0) {
		! save match globals
		@push match_from; @push token_filter; @push match_length;
		@push number_of_classes; @push oops_from;
		for (i=0: i<number_matched: i++) {
			t = match_list-->i; @push t;
			t = match_classes-->i; @push t;
			t = match_scores-->i; @push t;
		}
		@push number_matched;
	 }

	parsetoken_nesting++;
	rv = ParseToken__(given_ttype, given_tdata, token_n, token);
	parsetoken_nesting--;

	if (parsetoken_nesting > 0) {
		! restore match globals
		@pull number_matched;
		for (i=number_matched-1: i>=0: i--) {
 			@pull t; match_scores-->i = t;
			@pull t; match_classes-->i = t;
			@pull t; match_list-->i = t;
   		}
		@pull oops_from; @pull number_of_classes;
		@pull match_length; @pull token_filter; @pull match_from;
	}
	return rv;
];

[ ParseToken__ given_ttype given_tdata token_n token
	l o i j k and_parity single_object desc_wn many_flag
	token_allows_multiple prev_indef_wanted;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token Letter A
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    token_filter = 0;
    parser_inflection = name;

    switch (given_ttype) {
      ELEMENTARY_TT:
        switch (given_tdata) {
          SPECIAL_TOKEN:
            l = TryNumber(wn);
            special_word = NextWord();
            #Ifdef DEBUG;
            if (l ~= -1000)
                if (parser_trace >= 3) print "  [Read special as the number ", l, "]^";
            #Endif; ! DEBUG
            if (l == -1000) {
                #Ifdef DEBUG;
                if (parser_trace >= 3) print "  [Read special word at word number ", wn, "]^";
                #Endif; ! DEBUG
                l = special_word;
            }
            parsed_number = l;
            return GPR_NUMBER;

          NUMBER_TOKEN:
            l=TryNumber(wn++);
            if (l == -1000) {
                etype = NUMBER_PE;
                return GPR_FAIL;
            }
            #Ifdef DEBUG;
            if (parser_trace>=3) print "  [Read number as ", l, "]^";
            #Endif; ! DEBUG
            parsed_number = l;
            return GPR_NUMBER;

          CREATURE_TOKEN:
            if (action_to_be == ##Answer or ##Ask or ##AskFor or ##Tell)
                scope_reason = TALKING_REASON;

          TOPIC_TOKEN:
            consult_from = wn;
            if ((line_ttype-->(token_n+1) ~= PREPOSITION_TT) &&
               (line_token-->(token_n+1) ~= ENDIT_TOKEN)) {
               	RunTimeProblem(RTP_TEXTTOKENTOOHARD);
               	return GPR_PREPOSITION;
        	}
            do o = NextWordStopped();
            until (o == -1 || PrepositionChain(o, token_n+1) ~= -1);
            wn--;
            consult_words = wn-consult_from;
            if (consult_words == 0) return GPR_FAIL;
            if (action_to_be == ##Ask or ##Answer or ##Tell) {
                o = wn; wn = consult_from; parsed_number = NextWord();
                wn = o; return 1;
            }
            if (o==-1 && (line_ttype-->(token_n+1) == PREPOSITION_TT))
                return GPR_FAIL;    ! don't infer if required preposition is absent
            return GPR_PREPOSITION;
        }

      PREPOSITION_TT:
        ! Is it an unnecessary alternative preposition, when a previous choice
        ! has already been matched?
        if ((token->0) & $10) return GPR_PREPOSITION;

        ! If we've run out of the player's input, but still have parameters to
        ! specify, we go into "infer" mode, remembering where we are and the
        ! preposition we are inferring...

        if (wn > num_words) {
            if (inferfrom==0 && parameters<params_wanted) {
                inferfrom = pcount; inferword = token;
                pattern-->pcount = REPARSE_CODE + VM_DictionaryAddressToNumber(given_tdata);
            }

            ! If we are not inferring, then the line is wrong...

            if (inferfrom == 0) return -1;

            ! If not, then the line is right but we mark in the preposition...

            pattern-->pcount = REPARSE_CODE + VM_DictionaryAddressToNumber(given_tdata);
            return GPR_PREPOSITION;
        }

        o = NextWord();

        pattern-->pcount = REPARSE_CODE + VM_DictionaryAddressToNumber(o);

        ! Whereas, if the player has typed something here, see if it is the
        ! required preposition... if it's wrong, the line must be wrong,
        ! but if it's right, the token is passed (jump to finish this token).

        if (o == given_tdata) return GPR_PREPOSITION;
        if (PrepositionChain(o, token_n) ~= -1) return GPR_PREPOSITION;
        return -1;

      GPR_TT:
        l = indirect(given_tdata);
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Outside parsing routine returned ", l, "]^";
        #Endif; ! DEBUG
        return l;

      SCOPE_TT:
        scope_token = given_tdata;
        scope_stage = 1;
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Scope routine called at stage 1]^";
        #Endif; ! DEBUG
        l = indirect(scope_token);
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Scope routine returned multiple-flag of ", l, "]^";
        #Endif; ! DEBUG
        if (l == 1) given_tdata = MULTI_TOKEN; else given_tdata = NOUN_TOKEN;

      ATTR_FILTER_TT:
        token_filter = 1 + given_tdata;
        given_tdata = NOUN_TOKEN;

      ROUTINE_FILTER_TT:
        token_filter = given_tdata;
        given_tdata = NOUN_TOKEN;

    } ! end of switch(given_ttype)

    token = given_tdata;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token Letter B
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! There are now three possible ways we can be here:
    !     parsing an elementary token other than "special" or "number";
    !     parsing a scope token;
    !     parsing a noun-filter token (either by routine or attribute).
    !
    ! In each case, token holds the type of elementary parse to
    ! perform in matching one or more objects, and
    ! token_filter is 0 (default), an attribute + 1 for an attribute filter
    ! or a routine address for a routine filter.

    token_allows_multiple = false;
    if (token == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)
        token_allows_multiple = true;

    many_flag = false; and_parity = true; dont_infer = false;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token Letter C
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! We expect to find a list of objects next in what the player's typed.

  .ObjectList;

    #Ifdef DEBUG;
    if (parser_trace >= 3) print "  [Object list from word ", wn, "]^";
    #Endif; ! DEBUG

    ! Take an advance look at the next word: if it's "it" or "them", and these
    ! are unset, set the appropriate error number and give up on the line
    ! (if not, these are still parsed in the usual way - it is not assumed
    ! that they still refer to something in scope)

    o = NextWord(); wn--;

    pronoun_word = NULL; pronoun_obj = NULL;
    l = PronounValue(o);
    if (l ~= 0) {
        pronoun_word = o; pronoun_obj = l;
        if (l == NULL) {
            ! Don't assume this is a use of an unset pronoun until the
            ! descriptors have been checked, because it might be an
            ! article (or some such) instead

            for (l=1 : l<=LanguageDescriptors-->0 : l=l+4)
                if (o == LanguageDescriptors-->l) jump AssumeDescriptor;
            pronoun__word = pronoun_word; pronoun__obj = pronoun_obj;
            etype = VAGUE_PE;
            if (parser_trace >= 3) print "  [Stop: unset pronoun]^";
            return GPR_FAIL;
        }
    }

  .AssumeDescriptor;

    if (o == ME1__WD or ME2__WD or ME3__WD) { pronoun_word = o; pronoun_obj = player; }

    allow_plurals = true; desc_wn = wn;

  .TryAgain;

    ! First, we parse any descriptive words (like "the", "five" or "every"):
    l = Descriptors(token_allows_multiple);
    if (l ~= 0) { etype = l; return 0; }

  .TryAgain2;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token Letter D
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! This is an actual specified object, and is therefore where a typing error
    ! is most likely to occur, so we set:

    oops_from = wn;

    ! So, two cases.  Case 1: token not equal to "held" (so, no implicit takes)
    ! but we may well be dealing with multiple objects

    ! In either case below we use NounDomain, giving it the token number as
    ! context, and two places to look: among the actor's possessions, and in the
    ! present location.  (Note that the order depends on which is likeliest.)

    if (token ~= HELD_TOKEN) {
        i = multiple_object-->0;
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Calling NounDomain on location and actor]^";
        #Endif; ! DEBUG
        l = NounDomain(actors_location, actor, token);
        if (l == REPARSE_CODE) return l;                  ! Reparse after Q&A
        if (indef_wanted == INDEF_ALL_WANTED && l == 0 && number_matched == 0)
            l = 1;  ! ReviseMulti if TAKE ALL FROM empty container

        if (token_allows_multiple && ~~multiflag) {
            if (best_etype==MULTI_PE) best_etype=STUCK_PE;
            multiflag = true;
        }
        if (l == 0) {
            if (indef_possambig) {
                ResetDescriptors();
                wn = desc_wn;
                jump TryAgain2;
            }
            if (etype == MULTI_PE && multiflag) etype = STUCK_PE;
            etype=CantSee();
            jump FailToken;
        } ! Choose best error

        #Ifdef DEBUG;
        if (parser_trace >= 3) {
            if (l > 1) print "  [ND returned ", (the) l, "]^";
            else {
                print "  [ND appended to the multiple object list:^";
                k = multiple_object-->0;
                for (j=i+1 : j<=k : j++)
                    print "  Entry ", j, ": ", (The) multiple_object-->j,
                          " (", multiple_object-->j, ")^";
                print "  List now has size ", k, "]^";
            }
        }
        #Endif; ! DEBUG

        if (l == 1) {
            if (~~many_flag) many_flag = true;
            else {                                ! Merge with earlier ones
                k = multiple_object-->0;            ! (with either parity)
                multiple_object-->0 = i;
                for (j=i+1 : j<=k : j++) {
                    if (and_parity) MultiAdd(multiple_object-->j);
                    else            MultiSub(multiple_object-->j);
                }
                #Ifdef DEBUG;
                if (parser_trace >= 3)
                	print "  [Merging ", k-i, " new objects to the ", i, " old ones]^";
                #Endif; ! DEBUG
            }
        }
        else {
            ! A single object was indeed found

            if (match_length == 0 && indef_possambig) {
                ! So the answer had to be inferred from no textual data,
                ! and we know that there was an ambiguity in the descriptor
                ! stage (such as a word which could be a pronoun being
                ! parsed as an article or possessive).  It's worth having
                ! another go.

                ResetDescriptors();
                wn = desc_wn;
                jump TryAgain2;
            }

            if ((token == CREATURE_TOKEN) && (CreatureTest(l) == 0)) {
                etype = ANIMA_PE;
                jump FailToken;
            } !  Animation is required

            if (~~many_flag) single_object = l;
            else {
                if (and_parity) MultiAdd(l); else MultiSub(l);
                #Ifdef DEBUG;
                if (parser_trace >= 3) print "  [Combining ", (the) l, " with list]^";
                #Endif; ! DEBUG
            }
        }
    }

    else {

    ! Case 2: token is "held" (which fortunately can't take multiple objects)
    ! and may generate an implicit take

        l = NounDomain(actor,actors_location,token);       ! Same as above...
        if (l == REPARSE_CODE) return l;
        if (l == 0) {
            if (indef_possambig) {
                ResetDescriptors();
                wn = desc_wn;
                jump TryAgain2;
            }
            etype = CantSee(); jump FailToken;            ! Choose best error
        }

        ! ...until it produces something not held by the actor.  Then an implicit
        ! take must be tried.  If this is already happening anyway, things are too
        ! confused and we have to give up (but saving the oops marker so as to get
        ! it on the right word afterwards).
        ! The point of this last rule is that a sequence like
        !
        !     > read newspaper
        !     (taking the newspaper first)
        !     The dwarf unexpectedly prevents you from taking the newspaper!
        !
        ! should not be allowed to go into an infinite repeat - read becomes
        ! take then read, but take has no effect, so read becomes take then read...
        ! Anyway for now all we do is record the number of the object to take.

        o = parent(l);
        if (o ~= actor) {
            #Ifdef DEBUG;
            if (parser_trace >= 3) print "  [Allowing object ", (the) l, " for now]^";
            #Endif; ! DEBUG
        }
        single_object = l;
    } ! end of if (token ~= HELD_TOKEN) else

    ! The following moves the word marker to just past the named object...
	
!	if (match_from ~= oops_from) print match_from, " vs ", oops_from, "^";

!    wn = oops_from + match_length;
    wn = match_from + match_length;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token Letter E
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! Object(s) specified now: is that the end of the list, or have we reached
    ! "and", "but" and so on?  If so, create a multiple-object list if we
    ! haven't already (and are allowed to).

  .NextInList;

    o = NextWord();

    if (o == AND1__WD or AND2__WD or AND3__WD or BUT1__WD or BUT2__WD or BUT3__WD or comma_word) {

        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Read connective '", (address) o, "']^";
        #Endif; ! DEBUG

        if (~~token_allows_multiple) {
            if (multiflag) jump PassToken; ! give UPTO_PE error
            etype=MULTI_PE;
            jump FailToken;
        }

        if (o == BUT1__WD or BUT2__WD or BUT3__WD) and_parity = 1-and_parity;

        if (~~many_flag) {
            multiple_object-->0 = 1;
            multiple_object-->1 = single_object;
            many_flag = true;
            #Ifdef DEBUG;
            if (parser_trace >= 3) print "  [Making new list from ", (the) single_object, "]^";
            #Endif; ! DEBUG
        }
        dont_infer = true; inferfrom=0;           ! Don't print (inferences)
        jump ObjectList;                          ! And back around
    }

    wn--;   ! Word marker back to first not-understood word


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parse Token Letter F
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

    ! Happy or unhappy endings:

  .PassToken;
    if (many_flag) {
        single_object = GPR_MULTIPLE;
        multi_context = token;
    }
    else {
        if (indef_mode == 1 && indef_type & PLURAL_BIT ~= 0) {
		  	if (token == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN) multi_context = token;
            if (indef_wanted < INDEF_ALL_WANTED && indef_wanted > 1) {
                multi_had = 1; multi_wanted = indef_wanted;
                etype = TOOFEW_PE;
                jump FailToken;
            }
        }
    }
    return single_object;

  .FailToken;

    ! If we were only guessing about it being a plural, try again but only
    ! allowing singulars (so that words like "six" are not swallowed up as
    ! Descriptors)

    if (allow_plurals && indef_guess_p == 1) {
        #Ifdef DEBUG;
        if (parser_trace >= 4) print "   [Retrying singulars after failure ", etype, "]^";
        #Endif;
        prev_indef_wanted = indef_wanted;
        allow_plurals = false;
        wn = desc_wn;
        jump TryAgain;
    }

    if ((indef_wanted > 0 || prev_indef_wanted > 0) && (~~multiflag)) etype = MULTI_PE;

    return GPR_FAIL;

]; ! end of ParseToken__


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Descriptors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant OTHER_BIT  =   1;     !  These will be used in Adjudicate()
Constant MY_BIT     =   2;     !  to disambiguate choices
Constant THAT_BIT   =   4;
Constant PLURAL_BIT =   8;
Constant LIT_BIT    =  16;
Constant UNLIT_BIT  =  32;

[ ResetDescriptors;
    indef_mode = 0; indef_type = 0; indef_wanted = 0; indef_guess_p = 0;
    indef_possambig = false;
    indef_owner = nothing;
    indef_cases = $$111111111111;
    indef_nspec_at = 0;
];

[ ArticleDescriptors  o x flag cto type n;
    if (wn > num_words) return 0;

    for (flag=true : flag :) {
        o = NextWordStopped(); flag = false;

       for (x=1 : x<=LanguageDescriptors-->0 : x=x+4)
            if (o == LanguageDescriptors-->x) {
                type = LanguageDescriptors-->(x+2);
                if (type == DEFART_PK or INDEFART_PK) flag = true;
            }
    }
    wn--;
    return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parsing Descriptors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Descriptors  o x flag cto type n;
    ResetDescriptors();
    if (wn > num_words) return 0;

    for (flag=true : flag :) {
        o = NextWordStopped(); flag = false;

       for (x=1 : x<=LanguageDescriptors-->0 : x=x+4)
            if (o == LanguageDescriptors-->x) {
                flag = true;
                type = LanguageDescriptors-->(x+2);
                if (type ~= DEFART_PK) indef_mode = true;
                indef_possambig = true;
                indef_cases = indef_cases & (LanguageDescriptors-->(x+1));

                if (type == POSSESS_PK) {
                    cto = LanguageDescriptors-->(x+3);
                    switch (cto) {
                      0: indef_type = indef_type | MY_BIT;
                      1: indef_type = indef_type | THAT_BIT;
                      default:
                        indef_owner = PronounValue(cto);
                        if (indef_owner == NULL) indef_owner = InformParser;
                    }
                }

                if (type == light)  indef_type = indef_type | LIT_BIT;
                if (type == -light) indef_type = indef_type | UNLIT_BIT;
            }

        if (o == OTHER1__WD or OTHER2__WD or OTHER3__WD) {
            indef_mode = 1; flag = 1;
            indef_type = indef_type | OTHER_BIT;
        }
        if (o == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD) {
            indef_mode = 1; flag = 1; indef_wanted = INDEF_ALL_WANTED;
            if (take_all_rule == 1) take_all_rule = 2;
            indef_type = indef_type | PLURAL_BIT;
        }
        if (allow_plurals) {
        	if (NextWordStopped() ~= -1 or THEN1__WD) { wn--; n = TryNumber(wn-1); } else { n=0; wn--; }
            if (n == 1) { indef_mode = 1; flag = 1; }
            if (n > 1) {
                indef_guess_p = 1;
                indef_mode = 1; flag = 1; indef_wanted = n;
                indef_nspec_at = wn-1;
                indef_type = indef_type | PLURAL_BIT;
            }
        }
        if (flag == 1 && NextWordStopped() ~= OF1__WD or OF2__WD or OF3__WD or OF4__WD)
            wn--;  ! Skip 'of' after these
    }
    wn--;
    return 0;
];

[ SafeSkipDescriptors;
	@push indef_mode; @push indef_type; @push indef_wanted;
	@push indef_guess_p; @push indef_possambig; @push indef_owner;
	@push indef_cases; @push indef_nspec_at;
	
	Descriptors();
	
	@pull indef_nspec_at; @pull indef_cases;
	@pull indef_owner; @pull indef_possambig; @pull indef_guess_p;
	@pull indef_wanted; @pull indef_type; @pull indef_mode;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Preposition Chain
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrepositionChain wd index;
    if (line_tdata-->index == wd) return wd;
    if ((line_token-->index)->0 & $20 == 0) return -1;
    do {
        if (line_tdata-->index == wd) return wd;
        index++;
    } until ((line_token-->index == ENDIT_TOKEN) || (((line_token-->index)->0 & $10) == 0));
    return -1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Creature
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CreatureTest obj;
    if (obj has animate) rtrue;
    if (obj hasnt talkable) rfalse;
    if (action_to_be == ##Ask or ##Answer or ##Tell or ##AskFor) rtrue;
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Noun Domain
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NounDomain domain1 domain2 context dont_ask
	first_word i j k l answer_words marker;
    #Ifdef DEBUG;
    if (parser_trace >= 4) {
        print "   [NounDomain called at word ", wn, "^";
        print "   ";
        if (indef_mode) {
            print "seeking indefinite object: ";
            if (indef_type & OTHER_BIT)  print "other ";
            if (indef_type & MY_BIT)     print "my ";
            if (indef_type & THAT_BIT)   print "that ";
            if (indef_type & PLURAL_BIT) print "plural ";
            if (indef_type & LIT_BIT)    print "lit ";
            if (indef_type & UNLIT_BIT)  print "unlit ";
            if (indef_owner ~= 0) print "owner:", (name) indef_owner;
            new_line;
            print "   number wanted: ";
            if (indef_wanted == INDEF_ALL_WANTED) print "all"; else print indef_wanted;
            new_line;
            print "   most likely GNAs of names: ", indef_cases, "^";
        }
        else print "seeking definite object^";
    }
    #Endif; ! DEBUG

    match_length = 0; number_matched = 0; match_from = wn;

    SearchScope(domain1, domain2, context);

    #Ifdef DEBUG;
    if (parser_trace >= 4) print "   [ND made ", number_matched, " matches]^";
    #Endif; ! DEBUG

    wn = match_from+match_length;

    ! If nothing worked at all, leave with the word marker skipped past the
    ! first unmatched word...

    if (number_matched == 0) { wn++; rfalse; }

    ! Suppose that there really were some words being parsed (i.e., we did
    ! not just infer).  If so, and if there was only one match, it must be
    ! right and we return it...

    if (match_from <= num_words) {
        if (number_matched == 1) {
            i=match_list-->0;
            return i;
        }

        ! ...now suppose that there was more typing to come, i.e. suppose that
        ! the user entered something beyond this noun.  If nothing ought to follow,
        ! then there must be a mistake, (unless what does follow is just a full
        ! stop, and or comma)

        if (wn <= num_words) {
            i = NextWord(); wn--;
            if (i ~=  AND1__WD or AND2__WD or AND3__WD or comma_word
                   or THEN1__WD or THEN2__WD or THEN3__WD
                   or BUT1__WD or BUT2__WD or BUT3__WD) {
                if (lookahead == ENDIT_TOKEN) rfalse;
            }
        }
    }

    ! Now look for a good choice, if there's more than one choice...

    number_of_classes = 0;

    if (number_matched == 1) {
    	i = match_list-->0;
		if (indef_mode == 1 && indef_type & PLURAL_BIT ~= 0) {
			if (context == MULTI_TOKEN or MULTIHELD_TOKEN or
				MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN or
				NOUN_TOKEN or HELD_TOKEN or CREATURE_TOKEN) {
				BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, i);
				if ((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, i)) &&
					(RulebookFailed())) rfalse;
				EndActivity(DECIDING_WHETHER_ALL_INC_ACT, i);
			}
		}
    }
    if (number_matched > 1) {
		i = true;
	    if (number_matched > 1)
	    	for (j=0 : j<number_matched-1 : j++)
				if (Identical(match_list-->j, match_list-->(j+1)) == false)
					i = false;
		if (i) dont_infer = true;
        i = Adjudicate(context);
        if (i == -1) rfalse;
        if (i == 1) rtrue;       !  Adjudicate has made a multiple
                             !  object, and we pass it on
    }

    ! If i is non-zero here, one of two things is happening: either
    ! (a) an inference has been successfully made that object i is
    !     the intended one from the user's specification, or
    ! (b) the user finished typing some time ago, but we've decided
    !     on i because it's the only possible choice.
    ! In either case we have to keep the pattern up to date,
    ! note that an inference has been made and return.
    ! (Except, we don't note which of a pile of identical objects.)

    if (i ~= 0) {
    	if (dont_infer) return i;
        if (inferfrom == 0) inferfrom=pcount;
        pattern-->pcount = i;
        return i;
    }

	if (dont_ask) return match_list-->0;

    ! If we get here, there was no obvious choice of object to make.  If in
    ! fact we've already gone past the end of the player's typing (which
    ! means the match list must contain every object in scope, regardless
    ! of its name), then it's foolish to give an enormous list to choose
    ! from - instead we go and ask a more suitable question...

    if (match_from > num_words) jump Incomplete;

    ! Now we print up the question, using the equivalence classes as worked
    ! out by Adjudicate() so as not to repeat ourselves on plural objects...

	BeginActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);
	if (ForActivity(ASKING_WHICH_DO_YOU_MEAN_ACT)) jump SkipWhichQuestion;
	j = 1; marker = 0;
	for (i=1 : i<=number_of_classes : i++) {
		while (((match_classes-->marker) ~= i) && ((match_classes-->marker) ~= -i))
			marker++;
		if (match_list-->marker hasnt animate) j = 0;
	}
	if (j) PARSER_CLARIF_INTERNAL_RM('A');
	else PARSER_CLARIF_INTERNAL_RM('B');

    j = number_of_classes; marker = 0;
    for (i=1 : i<=number_of_classes : i++) {
        while (((match_classes-->marker) ~= i) && ((match_classes-->marker) ~= -i)) marker++;
        k = match_list-->marker;

        if (match_classes-->marker > 0) print (the) k; else print (a) k;

        if (i < j-1)  print ", ";
        if (i == j-1) {
			#Ifdef SERIAL_COMMA;
			if (j ~= 2) print ",";
        	#Endif; ! SERIAL_COMMA
        	PARSER_CLARIF_INTERNAL_RM('H');
        }
    }
    print "?^";

	.SkipWhichQuestion; EndActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);

    ! ...and get an answer:

  .WhichOne;
    #Ifdef TARGET_ZCODE;
    for (i=2 : i<INPUT_BUFFER_LEN : i++) buffer2->i = ' ';
    #Endif; ! TARGET_ZCODE
    
	    answer_words=Keyboard(buffer2, parse2);
	

    ! Conveniently, parse2-->1 is the first word in both ZCODE and GLULX.
    first_word = (parse2-->1);

    ! Take care of "all", because that does something too clever here to do
    ! later on:

    if (first_word == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD) {
        if (context == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN) {
            l = multiple_object-->0;
            for (i=0 : i<number_matched && l+i<MATCH_LIST_WORDS : i++) {
                k = match_list-->i;
                multiple_object-->(i+1+l) = k;
            }
            multiple_object-->0 = i+l;
            rtrue;
        }
        PARSER_CLARIF_INTERNAL_RM('C');
        jump WhichOne;
    }

	! Look for a comma, and interpret this as a fresh conversation command
	! if so:

	for (i=1 : i<=answer_words : i++)
		if (WordFrom(i, parse2) == comma_word) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;		
		}

    ! If the first word of the reply can be interpreted as a verb, then
    ! assume that the player has ignored the question and given a new
    ! command altogether.
    ! (This is one time when it's convenient that the directions are
    ! not themselves verbs - thus, "north" as a reply to "Which, the north
    ! or south door" is not treated as a fresh command but as an answer.)

    #Ifdef LanguageIsVerb;
    if (first_word == 0) {
        j = wn; first_word = LanguageIsVerb(buffer2, parse2, 1); wn = j;
    }
    #Endif; ! LanguageIsVerb
    if (first_word ~= 0) {
        j = first_word->#dict_par1;
        if ((0 ~= j&1) && ~~LanguageVerbMayBeName(first_word)) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }

    ! Now we insert the answer into the original typed command, as
    ! words additionally describing the same object
    ! (eg, > take red button
    !      Which one, ...
    !      > music
    ! becomes "take music red button".  The parser will thus have three
    ! words to work from next time, not two.)

    #Ifdef TARGET_ZCODE;
    k = WordAddress(match_from) - buffer; l=buffer2->1+1;
    for (j=buffer + buffer->0 - 1 : j>=buffer+k+l : j--) j->0 = 0->(j-l);
    for (i=0 : i<l : i++) buffer->(k+i) = buffer2->(2+i);
    buffer->(k+l-1) = ' ';
    buffer->1 = buffer->1 + l;
    if (buffer->1 >= (buffer->0 - 1)) buffer->1 = buffer->0;
    #Ifnot; ! TARGET_GLULX
    k = WordAddress(match_from) - buffer;
    l = (buffer2-->0) + 1;
    for (j=buffer+INPUT_BUFFER_LEN-1 : j>=buffer+k+l : j--) j->0 = j->(-l);
    for (i=0 : i<l : i++) buffer->(k+i) = buffer2->(WORDSIZE+i);
    buffer->(k+l-1) = ' ';
    buffer-->0 = buffer-->0 + l;
    if (buffer-->0 > (INPUT_BUFFER_LEN-WORDSIZE)) buffer-->0 = (INPUT_BUFFER_LEN-WORDSIZE);
    #Endif; ! TARGET_

    ! Having reconstructed the input, we warn the parser accordingly
    ! and get out.

	.RECONSTRUCT_INPUT;

	num_words = WordCount(); players_command = 100 + num_words;
    wn = 1;
    #Ifdef LanguageToInformese;
    LanguageToInformese();
    ! Re-tokenise:
    VM_Tokenise(buffer,parse);
    #Endif; ! LanguageToInformese
	num_words = WordCount(); players_command = 100 + num_words;
    actors_location = ScopeCeiling(player);
	FollowRulebook(Activity_after_rulebooks-->READING_A_COMMAND_ACT);

    return REPARSE_CODE;

    ! Now we come to the question asked when the input has run out
    ! and can't easily be guessed (eg, the player typed "take" and there
    ! were plenty of things which might have been meant).

  .Incomplete;

    if (context == CREATURE_TOKEN) PARSER_CLARIF_INTERNAL_RM('D', actor);
    else                           PARSER_CLARIF_INTERNAL_RM('E', actor);
    new_line;

    #Ifdef TARGET_ZCODE;
    for (i=2 : i<INPUT_BUFFER_LEN : i++) buffer2->i=' ';
    #Endif; ! TARGET_ZCODE
    answer_words = Keyboard(buffer2, parse2);

	! Look for a comma, and interpret this as a fresh conversation command
	! if so:

	for (i=1 : i<=answer_words : i++)
		if (WordFrom(i, parse2) == comma_word) {
			VM_CopyBuffer(buffer, buffer2);
			jump RECONSTRUCT_INPUT;
		}

    first_word=(parse2-->1);
    #Ifdef LanguageIsVerb;
    if (first_word==0) {
        j = wn; first_word=LanguageIsVerb(buffer2, parse2, 1); wn = j;
    }
    #Endif; ! LanguageIsVerb

    ! Once again, if the reply looks like a command, give it to the
    ! parser to get on with and forget about the question...

    if (first_word ~= 0) {
        j = first_word->#dict_par1;
        if ((0 ~= j&1) && ~~LanguageVerbMayBeName(first_word)) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }

    ! ...but if we have a genuine answer, then:
    !
    ! (1) we must glue in text suitable for anything that's been inferred.

    if (inferfrom ~= 0) {
        for (j=inferfrom : j<pcount : j++) {
            if (pattern-->j == PATTERN_NULL) continue;
            #Ifdef TARGET_ZCODE;
            i = 2+buffer->1; (buffer->1)++; buffer->(i++) = ' ';
            #Ifnot; ! TARGET_GLULX
            i = WORDSIZE + buffer-->0;
            (buffer-->0)++; buffer->(i++) = ' ';
            #Endif; ! TARGET_

            #Ifdef DEBUG;
            if (parser_trace >= 5)
            	print "[Gluing in inference with pattern code ", pattern-->j, "]^";
            #Endif; ! DEBUG

            ! Conveniently, parse2-->1 is the first word in both ZCODE and GLULX.

            parse2-->1 = 0;

            ! An inferred object.  Best we can do is glue in a pronoun.
            ! (This is imperfect, but it's very seldom needed anyway.)

            if (pattern-->j >= 2 && pattern-->j < REPARSE_CODE) {
                PronounNotice(pattern-->j);
                for (k=1 : k<=LanguagePronouns-->0 : k=k+3)
                    if (pattern-->j == LanguagePronouns-->(k+2)) {
                        parse2-->1 = LanguagePronouns-->k;
                        #Ifdef DEBUG;
                        if (parser_trace >= 5)
                        	print "[Using pronoun '", (address) parse2-->1, "']^";
                        #Endif; ! DEBUG
                        break;
                    }
            }
            else {
                ! An inferred preposition.
                parse2-->1 = VM_NumberToDictionaryAddress(pattern-->j - REPARSE_CODE);
                #Ifdef DEBUG;
                if (parser_trace >= 5)
                	print "[Using preposition '", (address) parse2-->1, "']^";
                #Endif; ! DEBUG
            }

            ! parse2-->1 now holds the dictionary address of the word to glue in.

            if (parse2-->1 ~= 0) {
                k = buffer + i;
                #Ifdef TARGET_ZCODE;
                @output_stream 3 k;
                 print (address) parse2-->1;
                @output_stream -3;
                k = k-->0;
                for (l=i : l<i+k : l++) buffer->l = buffer->(l+2);
                i = i + k; buffer->1 = i-2;
                #Ifnot; ! TARGET_GLULX
                k = Glulx_PrintAnyToArray(buffer+i, INPUT_BUFFER_LEN-i, parse2-->1);
                i = i + k; buffer-->0 = i - WORDSIZE;
                #Endif; ! TARGET_
            }
        }
    }

    ! (2) we must glue the newly-typed text onto the end.

    #Ifdef TARGET_ZCODE;
    i = 2+buffer->1; (buffer->1)++; buffer->(i++) = ' ';
    for (j=0 : j<buffer2->1 : i++,j++) {
        buffer->i = buffer2->(j+2);
        (buffer->1)++;
        if (buffer->1 == INPUT_BUFFER_LEN) break;
    }
    #Ifnot; ! TARGET_GLULX
    i = WORDSIZE + buffer-->0;
    (buffer-->0)++; buffer->(i++) = ' ';
    for (j=0 : j<buffer2-->0 : i++,j++) {
        buffer->i = buffer2->(j+WORDSIZE);
        (buffer-->0)++;
        if (buffer-->0 == INPUT_BUFFER_LEN) break;
    }
    #Endif; ! TARGET_

    ! (3) we fill up the buffer with spaces, which is unnecessary, but may
    !     help incorrectly-written interpreters to cope.

    #Ifdef TARGET_ZCODE;
    for (: i<INPUT_BUFFER_LEN : i++) buffer->i = ' ';
    #Endif; ! TARGET_ZCODE

    jump RECONSTRUCT_INPUT;

]; ! end of NounDomain

[ PARSER_CLARIF_INTERNAL_R; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Adjudicate
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Adjudicate context i j k good_ones last n ultimate flag offset;
    #Ifdef DEBUG;
    if (parser_trace >= 4) {
        print "   [Adjudicating match list of size ", number_matched,
        	" in context ", context, "^";
        print "   ";
        if (indef_mode) {
            print "indefinite type: ";
            if (indef_type & OTHER_BIT)  print "other ";
            if (indef_type & MY_BIT)     print "my ";
            if (indef_type & THAT_BIT)   print "that ";
            if (indef_type & PLURAL_BIT) print "plural ";
            if (indef_type & LIT_BIT)    print "lit ";
            if (indef_type & UNLIT_BIT)  print "unlit ";
            if (indef_owner ~= 0) print "owner:", (name) indef_owner;
            new_line;
            print "   number wanted: ";
            if (indef_wanted == INDEF_ALL_WANTED) print "all"; else print indef_wanted;
            new_line;
            print "   most likely GNAs of names: ", indef_cases, "^";
        }
        else print "definite object^";
    }
    #Endif; ! DEBUG

    j = number_matched-1; good_ones = 0; last = match_list-->0;
    for (i=0 : i<=j : i++) {
        n = match_list-->i;
        match_scores-->i = good_ones;
        ultimate = ScopeCeiling(n);

        if (context==HELD_TOKEN && parent(n)==actor)
        {   good_ones++; last=n; }
        if (context==MULTI_TOKEN && ultimate==ScopeCeiling(actor)
            && n~=actor && n hasnt concealed && n hasnt scenery) 
        {   good_ones++; last=n; }
        if (context==MULTIHELD_TOKEN && parent(n)==actor)
        {   good_ones++; last=n; }

        if (context==MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)
        {   if (advance_warning==-1)
            {   if (context==MULTIEXCEPT_TOKEN)
                {   good_ones++; last=n;
                 }
                if (context==MULTIINSIDE_TOKEN)
                {   if (parent(n)~=actor) { good_ones++; last=n; }
                 }
            }
            else
            {   if (context==MULTIEXCEPT_TOKEN && n~=advance_warning)
                {   good_ones++; last=n; }
                if (context==MULTIINSIDE_TOKEN && n in advance_warning)
                {   good_ones++; last=n; }
            }
         }
        if (context==CREATURE_TOKEN && CreatureTest(n)==1)
        {   good_ones++; last=n; }
        
        match_scores-->i = 1000*(good_ones - match_scores-->i);
    }
    if (good_ones == 1) {
		if (indef_mode == 1 && indef_type & PLURAL_BIT ~= 0 &&
			context == MULTI_TOKEN or MULTIHELD_TOKEN or
				MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN) {
	        BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, last);
            if ((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, last)) &&
            	(RulebookFailed())) good_ones = 0;
	        EndActivity(DECIDING_WHETHER_ALL_INC_ACT, last);
			if (good_ones == 1) return last;
		} else {
			return last;
		}
    }

    ! If there is ambiguity about what was typed, but it definitely wasn't
    ! animate as required, then return anything; higher up in the parser
    ! a suitable error will be given.  (This prevents a question being asked.)

    if (context == CREATURE_TOKEN && good_ones == 0) return match_list-->0;

    if (indef_mode == 0) indef_type=0;

    ScoreMatchL(context);
    if (number_matched == 0) return -1;

    if (indef_mode == 0) {
        !  Is there now a single highest-scoring object?
        i = SingleBestGuess();
        if (i >= 0) {

            #Ifdef DEBUG;
            if (parser_trace >= 4) print "   Single best-scoring object returned.]^";
            #Endif; ! DEBUG
            return i;
        }
    }

    if (indef_mode == 1 && indef_type & PLURAL_BIT ~= 0) {
        if (context ~= MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN
                     or MULTIINSIDE_TOKEN) {
            etype = MULTI_PE;
            return -1;
        }
        i = 0; offset = multiple_object-->0;
        for (j=BestGuess(): j~=-1 && i<indef_wanted && i+offset<MATCH_LIST_WORDS-1:
        	j=BestGuess()) {
            flag = 0;
            BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, j);
            if ((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, j)) == 0) {
                if (j hasnt concealed && j hasnt worn) flag = 1;
                if (context == MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN && parent(j) ~= actor)
                    flag = 0;

                if (action_to_be == ##Take or ##Remove && parent(j) == actor)
                    flag = 0;

                k = ChooseObjects(j, flag);

                if (k == 1)
                    flag = 1;
                else {
                    if (k == 2) flag = 0;
                }
            } else {
                flag = 0; if (RulebookSucceeded()) flag = 1;
            }
            EndActivity(DECIDING_WHETHER_ALL_INC_ACT, j);
            if (flag == 1) {
                i++; multiple_object-->(i+offset) = j;
                #Ifdef DEBUG;
                if (parser_trace >= 4) print "   Accepting it^";
                #Endif; ! DEBUG
            }
            else {
                i = i;
                #Ifdef DEBUG;
                if (parser_trace >= 4) print "   Rejecting it^";
                #Endif; ! DEBUG
            }
        }
        if (i < indef_wanted && indef_wanted < INDEF_ALL_WANTED) {
            etype = TOOFEW_PE; multi_wanted = indef_wanted;
			 if (parser_trace >= 4) print "Too few found^";
            multi_had=i;
            return -1;
        }
        multiple_object-->0 = i+offset;
        multi_context = context;
        #Ifdef DEBUG;
        if (parser_trace >= 4)
            print "   Made multiple object of size ", i, "]^";
        #Endif; ! DEBUG
        return 1;
    }

    for (i=0 : i<number_matched : i++) match_classes-->i = 0;

    n = 1;
    for (i=0 : i<number_matched : i++)
        if (match_classes-->i == 0) {
            match_classes-->i = n++; flag = 0;
            for (j=i+1 : j<number_matched : j++)
                if (match_classes-->j == 0 && Identical(match_list-->i, match_list-->j) == 1) {
                    flag=1;
                    match_classes-->j = match_classes-->i;
                }
            if (flag == 1) match_classes-->i = 1-n;
        }
     n--; number_of_classes = n;

    #Ifdef DEBUG;
    if (parser_trace >= 4) {
        print "   Grouped into ", n, " possibilities by name:^";
        for (i=0 : i<number_matched : i++)
            if (match_classes-->i > 0)
                print "   ", (The) match_list-->i, " (", match_list-->i, ")  ---  group ",
                  match_classes-->i, "^";
    }
    #Endif; ! DEBUG

    if (indef_mode == 0) {
        if (n > 1) {
            k = -1;
            for (i=0 : i<number_matched : i++) {
                if (match_scores-->i > k) {
                    k = match_scores-->i;
                    j = match_classes-->i; j = j*j;
                    flag = 0;
                }
                else
                    if (match_scores-->i == k) {
                        if ((match_classes-->i) * (match_classes-->i) ~= j)
                            flag = 1;
                    }
            }

        if (flag) {
            #Ifdef DEBUG;
            if (parser_trace >= 4) print "   Unable to choose best group, so ask player.]^";
            #Endif; ! DEBUG
            return 0;
        }
        #Ifdef DEBUG;
        if (parser_trace >= 4) print "   Best choices are all from the same group.^";
        #Endif; ! DEBUG
        }
    }

    !  When the player is really vague, or there's a single collection of
    !  indistinguishable objects to choose from, choose the one the player
    !  most recently acquired, or if the player has none of them, then
    !  the one most recently put where it is.

    if (n == 1) dont_infer = true;
    return BestGuess();

]; ! Adjudicate


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: ReviseMulti
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ReviseMulti second_p  i low;
    #Ifdef DEBUG;
    if (parser_trace >= 4)
    	print "   Revising multiple object list of size ", multiple_object-->0,
     	" with 2nd ", (name) second_p, "^";
    #Endif; ! DEBUG

    if (multi_context == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN) {
        for (i=1,low=0 : i<=multiple_object-->0 : i++) {
            if ( (multi_context==MULTIEXCEPT_TOKEN && multiple_object-->i ~= second_p) ||
                 (multi_context==MULTIINSIDE_TOKEN && multiple_object-->i in second_p)) {
                low++;
                multiple_object-->low = multiple_object-->i;
            }
        }
        multiple_object-->0 = low;
    }

    if (multi_context == MULTI_TOKEN && action_to_be == ##Take) {
        #Ifdef DEBUG;
        if (parser_trace >= 4) print "   Token 2 plural case: number with actor ", low, "^";
        #Endif; ! DEBUG
        if (take_all_rule == 2) {
            for (i=1,low=0 : i<=multiple_object-->0 : i++) {
                if (ScopeCeiling(multiple_object-->i) == ScopeCeiling(actor)) {
                    low++;
                    multiple_object-->low = multiple_object-->i;
                }
            }
            multiple_object-->0 = low;
        }
    }

    i = multiple_object-->0;
    #Ifdef DEBUG;
    if (parser_trace >= 4) print "   Done: new size ", i, "^";
    #Endif; ! DEBUG
    if (i == 0) return NOTHING_PE;
    return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Match List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MakeMatch obj quality i;
    #Ifdef DEBUG;
    if (parser_trace >= 6) print "    Match with quality ",quality,"^";
    #Endif; ! DEBUG
    if (token_filter ~= 0 && ConsultNounFilterToken(obj) == 0) {
        #Ifdef DEBUG;
        if (parser_trace >= 6) print "    Match filtered out: token filter ", token_filter, "^";
        #Endif; ! DEBUG
        rtrue;
    }
    if (quality < match_length) rtrue;
    if (quality > match_length) { match_length = quality; number_matched = 0; }
    else {
        if (number_matched >= MATCH_LIST_WORDS) rtrue;
        for (i=0 : i<number_matched : i++)
            if (match_list-->i == obj) rtrue;
    }
    match_list-->number_matched++ = obj;
    #Ifdef DEBUG;
    if (parser_trace >= 6) print "    Match added to list^";
    #Endif; ! DEBUG
];

[ ConsultNounFilterToken obj sn rv;
    if (token_filter ofclass Routine) {
    	sn = noun;
	    noun = obj;
    	rv = indirect(token_filter);
    	noun = sn;
    	return rv;
    }
    if (obj has (token_filter-1)) rtrue;
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: ScoreMatchL
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant SCORE__CHOOSEOBJ = 1000;
Constant SCORE__IFGOOD = 500;
Constant SCORE__UNCONCEALED = 100;
Constant SCORE__BESTLOC = 60;
Constant SCORE__NEXTBESTLOC = 40;
Constant SCORE__NOTCOMPASS = 20;
Constant SCORE__NOTSCENERY = 10;
Constant SCORE__NOTACTOR = 5;
Constant SCORE__GNA = 1;
Constant SCORE__DIVISOR = 20;

Constant PREFER_HELD;
[ ScoreMatchL context its_owner its_score obj i j threshold met a_s l_s;
!   if (indef_type & OTHER_BIT ~= 0) threshold++;
    if (indef_type & MY_BIT ~= 0)    threshold++;
    if (indef_type & THAT_BIT ~= 0)  threshold++;
    if (indef_type & LIT_BIT ~= 0)   threshold++;
    if (indef_type & UNLIT_BIT ~= 0) threshold++;
    if (indef_owner ~= nothing)      threshold++;

    #Ifdef DEBUG;
    if (parser_trace >= 4) print "   Scoring match list: indef mode ", indef_mode, " type ",
      indef_type, ", satisfying ", threshold, " requirements:^";
    #Endif; ! DEBUG

    #ifdef PREFER_HELD;
    a_s = SCORE__BESTLOC; l_s = SCORE__NEXTBESTLOC;
    if (action_to_be == ##Take or ##Remove) {
        a_s = SCORE__NEXTBESTLOC; l_s = SCORE__BESTLOC;
    }
    context = context;  ! silence warning
    #ifnot;
    a_s = SCORE__NEXTBESTLOC; l_s = SCORE__BESTLOC;
    if (context == HELD_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN) {
        a_s = SCORE__BESTLOC; l_s = SCORE__NEXTBESTLOC;
    }
    #endif; ! PREFER_HELD

    for (i=0 : i<number_matched : i++) {
        obj = match_list-->i; its_owner = parent(obj); its_score=0; met=0;

        !      if (indef_type & OTHER_BIT ~= 0
        !          &&  obj ~= itobj or himobj or herobj) met++;
        if (indef_type & MY_BIT ~= 0 && its_owner == actor) met++;
        if (indef_type & THAT_BIT ~= 0 && its_owner == actors_location) met++;
        if (indef_type & LIT_BIT ~= 0 && obj has light) met++;
        if (indef_type & UNLIT_BIT ~= 0 && obj hasnt light) met++;
        if (indef_owner ~= 0 && its_owner == indef_owner) met++;

        if (met < threshold) {
            #Ifdef DEBUG;
            if (parser_trace >= 4)
            	print "   ", (The) match_list-->i, " (", match_list-->i, ") in ",
            	    (the) its_owner, " is rejected (doesn't match descriptors)^";
            #Endif; ! DEBUG
            match_list-->i = -1;
        }
        else {
            its_score = 0;
            if (obj hasnt concealed) its_score = SCORE__UNCONCEALED;

            if (its_owner == actor) its_score = its_score + a_s;
            else
                if (its_owner == actors_location) its_score = its_score + l_s;
                else
                    if (its_owner ~= compass) its_score = its_score + SCORE__NOTCOMPASS;

            its_score = its_score + SCORE__CHOOSEOBJ * ChooseObjects(obj, 2);

            if (obj hasnt scenery) its_score = its_score + SCORE__NOTSCENERY;
            if (obj ~= actor) its_score = its_score + SCORE__NOTACTOR;

            !   A small bonus for having the correct GNA,
            !   for sorting out ambiguous articles and the like.

            if (indef_cases & (PowersOfTwo_TB-->(GetGNAOfObject(obj))))
                its_score = its_score + SCORE__GNA;

            match_scores-->i = match_scores-->i + its_score;
            #Ifdef DEBUG;
            if (parser_trace >= 4) print "     ", (The) match_list-->i, " (", match_list-->i,
              ") in ", (the) its_owner, " : ", match_scores-->i, " points^";
            #Endif; ! DEBUG
        }
     }

    for (i=0 : i<number_matched : i++) {
        while (match_list-->i == -1) {
            if (i == number_matched-1) { number_matched--; break; }
            for (j=i : j<number_matched-1 : j++) {
                match_list-->j = match_list-->(j+1);
                match_scores-->j = match_scores-->(j+1);
            }
            number_matched--;
        }
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: BestGuess
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BestGuess  earliest its_score best i;
    earliest = 0; best = -1;
    for (i=0 : i<number_matched : i++) {
        if (match_list-->i >= 0) {
            its_score = match_scores-->i;
            if (its_score > best) { best = its_score; earliest = i; }
        }
    }
    #Ifdef DEBUG;
    if (parser_trace >= 4)
      if (best < 0) print "   Best guess ran out of choices^";
      else print "   Best guess ", (the) match_list-->earliest,
      	" (", match_list-->earliest, ")^";
    #Endif; ! DEBUG
    if (best < 0) return -1;
    i = match_list-->earliest;
    match_list-->earliest = -1;
    return i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: SingleBestGuess
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SingleBestGuess  earliest its_score best i;
    earliest = -1; best = -1000;
    for (i=0 : i<number_matched : i++) {
        its_score = match_scores-->i;
        if (its_score == best) earliest = -1;
        if (its_score > best) { best = its_score; earliest = match_list-->i; }
    }
    return earliest;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Identical
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Identical o1 o2 p1 p2 n1 n2 i j flag;
    if (o1 == o2) rtrue;  ! This should never happen, but to be on the safe side
    if (o1 == 0 || o2 == 0) rfalse;  ! Similarly
    if (o1 ofclass K3_direction || o2 ofclass K3_direction) rfalse; ! Saves time

    !  What complicates things is that o1 or o2 might have a parsing routine,
    !  so the parser can't know from here whether they are or aren't the same.
    !  If they have different parsing routines, we simply assume they're
    !  different.  If they have the same routine (which they probably got from
    !  a class definition) then the decision process is as follows:
    !
    !     the routine is called (with self being o1, not that it matters)
    !       with noun and second being set to o1 and o2, and action being set
    !       to the fake action TheSame.  If it returns -1, they are found
    !       identical; if -2, different; and if >=0, then the usual method
    !       is used instead.

    if (o1.parse_name ~= 0 || o2.parse_name ~= 0) {
      if (o1.parse_name ~= o2.parse_name) rfalse;
      parser_action = ##TheSame; parser_one = o1; parser_two = o2;
      j = wn; i = RunRoutines(o1,parse_name); wn = j;
      if (i == -1) rtrue;
      if (i == -2) rfalse;
    }

    !  This is the default algorithm: do they have the same words in their
    !  "name" (i.e. property no. 1) properties.  (Note that the following allows
    !  for repeated words and words in different orders.)

    p1 = o1.&1; n1 = (o1.#1)/WORDSIZE;
    p2 = o2.&1; n2 = (o2.#1)/WORDSIZE;

    !  for (i=0 : i<n1 : i++) { print (address) p1-->i, " "; } new_line;
    !  for (i=0 : i<n2 : i++) { print (address) p2-->i, " "; } new_line;

    for (i=0 : i<n1 : i++) {
        flag = 0;
        for (j=0 : j<n2 : j++)
            if (p1-->i == p2-->j) flag = 1;
        if (flag == 0) rfalse;
    }

    for (j=0 : j<n2 : j++) {
        flag = 0;
        for (i=0 : i<n1 : i++)
            if (p1-->i == p2-->j) flag = 1;
        if (flag == 0) rfalse;
    }

    !  print "Which are identical!^";
    rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Print Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintInferredCommand from singleton_noun;
	singleton_noun = FALSE;
	if ((from ~= 0) && (from == pcount-1) &&
		(pattern-->from > 1) && (pattern-->from < REPARSE_CODE))
			singleton_noun = TRUE;

	if (singleton_noun) {
		BeginActivity(CLARIFYING_PARSERS_CHOICE_ACT, pattern-->from);
		if (ForActivity(CLARIFYING_PARSERS_CHOICE_ACT, pattern-->from) == 0) {
			print "("; PrintCommand(from); print ")^";
		}
		EndActivity(CLARIFYING_PARSERS_CHOICE_ACT, pattern-->from);
	} else {
		print "("; PrintCommand(from); print ")^";
	}
];

[ PrintCommand from i k spacing_flag;
    if (from == 0) {
        i = verb_word;
        if (LanguageVerb(i) == 0)
            if (PrintVerb(i) == 0) print (address) i;
        from++; spacing_flag = true;
    }
    for (k=from : k<pcount : k++) {
        i = pattern-->k;
        if (i == PATTERN_NULL) continue;
        if (spacing_flag) print (char) ' ';
        if (i == 0) { PARSER_CLARIF_INTERNAL_RM('F'); jump TokenPrinted; }
        if (i == 1) { PARSER_CLARIF_INTERNAL_RM('G'); jump TokenPrinted; }
        if (i >= REPARSE_CODE)
            print (address) VM_NumberToDictionaryAddress(i-REPARSE_CODE);
        else
            if (i ofclass K3_direction)
                print (LanguageDirection) i; ! the direction name as adverb
            else
                print (the) i;
      .TokenPrinted;
        spacing_flag = true;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: CantSee
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CantSee  i w e;
    saved_oops=oops_from;

    if (scope_token ~= 0) {
        scope_error = scope_token; return ASKSCOPE_PE;
    }

    wn--; w = NextWord();
    e = CANTSEE_PE;
    if (w == pronoun_word) {
		w = NextWordStopped(); wn--;
		if ((w == -1) || (line_token-->(pcount) ~= ENDIT_TOKEN)) {
			if (pcount > 0) AnalyseToken(line_token-->(pcount-1));
			if ((pcount > 0) && (found_ttype == ROUTINE_FILTER_TT or ATTR_FILTER_TT))
				e = NOTINCONTEXT_PE;
			else {
				pronoun__word = pronoun_word; pronoun__obj = pronoun_obj;
				e = ITGONE_PE;
			}
		}
    }
    
    if (etype > e) return etype;
    return e;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Multiple Object List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MultiAdd o i j;
    i = multiple_object-->0;
    if (i == MATCH_LIST_WORDS-1) { toomany_flag = 1; rtrue; }
    for (j=1 : j<=i : j++)
        if (o == multiple_object-->j) rtrue;
    i++;
    multiple_object-->i = o;
    multiple_object-->0 = i;
];

[ MultiSub o i j k;
    i = multiple_object-->0;
    for (j=1 : j<=i : j++)
        if (o == multiple_object-->j) {
            for (k=j : k<=i : k++) multiple_object-->k = multiple_object-->(k+1);
            multiple_object-->0 = --i;
            return 0;
        }
    return VAGUE_PE;
];

[ MultiFilter attr  i j o;
	.MFiltl;
    i = multiple_object-->0;
    for (j=1 : j<=i : j++) {
        o = multiple_object-->j;
        if (o hasnt attr) { MultiSub(o); jump Mfiltl; }
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Scope
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PlaceInScope O opts ws; ! If opts is set, do not place contents in scope
	ws = wn; wn = match_from;
	if (opts == false) DoScopeActionAndRecurse(O);
	else DoScopeAction(O);
	wn = ws; return;
];

[ AddToScope obj;
    if (ats_flag >= 2) DoScopeActionAndRecurse(obj, 0, ats_flag-2);
    if (ats_flag == 1) { if (HasLightSource(obj)==1) ats_hls = 1; }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Scope Level 0
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestScope obj act a al sr x y;
    x = parser_one; y = parser_two;
    parser_one = obj; parser_two = 0; a = actor; al = actors_location;
    sr = scope_reason; scope_reason = TESTSCOPE_REASON;
    if (act == 0) actor = player; else actor = act;
    actors_location = ScopeCeiling(actor);
    SearchScope(actors_location, actor, 0); scope_reason = sr; actor = a;
    actors_location = al; parser_one = x; x = parser_two; parser_two = y;
    return x;
];

[ LoopOverScope routine act x y a al;
    x = parser_one; y = scope_reason; a = actor; al = actors_location;
    parser_one = routine;
    if (act == 0) actor = player; else actor = act;
    actors_location = ScopeCeiling(actor);
    scope_reason = LOOPOVERSCOPE_REASON;
    SearchScope(actors_location, actor, 0);
    parser_one = x; scope_reason = y; actor = a; actors_location = al;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: SearchScope
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SearchScope domain1 domain2 context i;
	if (domain1 == 0) return;
	! (a)
    if (scope_token) {
        scope_stage = 2;
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Scope routine called at stage 2]^";
        #Endif;
        if (indirect(scope_token) ~= 0) rtrue;
    }
	! (b)
    BeginActivity(DECIDING_SCOPE_ACT, actor);
    if (ForActivity(DECIDING_SCOPE_ACT, actor) == false) {
		! (c.1)
		if ((scope_reason == PARSING_REASON) && (context == MULTIINSIDE_TOKEN) &&
			(advance_warning ~= -1)) {
			if (IsSeeThrough(advance_warning) == 1)
			    ScopeWithin(advance_warning, 0, context);
		} else {
			! (c.2)
			if ((scope_reason == PARSING_REASON) && (context ~= CREATURE_TOKEN) &&
				(indef_mode == 0) && (domain1 == actors_location))
					ScopeWithin(compass);
			! (c.3)
			if (domain1 has supporter or container) DoScopeAction(domain1);
			ScopeWithin(domain1, domain2, context);
			! (c.4)
			if (domain2) {
				if (domain2 has supporter or container) DoScopeAction(domain2);
				ScopeWithin(domain2, 0, context);
			}
		}
		! (c.5)
		if (thedark == domain1 or domain2) {
			DoScopeActionAndRecurse(actor, actor, context);
			if (parent(actor) has supporter or container)
				DoScopeActionAndRecurse(parent(actor), parent(actor), context);
		}
    }
    EndActivity(DECIDING_SCOPE_ACT, actor);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: ScopeWithin
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ScopeWithin domain nosearch context obj next_obj;
    if (domain == 0) rtrue;

    ! Look through the objects in the domain, avoiding "objectloop" in case
    ! movements occur.
    obj = child(domain);
    while (obj) {
        next_obj = sibling(obj);
        if ((domain == actor) || (TestConcealment(domain, obj) == false))
            DoScopeActionAndRecurse(obj, nosearch, context);
        obj = next_obj;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: DoScopeActionAndRecurse
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DoScopeActionAndRecurse domain nosearch context i ad n obj next_obj;
	DoScopeAction(domain);

 	! (a)
    if ((domain ~= nosearch) &&
        ((domain ofclass K1_room or K8_person) || (IsSeeThrough(domain) == 1))) {
		obj = child(domain);
		while (obj) {
			next_obj = sibling(obj);
			if ((domain == actor) || (TestConcealment(domain, obj) == false))
				DoScopeActionAndRecurse(obj, nosearch, context);
			obj = next_obj;
		}
	}

	! (b)
	if (domain provides component_child) {
		obj = domain.component_child;
		while (obj) {
			next_obj = obj.component_sibling;
			if ((domain == actor) || (TestConcealment(domain, obj) == false))
				DoScopeActionAndRecurse(obj, 0, context);
			obj = next_obj;
		}
	}

    ! (c)
    ad = domain.&add_to_scope;
    if (ad ~= 0) {
        ! Test if the property value is not an object.
        #Ifdef TARGET_ZCODE;
        i = (UnsignedCompare(ad-->0, top_object) > 0);
        #Ifnot; ! TARGET_GLULX
        i = (((ad-->0)->0) ~= $70);
        #Endif; ! TARGET_

        if (i) {
            ats_flag = 2+context;
            RunRoutines(domain, add_to_scope);
            ats_flag = 0;
        }
        else {
            n = domain.#add_to_scope;
            for (i=0 : (WORDSIZE*i)<n : i++)
                if (ad-->i)
                    DoScopeActionAndRecurse(ad-->i, 0, context);
        }
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: DoScopeAction
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DoScopeAction item;

    #Ifdef DEBUG;
    if (parser_trace >= 6)
        print "[DSA on ", (the) item, " with reason = ", scope_reason,
            " p1 = ", parser_one, " p2 = ", parser_two, "]^";
    #Endif; ! DEBUG

    @push parser_one; @push scope_reason;

	switch(scope_reason) {
		TESTSCOPE_REASON: if (item == parser_one) parser_two = 1;
		LOOPOVERSCOPE_REASON: if (parser_one ofclass Routine) indirect(parser_one, item);
		PARSING_REASON, TALKING_REASON: MatchTextAgainstObject(item);
    }

    @pull scope_reason; @pull parser_one;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Parsing Object Names
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MatchTextAgainstObject item i;
    if (token_filter ~= 0 && ConsultNounFilterToken(item) == 0) return;

	if (match_from <= num_words) { ! If there's any text to match, that is
		wn = match_from;
		i = NounWord();
		if ((i == 1) && (player == item)) MakeMatch(item, 1); ! "me"
		if ((i >= 2) && (i < 128) && (LanguagePronouns-->i == item)) MakeMatch(item, 1);
	}

	! Construing the current word as the start of a noun, can it refer to the
	! object?

	wn = match_from;
	if (TryGivenObject(item) > 0)
		if (indef_nspec_at > 0 && match_from ~= indef_nspec_at) {
			! This case arises if the player has typed a number in
			! which is hypothetically an indefinite descriptor:
			! e.g. "take two clubs".  We have just checked the object
			! against the word "clubs", in the hope of eventually finding
			! two such objects.  But we also backtrack and check it
			! against the words "two clubs", in case it turns out to
			! be the 2 of Clubs from a pack of cards, say.  If it does
			! match against "two clubs", we tear up our original
			! assumption about the meaning of "two" and lapse back into
			! definite mode.

			wn = indef_nspec_at;
			if (TryGivenObject(item) > 0) {
				match_from = indef_nspec_at;
				ResetDescriptors();
			}
			wn = match_from;
		}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: TryGivenObject
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TryGivenObject obj nomatch threshold k w j;
    #Ifdef DEBUG;
    if (parser_trace >= 5) print "    Trying ", (the) obj, " (", obj, ") at word ", wn, "^";
    #Endif; ! DEBUG

	if (nomatch && obj == 0) return 0;

! if (nomatch) print "*** TryGivenObject *** on ", (the) obj, " at wn = ", wn, "^";

    dict_flags_of_noun = 0;

!  If input has run out then always match, with only quality 0 (this saves
!  time).

    if (wn > num_words) {
    	if (nomatch) return 0;
        if (indef_mode ~= 0)
            dict_flags_of_noun = $$01110000;  ! Reject "plural" bit
        MakeMatch(obj,0);
        #Ifdef DEBUG;
        if (parser_trace >= 5) print "    Matched (0)^";
        #Endif; ! DEBUG
        return 1;
    }

!  Ask the object to parse itself if necessary, sitting up and taking notice
!  if it says the plural was used:

    if (obj.parse_name~=0) {
        parser_action = NULL; j=wn;
        k = RunRoutines(obj,parse_name);
        if (k > 0) {
            wn=j+k;

          .MMbyPN;

            if (parser_action == ##PluralFound)
                dict_flags_of_noun = dict_flags_of_noun | 4;

            if (dict_flags_of_noun & 4) {
                if (~~allow_plurals) k = 0;
                else {
                    if (indef_mode == 0) {
                        indef_mode = 1; indef_type = 0; indef_wanted = 0;
                    }
                    indef_type = indef_type | PLURAL_BIT;
                    if (indef_wanted == 0) indef_wanted = INDEF_ALL_WANTED;
                }
            }

            #Ifdef DEBUG;
            if (parser_trace >= 5) print "    Matched (", k, ")^";
            #Endif; ! DEBUG
            if (nomatch == false) MakeMatch(obj,k);
            return k;
        }
        if (k == 0) jump NoWordsMatch;
    }

    ! The default algorithm is simply to count up how many words pass the
    ! Refers test:

    parser_action = NULL;

    w = NounWord();

    if (w == 1 && player == obj) { k=1; jump MMbyPN; }

    if (w >= 2 && w < 128 && (LanguagePronouns-->w == obj)) { k = 1; jump MMbyPN; }

    if (Refers(obj, wn-1) == 0) {
        .NoWordsMatch;
        if (indef_mode ~= 0) { k = 0; parser_action = NULL; jump MMbyPN; }
        rfalse;
    }

	threshold = 1;
	dict_flags_of_noun = (w->#dict_par1) & $$01110100;
	w = NextWord();
	while (Refers(obj, wn-1)) {
		threshold++;
		if (w)
		   dict_flags_of_noun = dict_flags_of_noun | ((w->#dict_par1) & $$01110100);
		w = NextWord();
	}

    k = threshold;
    jump MMbyPN;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Refers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Refers obj wnum   wd k l m;
    if (obj == 0) rfalse;

    #Ifdef LanguageRefers;
    k = LanguageRefers(obj,wnum); if (k >= 0) return k;
    #Endif; ! LanguageRefers

    k = wn; wn = wnum; wd = NextWordStopped(); wn = k;

    if (parser_inflection >= 256) {
        k = indirect(parser_inflection, obj, wd);
        if (k >= 0) return k;
        m = -k;
    }
    else
        m = parser_inflection;
    k = obj.&m; l = (obj.#m)/WORDSIZE-1;
    for (m=0 : m<=l : m++)
        if (wd == k-->m) rtrue;
    rfalse;
];

[ WordInProperty wd obj prop k l m;
    k = obj.&prop; l = (obj.#prop)/WORDSIZE-1;
    for (m=0 : m<=l : m++)
        if (wd == k-->m) rtrue;
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: NounWord
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NounWord i j s;
    i = NextWord();
    if (i == 0) rfalse;
    if (i == ME1__WD or ME2__WD or ME3__WD) return 1;
    s = LanguagePronouns-->0;
    for (j=1 : j<=s : j=j+3)
        if (i == LanguagePronouns-->j)
            return j+2;
    if ((i->#dict_par1)&128 == 0) rfalse;
    return i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: TryNumber
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TryNumber wordnum   i j c num len mul tot d digit;
    i = wn; wn = wordnum; j = NextWord(); wn = i;
    j = NumberWord(j); ! Test for verbal forms ONE to THIRTY
    if (j >= 1) return j;

    #Ifdef TARGET_ZCODE;
    i = wordnum*4+1; j = parse->i; num = j+buffer; len = parse->(i-1);
    #Ifnot; ! TARGET_GLULX
    i = wordnum*3; j = parse-->i; num = j+buffer; len = parse-->(i-1);
    #Endif; ! TARGET_

    if (len >= 4) mul=1000;
    if (len == 3) mul=100;
    if (len == 2) mul=10;
    if (len == 1) mul=1;

    tot = 0; c = 0; len = len-1;

    for (c=0 : c<=len : c++) {
        digit=num->c;
        if (digit == '0') { d = 0; jump digok; }
        if (digit == '1') { d = 1; jump digok; }
        if (digit == '2') { d = 2; jump digok; }
        if (digit == '3') { d = 3; jump digok; }
        if (digit == '4') { d = 4; jump digok; }
        if (digit == '5') { d = 5; jump digok; }
        if (digit == '6') { d = 6; jump digok; }
        if (digit == '7') { d = 7; jump digok; }
        if (digit == '8') { d = 8; jump digok; }
        if (digit == '9') { d = 9; jump digok; }
        return -1000;
     .digok;
        tot = tot+mul*d; mul = mul/10;
    }
    if (len > 3) tot=10000;
    return tot;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Gender
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GetGender person;
    if (person hasnt female) rtrue;
    rfalse;
];

[ GetGNAOfObject obj case gender;
    if (obj hasnt animate) case = 6;
    if (obj has male) gender = male;
    if (obj has female) gender = female;
    if (obj has neuter) gender = neuter;
    if (gender == 0) {
        if (case == 0) gender = LanguageAnimateGender;
        else gender = LanguageInanimateGender;
    }
    if (gender == female)   case = case + 1;
    if (gender == neuter)   case = case + 2;
    if (obj has pluralname) case = case + 3;
    return case;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Noticing Plurals
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DetectPluralWord at n i w swn outcome;
	swn = wn; wn = at;
	for (i=0:i<n:i++) {
		w = NextWordStopped();
		if (w == 0 or THEN1__WD or COMMA_WORD or -1) break;
		if ((w->#dict_par1) & $$00000100) {
			parser_action = ##PluralFound;
			outcome = true;
		}
	}
	wn = swn;
	return outcome;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Gender Options replacement for Parser.i6t: Pronoun Handling
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SetPronoun dword value x;
    for (x=1 : x<=LanguagePronouns-->0 : x=x+3)
        if (LanguagePronouns-->x == dword) {
            LanguagePronouns-->(x+2) = value; return;
        }
    RunTimeError(12);
];

[ PronounValue dword x;
    for (x=1 : x<=LanguagePronouns-->0 : x=x+3)
        if (LanguagePronouns-->x == dword)
            return LanguagePronouns-->(x+2);
    return 0;
];

[ ResetVagueWords obj; PronounNotice(obj); ];

[ GetGNABitfield obj g gn;
	! First calculate three-bit gender field
	g = 0;
	if ( obj has neuter ) {
		g = g + 2;	! bit position 0
		}
	if ( obj has female ) {
		g = g + 4;	! bit position 1
		}
	if ( obj has male ) {
		g = g + 8;	! bit position 2
		}
	if ( obj has nomale ) {
		g = g + 1;	! bit position 3
		}
	gn = 0;
	if ( obj has ambigpluralname  ) {
		gn = g * 17;	 ! plural in low significant digits, plus singular shifted four to the left
	} else if ( obj has pluralname ) {
		gn = gn + g;	! plural is in low significant digits
	} else {	! obj is singular-named
		gn = gn + g * 16;	! singular is shifted 4 to the left
	}
	if ( obj has animate ) {
		return gn * 256;	! shift 8 to the left for animate objects
		}
	return gn;	! shift 0];
];

[ PronounNotice obj x bm;
    if (obj == player) return;

	bm = GetGNABitfield(obj);  ! This is the change made by Gender Options by Nathanael Nerode.

    for (x=1 : x<=LanguagePronouns-->0 : x=x+3)
        if (bm & (LanguagePronouns-->(x+1)) ~= 0)
            LanguagePronouns-->(x+2) = obj;
];

[ PronounNoticeHeldObjects x;
#IFNDEF MANUAL_PRONOUNS;
  objectloop(x in player) PronounNotice(x);
#ENDIF;
  x = 0; ! To prevent a "not used" error
  rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Pronoun Handling (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Yes/No Questions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ YesOrNo i j;
    for (::) {
        #Ifdef TARGET_ZCODE;
        if (location == nothing || parent(player) == nothing) read buffer2 parse2;
        else read buffer2 parse2 DrawStatusLine;
        j = parse2->1;
        #Ifnot; ! TARGET_GLULX;
        if (location ~= nothing && parent(player) ~= nothing) DrawStatusLine();
        KeyboardPrimitive(buffer2, parse2);
        j = parse2-->0;
        #Endif; ! TARGET_
        if (j) { ! at least one word entered
            i = parse2-->1;
            if (i == YES1__WD or YES2__WD or YES3__WD) rtrue;
            if (i == NO1__WD or NO2__WD or NO3__WD) rfalse;
        }
        YES_OR_NO_QUESTION_INTERNAL_RM('A'); print "> ";
    }
];

[ YES_OR_NO_QUESTION_INTERNAL_R; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Number Words
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NumberWord o i n;
    n = LanguageNumbers-->0;
    for (i=1 : i<=n : i=i+2)
        if (o == LanguageNumbers-->i) return LanguageNumbers-->(i+1);
    return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Choose Objects
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

!Constant COBJ_DEBUG;

! the highest value returned by CheckDPMR (see the Standard Rules)
Constant HIGHEST_DPMR_SCORE = 4;

Array alt_match_list --> (MATCH_LIST_WORDS+1);

#ifdef TARGET_GLULX;
[ COBJ__Copy words from to  i;
	for (i=0: i<words: i++)
		to-->i = from-->i;
];
#ifnot;
[ COBJ__Copy words from to  bytes;
	bytes = words * 2;
	@copy_table from to bytes;
];
#endif;

! swap alt_match_list with match_list/number_matched
[ COBJ__SwapMatches i x;
	! swap the counts
	x = number_matched;
	number_matched = alt_match_list-->0;
	alt_match_list-->0 = x;
	! swap the values
	if (x < number_matched) x = number_matched;
	for (i=x: i>0: i--) {
		x = match_list-->(i-1);
		match_list-->(i-1) = alt_match_list-->i;
		alt_match_list-->i = x;
	}
];

[ ChooseObjects obj code  l i swn spcount;
	if (code<2) rfalse;

	if (cobj_flag == 1) {
		.CodeOne;
		if (parameters > 0) {
			#ifdef COBJ_DEBUG;
			print "[scoring ", (the) obj, " (second)]^";
			#endif;
			return ScoreDabCombo(parser_results-->INP1_PRES, obj);
		} else {
			#ifdef COBJ_DEBUG;
			print "[scoring ", (the) obj, " (first) in ",
				alt_match_list-->0, " combinations]^";
			#endif;
			l = 0;
			for (i=1: i<=alt_match_list-->0: i++) {
				spcount = ScoreDabCombo(obj, alt_match_list-->i);
				if (spcount == HIGHEST_DPMR_SCORE) {
					#ifdef COBJ_DEBUG;
					print "[scored ", spcount, " - best possible]^";
					#endif;
					return spcount;
				}
				if (spcount>l) l = spcount;
			}
			return l;
		}
	}
	if (cobj_flag == 2) {
		.CodeTwo;
		#ifdef COBJ_DEBUG;
		print "[scoring ", (the) obj, " (simple); parameters = ", parameters,
			" aw = ", advance_warning, "]^";
		#endif;
		@push action_to_be;
		if (parameters==0) {
			if (advance_warning > 0)
				l = ScoreDabCombo(obj, advance_warning);
			else
				l = ScoreDabCombo(obj, 0);
		} else {
			l = ScoreDabCombo(parser_results-->INP1_PRES, obj);
		}
		@pull action_to_be;
		return l;
	}

	#ifdef COBJ_DEBUG;
	print "[choosing a cobj strategy: ";
	#endif;
	swn = wn;
	spcount = pcount;
	while (line_ttype-->pcount == PREPOSITION_TT) pcount++;
	if (line_ttype-->pcount == ELEMENTARY_TT) {
		if (line_tdata-->pcount == TOPIC_TOKEN) {
			pcount = spcount;
			jump CodeTwo;
		}
		while (wn <= num_words) {
			l = NextWordStopped(); wn--;
			if (l == THEN1__WD) break;
			if ( (l ~= -1 or 0) && (l->#dict_par1) &8 ) { wn++; continue; }	! if preposition
			if (l == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD) { wn++; continue; }
			SafeSkipDescriptors();
			! save the current match state
			@push match_length; @push token_filter; @push match_from;
			alt_match_list-->0 = number_matched;
			COBJ__Copy(number_matched, match_list, alt_match_list+WORDSIZE);
			! now get all the matches for the second noun
			match_length = 0; number_matched = 0; match_from = wn;
			token_filter = 0;
			SearchScope(actor, actors_location, line_tdata-->pcount);
			#ifdef COBJ_DEBUG;
			print number_matched, " possible second nouns]^";
			#endif;
			wn = swn;
			cobj_flag = 1;
			! restore match variables
			COBJ__SwapMatches();
			@pull match_from; @pull token_filter; @pull match_length;
			pcount = spcount;
			jump CodeOne;
		}
	}
	pcount = spcount;
	wn = swn;	
	
	#ifdef COBJ_DEBUG;
	print "nothing interesting]^";
	#endif;
	cobj_flag = 2;
	jump CodeTwo;
];

[ ScoreDabCombo a b  result;
	@push action; @push act_requester; @push noun; @push second;
	action = action_to_be;
	act_requester = player;
	if (action_reversed) { noun = b; second = a; }
	else { noun = a; second = b; }
	result = CheckDPMR();
	@pull second; @pull noun; @pull act_requester; @pull action;
	#ifdef COBJ_DEBUG;
	print "[", (the) a, " / ", (the) b, " => ", result, "]^";
	#endif;
	return result;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Parser.i6t: Default Topic
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DefaultTopic; return GPR_FAIL; ];



[ ParserError error_type;
	if (error_type) PrintSingleParagraph(error_type);
	rfalse;
];

Object InformLibrary "(Inform Library)" has proper;

Array Protect_I7_Arrays --> 16339 12345;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Order of Play
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Main
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global EarlyInTurnSequence;
Global IterationsOfTurnSequence;

[ Main;
	#ifdef TARGET_ZCODE; max_z_object = #largest_object - 255; #endif;
	ClearRTP();
	FollowRulebook(STARTUP_RB);
	#ifdef DEBUG; InternalTestCases(); #endif;
	while (true) {
		while (deadflag == false) {
			EarlyInTurnSequence = true;
			action = ##Wait; meta = false; noun = nothing; second = nothing;
			actor = player;
			FollowRulebook(TURN_SEQUENCE_RB);
			IterationsOfTurnSequence++;
		}
		if (FollowRulebook(SHUTDOWN_RB) == false) return;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Virtual Machine Startup Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VIRTUAL_MACHINE_STARTUP_R;
	CarryOutActivity(STARTING_VIRTUAL_MACHINE_ACT);
	VM_Initialise();
	print "^^^";
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Initial Situation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant PLAYER_OBJECT_INIS = 0;
Constant START_OBJECT_INIS = 1;
Constant START_ROOM_INIS = 2;
Constant START_TIME_INIS = 3;
Constant DONE_INIS = 4;

Array InitialSituation --> selfobj I357_room_of_stuff I357_room_of_stuff 540 0;




! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Initialise Memory Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ INITIALISE_MEMORY_R;
	#ifdef TARGET_GLULX; VM_PreInitialise(); #Endif;
	#Ifdef LanguageInitialise; LanguageInitialise(); #Endif;

	not_yet_in_play = true;
	#ifdef I7_LOOKMODE; lookmode = I7_LOOKMODE; #endif;
	player = InitialSituation-->PLAYER_OBJECT_INIS;
	the_time = InitialSituation-->START_TIME_INIS;
	real_location = nothing;
	location = nothing;

	CreatePropertyOffsets();
	HeapInitialise(); ! Create a completely unused memory allocation heap
	StackFramingInitialise(); ! Create an empty stack
	CreateDynamicRelations(); ! Create relation structures on the heap

	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Seed Random Number Generator Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SEED_RANDOM_NUMBER_GENERATOR_R i;
	if (0) VM_Seed_RNG(0);
	for (i=1: i<=100: i++) random(i);
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Position Player In Model World Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ POSITION_PLAYER_IN_MODEL_R player_to_be;

	player = selfobj;
	player_to_be = InitialSituation-->PLAYER_OBJECT_INIS;
	
	location = LocationOf(player_to_be);
	if (location == 0) {
		location = InitialSituation-->START_ROOM_INIS;
		if (InitialSituation-->START_OBJECT_INIS)
			move player_to_be to InitialSituation-->START_OBJECT_INIS;
		else move player_to_be to location;
	}

	if (player_to_be ~= player) { remove selfobj; ChangePlayer(player_to_be); }
	else { real_location = location; SilentlyConsiderLight(); }

	NOTE_OBJECT_ACQUISITIONS_R(); MoveFloatingObjects();
	
	actor = player; act_requester = nothing; actors_location = real_location; action = ##Wait;

	InitialSituation-->DONE_INIS = true;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Parse Command Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant ACTION_PRES = 0;
Constant NO_INPS_PRES = 1;
Constant INP1_PRES = 2;
Constant INP2_PRES = 3; ! Parser.i6t code assumes this is INP1_PRES + 1

[ PARSE_COMMAND_R;
	if (EarlyInTurnSequence == false) rfalse; ! Prevent use outside top level
	not_yet_in_play = false;

	Parser__parse();
	TreatParserResults();
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Treat Parser Results
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TreatParserResults;
	if (parser_results-->ACTION_PRES == ##MistakeAction) meta = true;

	if (parser_results-->ACTION_PRES == ##Tell &&
		parser_results-->INP1_PRES == player && actor ~= player) {
		parser_results-->ACTION_PRES = ##Ask;
		parser_results-->INP1_PRES = actor; actor = player;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Generate Action Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GENERATE_ACTION_R i;
	if (EarlyInTurnSequence == false) rfalse; ! Prevent use outside top level
	EarlyInTurnSequence = false;

	action = parser_results-->ACTION_PRES;
	act_requester = nothing; if (actor ~= player) act_requester = player;

	inp1 = 0; inp2 = 0; multiflag = false;
	if (parser_results-->NO_INPS_PRES >= 1) {
		inp1 = parser_results-->INP1_PRES; if (inp1 == 0) multiflag = true;
	}
	if (parser_results-->NO_INPS_PRES >= 2) {
		inp2 = parser_results-->INP2_PRES; if (inp2 == 0) multiflag = true;
	}

	if (inp1 == 1) noun = nothing; else noun = inp1;
	if (inp2 == 1) second = nothing; else second = inp2;

	if (multiflag) {
		if (multiple_object-->0 == 0) {
			if (actor == player) { GENERATE_ACTION_RM('B'); new_line; }
			return;
		}
		if (toomany_flag) {
			toomany_flag = false;
			if (actor == player) { GENERATE_ACTION_RM('A'); }
		}
		i = multiple_object-->0;
		FollowRulebook(MULTIPLE_ACTION_PROCESSING_RB);
		if ((multiple_object-->0 == 1) && (i > 1)) {
			multiflag = false;
			if (inp1 == 0) noun = multiple_object-->1;
			if ((inp2 == 0) && (parser_results-->NO_INPS_PRES >= 2))
				second = multiple_object-->1;
		}
		if (multiple_object-->0 == 0) rfalse;
	}
	
	if (multiflag) {
		GenerateMultipleActions();
		multiflag = false;
	} else BeginAction(action, noun, second);

	if ((actor ~= player) || (act_requester)) action = ##Wait;
	actor = player; act_requester = 0;

	if (meta) { RulebookSucceeds(); rtrue; }
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Generate Multiple Actions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GenerateMultipleActions initial_location k item;
	initial_location = location;
	for (k=1: k<=multiple_object-->0: k++) {
		item = multiple_object-->k;
		RunParagraphOn();
		if (inp1 == 0) { inp1 = item; BeginAction(action, item, second, item); inp1 = 0; }
		else { inp2 = item; BeginAction(action, noun, item, item); inp2 = 0; }
		if (deadflag) return;
		if (location ~= initial_location) {
			if (player == actor) { ACTION_PROCESSING_INTERNAL_RM('J'); new_line; }
			return;
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Timed Events Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TIMED_EVENTS_R i d event_timer fire rule;
	for (i=1: i<=(TimedEventsTable-->0): i++)
		if ((rule=TimedEventsTable-->i) ~= 0) {
			event_timer = TimedEventTimesTable-->i; fire = false;
			if (event_timer<0) {
				(TimedEventTimesTable-->i)++;
				if (TimedEventTimesTable-->i == 0) fire = true;
			} else {
				d = (the_time - event_timer + TWENTY_FOUR_HOURS) % TWENTY_FOUR_HOURS;
				if ((d >= 0) && (d < 30)) fire = true;
			}
			if (fire) {
				TimedEventsTable-->i = 0;
				FollowRulebook(rule);
			}
		}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Setting Timed Events
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SetTimedEvent rule event_time absolute_time i b;
	for (i=1: i<=(TimedEventsTable-->0): i++) {
		if (rule == TimedEventsTable-->i) { b=i; break; }
		if ((b==0) && (TimedEventsTable-->i == 0)) b=i;
	}
	if (b==0) return RunTimeProblem(RTP_TOOMANYEVENTS);
	TimedEventsTable-->b = rule;
	if (absolute_time) TimedEventTimesTable-->b = event_time;
	else TimedEventTimesTable-->b = -event_time;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Setting Time Of Day
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global time_step;

[ SetTime t s;
    the_time = t; time_rate = s; time_step = 0;
    if (s < 0) time_step = 0-s;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Advance Time Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ADVANCE_TIME_R;
    turns++;
    if (the_time ~= NULL) {
        if (time_rate >= 0) the_time = the_time+time_rate;
        else {
            time_step--;
            if (time_step == 0) {
                the_time++;
                time_step = -time_rate;
            }
        }
        the_time = the_time % TWENTY_FOUR_HOURS;
    }
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Note Object Acquisitions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NOTE_OBJECT_ACQUISITIONS_R obj;
    objectloop (obj in player) give obj moved;
    objectloop (obj has concealed)
    	if (IndirectlyContains(player, obj)) give obj ~concealed;
    #Ifdef RUCKSACK_CLASS;
	objectloop (obj in player)
		if (obj ofclass RUCKSACK_CLASS)
			SACK_OBJECT = obj;
	objectloop (obj ofclass RUCKSACK_CLASS && obj provides component_parent
		&& obj.component_parent == player)
		SACK_OBJECT = obj;
	#Endif;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Resurrect Player If Asked Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RESURRECT_PLAYER_IF_ASKED_R;
	if (resurrect_please) {
		RulebookSucceeds(); resurrect_please = false;
		deadflag = 0; story_complete = false; rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Ask The Final Question Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ASK_FINAL_QUESTION_R;
	print "^";
	while (true) {
		CarryOutActivity(DEALING_WITH_FINAL_QUESTION_ACT);
		DivideParagraphPoint();
		if (resurrect_please) rtrue;
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Read The Final Answer Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ READ_FINAL_ANSWER_R;
	DrawStatusLine();
	KeyboardPrimitive(buffer, parse);
	players_command = 100 + WordCount();
	num_words = WordCount();
	wn = 1;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Immediately Restart VM Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IMMEDIATELY_RESTART_VM_R; @restart; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Immediately Restore Saved Game Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IMMEDIATELY_RESTORE_SAVED_R; actor = player; RESTORE_THE_GAME_R(); ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Immediately Quit Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IMMEDIATELY_QUIT_R; @quit; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Immediately Undo Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IMMEDIATELY_UNDO_R; Perform_Undo(); ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Print Obituary Headline Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PRINT_OBITUARY_HEADLINE_R;
    print "^^    ";
    VM_Style(ALERT_VMSTY);
    print "***";
    if (deadflag == 1) PRINT_OBITUARY_HEADLINE_RM('A');
    if (deadflag == 2) PRINT_OBITUARY_HEADLINE_RM('B');
    if (deadflag == 3) PRINT_OBITUARY_HEADLINE_RM('C');
    if (deadflag ~= 0 or 1 or 2 or 3)  {
        print " ";
        TEXT_TY_Say(deadflag);
        print " ";
    }
    print "***";
    VM_Style(NORMAL_VMSTY);
    print "^^"; #Ifndef NO_SCORING; print "^"; #Endif;
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Print Final Score Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PRINT_FINAL_SCORE_R;
	#Iftrue USE_SCORING ~= 0; ANNOUNCE_SCORE_R(); #Endif;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OrderOfPlay.i6t: Display Final Status Line Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DISPLAY_FINAL_STATUS_LINE_R;
	sline1 = score; sline2 = turns;
	rfalse;
];



Constant p3_list_grouping_key = list_together;
Constant p4_printed_name = short_name;
Constant p5_printed_plural_name = plural;
Constant p6_indefinite_article = article;
Constant p7_description = description;
Constant p8_map_region = map_region;
Constant p9_initial_appearance = initial;
Constant p11_other_side = door_to;
Constant p12_carrying_capacity = capacity;
Constant p13_matching_key = with_key;
Constant p39_most_recent_reference = most_recent_reference;
Constant p42_third_singular_pronoun = third_singular_pronoun;
Constant p50_plural_named = pluralname;
Constant p52_proper_named = proper;
Constant p54_ambiguously_plural = ambigpluralname;
Constant p55_privately_named = privately_named;
Constant p57_lighted = light;
Constant p59_visited = visited;
Constant p61_lit = light;
Constant p63_edible = edible;
Constant p65_fixed_in_place = static;
Constant p67_scenery = scenery;
Constant p68_wearable = clothing;
Constant p69_pushable_between_rooms = pushable;
Constant p70_handled = moved;
Constant p72_undescribed = concealed;
Constant p73_marked_for_listing = workflag;
Constant p75_mentioned = mentioned;
Constant p77_enterable = enterable;
Constant p79_transparent = transparent;
Constant p80_open = open;
Constant p82_openable = openable;
Constant p84_lockable = lockable;
Constant p85_locked = locked;
Constant p87_neuter = neuter;
Constant p88_male = male;
Constant p89_female = female;
Constant p90_nomale = nomale;
Constant p91_switched_on = on;
Constant p170 = vector;
Constant p171 = room_index;
Constant p172 = door_dir;
Constant p173 = door_to;
Constant p174 = found_in;
Constant p175 = absent;
Constant p176 = cap_short_name;
Constant p177 = mark_as_room;
Constant p178 = mark_as_thing;
Constant p179 = component_parent;
Constant p180 = component_child;
Constant p181 = component_sibling;
Constant p182 = regional_found_in;
Constant p183 = IK1_Count;
Constant p184 = IK1_Link;
Constant p185 = IK2_Count;
Constant p186 = IK2_Link;
Constant p187 = IK3_Count;
Constant p188 = IK3_Link;
Constant p189 = IK4_Count;
Constant p190 = IK4_Link;
Constant p191 = IK5_Count;
Constant p192 = IK5_Link;
Constant p193 = IK6_Count;
Constant p194 = IK6_Link;
Constant p195 = IK7_Count;
Constant p196 = IK7_Link;
Constant p197 = IK8_Count;
Constant p198 = IK8_Link;
Constant p199 = IK9_Count;
Constant p200 = IK9_Link;
Constant p201 = IK10_Count;
Constant p202 = IK10_Link;
Constant p203 = IK11_Count;
Constant p204 = IK11_Link;
Constant p205 = IK12_Count;
Constant p206 = IK12_Link;
Constant p207 = IK13_Count;
Constant p208 = IK13_Link;
Constant p209 = IK14_Count;
Constant p210 = IK14_Link;
Constant p211 = IK15_Count;
Constant p212 = IK15_Link;
Constant p213 = IK16_Count;
Constant p214 = IK16_Link;
Constant p215 = IK17_Count;
Constant p216 = IK17_Link;
Constant p217 = IK18_Count;
Constant p218 = IK18_Link;
Constant p219 = IK19_Count;
Constant p220 = IK19_Link;
Constant p221 = IK20_Count;
Constant p222 = IK20_Link;
Constant p223 = IK21_Count;
Constant p224 = IK21_Link;
Constant p225 = IK22_Count;
Constant p226 = IK22_Link;
Constant p227 = IK23_Count;
Constant p228 = IK23_Link;
Constant p229 = IK24_Count;
Constant p230 = IK24_Link;
Constant p231 = IK25_Count;
Constant p232 = IK25_Link;
Constant p233 = IK26_Count;
Constant p234 = IK26_Link;
Constant p235 = IK27_Count;
Constant p236 = IK27_Link;
Constant p237 = IK28_Count;
Constant p238 = IK28_Link;
Constant p239 = IK29_Count;
Constant p240 = IK29_Link;
Constant p241 = IK30_Count;
Constant p242 = IK30_Link;
Constant p243 = IK31_Count;
Constant p244 = IK31_Link;
Constant p245 = IK32_Count;
Constant p246 = IK32_Link;
Constant p247 = IK33_Count;
Constant p248 = IK33_Link;
Constant p249 = IK34_Count;
Constant p250 = IK34_Link;
Constant p251 = IK35_Count;
Constant p252 = IK35_Link;
Constant p253 = IK36_Count;
Constant p254 = IK36_Link;
Constant p255 = IK37_Count;
Constant p256 = IK37_Link;
Constant p257 = KD_Count;
Constant p258 = name;
Constant p259 = parse_name;
Constant p260 = action_bitmap;

Attribute p95_seen;
Attribute p97_familiar;
Attribute p99_powered;
Attribute p100_dimly_lit;
Attribute p103_rainy;
Attribute p105_outdoor_adjacent;
Attribute p108_audible;
Attribute p109_noisy;
Attribute p111_insistent;
Attribute p114_caller_id;
Attribute p115_mobile;
Constant FBNA_PROP_NUMBER = p93_recurring;
Object property_numberspace_forcer
    with p93_recurring false
    with p117_identifiable false
    with p123_mc_enabled false
    with p127_always_indefinite false
    with p128_activated false
    with p129_marked_for_special_list false
    with p136_available false
    with p137_exhausted false
    with p139_fluorescent false
    with p141_one_shot false
    with p145_universal false
    with p146_always_available false
    with p152_hyperspatial false
    with p153_front_locked false
    with p154_back_locked false
    with p155_front_openable false
    with p156_back_openable false
    with p157_front_closable false
    with p158_back_closable false
    with p159_front_locks_the_back false
    with p160_front_locks_the_front false
    with p161_back_locks_the_back false
    with p162_back_locks_the_front false
    with p163_close_lock_the_back false
    with p164_close_lock_the_front false
    with p165_autolock_the_back false
    with p166_autolock_the_front false
    with p167_auto_closable false
    with p168_time_locked false
    with p169_swipable false
;

Array property_metadata -->
    ! offset 0: property p0_specification
    "specification" NULL
    ! offset 2: property p1_indefinite_appearance_tex
    "indefinite appearance text" NULL
    ! offset 4: property p2_variable_initial_value
    "variable initial value" K1_room K2_thing K3_direction K9_region K19_fact K25_behavior K36_pronoun NULL
    ! offset 13: property list_together
    "list grouping key" K1_room K2_thing K3_direction K9_region K19_fact K25_behavior K36_pronoun NULL
    ! offset 22: property short_name
    "printed name" K1_room K2_thing K3_direction K9_region K19_fact K25_behavior K36_pronoun NULL
    ! offset 31: property plural
    "printed plural name" K1_room K2_thing K3_direction K9_region K19_fact K25_behavior K36_pronoun NULL
    ! offset 40: property article
    "indefinite article" K1_room K2_thing K3_direction K9_region K19_fact K25_behavior K36_pronoun NULL
    ! offset 49: property description
    "description" K1_room K2_thing NULL
    ! offset 53: property map_region
    "map region" K1_room NULL
    ! offset 56: property initial
    "initial appearance" K2_thing NULL
    ! offset 59: property p10_opposite
    "opposite" K3_direction NULL
    ! offset 62: property door_to
    "other side" K4_door NULL
    ! offset 65: property capacity
    "carrying capacity" K5_container K6_supporter K8_person NULL
    ! offset 70: property with_key
    "matching key" K2_thing K4_door K5_container NULL
    ! offset 75: property p14_adaptive_text_viewpoint
    "adaptive text viewpoint" NULL
    ! offset 77: property p15_dark_description
    "dark description" K1_room K2_thing NULL
    ! offset 81: property p16_hearability
    "hearability" K2_thing NULL
    ! offset 84: property p17_volume
    "volume" K2_thing NULL
    ! offset 87: property p18_reception
    "reception" K1_room NULL
    ! offset 90: property p19_balance
    "balance" K22_money_card NULL
    ! offset 93: property p20_price
    "price" K2_thing NULL
    ! offset 96: property p21_preposition
    "preposition" K1_room NULL
    ! offset 99: property p22_behavior_stack
    "behavior stack" K8_person NULL
    ! offset 102: property p23_target_location
    "target location" K8_person NULL
    ! offset 105: property p24_destination_name
    "destination name" K1_room NULL
    ! offset 108: property p25_behind_description
    "behind description" K2_thing NULL
    ! offset 111: property p26_remembrances
    "remembrances" K8_person NULL
    ! offset 114: property p27_comment
    "comment" K29_quip NULL
    ! offset 117: property p28_reply
    "reply" K29_quip NULL
    ! offset 120: property p29_queue
    "queue" K8_person NULL
    ! offset 123: property p30_frontside
    "frontside" K30_two_sided_door NULL
    ! offset 126: property p31_close_delay
    "close delay" K30_two_sided_door NULL
    ! offset 129: property p32_time_lock_delay
    "time lock delay" K30_two_sided_door NULL
    ! offset 132: property p33_front_description
    "front description" K30_two_sided_door NULL
    ! offset 135: property p34_back_description
    "back description" K30_two_sided_door NULL
    ! offset 138: property p35_description_policy
    "description policy" K30_two_sided_door NULL
    ! offset 141: property p36_lock_countdown
    "lock countdown" K30_two_sided_door NULL
    ! offset 144: property p37_close_countdown
    "close countdown" K30_two_sided_door NULL
    ! offset 147: property p38_how_are_you_reply
    "how-are-you-reply" K8_person NULL
    ! offset 150: property most_recent_reference
    "most recent reference" K1_room K2_thing K3_direction K9_region K19_fact K25_behavior K36_pronoun NULL
    ! offset 159: property p40_grammatical_person
    "grammatical-person" K36_pronoun NULL
    ! offset 162: property p41_declensions
    "declensions" K36_pronoun NULL
    ! offset 165: property third_singular_pronoun
    "third singular pronoun" K1_room K2_thing K3_direction K9_region K19_fact K25_behavior K36_pronoun NULL
    ! offset 174: property p43_third_plural_pronoun
    "third-plural-pronoun" K2_thing NULL
    ! offset 177: property p44_first_singular_pronoun
    "first-singular-pronoun" K8_person NULL
    ! offset 180: property p45_first_plural_pronoun
    "first-plural-pronoun" K8_person NULL
    ! offset 183: property p46_second_singular_pronoun
    "second-singular-pronoun" K8_person NULL
    ! offset 186: property p47_second_plural_pronoun
    "second-plural-pronoun" K8_person NULL
    ! offset 189: property p48_possessive
    "possessive" K2_thing NULL
    ! offset 192: property p49_portrait
    "portrait" K2_thing NULL
    ! offset 195: property pluralname
    "plural-named" K1_room K2_thing K3_direction K9_region K19_fact K25_behavior K36_pronoun NULL
    ! offset 204: property proper
    "proper-named" K1_room K2_thing K3_direction K9_region K19_fact K25_behavior K36_pronoun NULL
    ! offset 213: property ambigpluralname
    "ambiguously plural" K1_room K2_thing K3_direction K9_region K19_fact K25_behavior K36_pronoun NULL
    ! offset 222: property privately_named
    "privately-named" K1_room K2_thing K3_direction K9_region NULL
    ! offset 228: property light
    "lighted" K1_room K2_thing NULL
    ! offset 232: property visited
    "visited" K1_room NULL
    ! offset 235: property light
    "lit" K1_room K2_thing NULL
    ! offset 239: property edible
    "edible" K2_thing NULL
    ! offset 242: property static
    "fixed in place" K2_thing NULL
    ! offset 245: property scenery
    "scenery" K2_thing NULL
    ! offset 248: property clothing
    "wearable" K2_thing NULL
    ! offset 251: property pushable
    "pushable between rooms" K2_thing NULL
    ! offset 254: property moved
    "handled" K2_thing NULL
    ! offset 257: property concealed
    "undescribed" K2_thing NULL
    ! offset 260: property workflag
    "marked for listing" K2_thing K3_direction NULL
    ! offset 264: property mentioned
    "mentioned" K2_thing NULL
    ! offset 267: property enterable
    "enterable" K5_container K6_supporter K18_unenterable_room NULL
    ! offset 272: property transparent
    "transparent" K5_container NULL
    ! offset 275: property open
    "open" K4_door K5_container NULL
    ! offset 279: property openable
    "openable" K4_door K5_container NULL
    ! offset 283: property lockable
    "lockable" K4_door K5_container NULL
    ! offset 287: property locked
    "locked" K4_door K5_container NULL
    ! offset 291: property neuter
    "neuter" K2_thing K36_pronoun NULL
    ! offset 295: property male
    "male" K2_thing NULL
    ! offset 298: property female
    "female" K2_thing NULL
    ! offset 301: property nomale
    "nomale" K2_thing NULL
    ! offset 304: property on
    "switched on" K14_device NULL
    ! offset 307: property p93_recurring
    "recurring" NULL
    ! offset 309: property p95_seen
    "seen" K2_thing NULL
    ! offset 312: property p97_familiar
    "familiar" K2_thing NULL
    ! offset 315: property p99_powered
    "powered" K9_region NULL
    ! offset 318: property p100_dimly_lit
    "dimly lit" K1_room NULL
    ! offset 321: property p102_room_condition
    "room condition" K1_room NULL
    ! offset 324: property p103_rainy
    "rainy" I159_weather NULL
    ! offset 327: property p105_outdoor_adjacent
    "outdoor-adjacent" K1_room NULL
    ! offset 330: property p106_summary
    "summary" K1_room K2_thing K3_direction K9_region K19_fact K25_behavior K36_pronoun NULL
    ! offset 339: property p107_knowledge_relation_stor
    "knowledge relation storage" NULL
    ! offset 341: property p108_audible
    "audible" K2_thing NULL
    ! offset 344: property p109_noisy
    "noisy" K2_thing NULL
    ! offset 347: property p111_insistent
    "insistent" K2_thing NULL
    ! offset 350: property p113_phone_condition
    "phone condition" K20_phone NULL
    ! offset 353: property p114_caller_id
    "caller id" K20_phone NULL
    ! offset 356: property p115_mobile
    "mobile" K20_phone NULL
    ! offset 359: property p117_identifiable
    "identifiable" K20_phone NULL
    ! offset 362: property p119_talking_on_relation_sto
    "talking on relation storage" K8_person NULL
    ! offset 365: property p120_talking_with_relation_s
    "talking with relation storage" NULL
    ! offset 367: property p121_calling_to_relation_sto
    "calling to relation storage" K8_person NULL
    ! offset 370: property p122_reaches_relation_storag
    "reaches relation storage" K21_phone_number NULL
    ! offset 373: property p123_mc_enabled
    "mc-enabled" K22_money_card NULL
    ! offset 376: property p125_owner
    "owner" K2_thing NULL
    ! offset 379: property p126_vendor
    "vendor" K2_thing NULL
    ! offset 382: property p127_always_indefinite
    "always-indefinite" K1_room K2_thing K3_direction K9_region K19_fact K25_behavior K36_pronoun NULL
    ! offset 391: property p128_activated
    "activated" K8_person NULL
    ! offset 394: property p129_marked_for_special_list
    "marked for special listing" K1_room K2_thing K3_direction K9_region K19_fact K25_behavior K36_pronoun NULL
    ! offset 403: property p131_first_delimiter
    "first delimiter" NULL
    ! offset 405: property p132_second_delimiter
    "second delimiter" NULL
    ! offset 407: property p133_alternate_second_delimi
    "alternate second delimiter" NULL
    ! offset 409: property p134_indefinite_name_phrase
    "indefinite name phrase" NULL
    ! offset 411: property p135_definite_name_phrase
    "definite name phrase" NULL
    ! offset 413: property p136_available
    "available" K26_choice NULL
    ! offset 416: property p137_exhausted
    "exhausted" K26_choice K29_quip NULL
    ! offset 420: property p138_demoing_relation_storag
    "demoing relation storage" K26_choice NULL
    ! offset 423: property p139_fluorescent
    "fluorescent" K27_light_source NULL
    ! offset 426: property p140_behindness_relation_sto
    "behindness relation storage" K2_thing NULL
    ! offset 429: property p141_one_shot
    "one-shot" K29_quip NULL
    ! offset 432: property p143_quip_condition
    "quip condition" K29_quip NULL
    ! offset 435: property p144_quip_condition_2
    "quip condition 2" K29_quip NULL
    ! offset 438: property p145_universal
    "universal" K29_quip NULL
    ! offset 441: property p146_always_available
    "always-available" K29_quip NULL
    ! offset 444: property p147_quip_supplying_relation
    "quip-supplying relation storage" NULL
    ! offset 446: property p148_following_relation_stor
    "following relation storage" NULL
    ! offset 448: property p149_exclusion_relation_stor
    "exclusion relation storage" NULL
    ! offset 450: property p150_mentioning_relation_sto
    "mentioning relation storage" NULL
    ! offset 452: property p151_stocking_relation_stora
    "stocking relation storage" NULL
    ! offset 454: property p152_hyperspatial
    "hyperspatial" K3_direction NULL
    ! offset 457: property p153_front_locked
    "front-locked" K30_two_sided_door NULL
    ! offset 460: property p154_back_locked
    "back-locked" K30_two_sided_door NULL
    ! offset 463: property p155_front_openable
    "front-openable" K30_two_sided_door NULL
    ! offset 466: property p156_back_openable
    "back-openable" K30_two_sided_door NULL
    ! offset 469: property p157_front_closable
    "front-closable" K30_two_sided_door NULL
    ! offset 472: property p158_back_closable
    "back-closable" K30_two_sided_door NULL
    ! offset 475: property p159_front_locks_the_back
    "front-locks-the-back" K30_two_sided_door NULL
    ! offset 478: property p160_front_locks_the_front
    "front-locks-the-front" K30_two_sided_door NULL
    ! offset 481: property p161_back_locks_the_back
    "back-locks-the-back" K30_two_sided_door NULL
    ! offset 484: property p162_back_locks_the_front
    "back-locks-the-front" K30_two_sided_door NULL
    ! offset 487: property p163_close_lock_the_back
    "close-lock-the-back" K30_two_sided_door NULL
    ! offset 490: property p164_close_lock_the_front
    "close-lock-the-front" K30_two_sided_door NULL
    ! offset 493: property p165_autolock_the_back
    "autolock-the-back" K30_two_sided_door NULL
    ! offset 496: property p166_autolock_the_front
    "autolock-the-front" K30_two_sided_door NULL
    ! offset 499: property p167_auto_closable
    "auto-closable" K30_two_sided_door NULL
    ! offset 502: property p168_time_locked
    "time-locked" K30_two_sided_door NULL
    ! offset 505: property p169_swipable
    "swipable" K2_thing NULL
    ! offset 508: property vector
    "<nameless>" NULL
    ! offset 510: property room_index
    "<nameless>" NULL
    ! offset 512: property door_dir
    "<nameless>" NULL
    ! offset 514: property door_to
    "<nameless>" K4_door NULL
    ! offset 517: property found_in
    "<nameless>" NULL
    ! offset 519: property absent
    "<nameless>" NULL
    ! offset 521: property cap_short_name
    "<nameless>" NULL
    ! offset 523: property mark_as_room
    "<nameless>" NULL
    ! offset 525: property mark_as_thing
    "<nameless>" NULL
    ! offset 527: property component_parent
    "<nameless>" NULL
    ! offset 529: property component_child
    "<nameless>" NULL
    ! offset 531: property component_sibling
    "<nameless>" NULL
    ! offset 533: property regional_found_in
    "<nameless>" NULL
    ! offset 535: property IK1_Count
    "<nameless>" NULL
    ! offset 537: property IK1_Link
    "<nameless>" NULL
    ! offset 539: property IK2_Count
    "<nameless>" NULL
    ! offset 541: property IK2_Link
    "<nameless>" NULL
    ! offset 543: property IK3_Count
    "<nameless>" NULL
    ! offset 545: property IK3_Link
    "<nameless>" NULL
    ! offset 547: property IK4_Count
    "<nameless>" NULL
    ! offset 549: property IK4_Link
    "<nameless>" NULL
    ! offset 551: property IK5_Count
    "<nameless>" NULL
    ! offset 553: property IK5_Link
    "<nameless>" NULL
    ! offset 555: property IK6_Count
    "<nameless>" NULL
    ! offset 557: property IK6_Link
    "<nameless>" NULL
    ! offset 559: property IK7_Count
    "<nameless>" NULL
    ! offset 561: property IK7_Link
    "<nameless>" NULL
    ! offset 563: property IK8_Count
    "<nameless>" NULL
    ! offset 565: property IK8_Link
    "<nameless>" NULL
    ! offset 567: property IK9_Count
    "<nameless>" NULL
    ! offset 569: property IK9_Link
    "<nameless>" NULL
    ! offset 571: property IK10_Count
    "<nameless>" NULL
    ! offset 573: property IK10_Link
    "<nameless>" NULL
    ! offset 575: property IK11_Count
    "<nameless>" NULL
    ! offset 577: property IK11_Link
    "<nameless>" NULL
    ! offset 579: property IK12_Count
    "<nameless>" NULL
    ! offset 581: property IK12_Link
    "<nameless>" NULL
    ! offset 583: property IK13_Count
    "<nameless>" NULL
    ! offset 585: property IK13_Link
    "<nameless>" NULL
    ! offset 587: property IK14_Count
    "<nameless>" NULL
    ! offset 589: property IK14_Link
    "<nameless>" NULL
    ! offset 591: property IK15_Count
    "<nameless>" NULL
    ! offset 593: property IK15_Link
    "<nameless>" NULL
    ! offset 595: property IK16_Count
    "<nameless>" NULL
    ! offset 597: property IK16_Link
    "<nameless>" NULL
    ! offset 599: property IK17_Count
    "<nameless>" NULL
    ! offset 601: property IK17_Link
    "<nameless>" NULL
    ! offset 603: property IK18_Count
    "<nameless>" NULL
    ! offset 605: property IK18_Link
    "<nameless>" NULL
    ! offset 607: property IK19_Count
    "<nameless>" NULL
    ! offset 609: property IK19_Link
    "<nameless>" NULL
    ! offset 611: property IK20_Count
    "<nameless>" NULL
    ! offset 613: property IK20_Link
    "<nameless>" NULL
    ! offset 615: property IK21_Count
    "<nameless>" NULL
    ! offset 617: property IK21_Link
    "<nameless>" NULL
    ! offset 619: property IK22_Count
    "<nameless>" NULL
    ! offset 621: property IK22_Link
    "<nameless>" NULL
    ! offset 623: property IK23_Count
    "<nameless>" NULL
    ! offset 625: property IK23_Link
    "<nameless>" NULL
    ! offset 627: property IK24_Count
    "<nameless>" NULL
    ! offset 629: property IK24_Link
    "<nameless>" NULL
    ! offset 631: property IK25_Count
    "<nameless>" NULL
    ! offset 633: property IK25_Link
    "<nameless>" NULL
    ! offset 635: property IK26_Count
    "<nameless>" NULL
    ! offset 637: property IK26_Link
    "<nameless>" NULL
    ! offset 639: property IK27_Count
    "<nameless>" NULL
    ! offset 641: property IK27_Link
    "<nameless>" NULL
    ! offset 643: property IK28_Count
    "<nameless>" NULL
    ! offset 645: property IK28_Link
    "<nameless>" NULL
    ! offset 647: property IK29_Count
    "<nameless>" NULL
    ! offset 649: property IK29_Link
    "<nameless>" NULL
    ! offset 651: property IK30_Count
    "<nameless>" NULL
    ! offset 653: property IK30_Link
    "<nameless>" NULL
    ! offset 655: property IK31_Count
    "<nameless>" NULL
    ! offset 657: property IK31_Link
    "<nameless>" NULL
    ! offset 659: property IK32_Count
    "<nameless>" NULL
    ! offset 661: property IK32_Link
    "<nameless>" NULL
    ! offset 663: property IK33_Count
    "<nameless>" NULL
    ! offset 665: property IK33_Link
    "<nameless>" NULL
    ! offset 667: property IK34_Count
    "<nameless>" NULL
    ! offset 669: property IK34_Link
    "<nameless>" NULL
    ! offset 671: property IK35_Count
    "<nameless>" NULL
    ! offset 673: property IK35_Link
    "<nameless>" NULL
    ! offset 675: property IK36_Count
    "<nameless>" NULL
    ! offset 677: property IK36_Link
    "<nameless>" NULL
    ! offset 679: property IK37_Count
    "<nameless>" NULL
    ! offset 681: property IK37_Link
    "<nameless>" NULL
    ! offset 683: property KD_Count
    "<nameless>" NULL
    ! offset 685: property name
    "<nameless>" NULL
    ! offset 687: property parse_name
    "<nameless>" NULL
    ! offset 689: property action_bitmap
    "<nameless>" NULL
;

Constant attributed_property_offsets_SIZE 64;
Array attributed_property_offsets --> attributed_property_offsets_SIZE;
Constant valued_property_offsets_SIZE (100 + 261 + INDIV_PROP_START-48);
Array valued_property_offsets --> valued_property_offsets_SIZE;

[ CreatePropertyOffsets 
    i ! loop counter
    ;
    for (i=0: i<attributed_property_offsets_SIZE: i++)attributed_property_offsets-->i = -1;
    for (i=0: i<valued_property_offsets_SIZE: i++)valued_property_offsets-->i = -1;
    valued_property_offsets-->p0_specification = 0;
    valued_property_offsets-->p1_indefinite_appearance_tex = 2;
    valued_property_offsets-->p2_variable_initial_value = 4;
    valued_property_offsets-->list_together = 13;
    valued_property_offsets-->short_name = 22;
    valued_property_offsets-->plural = 31;
    valued_property_offsets-->article = 40;
    valued_property_offsets-->description = 49;
    valued_property_offsets-->map_region = 53;
    valued_property_offsets-->initial = 56;
    valued_property_offsets-->p10_opposite = 59;
    valued_property_offsets-->door_to = 62;
    valued_property_offsets-->capacity = 65;
    valued_property_offsets-->with_key = 70;
    valued_property_offsets-->p14_adaptive_text_viewpoint = 75;
    valued_property_offsets-->p15_dark_description = 77;
    valued_property_offsets-->p16_hearability = 81;
    valued_property_offsets-->p17_volume = 84;
    valued_property_offsets-->p18_reception = 87;
    valued_property_offsets-->p19_balance = 90;
    valued_property_offsets-->p20_price = 93;
    valued_property_offsets-->p21_preposition = 96;
    valued_property_offsets-->p22_behavior_stack = 99;
    valued_property_offsets-->p23_target_location = 102;
    valued_property_offsets-->p24_destination_name = 105;
    valued_property_offsets-->p25_behind_description = 108;
    valued_property_offsets-->p26_remembrances = 111;
    valued_property_offsets-->p27_comment = 114;
    valued_property_offsets-->p28_reply = 117;
    valued_property_offsets-->p29_queue = 120;
    valued_property_offsets-->p30_frontside = 123;
    valued_property_offsets-->p31_close_delay = 126;
    valued_property_offsets-->p32_time_lock_delay = 129;
    valued_property_offsets-->p33_front_description = 132;
    valued_property_offsets-->p34_back_description = 135;
    valued_property_offsets-->p35_description_policy = 138;
    valued_property_offsets-->p36_lock_countdown = 141;
    valued_property_offsets-->p37_close_countdown = 144;
    valued_property_offsets-->p38_how_are_you_reply = 147;
    valued_property_offsets-->most_recent_reference = 150;
    valued_property_offsets-->p40_grammatical_person = 159;
    valued_property_offsets-->p41_declensions = 162;
    valued_property_offsets-->third_singular_pronoun = 165;
    valued_property_offsets-->p43_third_plural_pronoun = 174;
    valued_property_offsets-->p44_first_singular_pronoun = 177;
    valued_property_offsets-->p45_first_plural_pronoun = 180;
    valued_property_offsets-->p46_second_singular_pronoun = 183;
    valued_property_offsets-->p47_second_plural_pronoun = 186;
    valued_property_offsets-->p48_possessive = 189;
    valued_property_offsets-->p49_portrait = 192;
    attributed_property_offsets-->pluralname = 195;
    attributed_property_offsets-->proper = 204;
    attributed_property_offsets-->ambigpluralname = 213;
    attributed_property_offsets-->privately_named = 222;
    attributed_property_offsets-->light = 228;
    attributed_property_offsets-->visited = 232;
    attributed_property_offsets-->light = 235;
    attributed_property_offsets-->edible = 239;
    attributed_property_offsets-->static = 242;
    attributed_property_offsets-->scenery = 245;
    attributed_property_offsets-->clothing = 248;
    attributed_property_offsets-->pushable = 251;
    attributed_property_offsets-->moved = 254;
    attributed_property_offsets-->concealed = 257;
    attributed_property_offsets-->workflag = 260;
    attributed_property_offsets-->mentioned = 264;
    attributed_property_offsets-->enterable = 267;
    attributed_property_offsets-->transparent = 272;
    attributed_property_offsets-->open = 275;
    attributed_property_offsets-->openable = 279;
    attributed_property_offsets-->lockable = 283;
    attributed_property_offsets-->locked = 287;
    attributed_property_offsets-->neuter = 291;
    attributed_property_offsets-->male = 295;
    attributed_property_offsets-->female = 298;
    attributed_property_offsets-->nomale = 301;
    attributed_property_offsets-->on = 304;
    valued_property_offsets-->p93_recurring = 307;
    attributed_property_offsets-->p95_seen = 309;
    attributed_property_offsets-->p97_familiar = 312;
    attributed_property_offsets-->p99_powered = 315;
    attributed_property_offsets-->p100_dimly_lit = 318;
    valued_property_offsets-->p102_room_condition = 321;
    attributed_property_offsets-->p103_rainy = 324;
    attributed_property_offsets-->p105_outdoor_adjacent = 327;
    valued_property_offsets-->p106_summary = 330;
    valued_property_offsets-->p107_knowledge_relation_stor = 339;
    attributed_property_offsets-->p108_audible = 341;
    attributed_property_offsets-->p109_noisy = 344;
    attributed_property_offsets-->p111_insistent = 347;
    valued_property_offsets-->p113_phone_condition = 350;
    attributed_property_offsets-->p114_caller_id = 353;
    attributed_property_offsets-->p115_mobile = 356;
    valued_property_offsets-->p117_identifiable = 359;
    valued_property_offsets-->p119_talking_on_relation_sto = 362;
    valued_property_offsets-->p120_talking_with_relation_s = 365;
    valued_property_offsets-->p121_calling_to_relation_sto = 367;
    valued_property_offsets-->p122_reaches_relation_storag = 370;
    valued_property_offsets-->p123_mc_enabled = 373;
    valued_property_offsets-->p125_owner = 376;
    valued_property_offsets-->p126_vendor = 379;
    valued_property_offsets-->p127_always_indefinite = 382;
    valued_property_offsets-->p128_activated = 391;
    valued_property_offsets-->p129_marked_for_special_list = 394;
    valued_property_offsets-->p131_first_delimiter = 403;
    valued_property_offsets-->p132_second_delimiter = 405;
    valued_property_offsets-->p133_alternate_second_delimi = 407;
    valued_property_offsets-->p134_indefinite_name_phrase = 409;
    valued_property_offsets-->p135_definite_name_phrase = 411;
    valued_property_offsets-->p136_available = 413;
    valued_property_offsets-->p137_exhausted = 416;
    valued_property_offsets-->p138_demoing_relation_storag = 420;
    valued_property_offsets-->p139_fluorescent = 423;
    valued_property_offsets-->p140_behindness_relation_sto = 426;
    valued_property_offsets-->p141_one_shot = 429;
    valued_property_offsets-->p143_quip_condition = 432;
    valued_property_offsets-->p144_quip_condition_2 = 435;
    valued_property_offsets-->p145_universal = 438;
    valued_property_offsets-->p146_always_available = 441;
    valued_property_offsets-->p147_quip_supplying_relation = 444;
    valued_property_offsets-->p148_following_relation_stor = 446;
    valued_property_offsets-->p149_exclusion_relation_stor = 448;
    valued_property_offsets-->p150_mentioning_relation_sto = 450;
    valued_property_offsets-->p151_stocking_relation_stora = 452;
    valued_property_offsets-->p152_hyperspatial = 454;
    valued_property_offsets-->p153_front_locked = 457;
    valued_property_offsets-->p154_back_locked = 460;
    valued_property_offsets-->p155_front_openable = 463;
    valued_property_offsets-->p156_back_openable = 466;
    valued_property_offsets-->p157_front_closable = 469;
    valued_property_offsets-->p158_back_closable = 472;
    valued_property_offsets-->p159_front_locks_the_back = 475;
    valued_property_offsets-->p160_front_locks_the_front = 478;
    valued_property_offsets-->p161_back_locks_the_back = 481;
    valued_property_offsets-->p162_back_locks_the_front = 484;
    valued_property_offsets-->p163_close_lock_the_back = 487;
    valued_property_offsets-->p164_close_lock_the_front = 490;
    valued_property_offsets-->p165_autolock_the_back = 493;
    valued_property_offsets-->p166_autolock_the_front = 496;
    valued_property_offsets-->p167_auto_closable = 499;
    valued_property_offsets-->p168_time_locked = 502;
    valued_property_offsets-->p169_swipable = 505;
    valued_property_offsets-->vector = 508;
    valued_property_offsets-->room_index = 510;
    valued_property_offsets-->door_dir = 512;
    valued_property_offsets-->door_to = 514;
    valued_property_offsets-->found_in = 517;
    attributed_property_offsets-->absent = 519;
    valued_property_offsets-->cap_short_name = 521;
    attributed_property_offsets-->mark_as_room = 523;
    attributed_property_offsets-->mark_as_thing = 525;
    valued_property_offsets-->component_parent = 527;
    valued_property_offsets-->component_child = 529;
    valued_property_offsets-->component_sibling = 531;
    valued_property_offsets-->regional_found_in = 533;
    valued_property_offsets-->IK1_Count = 535;
    valued_property_offsets-->IK1_Link = 537;
    valued_property_offsets-->IK2_Count = 539;
    valued_property_offsets-->IK2_Link = 541;
    valued_property_offsets-->IK3_Count = 543;
    valued_property_offsets-->IK3_Link = 545;
    valued_property_offsets-->IK4_Count = 547;
    valued_property_offsets-->IK4_Link = 549;
    valued_property_offsets-->IK5_Count = 551;
    valued_property_offsets-->IK5_Link = 553;
    valued_property_offsets-->IK6_Count = 555;
    valued_property_offsets-->IK6_Link = 557;
    valued_property_offsets-->IK7_Count = 559;
    valued_property_offsets-->IK7_Link = 561;
    valued_property_offsets-->IK8_Count = 563;
    valued_property_offsets-->IK8_Link = 565;
    valued_property_offsets-->IK9_Count = 567;
    valued_property_offsets-->IK9_Link = 569;
    valued_property_offsets-->IK10_Count = 571;
    valued_property_offsets-->IK10_Link = 573;
    valued_property_offsets-->IK11_Count = 575;
    valued_property_offsets-->IK11_Link = 577;
    valued_property_offsets-->IK12_Count = 579;
    valued_property_offsets-->IK12_Link = 581;
    valued_property_offsets-->IK13_Count = 583;
    valued_property_offsets-->IK13_Link = 585;
    valued_property_offsets-->IK14_Count = 587;
    valued_property_offsets-->IK14_Link = 589;
    valued_property_offsets-->IK15_Count = 591;
    valued_property_offsets-->IK15_Link = 593;
    valued_property_offsets-->IK16_Count = 595;
    valued_property_offsets-->IK16_Link = 597;
    valued_property_offsets-->IK17_Count = 599;
    valued_property_offsets-->IK17_Link = 601;
    valued_property_offsets-->IK18_Count = 603;
    valued_property_offsets-->IK18_Link = 605;
    valued_property_offsets-->IK19_Count = 607;
    valued_property_offsets-->IK19_Link = 609;
    valued_property_offsets-->IK20_Count = 611;
    valued_property_offsets-->IK20_Link = 613;
    valued_property_offsets-->IK21_Count = 615;
    valued_property_offsets-->IK21_Link = 617;
    valued_property_offsets-->IK22_Count = 619;
    valued_property_offsets-->IK22_Link = 621;
    valued_property_offsets-->IK23_Count = 623;
    valued_property_offsets-->IK23_Link = 625;
    valued_property_offsets-->IK24_Count = 627;
    valued_property_offsets-->IK24_Link = 629;
    valued_property_offsets-->IK25_Count = 631;
    valued_property_offsets-->IK25_Link = 633;
    valued_property_offsets-->IK26_Count = 635;
    valued_property_offsets-->IK26_Link = 637;
    valued_property_offsets-->IK27_Count = 639;
    valued_property_offsets-->IK27_Link = 641;
    valued_property_offsets-->IK28_Count = 643;
    valued_property_offsets-->IK28_Link = 645;
    valued_property_offsets-->IK29_Count = 647;
    valued_property_offsets-->IK29_Link = 649;
    valued_property_offsets-->IK30_Count = 651;
    valued_property_offsets-->IK30_Link = 653;
    valued_property_offsets-->IK31_Count = 655;
    valued_property_offsets-->IK31_Link = 657;
    valued_property_offsets-->IK32_Count = 659;
    valued_property_offsets-->IK32_Link = 661;
    valued_property_offsets-->IK33_Count = 663;
    valued_property_offsets-->IK33_Link = 665;
    valued_property_offsets-->IK34_Count = 667;
    valued_property_offsets-->IK34_Link = 669;
    valued_property_offsets-->IK35_Count = 671;
    valued_property_offsets-->IK35_Link = 673;
    valued_property_offsets-->IK36_Count = 675;
    valued_property_offsets-->IK36_Link = 677;
    valued_property_offsets-->IK37_Count = 679;
    valued_property_offsets-->IK37_Link = 681;
    valued_property_offsets-->KD_Count = 683;
    valued_property_offsets-->name = 685;
    valued_property_offsets-->parse_name = 687;
    valued_property_offsets-->action_bitmap = 689;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Properties (skipping)
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Activities
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant NUMBER_RULEBOOKS_CREATED = 576;
Constant V0_printing_the_name = 0;
Constant V1_printing_the_plural_name = 1;
Constant V2_printing_a_number = 2;
Constant V3_printing_room_description = 3;
Constant V4_printing_inventory_detail = 4;
Constant V5_listing_contents = 5;
Constant V6_grouping_together = 6;
Constant V7_writing_a_paragraph_about = 7;
Constant V8_listing_nondescript_items = 8;
Constant V9_printing_the_name_of_a_da = 9;
Constant V10_printing_the_description = 10;
Constant V11_printing_the_announcemen = 11;
Constant V12_printing_the_announcemen = 12;
Constant V13_printing_a_refusal_to_ac = 13;
Constant V14_constructing_the_status_ = 14;
Constant V15_printing_the_banner_text = 15;
Constant V16_reading_a_command = 16;
Constant V17_deciding_the_scope = 17;
Constant V18_deciding_the_concealed_p = 18;
Constant V19_deciding_whether_all_inc = 19;
Constant V20_clarifying_the_parser_s_ = 20;
Constant V21_asking_which_do_you_mean = 21;
Constant V22_printing_a_parser_error = 22;
Constant V23_supplying_a_missing_noun = 23;
Constant V24_supplying_a_missing_seco = 24;
Constant V25_implicitly_taking = 25;
Constant V26_starting_the_virtual_mac = 26;
Constant V27_amusing_a_victorious_pla = 27;
Constant V28_printing_the_player_s_ob = 28;
Constant V29_handling_the_final_quest = 29;
Constant V30_printing_the_locale_desc = 30;
Constant V31_choosing_notable_locale_ = 31;
Constant V32_printing_a_locale_paragr = 32;
Constant V33_issuing_the_response_tex = 33;
Constant V34_pausing_the_game = 34;
Constant V35_printing_insistent_sound = 35;
Constant V36_printing_background_soun = 36;
Constant V37_determining_the_subjecti = 37;
Constant V38_printing_the_sound_descr = 38;
Constant V39_printing_the_sound_actio = 39;
Constant V40_acting_as = 40;
Constant V41_behaving_as = 41;
Constant V42_initializing = 42;
Constant V43_list_arranging = 43;
Constant V44_delimiting_a_list = 44;
Constant V45_printing_the_options_par = 45;
Constant V46_listing_the_available_ch = 46;
Constant V47_queueing_quips_following = 47;
Constant V48_ruling_out_quips_followi = 48;
Constant V49_listing_the_available_qu = 49;

Array Activity_before_rulebooks --> 29 32 35 38 41 44 47 50 53 56 59 62 65 68 71 74 77 80 83 86 89 92 95 98 101 104 107 110 113 116 119 122 125 128 380 398 401 404 407 410 446 451 454 466 469 489 495 513 516 521 NULL;

Array Activity_for_rulebooks --> 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84 87 90 93 96 99 102 105 108 111 114 117 120 123 126 129 381 399 402 405 408 411 447 452 455 467 470 490 496 514 517 522 NULL;

Array Activity_after_rulebooks --> 31 34 37 40 43 46 49 52 55 58 61 64 67 70 73 76 79 82 85 88 91 94 97 100 103 106 109 112 115 118 121 124 127 130 382 400 403 406 409 412 448 453 456 468 471 491 497 515 518 523 NULL;

Array Activity_atb_rulebooks -> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ff;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RELS_SYMMETRIC $8000;
Constant RELS_EQUIVALENCE $4000;
Constant RELS_X_UNIQUE $2000;
Constant RELS_Y_UNIQUE $1000;
Constant RELS_TEST $0800;
Constant RELS_ASSERT_TRUE $0400;
Constant RELS_ASSERT_FALSE $0200;
Constant RELS_SHOW $0100;
Constant RELS_ROUTE_FIND $0080;
Constant RELS_ROUTE_FIND_COUNT $0040;
Constant RELS_LOOKUP_ANY $0008;
Constant RELS_LOOKUP_ALL_X $0004;
Constant RELS_LOOKUP_ALL_Y $0002;
Constant RELS_LIST $0001;
#Iftrue (WORDSIZE == 2);
Constant REL_BLOCK_HEADER ($100*5 + $$1101);
#Ifnot;
Constant REL_BLOCK_HEADER ($100*6 + $$1101)*$10000;
#Endif;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Printing Routines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintSceneName 
    value ! Implied call parameter
    ;
    switch(value) {
        I84_entire_game: print "Entire Game";
        I412_klimp_in_the_office: print "Klimp in-the-office";
        I413_moira_in_the_office: print "Moira in-the-office";
        I414_denouement: print "Denouement";
        default: print "<illegal scene>";
    }
];
[ A_PrintSceneName 
    value ! Implied call parameter
    ;
    return (value % 4)+1;
];
[ B_PrintSceneName 
    value ! Implied call parameter
    ;
    return ((value+2) % 4)+1;
];
[ R_PrintSceneName 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(4));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintFigureName 
    value ! Implied call parameter
    ;
    switch(value) {
        I83_figure_of_cover: print "Figure of cover";
        I500_figure_null: print "Figure Null";
        I501_figure_goldberg: print "Figure Goldberg";
        I502_figure_gaunt: print "Figure Gaunt";
        I503_figure_faraji: print "Figure Faraji";
        I504_figure_klimp: print "Figure Klimp";
        I505_figure_margaret: print "Figure Margaret";
        I506_figure_draco: print "Figure Draco";
        I507_figure_clerk: print "Figure Clerk";
        I508_figure_pawn_owner: print "Figure Pawn Owner";
        I509_figure_doris: print "Figure Doris";
        I510_figure_speech_bubble: print "Figure Speech Bubble";
        I511_figure_phone_handset: print "Figure Phone Handset";
        I512_figure_phone: print "Figure Phone";
        I513_figure_caller: print "Figure Caller";
        I514_figure_parking_lot: print "Figure Parking Lot";
        I515_figure_pawn_shop: print "Figure Pawn Shop";
        I516_figure_bosh: print "Figure BOSH";
        I517_figure_store: print "Figure Store";
        I518_figure_laundromat: print "Figure Laundromat";
        I519_figure_white_tunnel: print "Figure White Tunnel";
        I520_figure_moira: print "Figure Moira";
        I521_figure_hyperspace: print "Figure Hyperspace";
        I522_figure_enigma_lake: print "Figure Enigma Lake";
        I523_figure_enigma_park: print "Figure Enigma Park";
        I524_figure_engima_shore: print "Figure Engima Shore";
        I525_figure_field_office: print "Figure Field Office";
        I526_figure_maggie: print "Figure Maggie";
        I527_figure_minerva: print "Figure Minerva";
        I528_figure_christy: print "Figure Christy";
        default: print "<illegal figure name>";
    }
];
[ A_PrintFigureName 
    value ! Implied call parameter
    ;
    return (value % 30)+1;
];
[ B_PrintFigureName 
    value ! Implied call parameter
    ;
    return ((value+28) % 30)+1;
];
[ R_PrintFigureName 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(30));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintSoundName 
    value ! Implied call parameter
    ;
    switch(value) {
        default: print "<illegal sound name>";
    }
];
[ A_PrintSoundName 
    value ! Implied call parameter
    ;
    return (value % 0)+1;
];
[ B_PrintSoundName 
    value ! Implied call parameter
    ;
    return ((value+-2) % 0)+1;
];
[ R_PrintSoundName 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(0));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintExternalFileName 
    value ! Implied call parameter
    ;
    switch(value) {
        default: print "<illegal external file>";
    }
];
[ A_PrintExternalFileName 
    value ! Implied call parameter
    ;
    return (value % 0)+1;
];
[ B_PrintExternalFileName 
    value ! Implied call parameter
    ;
    return ((value+-2) % 0)+1;
];
[ R_PrintExternalFileName 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(0));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E55 
    value ! Implied call parameter
    ;
    switch(value) {
        I65_neuter_gender: print "neuter gender";
        I66_masculine_gender: print "masculine gender";
        I67_feminine_gender: print "feminine gender";
        I68_neitherine_gender: print "neitherine gender";
        default: print "<illegal grammatical gender>";
    }
];
[ A_E55 
    value ! Implied call parameter
    ;
    return (value % 4)+1;
];
[ B_E55 
    value ! Implied call parameter
    ;
    return ((value+2) % 4)+1;
];
[ R_E55 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(4));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E63 
    value ! Implied call parameter
    ;
    switch(value) {
        I77_german_language: print "German language";
        I78_italian_language: print "Italian language";
        I79_english_language: print "English language";
        I80_french_language: print "French language";
        I81_swedish_language: print "Swedish language";
        I82_spanish_language: print "Spanish language";
        default: print "<illegal natural language>";
    }
];
[ A_E63 
    value ! Implied call parameter
    ;
    return (value % 6)+1;
];
[ B_E63 
    value ! Implied call parameter
    ;
    return ((value+4) % 6)+1;
];
[ R_E63 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(6));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E64 
    value ! Implied call parameter
    ;
    switch(value) {
        I86_didn_t_understand_error: print "didn't understand error";
        I87_only_understood_as_far_a: print "only understood as far as error";
        I88_didn_t_understand_that_n: print "didn't understand that number error";
        I89_can_only_do_that_to_some: print "can only do that to something animate error";
        I90_can_t_see_any_such_thing: print "can't see any such thing error";
        I91_said_too_little_error: print "said too little error";
        I92_aren_t_holding_that_erro: print "aren't holding that error";
        I93_can_t_use_multiple_objec: print "can't use multiple objects error";
        I94_can_only_use_multiple_ob: print "can only use multiple objects error";
        I95_not_sure_what_it_refers_: print "not sure what it refers to error";
        I96_excepted_something_not_i: print "excepted something not included error";
        I97_not_a_verb_i_recognise_e: print "not a verb I recognise error";
        I98_not_something_you_need_t: print "not something you need to refer to error";
        I99_can_t_see_it_at_the_mome: print "can't see it at the moment error";
        I100_didn_t_understand_the_w: print "didn't understand the way that finished error";
        I101_not_enough_of_those_ava: print "not enough of those available error";
        I102_nothing_to_do_error: print "nothing to do error";
        I103_noun_did_not_make_sense: print "noun did not make sense in that context error";
        I104_referred_to_a_determina: print "referred to a determination of scope error";
        I105_i_beg_your_pardon_error: print "I beg your pardon error";
        I106_can_t_again_the_address: print "can't again the addressee error";
        I107_comma_can_t_begin_error: print "comma can't begin error";
        I108_can_t_see_whom_to_talk_: print "can't see whom to talk to error";
        I109_can_t_talk_to_inanimate: print "can't talk to inanimate things error";
        I110_didn_t_understand_addre: print "didn't understand addressee's last name error";
        default: print "<illegal command parser error>";
    }
];
[ A_E64 
    value ! Implied call parameter
    ;
    return (value % 25)+1;
];
[ B_E64 
    value ! Implied call parameter
    ;
    return ((value+23) % 25)+1;
];
[ R_E64 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(25));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E65 
    value ! Implied call parameter
    ;
    switch(value) {
        I112_present_tense: print "present tense";
        I113_past_tense: print "past tense";
        I114_perfect_tense: print "perfect tense";
        I115_past_perfect_tense: print "past perfect tense";
        I116_future_tense: print "future tense";
        default: print "<illegal grammatical tense>";
    }
];
[ A_E65 
    value ! Implied call parameter
    ;
    return (value % 5)+1;
];
[ B_E65 
    value ! Implied call parameter
    ;
    return ((value+3) % 5)+1;
];
[ R_E65 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(5));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E66 
    value ! Implied call parameter
    ;
    switch(value) {
        I118_first_person_singular: print "first person singular";
        I119_second_person_singular: print "second person singular";
        I120_third_person_singular: print "third person singular";
        I121_first_person_plural: print "first person plural";
        I122_second_person_plural: print "second person plural";
        I123_third_person_plural: print "third person plural";
        default: print "<illegal narrative viewpoint>";
    }
];
[ A_E66 
    value ! Implied call parameter
    ;
    return (value % 6)+1;
];
[ B_E66 
    value ! Implied call parameter
    ;
    return ((value+4) % 6)+1;
];
[ R_E66 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(6));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E67 
    value ! Implied call parameter
    ;
    switch(value) {
        I125_nominative: print "nominative";
        I126_accusative: print "accusative";
        default: print "<illegal grammatical case>";
    }
];
[ A_E67 
    value ! Implied call parameter
    ;
    return (value % 2)+1;
];
[ B_E67 
    value ! Implied call parameter
    ;
    return ((value+0) % 2)+1;
];
[ R_E67 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(2));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E69 
    value ! Implied call parameter
    ;
    switch(value) {
        I129_implicit: print "implicit";
        I130_explicit: print "explicit";
        default: print "<illegal protocol type>";
    }
];
[ A_E69 
    value ! Implied call parameter
    ;
    return (value % 2)+1;
];
[ B_E69 
    value ! Implied call parameter
    ;
    return ((value+0) % 2)+1;
];
[ R_E69 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(2));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E70 
    value ! Implied call parameter
    ;
    switch(value) {
        I132_all_styles: print "all-styles";
        I133_normal_style: print "normal-style";
        I134_italic_style: print "italic-style";
        I135_fixed_letter_spacing_st: print "fixed-letter-spacing-style";
        I136_header_style: print "header-style";
        I137_bold_style: print "bold-style";
        I138_alert_style: print "alert-style";
        I139_note_style: print "note-style";
        I140_blockquote_style: print "blockquote-style";
        I141_input_style: print "input-style";
        I142_special_style_1: print "special-style-1";
        I143_special_style_2: print "special-style-2";
        default: print "<illegal glulx text style>";
    }
];
[ A_E70 
    value ! Implied call parameter
    ;
    return (value % 12)+1;
];
[ B_E70 
    value ! Implied call parameter
    ;
    return ((value+10) % 12)+1;
];
[ R_E70 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(12));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E71 
    value ! Implied call parameter
    ;
    switch(value) {
        I145_left_justified: print "left-justified";
        I146_left_right_justified: print "left-right-justified";
        I147_center_justified: print "center-justified";
        I148_right_justified: print "right-justified";
        default: print "<illegal text justification>";
    }
];
[ A_E71 
    value ! Implied call parameter
    ;
    return (value % 4)+1;
];
[ B_E71 
    value ! Implied call parameter
    ;
    return ((value+2) % 4)+1;
];
[ R_E71 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(4));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E72 
    value ! Implied call parameter
    ;
    switch(value) {
        I150_light_weight: print "light-weight";
        I151_regular_weight: print "regular-weight";
        I152_bold_weight: print "bold-weight";
        default: print "<illegal font weight>";
    }
];
[ A_E72 
    value ! Implied call parameter
    ;
    return (value % 3)+1;
];
[ B_E72 
    value ! Implied call parameter
    ;
    return ((value+1) % 3)+1;
];
[ R_E72 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(3));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E74 
    value ! Implied call parameter
    ;
    switch(value) {
        I156_indoors: print "indoors";
        I157_outdoors: print "outdoors";
        I158_floating: print "floating";
        default: print "<illegal room condition>";
    }
];
[ A_E74 
    value ! Implied call parameter
    ;
    return (value % 3)+1;
];
[ B_E74 
    value ! Implied call parameter
    ;
    return ((value+1) % 3)+1;
];
[ R_E74 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(3));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E76 
    value ! Implied call parameter
    ;
    switch(value) {
        I173_very_loud: print "very loud";
        I174_loud: print "loud";
        I175_moderately_loud: print "moderately loud";
        I176_faint: print "faint";
        I177_very_faint: print "very faint";
        I178_inaudible: print "inaudible";
        default: print "<illegal loudness>";
    }
];
[ A_E76 
    value ! Implied call parameter
    ;
    return (value % 6)+1;
];
[ B_E76 
    value ! Implied call parameter
    ;
    return ((value+4) % 6)+1;
];
[ R_E76 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(6));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E78 
    value ! Implied call parameter
    ;
    switch(value) {
        I181_ringing: print "ringing";
        I182_idle: print "idle";
        I183_in_use: print "in use";
        default: print "<illegal phone condition>";
    }
];
[ A_E78 
    value ! Implied call parameter
    ;
    return (value % 3)+1;
];
[ B_E78 
    value ! Implied call parameter
    ;
    return ((value+1) % 3)+1;
];
[ R_E78 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(3));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E85 
    value ! Implied call parameter
    ;
    switch(value) {
        I196_bare: print "bare";
        I197_definite: print "definite";
        I198_indefinite: print "indefinite";
        default: print "<illegal articulation style>";
    }
];
[ A_E85 
    value ! Implied call parameter
    ;
    return (value % 3)+1;
];
[ B_E85 
    value ! Implied call parameter
    ;
    return ((value+1) % 3)+1;
];
[ R_E85 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(3));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E86 
    value ! Implied call parameter
    ;
    switch(value) {
        I200_sequential: print "sequential";
        I201_disjunctive: print "disjunctive";
        I202_semi_colon: print "semi-colon";
        I203_comma: print "comma";
        I204_null: print "null";
        I205_hyperconnective: print "hyperconnective";
        I206_fragmentary: print "fragmentary";
        I207_enumerated: print "enumerated";
        default: print "<illegal list style>";
    }
];
[ A_E86 
    value ! Implied call parameter
    ;
    return (value % 8)+1;
];
[ B_E86 
    value ! Implied call parameter
    ;
    return ((value+6) % 8)+1;
];
[ R_E86 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(8));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E87 
    value ! Implied call parameter
    ;
    switch(value) {
        I210_enabled: print "enabled";
        I211_disabled: print "disabled";
        default: print "<illegal listing_state>";
    }
];
[ A_E87 
    value ! Implied call parameter
    ;
    return (value % 2)+1;
];
[ B_E87 
    value ! Implied call parameter
    ;
    return ((value+0) % 2)+1;
];
[ R_E87 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(2));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E88 
    value ! Implied call parameter
    ;
    switch(value) {
        I213_show_unvisited: print "show-unvisited";
        I214_dont_show_unvisited: print "dont-show-unvisited";
        default: print "<illegal visiting-mark>";
    }
];
[ A_E88 
    value ! Implied call parameter
    ;
    return (value % 2)+1;
];
[ B_E88 
    value ! Implied call parameter
    ;
    return ((value+0) % 2)+1;
];
[ R_E88 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(2));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E93 
    value ! Implied call parameter
    ;
    switch(value) {
        I223_questioning: print "questioning";
        I224_informative: print "informative";
        I225_performative: print "performative";
        default: print "<illegal quip condition>";
    }
];
[ A_E93 
    value ! Implied call parameter
    ;
    return (value % 3)+1;
];
[ B_E93 
    value ! Implied call parameter
    ;
    return ((value+1) % 3)+1;
];
[ R_E93 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(3));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E94 
    value ! Implied call parameter
    ;
    switch(value) {
        I227_ubiquitous: print "ubiquitous";
        I228_ignored: print "ignored";
        I229_plausibility_normal: print "plausibility-normal";
        default: print "<illegal quip condition 2>";
    }
];
[ A_E94 
    value ! Implied call parameter
    ;
    return (value % 3)+1;
];
[ B_E94 
    value ! Implied call parameter
    ;
    return ((value+1) % 3)+1;
];
[ R_E94 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(3));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E95 
    value ! Implied call parameter
    ;
    switch(value) {
        I266_timer_event: print "timer-event";
        I267_char_event: print "char-event";
        I268_line_event: print "line-event";
        I269_mouse_event: print "mouse-event";
        I270_arrange_event: print "arrange-event";
        I271_redraw_event: print "redraw-event";
        I272_sound_notify_event: print "sound-notify-event";
        I273_hyperlink_event: print "hyperlink-event";
        default: print "<illegal g-event>";
    }
];
[ A_E95 
    value ! Implied call parameter
    ;
    return (value % 8)+1;
];
[ B_E95 
    value ! Implied call parameter
    ;
    return ((value+6) % 8)+1;
];
[ R_E95 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(8));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E96 
    value ! Implied call parameter
    ;
    switch(value) {
        I275_g_null: print "g-null";
        I276_g_above: print "g-above";
        I277_g_below: print "g-below";
        I278_g_left: print "g-left";
        I279_g_right: print "g-right";
        default: print "<illegal glulx window position>";
    }
];
[ A_E96 
    value ! Implied call parameter
    ;
    return (value % 5)+1;
];
[ B_E96 
    value ! Implied call parameter
    ;
    return ((value+3) % 5)+1;
];
[ R_E96 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(5));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E98 
    value ! Implied call parameter
    ;
    switch(value) {
        I282_describe_always: print "describe-always";
        I283_only_open: print "only open";
        I284_never: print "never";
        default: print "<illegal door description policy>";
    }
];
[ A_E98 
    value ! Implied call parameter
    ;
    return (value % 3)+1;
];
[ B_E98 
    value ! Implied call parameter
    ;
    return ((value+1) % 3)+1;
];
[ R_E98 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(3));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E99 
    value ! Implied call parameter
    ;
    switch(value) {
        I286_front: print "front";
        I287_xback: print "xback";
        default: print "<illegal side>";
    }
];
[ A_E99 
    value ! Implied call parameter
    ;
    return (value % 2)+1;
];
[ B_E99 
    value ! Implied call parameter
    ;
    return ((value+0) % 2)+1;
];
[ R_E99 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(2));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E105 
    value ! Implied call parameter
    ;
    switch(value) {
        I391_nominal: print "nominal";
        I392_pronominal: print "pronominal";
        default: print "<illegal most-recent-reference-value>";
    }
];
[ A_E105 
    value ! Implied call parameter
    ;
    return (value % 2)+1;
];
[ B_E105 
    value ! Implied call parameter
    ;
    return ((value+0) % 2)+1;
];
[ R_E105 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(2));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E108 
    value ! Implied call parameter
    ;
    switch(value) {
        I408__startup: print "_startup";
        I409__normal: print "_normal";
        I410_picking_character: print "picking character";
        default: print "<illegal play mode>";
    }
];
[ A_E108 
    value ! Implied call parameter
    ;
    return (value % 3)+1;
];
[ B_E108 
    value ! Implied call parameter
    ;
    return ((value+1) % 3)+1;
];
[ R_E108 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(3));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ E80 
    value ! Implied call parameter
    which ! Implied call parameter
    rem ! internal use only
    S ! internal use only
    ;
    if (value == 0) jump Use_LP_0;
    if (NUMBER_TY_Abs(value) >= 1) jump Use_LP_0;
    jump Use_LP_0;
    rtrue;

    ! $1, scaling: x units --> 1 x + 0 stored at runtime (int) (defined as benchmark * 1)
    .Use_LP_0;
    print "$";
    print value;
    if (rem > 0) {
        print ".";
        ! M = 1, ceiling(log_10(M)) = 1
        S = 1;
        while ((rem % 10 == 0) && (rem > 0)) {
            rem = rem/10;
            S = S/10;
        }
        while (rem < S/10) {
            print "0";
            S = S/10;
        }
        print rem;
    }
    rtrue;
];
[ R_E80 
    a ! Implied call parameter
    b ! Implied call parameter
    ;
    if (a == 0 && b == 0) return (random(MAX_POSITIVE_NUMBER));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintKindValuePair 
    k ! Implied call parameter
    v ! Implied call parameter
    ;
    k = KindAtomic(k);
      switch(k) {
        2: print (DA_Number) v;
        3: print (DA_Number) v;
        4: print (DA_Number) v;
        5: print (DA_Number) v;
        6: print (DA_Number) v;
        7: print (DA_Number) v;
        8: print (DA_Number) v;
        9: print (DA_Number) v;
        10: print (PrintShortName) v;
        11: print (DecimalNumber) v;
        12: print (REAL_NUMBER_TY_Say) v;
        13: print (DA_TruthState) v;
        14: print (TEXT_TY_Say) v;
        15: print (DecimalNumber) v;
        16: print (PrintUseOption) v;
        17: print (PrintResponse) v;
        18: print (PrintVerbAsValue) v;
        19: print (PrintSnippet) v;
        20: print (PrintTableName) v;
        21: print (DA_Number) v;
        22: print (RulebookOutcomePrintingRule) v;
        23: print (DecimalNumber) v;
        25: print (DecimalNumber) v;
        27: print (SayPhraseName) v;
        28: print (DecimalNumber) v;
        29: print (DecimalNumber) v;
        30: print (RELATION_TY_Say) v;
        31: print (RulePrintingRule) v;
        32: print (RulePrintingRule) v;
        33: print (DecimalNumber) v;
        34: print (LIST_OF_TY_Say) v;
        35: print (DecimalNumber) v;
        36: print (PROPERTY_TY_Say) v;
        37: print (DecimalNumber) v;
        38: print (COMBINATION_TY_Say) v;
        39: print (DecimalNumber) v;
        40: print (STORED_ACTION_TY_Say) v;
        41: print (SayActionName) v;
        42: print (PrintTimeOfDay) v;
        43: print (PrintSceneName) v;
        44: print (PrintFigureName) v;
        45: print (PrintSoundName) v;
        46: print (PrintExternalFileName) v;
        47: print (E55) v;
        48: print (E63) v;
        49: print (E64) v;
        50: print (E65) v;
        51: print (E66) v;
        52: print (E67) v;
        53: print (E69) v;
        54: print (E70) v;
        55: print (E71) v;
        56: print (E72) v;
        57: print (E74) v;
        58: print (E76) v;
        59: print (E78) v;
        60: print (E80) v;
        61: print (E85) v;
        62: print (E86) v;
        63: print (E87) v;
        64: print (E88) v;
        65: print (E93) v;
        66: print (E94) v;
        67: print (E95) v;
        68: print (E96) v;
        69: print (E98) v;
        70: print (E99) v;
        71: print (E105) v;
        72: print (E108) v;
        default: print v;
    }
];
[ DefaultValueOfKOV 
    sk ! Implied call parameter
    k ! weak kind ID
    ;
    k = KindAtomic(sk);
    switch(k) {
        10: return nothing;
        11: return 0;
        12: return 0;
        13: return false;
        14: return BlkValueCreate(sk);
        15: return 32;
        16: return 0;
        17: return 0;
        18: return ConjugateVerb_0;
        19: return 101;
        20: return TheEmptyTable;
        21: return 0;
        22: return RBNO_0;
        23: return DefaultTopic;
        25: return ;
        34: return BlkValueCreate(sk);
        39: return ;
        40: return BlkValueCreate(sk);
        41: return ##Wait;
        42: return 540;
        43: return I84_entire_game;
        44: return I83_figure_of_cover;
        45: return ;
        46: return ;
        47: return I65_neuter_gender;
        48: return I77_german_language;
        49: return I86_didn_t_understand_error;
        50: return I112_present_tense;
        51: return I118_first_person_singular;
        52: return I125_nominative;
        53: return I129_implicit;
        54: return I132_all_styles;
        55: return I145_left_justified;
        56: return I150_light_weight;
        57: return I156_indoors;
        58: return I173_very_loud;
        59: return I181_ringing;
        60: return 0;
        61: return I196_bare;
        62: return I200_sequential;
        63: return I210_enabled;
        64: return I213_show_unvisited;
        65: return I223_questioning;
        66: return I227_ubiquitous;
        67: return I266_timer_event;
        68: return I275_g_null;
        69: return I282_describe_always;
        70: return I286_front;
        71: return I391_nominal;
        72: return I408__startup;
        default: return 0;
    }
];
[ KOVComparisonFunction 
    k ! Implied call parameter
    ;
    k = KindAtomic(k);
    switch(k) {
        10: return UnsignedCompare;
        12: return REAL_NUMBER_TY_Compare;
        13: return UnsignedCompare;
        14: return BlkValueCompare;
        15: return UnsignedCompare;
        16: return UnsignedCompare;
        17: return UnsignedCompare;
        18: return UnsignedCompare;
        19: return UnsignedCompare;
        20: return UnsignedCompare;
        21: return UnsignedCompare;
        22: return UnsignedCompare;
        23: return UnsignedCompare;
        25: return UnsignedCompare;
        34: return BlkValueCompare;
        39: return UnsignedCompare;
        40: return BlkValueCompare;
        41: return UnsignedCompare;
        43: return UnsignedCompare;
        44: return UnsignedCompare;
        45: return UnsignedCompare;
        46: return UnsignedCompare;
        default: return 0;
    }
];
[ KOVDomainSize 
    k ! Implied call parameter
    ;
    k = KindAtomic(k);
    switch(k) {
        43: return 4;
        44: return 30;
        45: return 0;
        46: return 0;
        47: return 4;
        48: return 6;
        49: return 25;
        50: return 5;
        51: return 6;
        52: return 2;
        53: return 2;
        54: return 12;
        55: return 4;
        56: return 3;
        57: return 3;
        58: return 6;
        59: return 3;
        61: return 3;
        62: return 8;
        63: return 2;
        64: return 2;
        65: return 3;
        66: return 3;
        67: return 8;
        68: return 5;
        69: return 3;
        70: return 2;
        71: return 2;
        72: return 3;
        default: return 0;
    }
];
[ KOVIsBlockValue 
    k ! Implied call parameter
    ;
    k = KindAtomic(k);
    if (k == 14 or 30 or 34 or 38 or 40) rtrue;
    rfalse;
];
[ KOVSupportFunction 
    k ! Implied call parameter
    fail ! Implied call parameter
    ;
    k = KindAtomic(k);
    switch(k) {
        14: return TEXT_TY_Support;
        30: return RELATION_TY_Support;
        34: return LIST_OF_TY_Support;
        38: return COMBINATION_TY_Support;
        40: return STORED_ACTION_TY_Support;
    }
    if (fail) BlkValueError(fail);
    rfalse;
];

[ I7_Kind_Name 
    k ! Implied call parameter
    ;
    if (k == K1_room) print "room";
    if (k == K2_thing) print "thing";
    if (k == K3_direction) print "direction";
    if (k == K4_door) print "door";
    if (k == K5_container) print "container";
    if (k == K6_supporter) print "supporter";
    if (k == K7_backdrop) print "backdrop";
    if (k == K8_person) print "person";
    if (k == K9_region) print "region";
    if (k == K10_man) print "man";
    if (k == K11_woman) print "woman";
    if (k == K12_nonbinary) print "nonbinary";
    if (k == K13_animal) print "animal";
    if (k == K14_device) print "device";
    if (k == K15_vehicle) print "vehicle";
    if (k == K16_player_s_holdall) print "player's holdall";
    if (k == K17_subject) print "subject";
    if (k == K18_unenterable_room) print "unenterable room";
    if (k == K19_fact) print "fact";
    if (k == K20_phone) print "phone";
    if (k == K21_phone_number) print "phone number";
    if (k == K22_money_card) print "money card";
    if (k == K23_drawer) print "drawer";
    if (k == K24_desk) print "desk";
    if (k == K25_behavior) print "behavior";
    if (k == K26_choice) print "choice";
    if (k == K27_light_source) print "light source";
    if (k == K28_memory) print "memory";
    if (k == K29_quip) print "quip";
    if (k == K30_two_sided_door) print "two-sided door";
    if (k == K31_pushbar_door) print "pushbar door";
    if (k == K32_shop_door) print "shop-door";
    if (k == K33_card_key) print "card key";
    if (k == K34_swipe_lock) print "swipe lock";
    if (k == K35_swipe_door) print "swipe door";
    if (k == K36_pronoun) print "pronoun";
    if (k == K37_third_person_personal_pr) print "third-person-personal-pronoun";
];

Constant RBNO_0 = "allow access";
Constant RBNO_1 = "deny access";
Constant RBNO_2 = "there is sufficient light";
Constant RBNO_3 = "there is insufficient light";
Constant RBNO_4 = "persuasion succeeds";
Constant RBNO_5 = "persuasion fails";
Constant RBNO_6 = "it is very likely";
Constant RBNO_7 = "it is likely";
Constant RBNO_8 = "it is possible";
Constant RBNO_9 = "it is unlikely";
Constant RBNO_10 = "it is very unlikely";
Constant RBNO_11 = "it does not";
Constant RBNO_12 = "it does";
Constant RBNO_13 = "very loud";
Constant RBNO_14 = "loud";
Constant RBNO_15 = "moderately loud";
Constant RBNO_16 = "faint";
Constant RBNO_17 = "very faint";
Constant RBNO_18 = "inaudible";
Constant RBNO_19 = "noisy";
Constant RBNO_20 = "quiet";
Constant RBNO_21 = "always available";
Constant RBNO_22 = "when queued";
Constant RBNO_23 = "unless not queued";
Constant RBNO_24 = "never available";
Constant RBNO_25 = "it is plausible";
Constant RBNO_26 = "it is dubious";
Constant RBNO_27 = "it is implausible";
Constant RBNO_28 = "replace player input";
Constant RBNO_29 = "require input to continue";
[ RulebookOutcomePrintingRule 
    rbno ! Implied call parameter
    ;
    if (rbno == 0) print "(no outcome)";
    else print (string) rbno; rfalse;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Object Tree
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


Array KindHierarchy --> K0_kind (0) K1_room (0) K2_thing (0) K3_direction (0) K4_door (2) K5_container (2) K6_supporter (2) K7_backdrop (2) K8_person (2) K9_region (0) K10_man (8) K11_woman (8) K12_nonbinary (8) K13_animal (8) K14_device (2) K15_vehicle (5) K16_player_s_holdall (5) K17_subject (2) K18_unenterable_room (2) K19_fact (0) K20_phone (2) K21_phone_number (19) K22_money_card (2) K23_drawer (5) K24_desk (6) K25_behavior (0) K26_choice (2) K27_light_source (2) K28_memory (2) K29_quip (2) K30_two_sided_door (4) K31_pushbar_door (30) K32_shop_door (30) K33_card_key (2) K34_swipe_lock (2) K35_swipe_door (30) K36_pronoun (0) K37_third_person_personal_pr (36) ;
Constant IK1_First = I154_room_of_subjects;
Constant IK2_First = I159_weather;
Constant IK3_First = I51_north;
Constant IK4_First = I303_laundromat_door;
Constant IK5_First = I469_heating_vent;
Constant IK6_First = I457_coffee_table;
Constant IK7_First = I192_walls;
Constant IK8_First = I249_maggie;
Constant IK9_First = I219_marsh_street;
Constant IK10_First = I254_doris;
Constant IK11_First = I249_maggie;
Constant IK12_First = I256_christy;
Constant IK13_First = nothing;
Constant IK14_First = I338_light_switch;
Constant IK15_First = nothing;
Constant IK16_First = nothing;
Constant IK17_First = I160_motives;
Constant IK18_First = I296_office_;
Constant IK19_First = I162_generic_truth;
Constant IK20_First = I420_klimp_s_mobile_phone;
Constant IK21_First = I421_klimp_s_mobile_phone_nu;
Constant IK22_First = I437_bureau_credit_card;
Constant IK23_First = I431_biff_s_desk_s_drawer;
Constant IK24_First = I430_biff_s_desk;
Constant IK25_First = I190_doing_nothing;
Constant IK26_First = nothing;
Constant IK27_First = I332_ls_light;
Constant IK28_First = I465_finding_the_drive_befor;
Constant IK29_First = I230_generic_quip;
Constant IK30_First = I303_laundromat_door;
Constant IK31_First = nothing;
Constant IK32_First = I303_laundromat_door;
Constant IK33_First = nothing;
Constant IK34_First = nothing;
Constant IK35_First = nothing;
Constant IK36_First = I395_i_pronoun;
Constant IK37_First = nothing;
Constant No_Directions = 22;
! Table of direction object alias constants:
Constant DirectionObject_0 = I51_north;
Constant DirectionObject_1 = I52_northeast;
Constant DirectionObject_2 = I53_northwest;
Constant DirectionObject_3 = I54_south;
Constant DirectionObject_4 = I55_southeast;
Constant DirectionObject_5 = I56_southwest;
Constant DirectionObject_6 = I57_east;
Constant DirectionObject_7 = I58_west;
Constant DirectionObject_8 = I59_up;
Constant DirectionObject_9 = I60_down;
Constant DirectionObject_10 = in_obj;
Constant DirectionObject_11 = out_obj;
Constant DirectionObject_12 = I233_back;
Constant DirectionObject_13 = I234_forth;
Constant DirectionObject_14 = I235_forthnorth;
Constant DirectionObject_15 = I236_fortheast;
Constant DirectionObject_16 = I237_forthsouth;
Constant DirectionObject_17 = I238_forthwest;
Constant DirectionObject_18 = I239_backnorth;
Constant DirectionObject_19 = I240_backeast;
Constant DirectionObject_20 = I241_backsouth;
Constant DirectionObject_21 = I242_backwest;
Array Map_Storage -->
 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I154_room_of_subjects
 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I216_room_of_choices
 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I231_room_of_quips
 I244_featureless_hyperplane I244_featureless_hyperplane I244_featureless_hyperplane I244_featureless_hyperplane I244_featureless_hyperplane I244_featureless_hyperplane I244_featureless_hyperplane I244_featureless_hyperplane 0 I248_field_office_reception 0 0 I244_featureless_hyperplane I244_featureless_hyperplane I244_featureless_hyperplane I244_featureless_hyperplane I244_featureless_hyperplane I244_featureless_hyperplane I244_featureless_hyperplane I244_featureless_hyperplane I244_featureless_hyperplane I244_featureless_hyperplane ! Exits from: I244_featureless_hyperplane
 0 0 0 0 0 0 0 I250_field_office_hallway I244_featureless_hyperplane 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I248_field_office_reception
 I251_minerva_s_office 0 0 I255_christy_s_office 0 0 I248_field_office_reception I253_field_office_chief_s_of 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I250_field_office_hallway
 0 0 0 I250_field_office_hallway 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I251_minerva_s_office
 0 0 0 0 0 0 I250_field_office_hallway 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I253_field_office_chief_s_of
 I250_field_office_hallway 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I255_christy_s_office
 I312_strip_mall_parking_lot_ 0 I303_laundromat_door 0 0 I308_pawn_shop_door 0 I295_the_front_office 0 0 I295_the_front_office 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I294_strip_mall_parking_lot_
 0 0 0 0 0 0 I294_strip_mall_parking_lot_ I452_bosh_office_hallway 0 0 0 I294_strip_mall_parking_lot_ 0 0 0 0 0 0 0 0 0 0 ! Exits from: I295_the_front_office
 0 0 0 0 I303_laundromat_door 0 0 I329_laundromat_back_room 0 0 0 0 0 0 0 0 0 0 0 0 I339_astral_tunnel_3 0 ! Exits from: I304_laundromat_store
 0 I308_pawn_shop_door 0 0 0 0 0 0 0 0 0 I294_strip_mall_parking_lot_ 0 0 0 0 0 0 0 0 0 0 ! Exits from: I309_dave_s_pawn_shop
 0 0 0 I294_strip_mall_parking_lot_ 0 0 I340_li_l_nectarine_convenie 0 0 0 I340_li_l_nectarine_convenie 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I312_strip_mall_parking_lot_
 I326_astral_tunnel_2 0 0 0 0 0 0 0 0 0 0 0 0 I325_back_lot 0 0 0 0 0 0 0 0 ! Exits from: I324_astral_tunnel_1
 I447_laundromat_back_door 0 0 0 0 0 I367_bosh_back_door 0 0 0 0 0 I324_astral_tunnel_1 0 0 0 0 0 0 0 0 0 ! Exits from: I325_back_lot
 0 0 0 I324_astral_tunnel_1 0 0 0 0 0 0 0 0 0 I329_laundromat_back_room 0 0 0 0 0 0 0 0 ! Exits from: I326_astral_tunnel_2
 0 0 0 I447_laundromat_back_door 0 0 I304_laundromat_store 0 0 I330_laundromat_basement 0 0 I326_astral_tunnel_2 0 0 0 0 0 0 0 0 0 ! Exits from: I329_laundromat_back_room
 0 0 0 I331_back_basement 0 0 0 0 I329_laundromat_back_room 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I330_laundromat_basement
 I330_laundromat_basement 0 0 0 0 0 0 0 0 0 0 0 0 I339_astral_tunnel_3 0 0 0 0 0 0 0 0 ! Exits from: I331_back_basement
 0 0 0 0 0 0 0 0 0 0 0 0 I331_back_basement 0 I304_laundromat_store 0 0 0 0 0 0 0 ! Exits from: I339_astral_tunnel_3
 0 0 0 0 0 0 0 I312_strip_mall_parking_lot_ 0 0 0 I312_strip_mall_parking_lot_ 0 0 0 0 0 0 0 0 0 0 ! Exits from: I340_li_l_nectarine_convenie
 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I357_room_of_stuff
 I371_enigma_park 0 0 I372_main_street_200_block 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I370_enigma_lake_town_hall
 I381_lake_shore_north_of_the 0 0 I370_enigma_lake_town_hall 0 0 I378_lake_street_by_the_park 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I371_enigma_park
 I370_enigma_lake_town_hall 0 0 I388_rolle_s_department_stor 0 0 I376_main_at_lake I373_main_at_solvay 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I372_main_street_200_block
 I374_solvay_road_by_the_fire 0 0 I387_henry_s_hot_skillet 0 I386_fresnel_s_music I372_main_street_200_block I385_reading_room 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I373_main_at_solvay
 I375_solvay_road_leading_out 0 0 I373_main_at_solvay 0 0 0 I384_hook_n_ladder_company 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I374_solvay_road_by_the_fire
 I382_lake_shore_west 0 0 I374_solvay_road_by_the_fire 0 0 0 I383_horton_house 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I375_solvay_road_leading_out
 I377_lake_street_by_the_cour 0 0 0 0 0 0 I372_main_street_200_block 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I376_main_at_lake
 I378_lake_street_by_the_park 0 0 I376_main_at_lake 0 0 I389_municipal_courthouse 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I377_lake_street_by_the_cour
 I380_lake_at_ridge 0 0 I377_lake_street_by_the_cour 0 0 I379_first_unitarian_church_ I371_enigma_park 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I378_lake_street_by_the_park
 0 0 0 0 0 0 0 I378_lake_street_by_the_park 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I379_first_unitarian_church_
 0 0 0 I378_lake_street_by_the_park 0 0 0 I381_lake_shore_north_of_the 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I380_lake_at_ridge
 0 0 0 I371_enigma_park 0 0 I380_lake_at_ridge I382_lake_shore_west 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I381_lake_shore_north_of_the
 0 0 0 I375_solvay_road_leading_out 0 0 I381_lake_shore_north_of_the 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I382_lake_shore_west
 0 0 0 0 0 0 I375_solvay_road_leading_out 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I383_horton_house
 0 0 0 0 0 0 I374_solvay_road_by_the_fire 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I384_hook_n_ladder_company
 0 0 0 0 0 0 I373_main_at_solvay 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I385_reading_room
 0 I373_main_at_solvay 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I386_fresnel_s_music
 I373_main_at_solvay 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I387_henry_s_hot_skillet
 I372_main_street_200_block 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I388_rolle_s_department_stor
 0 0 0 0 0 0 0 I377_lake_street_by_the_cour 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I389_municipal_courthouse
 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I411_isolation_booth
 I451_biff_s_door 0 0 0 0 0 0 I367_bosh_back_door 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I429_biff_s_office
 I455_moira_s_door 0 0 I451_biff_s_door 0 0 I295_the_front_office I453_klimp_s_door 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I452_bosh_office_hallway
 0 0 0 0 0 0 I453_klimp_s_door 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I454_bosh_chief_s_office
 0 0 0 I455_moira_s_door 0 0 I494_closet_door 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I456_moira_s_office
 0 0 0 0 0 0 0 I494_closet_door 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I495_utility_closet
;

Class VPH_Class;
Array KOV_representatives --> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ValuePropertyHolder_43 0 0 0 0 ValuePropertyHolder_48 0 0 0 0 0 0 0 0 0 0 0 0 0 ValuePropertyHolder_62 0 0 0 0 0 0 0 0 0 0 ;
VPH_Class ValuePropertyHolder_43
    with value_range 4
    with p93_recurring KOVP_43_P93
    with description KOVP_43_P7
;
! Storage for property p93_recurring of kind SCENE_TY
Array KOVP_43_P93 table 0 0 (true) (false) (false) (false) ;
! Storage for property description of kind SCENE_TY
Array KOVP_43_P7 table 0 0 (BC_3) (BC_4) (BC_5) (BC_6) ;
VPH_Class ValuePropertyHolder_48
    with value_range 6
    with p14_adaptive_text_viewpoint KOVP_48_P14
;
! Storage for property p14_adaptive_text_viewpoint of kind 
Array KOVP_48_P14 table 0 0 (I118_first_person_singular) (I118_first_person_singular) (I121_first_person_plural) (I118_first_person_singular) (I118_first_person_singular) (I118_first_person_singular) ;
VPH_Class ValuePropertyHolder_62
    with value_range 8
    with p131_first_delimiter tab_11_1
    with p132_second_delimiter tab_11_2
    with p133_alternate_second_delimi tab_11_3
    with p134_indefinite_name_phrase tab_11_4
    with p135_definite_name_phrase tab_11_5
;
! Storage for property p131_first_delimiter of kind 
Array KOVP_62_P131 table 0 0 (BC_7) (BC_8) (BC_9) (BC_10) (BC_11) (BC_12) (BC_13) (BC_14) ;
! Storage for property p132_second_delimiter of kind 
Array KOVP_62_P132 table 0 0 (BC_15) (BC_16) (BC_17) (BC_18) (BC_19) (BC_20) (BC_21) (BC_22) ;
! Storage for property p133_alternate_second_delimi of kind 
Array KOVP_62_P133 table 0 0 (BC_23) (BC_24) (BC_25) (BC_26) (BC_27) (BC_28) (BC_29) (BC_30) ;
! Storage for property p134_indefinite_name_phrase of kind 
Array KOVP_62_P134 table 0 0 (BC_31) (BC_32) (BC_33) (BC_34) (BC_35) (BC_36) (BC_37) (BC_38) ;
! Storage for property p135_definite_name_phrase of kind 
Array KOVP_62_P135 table 0 0 (BC_39) (BC_40) (BC_41) (BC_42) (BC_43) (BC_44) (BC_45) (BC_46) ;
Class K0_kind 
    with third_singular_pronoun I397_it_pronoun
    has ~pluralname
    has ~proper
    with p127_always_indefinite false
    with p129_marked_for_special_list false
    with list_together BC_47
    with short_name BC_48
    with plural BC_49
    with article BC_50
    has ~ambigpluralname
    with p106_summary BC_51
    with most_recent_reference I391_nominal
;

Class K1_room 
    class K0_kind
    with description BC_52
    with map_region nothing
    with p18_reception 1
    with p21_preposition BC_53
    with p24_destination_name BC_54
    has ~privately_named
    has light
    has ~visited
    with p102_room_condition I156_indoors
    with p15_dark_description BC_55
    has ~p100_dimly_lit
    has ~p105_outdoor_adjacent
    with list_together BC_56
    with short_name BC_57
    with plural BC_58
    with article BC_59
    with p106_summary BC_60
;

Class K2_thing 
    class K0_kind
    with p17_volume 0
    with most_recent_reference I391_nominal
    with p43_third_plural_pronoun I402_they_pronoun
    with p48_possessive BC_61
    with p49_portrait I500_figure_null
    has ~privately_named
    has ~light
    has ~edible
    has ~static
    has ~concealed
    has ~workflag
    has mentioned
    has neuter
    has ~male
    has ~female
    has ~nomale
    has ~p95_seen
    has ~p97_familiar
    has ~p109_noisy
    has ~p111_insistent
    with component_parent nothing
    with component_child nothing
    with component_sibling nothing
    with parse_name [ 
        original_wn ! first word of text parsed
        group_wn ! first word matched against A/B/C/... disjunction
        try_from_wn ! position to try matching from
        n ! number of words matched
        f ! flag: sufficiently good match found to justify success
        w ! for use by individual grammar lines
        rv ! for use by individual grammar lines
        g ! temporary: success flag for parsing visibles
        ss ! temporary: saves 'self' in distinguishing visibles
        spn ! temporary: saves 'parsed_number' in parsing visibles
        pass ! pass counter (1 to 3)
        pass1_n ! value of n recorded during pass 1
        pass2_n ! value of n recorded during pass 2
        ;
        #ifdef DEBUG;
        if (parser_trace >= 3) print "Parse_name called^";
        #endif;
        original_wn = wn;
        for (pass = 1: pass <= 3: pass++) {
            wn = original_wn;
            try_from_wn = wn; f = false; n = 0;
            while (true) {
                ! On pass 1 only, advance wn past name property words
                ! (but do not do this for ##TheSame, when wn is undefined)
                if ((parser_action ~= ##TheSame) && (pass == 1)) {
                    while (WordInProperty(NextWordStopped(), self, name)) f = true;
                    wn--; try_from_wn = wn;
                }
                if (pass == 1 or 2) {
                    if (parser_action==##TheSame) {
                        #ifdef DEBUG;
                        if (parser_trace >= 4) print "p1, p2 = ", parser_one, ", ", parser_two, "^";
                        #endif;
                        ss = self;
                        ! Distinguishing property p48_possessive
                        if (TEXT_TY_Distinguish(parser_one.p48_possessive, parser_two.p48_possessive)) return -2;
                        self = ss; return 0;
                    }
                    ! Match any number of visible property values
                    try_from_wn = wn; g = true; while (g) {
                        g = false;
                        ! Parsing property p48_possessive
                        wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                            try_from_wn = wn;
                            g = true;
                            f = true;
                        }
                        parsed_number = spn; etype = ss;
                    }
                    ! try_from_wn is now advanced past any visible property values
                    wn = try_from_wn;
                }
                if ((parser_action ~= ##TheSame) && (pass == 1)) {
                    while (WordInProperty(NextWordStopped(), self, name)) f = true;
                    wn--; try_from_wn = wn;
                }
                break;
            } ! End of endless loop
            while (WordInProperty(NextWordStopped(), self, name)) n++;
            if ((f) || (n>0)) n = n + try_from_wn - original_wn;
            if (pass == 1) pass1_n = n;
            if (pass == 2) pass2_n = n;
        } ! End of pass loop
        #ifdef DEBUG;
        if (parser_trace >= 3)
            print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
        #endif;
        if (pass1_n > n) n = pass1_n;
        if (pass2_n > n) n = pass2_n;
        wn = original_wn + n;
        if (n == 0) return -1;
        DetectPluralWord(original_wn, n);
        return n;
    ],
    with action_bitmap 0 0 0 0 0 0 0 0 
    has ~scenery
    has ~clothing
    has ~pushable
    has ~moved
    with description BC_62
    with initial BC_63
    with with_key nothing
    with p15_dark_description BC_64
    has ~p108_audible
    with p16_hearability I173_very_loud
    with p20_price 0
    with p125_owner nothing
    with p126_vendor nothing
    with p140_behindness_relation_sto nothing
    with p25_behind_description BC_65
    with p169_swipable false
    with list_together BC_66
    with short_name BC_67
    with plural BC_68
    with article BC_69
    with p106_summary BC_70
;

Class K6_supporter 
    class K2_thing

    	has transparent supporter

    with plural BC_71
    with capacity 100
    has static
    has ~enterable
    with description BC_72
    with initial BC_73
    with p15_dark_description BC_74
    with p25_behind_description BC_75
    with p48_possessive BC_76
    with list_together BC_77
    with short_name BC_78
    with article BC_79
    with p106_summary BC_80
;

Class K24_desk 
    class K6_supporter
    with plural BC_81
    with description BC_82
    with initial BC_83
    with p15_dark_description BC_84
    with p25_behind_description BC_85
    with p48_possessive BC_86
    with list_together BC_87
    with short_name BC_88
    with article BC_89
    with p106_summary BC_90
;

Class K8_person 
    class K2_thing

    	has transparent animate
    	with before NULL,

    with plural BC_91
    with capacity 100
    with p22_behavior_stack BC_92
    with third_singular_pronoun I403_singular_they_pronoun
    with p44_first_singular_pronoun I395_i_pronoun
    with p45_first_plural_pronoun I396_we_pronoun
    with p46_second_singular_pronoun I400_singular_you_pronoun
    with p47_second_plural_pronoun I401_plural_you_pronoun
    has ~neuter
    has male
    has female
    has nomale
    with p128_activated false
    with p119_talking_on_relation_sto nothing
    with p121_calling_to_relation_sto nothing
    with p23_target_location I154_room_of_subjects
    with p26_remembrances BC_93
    with p29_queue BC_94
    with p38_how_are_you_reply BC_95
    with description BC_96
    with initial BC_97
    with p15_dark_description BC_98
    with p25_behind_description BC_99
    with p48_possessive BC_100
    with list_together BC_101
    with short_name BC_102
    with article BC_103
    with p106_summary BC_104
;

Class K10_man 
    class K8_person
    with plural BC_105
    with third_singular_pronoun I398_he_pronoun
    has ~neuter
    has male
    has ~female
    has ~nomale
    with p22_behavior_stack BC_106
    with p26_remembrances BC_107
    with p29_queue BC_108
    with p38_how_are_you_reply BC_109
    with description BC_110
    with initial BC_111
    with p15_dark_description BC_112
    with p25_behind_description BC_113
    with p48_possessive BC_114
    with list_together BC_115
    with short_name BC_116
    with article BC_117
    with p106_summary BC_118
;

Class K11_woman 
    class K8_person
    with plural BC_119
    with third_singular_pronoun I399_she_pronoun
    has ~neuter
    has ~male
    has female
    has ~nomale
    with p22_behavior_stack BC_120
    with p26_remembrances BC_121
    with p29_queue BC_122
    with p38_how_are_you_reply BC_123
    with description BC_124
    with initial BC_125
    with p15_dark_description BC_126
    with p25_behind_description BC_127
    with p48_possessive BC_128
    with list_together BC_129
    with short_name BC_130
    with article BC_131
    with p106_summary BC_132
;

Class K12_nonbinary 
    class K8_person
    with plural BC_133
    has ~neuter
    has ~male
    has ~female
    has nomale
    with p22_behavior_stack BC_134
    with p26_remembrances BC_135
    with p29_queue BC_136
    with p38_how_are_you_reply BC_137
    with description BC_138
    with initial BC_139
    with p15_dark_description BC_140
    with p25_behind_description BC_141
    with p48_possessive BC_142
    with list_together BC_143
    with short_name BC_144
    with article BC_145
    with p106_summary BC_146
;

Class K13_animal 
    class K8_person
    with plural BC_147
    has neuter
    has ~male
    has ~female
    has ~nomale
    with p22_behavior_stack BC_148
    with p26_remembrances BC_149
    with p29_queue BC_150
    with p38_how_are_you_reply BC_151
    with description BC_152
    with initial BC_153
    with p15_dark_description BC_154
    with p25_behind_description BC_155
    with p48_possessive BC_156
    with list_together BC_157
    with short_name BC_158
    with article BC_159
    with p106_summary BC_160
;

Class K4_door 
    class K2_thing
     has door, 
    with plural BC_161
    has static
    has ~pushable
    has ~open
    has openable
    has ~lockable
    has ~locked
    with door_to nothing
    with with_key nothing
    with description BC_162
    with initial BC_163
    with p15_dark_description BC_164
    with p25_behind_description BC_165
    with p48_possessive BC_166
    with list_together BC_167
    with short_name BC_168
    with article BC_169
    with p106_summary BC_170
;

Class K30_two_sided_door 
    class K4_door
    with plural BC_171
    with p36_lock_countdown -1
    with p37_close_countdown -1
    has openable
    has lockable
    with p155_front_openable true
    with p156_back_openable true
    with p157_front_closable true
    with p158_back_closable true
    with p30_frontside I154_room_of_subjects
    with p153_front_locked false
    with p154_back_locked false
    with p159_front_locks_the_back false
    with p160_front_locks_the_front false
    with p161_back_locks_the_back false
    with p162_back_locks_the_front false
    with p163_close_lock_the_back false
    with p164_close_lock_the_front false
    with p165_autolock_the_back false
    with p166_autolock_the_front false
    with p167_auto_closable false
    with p31_close_delay 0
    with p168_time_locked false
    with p32_time_lock_delay 0
    with p33_front_description BC_172
    with p34_back_description BC_173
    with p35_description_policy I282_describe_always
    with description BC_174
    with initial BC_175
    with p15_dark_description BC_176
    with p25_behind_description BC_177
    with p48_possessive BC_178
    with list_together BC_179
    with short_name BC_180
    with article BC_181
    with p106_summary BC_182
;

Class K31_pushbar_door 
    class K30_two_sided_door
    with plural BC_183
    with p31_close_delay 1
    with p33_front_description BC_184
    with p34_back_description BC_185
    has lockable
    with p153_front_locked true
    with p159_front_locks_the_back true
    with p160_front_locks_the_front true
    with p164_close_lock_the_front true
    with p167_auto_closable true
    with description BC_186
    with initial BC_187
    with p15_dark_description BC_188
    with p25_behind_description BC_189
    with p48_possessive BC_190
    with list_together BC_191
    with short_name BC_192
    with article BC_193
    with p106_summary BC_194
;

Class K32_shop_door 
    class K30_two_sided_door
    with plural BC_195
    with p31_close_delay 0
    has lockable
    with p159_front_locks_the_back true
    with p160_front_locks_the_front true
    with p161_back_locks_the_back true
    with p162_back_locks_the_front true
    with p167_auto_closable true
    with p33_front_description BC_196
    with p34_back_description BC_197
    with description BC_198
    with initial BC_199
    with p15_dark_description BC_200
    with p25_behind_description BC_201
    with p48_possessive BC_202
    with list_together BC_203
    with short_name BC_204
    with article BC_205
    with p106_summary BC_206
;

Class K35_swipe_door 
    class K30_two_sided_door
    with plural BC_207
    has openable
    has lockable
    with p33_front_description BC_208
    with p34_back_description BC_209
    with description BC_210
    with initial BC_211
    with p15_dark_description BC_212
    with p25_behind_description BC_213
    with p48_possessive BC_214
    with list_together BC_215
    with short_name BC_216
    with article BC_217
    with p106_summary BC_218
;

Class K5_container 
    class K2_thing
     has container, 
    with plural BC_219
    with capacity 100
    has ~transparent
    has open
    has ~openable
    has ~lockable
    has ~locked
    has ~enterable
    with with_key nothing
    with description BC_220
    with initial BC_221
    with p15_dark_description BC_222
    with p25_behind_description BC_223
    with p48_possessive BC_224
    with list_together BC_225
    with short_name BC_226
    with article BC_227
    with p106_summary BC_228
;

Class K15_vehicle 
    class K5_container
    with plural BC_229
    has static
    has enterable
    with description BC_230
    with initial BC_231
    with p15_dark_description BC_232
    with p25_behind_description BC_233
    with p48_possessive BC_234
    with list_together BC_235
    with short_name BC_236
    with article BC_237
    with p106_summary BC_238
;

Class K16_player_s_holdall 
    class K5_container
    with plural BC_239
    has ~static
    has openable
    with description BC_240
    with initial BC_241
    with p15_dark_description BC_242
    with p25_behind_description BC_243
    with p48_possessive BC_244
    with list_together BC_245
    with short_name BC_246
    with article BC_247
    with p106_summary BC_248
;

Class K23_drawer 
    class K5_container
    with plural BC_249
    has openable
    has lockable
    with description BC_250
    with initial BC_251
    with p15_dark_description BC_252
    with p25_behind_description BC_253
    with p48_possessive BC_254
    with list_together BC_255
    with short_name BC_256
    with article BC_257
    with p106_summary BC_258
;

Class K7_backdrop 
    class K2_thing
    with plural BC_259
    has static
    has scenery
    has ~pushable
    with description BC_260
    with initial BC_261
    with p15_dark_description BC_262
    with p25_behind_description BC_263
    with p48_possessive BC_264
    with list_together BC_265
    with short_name BC_266
    with article BC_267
    with p106_summary BC_268
;

Class K14_device 
    class K2_thing
     has switchable, 
    with plural BC_269
    has ~on
    with description BC_270
    with initial BC_271
    with p15_dark_description BC_272
    with p25_behind_description BC_273
    with p48_possessive BC_274
    with list_together BC_275
    with short_name BC_276
    with article BC_277
    with p106_summary BC_278
;

Class K17_subject 
    class K2_thing
    with plural BC_279
    has p97_familiar
    with description BC_280
    with initial BC_281
    with p15_dark_description BC_282
    with p25_behind_description BC_283
    with p48_possessive BC_284
    with list_together BC_285
    with short_name BC_286
    with article BC_287
    with p106_summary BC_288
;

Class K18_unenterable_room 
    class K2_thing
    with plural BC_289
    has scenery
    has enterable
    with description BC_290
    with initial BC_291
    with p15_dark_description BC_292
    with p25_behind_description BC_293
    with p48_possessive BC_294
    with list_together BC_295
    with short_name BC_296
    with article BC_297
    with p106_summary BC_298
;

Class K20_phone 
    class K2_thing
    with plural BC_299
    with p17_volume 1065353216
    has p108_audible
    has p111_insistent
    with p113_phone_condition I182_idle
    has p114_caller_id
    has p115_mobile
    with p117_identifiable true
    with parse_name Parse_Name_GV94
    with description BC_300
    with initial BC_301
    with p15_dark_description BC_302
    with p25_behind_description BC_303
    with p48_possessive BC_304
    with list_together BC_305
    with short_name BC_306
    with article BC_307
    with p106_summary BC_308
;

Class K22_money_card 
    class K2_thing
    with plural BC_309
    with p123_mc_enabled true
    with p19_balance 0
    with description BC_310
    with initial BC_311
    with p15_dark_description BC_312
    with p25_behind_description BC_313
    with p48_possessive BC_314
    with list_together BC_315
    with short_name BC_316
    with article BC_317
    with p106_summary BC_318
;

Class K26_choice 
    class K2_thing
    with plural BC_319
    with p136_available false
    with p137_exhausted false
    with p138_demoing_relation_storag nothing
    with description BC_320
    with initial BC_321
    with p15_dark_description BC_322
    with p25_behind_description BC_323
    with p48_possessive BC_324
    with list_together BC_325
    with short_name BC_326
    with article BC_327
    with p106_summary BC_328
;

Class K27_light_source 
    class K2_thing
    with plural BC_329
    has privately_named
    has light
    has concealed
    with p139_fluorescent false
    with description BC_330
    with initial BC_331
    with p15_dark_description BC_332
    with p25_behind_description BC_333
    with p48_possessive BC_334
    with list_together BC_335
    with short_name BC_336
    with article BC_337
    with p106_summary BC_338
;

Class K28_memory 
    class K2_thing
    with plural BC_339
    with description BC_340
    with initial BC_341
    with p15_dark_description BC_342
    with p25_behind_description BC_343
    with p48_possessive BC_344
    with list_together BC_345
    with short_name BC_346
    with article BC_347
    with p106_summary BC_348
;

Class K29_quip 
    class K2_thing
    with plural BC_349
    with p141_one_shot true
    with p143_quip_condition I225_performative
    with p144_quip_condition_2 I229_plausibility_normal
    with parse_name Parse_Name_GV108
    with p145_universal false
    with p146_always_available false
    with p137_exhausted false
    with p27_comment BC_350
    with p28_reply BC_351
    with description BC_352
    with initial BC_353
    with p15_dark_description BC_354
    with p25_behind_description BC_355
    with p48_possessive BC_356
    with list_together BC_357
    with short_name BC_358
    with article BC_359
    with p106_summary BC_360
;

Class K33_card_key 
    class K2_thing
    with plural BC_361
    with p169_swipable true
    with description BC_362
    with initial BC_363
    with p15_dark_description BC_364
    with p25_behind_description BC_365
    with p48_possessive BC_366
    with list_together BC_367
    with short_name BC_368
    with article BC_369
    with p106_summary BC_370
;

Class K34_swipe_lock 
    class K2_thing
    with plural BC_371
    with description BC_372
    with initial BC_373
    with p15_dark_description BC_374
    with p25_behind_description BC_375
    with p48_possessive BC_376
    with list_together BC_377
    with short_name BC_378
    with article BC_379
    with p106_summary BC_380
;

Class K9_region 
    class K0_kind
    with plural BC_381
    has ~privately_named
    has p99_powered
    with list_together BC_382
    with short_name BC_383
    with article BC_384
    with p106_summary BC_385
;

Class K3_direction 
    class K0_kind

    	has scenery, ! class CompassDirection,

    with plural BC_386
    has ~privately_named
    has ~workflag
    with p10_opposite I51_north
    with p152_hyperspatial false
    with list_together BC_387
    with short_name BC_388
    with article BC_389
    with p106_summary BC_390
;

Class K19_fact 
    class K0_kind
    with plural BC_391
    with list_together BC_392
    with short_name BC_393
    with article BC_394
    with p106_summary BC_395
;

Class K21_phone_number 
    class K19_fact
    with plural BC_396
    with p122_reaches_relation_storag nothing
    with list_together BC_397
    with short_name BC_398
    with article BC_399
    with p106_summary BC_400
;

Class K25_behavior 
    class K0_kind
    with plural BC_401
    with list_together BC_402
    with short_name BC_403
    with article BC_404
    with p106_summary BC_405
;

Class K36_pronoun 
    class K0_kind
    with plural BC_406
    has ~pluralname
    with p40_grammatical_person 0
    with p41_declensions BC_407
    has ~neuter
    with list_together BC_408
    with short_name BC_409
    with article BC_410
    with p106_summary BC_411
;

Class K37_third_person_personal_pr 
    class K36_pronoun
    with plural BC_412
    with p40_grammatical_person 3
    with p41_declensions BC_413
    with list_together BC_414
    with short_name BC_415
    with article BC_416
    with p106_summary BC_417
;

Object I51_north "" Compass
    class K3_direction
    with short_name BC_418
    with article BC_419
    with p10_opposite I54_south
    with vector 0
    with IK3_Count 0
    with IK3_Link I52_northeast
    with KD_Count 3
    with name 'north' 'directions//p' 'n//' 
    with parse_name Parse_Name_GV1
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_420
    with plural BC_421
    with p106_summary BC_422
;

Object I52_northeast "" Compass
    class K3_direction
    with short_name BC_423
    with article BC_424
    with p10_opposite I56_southwest
    with vector 0
    with IK3_Count 1
    with IK3_Link I53_northwest
    with KD_Count 3
    with name 'northeast' 'directions//p' 'ne' 
    with parse_name Parse_Name_GV2
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_425
    with plural BC_426
    with p106_summary BC_427
;

Object I53_northwest "" Compass
    class K3_direction
    with short_name BC_428
    with article BC_429
    with p10_opposite I55_southeast
    with vector 0
    with IK3_Count 2
    with IK3_Link I54_south
    with KD_Count 3
    with name 'northwest' 'directions//p' 'nw' 
    with parse_name Parse_Name_GV3
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_430
    with plural BC_431
    with p106_summary BC_432
;

Object I54_south "" Compass
    class K3_direction
    with short_name BC_433
    with article BC_434
    with p10_opposite I51_north
    with vector 0
    with IK3_Count 3
    with IK3_Link I55_southeast
    with KD_Count 3
    with name 'south' 'directions//p' 's//' 
    with parse_name Parse_Name_GV4
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_435
    with plural BC_436
    with p106_summary BC_437
;

Object I55_southeast "" Compass
    class K3_direction
    with short_name BC_438
    with article BC_439
    with p10_opposite I53_northwest
    with vector 0
    with IK3_Count 4
    with IK3_Link I56_southwest
    with KD_Count 3
    with name 'southeast' 'directions//p' 'se' 
    with parse_name Parse_Name_GV5
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_440
    with plural BC_441
    with p106_summary BC_442
;

Object I56_southwest "" Compass
    class K3_direction
    with short_name BC_443
    with article BC_444
    with p10_opposite I52_northeast
    with vector 0
    with IK3_Count 5
    with IK3_Link I57_east
    with KD_Count 3
    with name 'southwest' 'directions//p' 'sw' 
    with parse_name Parse_Name_GV6
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_445
    with plural BC_446
    with p106_summary BC_447
;

Object I57_east "" Compass
    class K3_direction
    with short_name BC_448
    with article BC_449
    with p10_opposite I58_west
    with vector 0
    with IK3_Count 6
    with IK3_Link I58_west
    with KD_Count 3
    with name 'east' 'directions//p' 'e//' 
    with parse_name Parse_Name_GV7
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_450
    with plural BC_451
    with p106_summary BC_452
;

Object I58_west "" Compass
    class K3_direction
    with short_name BC_453
    with article BC_454
    with p10_opposite I57_east
    with vector 0
    with IK3_Count 7
    with IK3_Link I59_up
    with KD_Count 3
    with name 'west' 'directions//p' 'w//' 
    with parse_name Parse_Name_GV8
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_455
    with plural BC_456
    with p106_summary BC_457
;

Object I59_up "" Compass
    class K3_direction
    with short_name BC_458
    with article BC_459
    with p10_opposite I60_down
    with vector 0
    with IK3_Count 8
    with IK3_Link I60_down
    with KD_Count 3
    with name 'up' 'directions//p' 'u//' 
    with parse_name Parse_Name_GV9
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_460
    with plural BC_461
    with p106_summary BC_462
;

Object I60_down "" Compass
    class K3_direction
    with short_name BC_463
    with article BC_464
    with p10_opposite I59_up
    with vector 0
    with IK3_Count 9
    with IK3_Link in_obj
    with KD_Count 3
    with name 'down' 'directions//p' 'd//' 
    with parse_name Parse_Name_GV10
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_465
    with plural BC_466
    with p106_summary BC_467
;

Object in_obj "" Compass
    class K3_direction
    with short_name BC_468
    with article BC_469
    with p10_opposite out_obj
    with vector 0
    with IK3_Count 10
    with IK3_Link out_obj
    with KD_Count 3
    with name 'inside' 'directions//p' 'in' 
    with parse_name Parse_Name_GV11
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_470
    with plural BC_471
    with p106_summary BC_472
;

Object out_obj "" Compass
    class K3_direction
    with short_name BC_473
    with article BC_474
    with p10_opposite in_obj
    with vector 0
    with IK3_Count 11
    with IK3_Link I233_back
    with KD_Count 3
    with name 'outside' 'directions//p' 'out' 
    with parse_name Parse_Name_GV12
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_475
    with plural BC_476
    with p106_summary BC_477
;

Object I154_room_of_subjects ""
    class K1_room
    with short_name BC_478
    with description BC_479
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 0
    with IK1_Link I216_room_of_choices
    with KD_Count 1
    with name 'room' 'of' 'subjects' 'rooms//p' 
    with p15_dark_description BC_480
    with p21_preposition BC_481
    with p24_destination_name BC_482
    with list_together BC_483
    with plural BC_484
    with article BC_485
    with p106_summary BC_486
;

Object I159_weather ""
    class K2_thing
    with short_name BC_487
    has ~p103_rainy
    with vector 0
    has mark_as_thing
    with IK2_Count 1
    with IK2_Link I160_motives
    with KD_Count 2
    with name 'weather' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_488
    with initial BC_489
    with p15_dark_description BC_490
    with p25_behind_description BC_491
    with p48_possessive BC_492
    with list_together BC_493
    with plural BC_494
    with article BC_495
    with p106_summary BC_496
;

Object I160_motives ""
    class K17_subject
    with short_name BC_497
    has proper
    with vector 0
    has mark_as_thing
    with IK2_Count 2
    with IK2_Link I192_walls
    with IK17_Count 0
    with IK17_Link I416_spacetime
    with KD_Count 17
    with name 'motives' 'subjects//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_498
    with initial BC_499
    with p15_dark_description BC_500
    with p25_behind_description BC_501
    with p48_possessive BC_502
    with list_together BC_503
    with plural BC_504
    with article BC_505
    with p106_summary BC_506
;

Object I162_generic_truth ""
    class K19_fact
    with short_name BC_507
    has proper
    with p106_summary BC_508
    with vector 0
    with cap_short_name BC_509
    with IK19_Count 0
    with IK19_Link I163_vent_screws
    with KD_Count 19
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_510
    with plural BC_511
    with article BC_512
;

Object I163_vent_screws ""
    class K19_fact
    with short_name BC_513
    has proper
    with p106_summary BC_514
    with vector 0
    with cap_short_name BC_515
    with IK19_Count 1
    with IK19_Link I164_desk_locked
    with KD_Count 19
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_516
    with plural BC_517
    with article BC_518
;

Object I164_desk_locked ""
    class K19_fact
    with short_name BC_519
    has proper
    with p106_summary BC_520
    with vector 0
    with cap_short_name BC_521
    with IK19_Count 2
    with IK19_Link I165_pawn_shop_screwdriver
    with KD_Count 19
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_522
    with plural BC_523
    with article BC_524
;

Object I165_pawn_shop_screwdriver ""
    class K19_fact
    with short_name BC_525
    has proper
    with p106_summary BC_526
    with vector 0
    with cap_short_name BC_527
    with IK19_Count 3
    with IK19_Link I166_pawn_shop_dave
    with KD_Count 19
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_528
    with plural BC_529
    with article BC_530
;

Object I166_pawn_shop_dave ""
    class K19_fact
    with short_name BC_531
    has proper
    with p106_summary BC_532
    with vector 0
    with cap_short_name BC_533
    with IK19_Count 4
    with IK19_Link I167_key_is_lost
    with KD_Count 19
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_534
    with plural BC_535
    with article BC_536
;

Object I167_key_is_lost ""
    class K19_fact
    with short_name BC_537
    has proper
    with p106_summary BC_538
    with vector 0
    with cap_short_name BC_539
    with IK19_Count 5
    with IK19_Link I168_screwdriver_in_laundrom
    with KD_Count 19
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_540
    with plural BC_541
    with article BC_542
;

Object I168_screwdriver_in_laundrom ""
    class K19_fact
    with short_name BC_543
    has proper
    with p106_summary BC_544
    with vector 0
    with cap_short_name BC_545
    with IK19_Count 6
    with IK19_Link I169_hex_screws
    with KD_Count 19
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_546
    with plural BC_547
    with article BC_548
;

Object I169_hex_screws ""
    class K19_fact
    with short_name BC_549
    has proper
    with p106_summary BC_550
    with vector 0
    with cap_short_name BC_551
    with IK19_Count 7
    with IK19_Link I170_break_in_to_laundromat
    with KD_Count 19
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_552
    with plural BC_553
    with article BC_554
;

Object I170_break_in_to_laundromat ""
    class K19_fact
    with short_name BC_555
    has proper
    with p106_summary BC_556
    with vector 0
    with cap_short_name BC_557
    with IK19_Count 8
    with IK19_Link I171_back_door_is_locked
    with KD_Count 19
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_558
    with plural BC_559
    with article BC_560
;

Object I171_back_door_is_locked ""
    class K19_fact
    with short_name BC_561
    has proper
    with p106_summary BC_562
    with vector 0
    with cap_short_name BC_563
    with IK19_Count 9
    with IK19_Link I421_klimp_s_mobile_phone_nu
    with KD_Count 19
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_564
    with plural BC_565
    with article BC_566
;

Object I190_doing_nothing ""
    class K25_behavior
    with short_name BC_567
    has proper
    with vector 0
    with IK25_Count 0
    with IK25_Link I191_walking_to
    with KD_Count 25
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_568
    with plural BC_569
    with article BC_570
    with p106_summary BC_571
;

Object I191_walking_to ""
    class K25_behavior
    with short_name BC_572
    has proper
    with vector 0
    with IK25_Count 1
    with IK25_Link I368_throw_out_boxes
    with KD_Count 25
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_573
    with plural BC_574
    with article BC_575
    with p106_summary BC_576
;

Object I192_walls ""
    class K7_backdrop
    with short_name BC_577
    has privately_named
    with vector 0
    with found_in FoundEverywhere
    has mark_as_thing
    with IK2_Count 3
    with IK2_Link I193_floor
    with IK7_Count 0
    with IK7_Link I193_floor
    with KD_Count 7
    with parse_name Parse_Name_GV101
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_578
    with initial BC_579
    with p15_dark_description BC_580
    with p25_behind_description BC_581
    with p48_possessive BC_582
    with list_together BC_583
    with plural BC_584
    with article BC_585
    with p106_summary BC_586
;

Object I193_floor ""
    class K7_backdrop
    with short_name BC_587
    with vector 0
    with found_in FoundEverywhere
    has mark_as_thing
    with IK2_Count 4
    with IK2_Link I194_ceiling
    with IK7_Count 1
    with IK7_Link I194_ceiling
    with KD_Count 7
    with name 'floor' 'backdrops//p' 
    with parse_name Parse_Name_GV102
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_588
    with initial BC_589
    with p15_dark_description BC_590
    with p25_behind_description BC_591
    with p48_possessive BC_592
    with list_together BC_593
    with plural BC_594
    with article BC_595
    with p106_summary BC_596
;

Object I194_ceiling ""
    class K7_backdrop
    with short_name BC_597
    with vector 0
    with found_in FoundEverywhere
    has mark_as_thing
    with IK2_Count 5
    with IK2_Link I208_light_meter
    with IK7_Count 2
    with IK7_Link I218_hyperlight
    with KD_Count 7
    with name 'ceiling' 'backdrops//p' 
    with parse_name Parse_Name_GV103
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_598
    with initial BC_599
    with p15_dark_description BC_600
    with p25_behind_description BC_601
    with p48_possessive BC_602
    with list_together BC_603
    with plural BC_604
    with article BC_605
    with p106_summary BC_606
;

Object I208_light_meter ""
    class K2_thing
    with short_name BC_607
    has privately_named
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 6
    with IK2_Link I218_hyperlight
    with KD_Count 2
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_608
    with initial BC_609
    with p15_dark_description BC_610
    with p25_behind_description BC_611
    with p48_possessive BC_612
    with list_together BC_613
    with plural BC_614
    with article BC_615
    with p106_summary BC_616
;

Object I216_room_of_choices ""
    class K1_room
    with short_name BC_617
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 1
    with IK1_Link I231_room_of_quips
    with KD_Count 1
    with name 'room' 'of' 'choices' 'rooms//p' 
    with description BC_618
    with p15_dark_description BC_619
    with p21_preposition BC_620
    with p24_destination_name BC_621
    with list_together BC_622
    with plural BC_623
    with article BC_624
    with p106_summary BC_625
;

Object I218_hyperlight ""
    class K7_backdrop
    with short_name BC_626
    has proper
    has privately_named
    has ~light
    has concealed
    with vector 0
    with found_in FoundEverywhere
    has mark_as_thing
    with IK2_Count 7
    with IK2_Link I230_generic_quip
    with IK7_Count 3
    with IK7_Link nothing
    with KD_Count 7
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_627
    with initial BC_628
    with p15_dark_description BC_629
    with p25_behind_description BC_630
    with p48_possessive BC_631
    with list_together BC_632
    with plural BC_633
    with article BC_634
    with p106_summary BC_635
;

Object I219_marsh_street ""
    class K9_region
    with short_name BC_636
    has proper
    with vector 0
    with regional_found_in [ ;
        if (TestRegionalContainment(location, I219_marsh_street)) rtrue; rfalse;],
    with IK9_Count 0
    with IK9_Link I232_hyperspace
    with KD_Count 9
    with name 'marsh' 'street' 'regions//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_637
    with plural BC_638
    with article BC_639
    with p106_summary BC_640
;

Object I230_generic_quip ""
    class K29_quip
    with short_name BC_641
    with vector 0
    has mark_as_thing
    with IK2_Count 8
    with IK2_Link I243_mystic_compass
    with IK29_Count 0
    with IK29_Link I257_how_to_get_home
    with KD_Count 29
    with name 'generic' 'quip' 'quips//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p27_comment BC_642
    with p28_reply BC_643
    with description BC_644
    with initial BC_645
    with p15_dark_description BC_646
    with p25_behind_description BC_647
    with p48_possessive BC_648
    with list_together BC_649
    with plural BC_650
    with article BC_651
    with p106_summary BC_652
;

Object I231_room_of_quips ""
    class K1_room
    with short_name BC_653
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 2
    with IK1_Link I244_featureless_hyperplane
    with KD_Count 1
    with name 'room' 'of' 'quips' 'rooms//p' 
    with description BC_654
    with p15_dark_description BC_655
    with p21_preposition BC_656
    with p24_destination_name BC_657
    with list_together BC_658
    with plural BC_659
    with article BC_660
    with p106_summary BC_661
;

Object I232_hyperspace ""
    class K9_region
    with short_name BC_662
    has proper
    with vector 0
    with regional_found_in [ ;
        if (TestRegionalContainment(location, I232_hyperspace)) rtrue; rfalse;],
    with IK9_Count 1
    with IK9_Link I247_field_office_area
    with KD_Count 9
    with name 'hyperspace' 'regions//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_663
    with plural BC_664
    with article BC_665
    with p106_summary BC_666
;

Object -> I247_field_office_area ""
    class K9_region
    with short_name BC_667
    has proper
    with vector 0
    with cap_short_name BC_668
    with regional_found_in [ ;
        if (TestRegionalContainment(location, I247_field_office_area)) rtrue; rfalse;],
    with IK9_Count 2
    with IK9_Link I293_swamp_park
    with KD_Count 9
    with name 'field' 'office' 'area' 'regions//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_669
    with plural BC_670
    with article BC_671
    with p106_summary BC_672
;

Object I233_back "" Compass
    class K3_direction
    with short_name BC_673
    with article BC_674
    with p10_opposite I234_forth
    has proper
    with p152_hyperspatial true
    with vector 0
    with cap_short_name BC_675
    with IK3_Count 12
    with IK3_Link I234_forth
    with KD_Count 3
    with name 'back' 'directions//p' 'b//' 
    with parse_name Parse_Name_GV111
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_676
    with plural BC_677
    with p106_summary BC_678
;

Object I234_forth "" Compass
    class K3_direction
    with short_name BC_679
    with article BC_680
    with p10_opposite I233_back
    has proper
    with p152_hyperspatial true
    with vector 0
    with cap_short_name BC_681
    with IK3_Count 13
    with IK3_Link I235_forthnorth
    with KD_Count 3
    with name 'forth' 'directions//p' 'f//' 
    with parse_name Parse_Name_GV110
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_682
    with plural BC_683
    with p106_summary BC_684
;

Object I235_forthnorth "" Compass
    class K3_direction
    with short_name BC_685
    with article BC_686
    with p10_opposite I241_backsouth
    has proper
    with p152_hyperspatial true
    with vector 0
    with cap_short_name BC_687
    with IK3_Count 14
    with IK3_Link I236_fortheast
    with KD_Count 3
    with name 'forthnorth' 'directions//p' 'fn' 
    with parse_name Parse_Name_GV112
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_688
    with plural BC_689
    with p106_summary BC_690
;

Object I236_fortheast "" Compass
    class K3_direction
    with short_name BC_691
    with article BC_692
    with p10_opposite I242_backwest
    has proper
    with p152_hyperspatial true
    with vector 0
    with cap_short_name BC_693
    with IK3_Count 15
    with IK3_Link I237_forthsouth
    with KD_Count 3
    with name 'fortheast' 'directions//p' 'fe' 
    with parse_name Parse_Name_GV113
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_694
    with plural BC_695
    with p106_summary BC_696
;

Object I237_forthsouth "" Compass
    class K3_direction
    with short_name BC_697
    with article BC_698
    with p10_opposite I239_backnorth
    has proper
    with p152_hyperspatial true
    with vector 0
    with cap_short_name BC_699
    with IK3_Count 16
    with IK3_Link I238_forthwest
    with KD_Count 3
    with name 'forthsouth' 'directions//p' 'fs' 
    with parse_name Parse_Name_GV114
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_700
    with plural BC_701
    with p106_summary BC_702
;

Object I238_forthwest "" Compass
    class K3_direction
    with short_name BC_703
    with article BC_704
    with p10_opposite I240_backeast
    has proper
    with p152_hyperspatial true
    with vector 0
    with cap_short_name BC_705
    with IK3_Count 17
    with IK3_Link I239_backnorth
    with KD_Count 3
    with name 'forthwest' 'directions//p' 'fw' 
    with parse_name Parse_Name_GV115
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_706
    with plural BC_707
    with p106_summary BC_708
;

Object I239_backnorth "" Compass
    class K3_direction
    with short_name BC_709
    with article BC_710
    with p10_opposite I237_forthsouth
    has proper
    with p152_hyperspatial true
    with vector 0
    with cap_short_name BC_711
    with IK3_Count 18
    with IK3_Link I240_backeast
    with KD_Count 3
    with name 'backnorth' 'directions//p' 'bn' 
    with parse_name Parse_Name_GV116
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_712
    with plural BC_713
    with p106_summary BC_714
;

Object I240_backeast "" Compass
    class K3_direction
    with short_name BC_715
    with article BC_716
    with p10_opposite I238_forthwest
    has proper
    with p152_hyperspatial true
    with vector 0
    with cap_short_name BC_717
    with IK3_Count 19
    with IK3_Link I241_backsouth
    with KD_Count 3
    with name 'backeast' 'directions//p' 'be' 
    with parse_name Parse_Name_GV117
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_718
    with plural BC_719
    with p106_summary BC_720
;

Object I241_backsouth "" Compass
    class K3_direction
    with short_name BC_721
    with article BC_722
    with p10_opposite I235_forthnorth
    has proper
    with p152_hyperspatial true
    with vector 0
    with cap_short_name BC_723
    with IK3_Count 20
    with IK3_Link I242_backwest
    with KD_Count 3
    with name 'backsouth' 'directions//p' 'bs' 
    with parse_name Parse_Name_GV118
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_724
    with plural BC_725
    with p106_summary BC_726
;

Object I242_backwest "" Compass
    class K3_direction
    with short_name BC_727
    with article BC_728
    with p10_opposite I236_fortheast
    has proper
    with p152_hyperspatial true
    with vector 0
    with cap_short_name BC_729
    with IK3_Count 21
    with IK3_Link nothing
    with KD_Count 3
    with name 'backwest' 'directions//p' 'bw' 
    with parse_name Parse_Name_GV119
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_730
    with plural BC_731
    with p106_summary BC_732
;

Object I243_mystic_compass ""
    class K2_thing
    with short_name BC_733
    with vector 0
    has mark_as_thing
    with IK2_Count 9
    with IK2_Link I245_descending_stair
    with KD_Count 2
    with name 'mystic' 'compass' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_734
    with initial BC_735
    with p15_dark_description BC_736
    with p25_behind_description BC_737
    with p48_possessive BC_738
    with list_together BC_739
    with plural BC_740
    with article BC_741
    with p106_summary BC_742
;

Object I244_featureless_hyperplane ""
    class K1_room
    with short_name BC_743
    with description BC_744
    with map_region I232_hyperspace
    with p21_preposition BC_745
    with p127_always_indefinite true
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 3
    with IK1_Link I248_field_office_reception
    with KD_Count 1
    with name 'featureless' 'hyperplane' 'rooms//p' 
    with p15_dark_description BC_746
    with p24_destination_name BC_747
    with list_together BC_748
    with plural BC_749
    with article BC_750
    with p106_summary BC_751
;

Object I245_descending_stair ""
    class K2_thing
    with short_name BC_752
    has proper
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 10
    with IK2_Link I246_ethereal_pillar
    with KD_Count 2
    with name 'descending' 'stair' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_753
    with initial BC_754
    with p15_dark_description BC_755
    with p25_behind_description BC_756
    with p48_possessive BC_757
    with list_together BC_758
    with plural BC_759
    with article BC_760
    with p106_summary BC_761
;

Object I246_ethereal_pillar ""
    class K2_thing
    with short_name BC_762
    with vector 0
    has mark_as_thing
    with IK2_Count 11
    with IK2_Link I249_maggie
    with KD_Count 2
    with name 'ethereal' 'pillar' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_763
    with initial BC_764
    with p15_dark_description BC_765
    with p25_behind_description BC_766
    with p48_possessive BC_767
    with list_together BC_768
    with plural BC_769
    with article BC_770
    with p106_summary BC_771
;

Object I248_field_office_reception ""
    class K1_room
    with short_name BC_772
    with description BC_773
    with map_region I247_field_office_area
    with p21_preposition BC_774
    has proper
    with vector 0
    with room_index -1
    with cap_short_name BC_775
    has mark_as_room
    with IK1_Count 4
    with IK1_Link I250_field_office_hallway
    with KD_Count 1
    with name 'field' 'office' 'reception' 'rooms//p' 
    with p15_dark_description BC_776
    with p24_destination_name BC_777
    with list_together BC_778
    with plural BC_779
    with article BC_780
    with p106_summary BC_781
;

Object -> I249_maggie ""
    class K11_woman
    with short_name BC_782
    with p49_portrait I526_figure_maggie
    has proper
    with vector 0
    has mark_as_thing
    with IK2_Count 12
    with IK2_Link I252_minerva
    with IK8_Count 1
    with IK8_Link I252_minerva
    with IK11_Count 0
    with IK11_Link I252_minerva
    with KD_Count 11
    with name 'maggie' 'women//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p22_behavior_stack BC_783
    with p26_remembrances BC_784
    with p29_queue BC_785
    with p38_how_are_you_reply BC_786
    with description BC_787
    with initial BC_788
    with p15_dark_description BC_789
    with p25_behind_description BC_790
    with p48_possessive BC_791
    with list_together BC_792
    with plural BC_793
    with article BC_794
    with p106_summary BC_795
;

Object I250_field_office_hallway ""
    class K1_room
    with short_name BC_796
    with description BC_797
    with map_region I247_field_office_area
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 5
    with IK1_Link I251_minerva_s_office
    with KD_Count 1
    with name 'field' 'office' 'hallway' 'rooms//p' 
    with p15_dark_description BC_798
    with p21_preposition BC_799
    with p24_destination_name BC_800
    with list_together BC_801
    with plural BC_802
    with article BC_803
    with p106_summary BC_804
;

Object I251_minerva_s_office ""
    class K1_room
    with short_name BC_805
    with map_region I247_field_office_area
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 6
    with IK1_Link I253_field_office_chief_s_of
    with KD_Count 1
    with name 'minerva^s' 'office' 'rooms//p' 
    with description BC_806
    with p15_dark_description BC_807
    with p21_preposition BC_808
    with p24_destination_name BC_809
    with list_together BC_810
    with plural BC_811
    with article BC_812
    with p106_summary BC_813
;

Object -> I252_minerva ""
    class K11_woman
    with short_name BC_814
    with p49_portrait I527_figure_minerva
    has proper
    with vector 0
    has mark_as_thing
    with IK2_Count 13
    with IK2_Link I254_doris
    with IK8_Count 2
    with IK8_Link I254_doris
    with IK11_Count 1
    with IK11_Link I358_margaret_chao
    with KD_Count 11
    with name 'minerva' 'women//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p22_behavior_stack BC_815
    with p26_remembrances BC_816
    with p29_queue BC_817
    with p38_how_are_you_reply BC_818
    with description BC_819
    with initial BC_820
    with p15_dark_description BC_821
    with p25_behind_description BC_822
    with p48_possessive BC_823
    with list_together BC_824
    with plural BC_825
    with article BC_826
    with p106_summary BC_827
;

Object I253_field_office_chief_s_of ""
    class K1_room
    with short_name BC_828
    with description BC_829
    with map_region I247_field_office_area
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 7
    with IK1_Link I255_christy_s_office
    with KD_Count 1
    with name 'field' 'office' 'chief^s' 'office' 'rooms//p' 
    with p15_dark_description BC_830
    with p21_preposition BC_831
    with p24_destination_name BC_832
    with list_together BC_833
    with plural BC_834
    with article BC_835
    with p106_summary BC_836
;

Object -> I254_doris ""
    class K10_man
    with short_name BC_837
    with initial BC_838
    with p49_portrait I509_figure_doris
    has proper
    with vector 0
    has mark_as_thing
    with IK2_Count 14
    with IK2_Link I256_christy
    with IK8_Count 3
    with IK8_Link I256_christy
    with IK10_Count 0
    with IK10_Link I320_dave
    with KD_Count 10
    with name 'doris' 'men//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p22_behavior_stack BC_839
    with p26_remembrances BC_840
    with p29_queue BC_841
    with p38_how_are_you_reply BC_842
    with description BC_843
    with p15_dark_description BC_844
    with p25_behind_description BC_845
    with p48_possessive BC_846
    with list_together BC_847
    with plural BC_848
    with article BC_849
    with p106_summary BC_850
;

Object I255_christy_s_office ""
    class K1_room
    with short_name BC_851
    with map_region I247_field_office_area
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 8
    with IK1_Link I294_strip_mall_parking_lot_
    with KD_Count 1
    with name 'christy^s' 'office' 'rooms//p' 
    with description BC_852
    with p15_dark_description BC_853
    with p21_preposition BC_854
    with p24_destination_name BC_855
    with list_together BC_856
    with plural BC_857
    with article BC_858
    with p106_summary BC_859
;

Object -> I256_christy ""
    class K12_nonbinary
    with short_name BC_860
    with p49_portrait I528_figure_christy
    has proper
    with vector 0
    has mark_as_thing
    with IK2_Count 15
    with IK2_Link I257_how_to_get_home
    with IK8_Count 4
    with IK8_Link I358_margaret_chao
    with IK12_Count 0
    with IK12_Link I406_larch_faraji
    with KD_Count 12
    with name 'christy' 'nonbinaries//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p22_behavior_stack BC_861
    with p26_remembrances BC_862
    with p29_queue BC_863
    with p38_how_are_you_reply BC_864
    with description BC_865
    with initial BC_866
    with p15_dark_description BC_867
    with p25_behind_description BC_868
    with p48_possessive BC_869
    with list_together BC_870
    with plural BC_871
    with article BC_872
    with p106_summary BC_873
;

Object I257_how_to_get_home ""
    class K29_quip
    with short_name BC_874
    with p27_comment BC_875
    with p28_reply BC_876
    has proper
    with p141_one_shot false
    with p143_quip_condition I223_questioning
    with p144_quip_condition_2 I227_ubiquitous
    with p146_always_available true
    with vector 0
    with cap_short_name BC_877
    has mark_as_thing
    with IK2_Count 16
    with IK2_Link I258_no_thumb_drive
    with IK29_Count 1
    with IK29_Link I258_no_thumb_drive
    with KD_Count 29
    with name 'how' 'to' 'get' 'home' 'quips//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_878
    with initial BC_879
    with p15_dark_description BC_880
    with p25_behind_description BC_881
    with p48_possessive BC_882
    with list_together BC_883
    with plural BC_884
    with article BC_885
    with p106_summary BC_886
;

Object I258_no_thumb_drive ""
    class K29_quip
    with short_name BC_887
    with p27_comment BC_888
    with p28_reply BC_889
    has proper
    has privately_named
    with p143_quip_condition I224_informative
    with vector 0
    has mark_as_thing
    with IK2_Count 17
    with IK2_Link I260_yes_thumb_drive
    with IK29_Count 2
    with IK29_Link I260_yes_thumb_drive
    with KD_Count 29
    with parse_name Parse_Name_GV120
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_890
    with initial BC_891
    with p15_dark_description BC_892
    with p25_behind_description BC_893
    with p48_possessive BC_894
    with list_together BC_895
    with plural BC_896
    with article BC_897
    with p106_summary BC_898
;

Object I260_yes_thumb_drive ""
    class K29_quip
    with short_name BC_899
    with p27_comment BC_900
    with p28_reply BC_901
    has proper
    has privately_named
    with p143_quip_condition I224_informative
    with vector 0
    has mark_as_thing
    with IK2_Count 19
    with IK2_Link I261_hand_over_the_thumb_dri
    with IK29_Count 3
    with IK29_Link I261_hand_over_the_thumb_dri
    with KD_Count 29
    with parse_name Parse_Name_GV121
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_902
    with initial BC_903
    with p15_dark_description BC_904
    with p25_behind_description BC_905
    with p48_possessive BC_906
    with list_together BC_907
    with plural BC_908
    with article BC_909
    with p106_summary BC_910
;

Object I261_hand_over_the_thumb_dri ""
    class K29_quip
    with short_name BC_911
    with p27_comment BC_912
    with p28_reply BC_913
    has proper
    with p143_quip_condition I225_performative
    with vector 0
    with cap_short_name BC_914
    has mark_as_thing
    with IK2_Count 20
    with IK2_Link I262_about_savra
    with IK29_Count 4
    with IK29_Link I262_about_savra
    with KD_Count 29
    with name 'hand' 'over' 'the' 'thumb' 'drive' 'quips//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_915
    with initial BC_916
    with p15_dark_description BC_917
    with p25_behind_description BC_918
    with p48_possessive BC_919
    with list_together BC_920
    with plural BC_921
    with article BC_922
    with p106_summary BC_923
;

Object I262_about_savra ""
    class K29_quip
    with short_name BC_924
    has proper
    with p143_quip_condition I223_questioning
    with vector 0
    with cap_short_name BC_925
    has mark_as_thing
    with IK2_Count 21
    with IK2_Link I263_about_the_dragon
    with IK29_Count 5
    with IK29_Link I263_about_the_dragon
    with KD_Count 29
    with name 'about' 'savra' 'quips//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p27_comment BC_926
    with p28_reply BC_927
    with description BC_928
    with initial BC_929
    with p15_dark_description BC_930
    with p25_behind_description BC_931
    with p48_possessive BC_932
    with list_together BC_933
    with plural BC_934
    with article BC_935
    with p106_summary BC_936
;

Object I263_about_the_dragon ""
    class K29_quip
    with short_name BC_937
    has proper
    with p143_quip_condition I223_questioning
    with vector 0
    with cap_short_name BC_938
    has mark_as_thing
    with IK2_Count 22
    with IK2_Link I264_about_time_travel
    with IK29_Count 6
    with IK29_Link I264_about_time_travel
    with KD_Count 29
    with name 'about' 'the' 'dragon' 'quips//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p27_comment BC_939
    with p28_reply BC_940
    with description BC_941
    with initial BC_942
    with p15_dark_description BC_943
    with p25_behind_description BC_944
    with p48_possessive BC_945
    with list_together BC_946
    with plural BC_947
    with article BC_948
    with p106_summary BC_949
;

Object I264_about_time_travel ""
    class K29_quip
    with short_name BC_950
    has proper
    with p143_quip_condition I223_questioning
    with vector 0
    with cap_short_name BC_951
    has mark_as_thing
    with IK2_Count 23
    with IK2_Link I296_office_
    with IK29_Count 7
    with IK29_Link I321_for_a_screwdriver_pawn
    with KD_Count 29
    with name 'about' 'time' 'travel' 'quips//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p27_comment BC_952
    with p28_reply BC_953
    with description BC_954
    with initial BC_955
    with p15_dark_description BC_956
    with p25_behind_description BC_957
    with p48_possessive BC_958
    with list_together BC_959
    with plural BC_960
    with article BC_961
    with p106_summary BC_962
;

Object I293_swamp_park ""
    class K9_region
    with short_name BC_963
    has proper
    with vector 0
    with regional_found_in [ ;
        if (TestRegionalContainment(location, I293_swamp_park)) rtrue; rfalse;],
    with IK9_Count 3
    with IK9_Link I327_laundromat_region
    with KD_Count 9
    with name 'swamp' 'park' 'regions//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_964
    with plural BC_965
    with article BC_966
    with p106_summary BC_967
;

Object -> I327_laundromat_region ""
    class K9_region
    with short_name BC_968
    has proper
    with vector 0
    with cap_short_name BC_969
    with regional_found_in [ ;
        if (TestRegionalContainment(location, I327_laundromat_region)) rtrue; rfalse;],
    with IK9_Count 4
    with IK9_Link I369_elr
    with KD_Count 9
    with name 'laundromat-region' 'regions//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_970
    with plural BC_971
    with article BC_972
    with p106_summary BC_973
;

Object I294_strip_mall_parking_lot_ ""
    class K1_room
    with short_name BC_974
    with description BC_975
    with map_region I293_swamp_park
    with p21_preposition BC_976
    with p102_room_condition I157_outdoors
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 9
    with IK1_Link I295_the_front_office
    with KD_Count 1
    with name 'strip' 'mall' 'parking' 'lot' 'south' 'rooms//p' 
    with parse_name Parse_Name_GV123
    with p15_dark_description BC_977
    with p24_destination_name BC_978
    with list_together BC_979
    with plural BC_980
    with article BC_981
    with p106_summary BC_982
;

Object -> I296_office_ ""
    class K18_unenterable_room
    with short_name BC_983
    with description BC_984
    has static
    with vector 0
    has mark_as_thing
    with component_child I297_margaret_at_a_distance
    with IK2_Count 24
    with IK2_Link I299_car_1
    with IK18_Count 0
    with IK18_Link I301_laundromat_facade
    with KD_Count 18
    with name 'office_' 'unenterable//p' 'rooms//p' 
    with parse_name Parse_Name_GV126
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_985
    with p15_dark_description BC_986
    with p25_behind_description BC_987
    with p48_possessive BC_988
    with list_together BC_989
    with plural BC_990
    with article BC_991
    with p106_summary BC_992
;

Object -> I299_car_1 ""
    class K2_thing
    with short_name BC_993
    with description BC_994
    with initial BC_995
    has proper
    has privately_named
    has static
    with vector 0
    has mark_as_thing
    with IK2_Count 27
    with IK2_Link I301_laundromat_facade
    with KD_Count 2
    with parse_name Parse_Name_GV127
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p15_dark_description BC_996
    with p25_behind_description BC_997
    with p48_possessive BC_998
    with list_together BC_999
    with plural BC_1000
    with article BC_1001
    with p106_summary BC_1002
;

Object -> I301_laundromat_facade ""
    class K18_unenterable_room
    with short_name BC_1003
    with description BC_1004
    has privately_named
    has static
    with vector 0
    has mark_as_thing
    with component_child I302_laundromat_sign
    with IK2_Count 29
    with IK2_Link I305_swamp_facade
    with IK18_Count 1
    with IK18_Link I305_swamp_facade
    with KD_Count 18
    with parse_name Parse_Name_GV129
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1005
    with p15_dark_description BC_1006
    with p25_behind_description BC_1007
    with p48_possessive BC_1008
    with list_together BC_1009
    with plural BC_1010
    with article BC_1011
    with p106_summary BC_1012
;

Object -> I305_swamp_facade ""
    class K18_unenterable_room
    with short_name BC_1013
    with description BC_1014
    has privately_named
    has static
    with vector 0
    has mark_as_thing
    with IK2_Count 32
    with IK2_Link I306_pawn_shop_facade
    with IK18_Count 2
    with IK18_Link I306_pawn_shop_facade
    with KD_Count 18
    with parse_name Parse_Name_GV130
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1015
    with p15_dark_description BC_1016
    with p25_behind_description BC_1017
    with p48_possessive BC_1018
    with list_together BC_1019
    with plural BC_1020
    with article BC_1021
    with p106_summary BC_1022
;

Object -> I306_pawn_shop_facade ""
    class K18_unenterable_room
    with short_name BC_1023
    with description BC_1024
    has proper
    has privately_named
    has static
    with vector 0
    has mark_as_thing
    with component_child I307_flashing_neon_sign
    with IK2_Count 33
    with IK2_Link I310_automatic_car_wash
    with IK18_Count 3
    with IK18_Link I310_automatic_car_wash
    with KD_Count 18
    with parse_name Parse_Name_GV131
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1025
    with p15_dark_description BC_1026
    with p25_behind_description BC_1027
    with p48_possessive BC_1028
    with list_together BC_1029
    with plural BC_1030
    with article BC_1031
    with p106_summary BC_1032
;

Object -> I310_automatic_car_wash ""
    class K18_unenterable_room
    with short_name BC_1033
    with description BC_1034
    has static
    with vector 0
    has mark_as_thing
    with IK2_Count 36
    with IK2_Link I311_interstate
    with IK18_Count 4
    with IK18_Link I313_convenience_store_facad
    with KD_Count 18
    with name 'automatic' 'car' 'wash' 'unenterable//p' 'rooms//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1035
    with p15_dark_description BC_1036
    with p25_behind_description BC_1037
    with p48_possessive BC_1038
    with list_together BC_1039
    with plural BC_1040
    with article BC_1041
    with p106_summary BC_1042
;

Object -> I311_interstate ""
    class K2_thing
    with short_name BC_1043
    with description BC_1044
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 37
    with IK2_Link I358_margaret_chao
    with KD_Count 2
    with name 'interstate' 'things//p' 
    with parse_name Parse_Name_GV133
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1045
    with p15_dark_description BC_1046
    with p25_behind_description BC_1047
    with p48_possessive BC_1048
    with list_together BC_1049
    with plural BC_1050
    with article BC_1051
    with p106_summary BC_1052
;

Object I295_the_front_office ""
    class K1_room
    with short_name BC_1053
    with description BC_1054
    with map_region I428_bosh_hq
    has proper
    has p105_outdoor_adjacent
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 10
    with IK1_Link I304_laundromat_store
    with KD_Count 1
    with name 'the' 'front' 'office' 'rooms//p' 
    with p15_dark_description BC_1055
    with p21_preposition BC_1056
    with p24_destination_name BC_1057
    with list_together BC_1058
    with plural BC_1059
    with article BC_1060
    with p106_summary BC_1061
;

Object -> I358_margaret_chao ""
    class K11_woman
    with short_name BC_1062
    with description BC_1063
    with p38_how_are_you_reply BC_1064
    with p49_portrait I505_figure_margaret
    has proper
    has p97_familiar
    with vector 0
    has mark_as_thing
    with IK2_Count 73
    with IK2_Link I457_coffee_table
    with IK8_Count 7
    with IK8_Link I320_dave
    with IK11_Count 2
    with IK11_Link I405_petula_goldberg
    with KD_Count 11
    with name 'margaret' 'chao' 'women//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p22_behavior_stack BC_1065
    with p26_remembrances BC_1066
    with p29_queue BC_1067
    with initial BC_1068
    with p15_dark_description BC_1069
    with p25_behind_description BC_1070
    with p48_possessive BC_1071
    with list_together BC_1072
    with plural BC_1073
    with article BC_1074
    with p106_summary BC_1075
;

Object -> I457_coffee_table ""
    class K6_supporter
    with short_name BC_1076
    with description BC_1077
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 119
    with IK2_Link I458_couch
    with IK6_Count 3
    with IK6_Link I458_couch
    with KD_Count 6
    with name 'coffee' 'table' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1078
    with p15_dark_description BC_1079
    with p25_behind_description BC_1080
    with p48_possessive BC_1081
    with list_together BC_1082
    with plural BC_1083
    with article BC_1084
    with p106_summary BC_1085
;

Object -> I458_couch ""
    class K6_supporter
    with short_name BC_1086
    with description BC_1087
    has static
    has scenery
    has enterable
    with vector 0
    has mark_as_thing
    with IK2_Count 120
    with IK2_Link I459_seating_area
    with IK6_Count 4
    with IK6_Link I462_front_desk
    with KD_Count 6
    with name 'couch' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1088
    with p15_dark_description BC_1089
    with p25_behind_description BC_1090
    with p48_possessive BC_1091
    with list_together BC_1092
    with plural BC_1093
    with article BC_1094
    with p106_summary BC_1095
;

Object -> I459_seating_area ""
    class K2_thing
    with short_name BC_1096
    with description BC_1097
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 121
    with IK2_Link I460_coatrack
    with KD_Count 2
    with name 'seating' 'area' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1098
    with p15_dark_description BC_1099
    with p25_behind_description BC_1100
    with p48_possessive BC_1101
    with list_together BC_1102
    with plural BC_1103
    with article BC_1104
    with p106_summary BC_1105
;

Object -> I460_coatrack ""
    class K2_thing
    with short_name BC_1106
    with description BC_1107
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 122
    with IK2_Link I462_front_desk
    with KD_Count 2
    with name 'coatrack' 'things//p' 
    with parse_name Parse_Name_GV173
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1108
    with p15_dark_description BC_1109
    with p25_behind_description BC_1110
    with p48_possessive BC_1111
    with list_together BC_1112
    with plural BC_1113
    with article BC_1114
    with p106_summary BC_1115
;

Object -> I462_front_desk ""
    class K6_supporter
    with short_name BC_1116
    with description BC_1117
    with p25_behind_description BC_1118
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 124
    with IK2_Link I463_shelves_of_office_suppl
    with IK6_Count 5
    with IK6_Link I342_shop_counter
    with KD_Count 6
    with name 'front' 'desk' 'supporters//p' 'sales' 'counter' 
    with parse_name Parse_Name_GV175
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1119
    with p15_dark_description BC_1120
    with p48_possessive BC_1121
    with list_together BC_1122
    with plural BC_1123
    with article BC_1124
    with p106_summary BC_1125
;

Object -> I463_shelves_of_office_suppl ""
    class K2_thing
    with short_name BC_1126
    with description BC_1127
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 125
    with IK2_Link I466_cardboard_boxes
    with KD_Count 2
    with name 'shelves' 'of' 'office' 'supplies' 'things//p' 'drawers' 
    with parse_name Parse_Name_GV176
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1128
    with p15_dark_description BC_1129
    with p25_behind_description BC_1130
    with p48_possessive BC_1131
    with list_together BC_1132
    with plural BC_1133
    with article BC_1134
    with p106_summary BC_1135
;

Object -> I466_cardboard_boxes ""
    class K2_thing
    with short_name BC_1136
    with description BC_1137
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 128
    with IK2_Link I469_heating_vent
    with KD_Count 2
    with name 'cardboard' 'boxes' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1138
    with p15_dark_description BC_1139
    with p25_behind_description BC_1140
    with p48_possessive BC_1141
    with list_together BC_1142
    with plural BC_1143
    with article BC_1144
    with p106_summary BC_1145
;

Object -> I469_heating_vent ""
    class K5_container
    with short_name BC_1146
    with description BC_1147
    has static
    has scenery
    has transparent
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    has mark_as_thing
    with component_child I470_screws
    with IK2_Count 131
    with IK2_Link I364_hex_wrench
    with IK5_Count 3
    with IK5_Link I336_broken_washing_machine
    with KD_Count 5
    with name 'heating' 'vent' 'containers//p' 
    with parse_name Parse_Name_GV180
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1148
    with p15_dark_description BC_1149
    with p25_behind_description BC_1150
    with p48_possessive BC_1151
    with list_together BC_1152
    with plural BC_1153
    with article BC_1154
    with p106_summary BC_1155
;

Object -> -> I364_hex_wrench ""
    class K2_thing
    with short_name BC_1156
    with description BC_1157
    with vector 0
    has mark_as_thing
    with IK2_Count 79
    with IK2_Link I297_margaret_at_a_distance
    with KD_Count 2
    with name 'hex' 'wrench' 'things//p' 
    with parse_name Parse_Name_GV181
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1158
    with p15_dark_description BC_1159
    with p25_behind_description BC_1160
    with p48_possessive BC_1161
    with list_together BC_1162
    with plural BC_1163
    with article BC_1164
    with p106_summary BC_1165
;

Object I297_margaret_at_a_distance ""
    class K2_thing
    with short_name BC_1166
    with description BC_1167
    has proper
    has privately_named
    has ~neuter
    has female
    with vector 0
    has mark_as_thing
    with component_parent I296_office_
    with component_sibling I298_department_store_sign
    with IK2_Count 25
    with IK2_Link I298_department_store_sign
    with KD_Count 2
    with parse_name Parse_Name_GV124
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1168
    with p15_dark_description BC_1169
    with p25_behind_description BC_1170
    with p48_possessive BC_1171
    with list_together BC_1172
    with plural BC_1173
    with article BC_1174
    with p106_summary BC_1175
;

Object I298_department_store_sign ""
    class K2_thing
    with short_name BC_1176
    with description BC_1177
    with vector 0
    has mark_as_thing
    with component_parent I296_office_
    with IK2_Count 26
    with IK2_Link I300_car_2
    with KD_Count 2
    with name 'department' 'store' 'sign' 'things//p' 
    with parse_name Parse_Name_GV125
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1178
    with p15_dark_description BC_1179
    with p25_behind_description BC_1180
    with p48_possessive BC_1181
    with list_together BC_1182
    with plural BC_1183
    with article BC_1184
    with p106_summary BC_1185
;

Object I300_car_2 ""
    class K2_thing
    with short_name BC_1186
    with description BC_1187
    with initial BC_1188
    has proper
    has privately_named
    has static
    with vector 0
    has mark_as_thing
    with IK2_Count 28
    with IK2_Link I302_laundromat_sign
    with KD_Count 2
    with parse_name Parse_Name_GV128
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p15_dark_description BC_1189
    with p25_behind_description BC_1190
    with p48_possessive BC_1191
    with list_together BC_1192
    with plural BC_1193
    with article BC_1194
    with p106_summary BC_1195
;

Object I302_laundromat_sign ""
    class K2_thing
    with short_name BC_1196
    with description BC_1197
    with vector 0
    has mark_as_thing
    with component_parent I301_laundromat_facade
    with IK2_Count 30
    with IK2_Link I303_laundromat_door
    with KD_Count 2
    with name 'laundromat' 'sign' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1198
    with p15_dark_description BC_1199
    with p25_behind_description BC_1200
    with p48_possessive BC_1201
    with list_together BC_1202
    with plural BC_1203
    with article BC_1204
    with p106_summary BC_1205
;

Object I303_laundromat_door ""
    class K32_shop_door
    with short_name BC_1206
    with p30_frontside I294_strip_mall_parking_lot_
    with p33_front_description BC_1207
    with p34_back_description BC_1208
    has scenery
    has ~open
    has lockable
    has locked
    with vector 0
    with door_dir [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I294_strip_mall_parking_lot_) return I53_northwest; return I55_southeast;],
    with door_to [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I294_strip_mall_parking_lot_) return I304_laundromat_store; return I294_strip_mall_parking_lot_;],
    with found_in I294_strip_mall_parking_lot_ I304_laundromat_store
    has mark_as_thing
    with IK2_Count 31
    with IK2_Link I328_handtruck
    with IK4_Count 0
    with IK4_Link I308_pawn_shop_door
    with IK30_Count 0
    with IK30_Link I308_pawn_shop_door
    with IK32_Count 0
    with IK32_Link I308_pawn_shop_door
    with KD_Count 32
    with name 'laundromat' 'door' 'shop-doors//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1209
    with initial BC_1210
    with p15_dark_description BC_1211
    with p25_behind_description BC_1212
    with p48_possessive BC_1213
    with list_together BC_1214
    with plural BC_1215
    with article BC_1216
    with p106_summary BC_1217
;

Object I304_laundromat_store ""
    class K1_room
    with short_name BC_1218
    with description BC_1219
    with map_region I327_laundromat_region
    has privately_named
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 11
    with IK1_Link I309_dave_s_pawn_shop
    with KD_Count 1
    with parse_name Parse_Name_GV141
    with p15_dark_description BC_1220
    with p21_preposition BC_1221
    with p24_destination_name BC_1222
    with list_together BC_1223
    with plural BC_1224
    with article BC_1225
    with p106_summary BC_1226
;

Object -> I328_handtruck ""
    class K2_thing
    with short_name BC_1227
    has pushable
    with vector 0
    has mark_as_thing
    with IK2_Count 49
    with IK2_Link I332_ls_light
    with KD_Count 2
    with name 'handtruck' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1228
    with initial BC_1229
    with p15_dark_description BC_1230
    with p25_behind_description BC_1231
    with p48_possessive BC_1232
    with list_together BC_1233
    with plural BC_1234
    with article BC_1235
    with p106_summary BC_1236
;

Object -> I332_ls_light ""
    class K27_light_source
    with short_name BC_1237
    has proper
    with p139_fluorescent true
    with vector 0
    with cap_short_name BC_1238
    has mark_as_thing
    with IK2_Count 50
    with IK2_Link I307_flashing_neon_sign
    with IK27_Count 1
    with IK27_Link I319_pawn_light
    with KD_Count 27
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1239
    with initial BC_1240
    with p15_dark_description BC_1241
    with p25_behind_description BC_1242
    with p48_possessive BC_1243
    with list_together BC_1244
    with plural BC_1245
    with article BC_1246
    with p106_summary BC_1247
;

Object I307_flashing_neon_sign ""
    class K2_thing
    with short_name BC_1248
    with description BC_1249
    with vector 0
    has mark_as_thing
    with component_parent I306_pawn_shop_facade
    with IK2_Count 34
    with IK2_Link I308_pawn_shop_door
    with KD_Count 2
    with name 'flashing' 'neon' 'sign' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1250
    with p15_dark_description BC_1251
    with p25_behind_description BC_1252
    with p48_possessive BC_1253
    with list_together BC_1254
    with plural BC_1255
    with article BC_1256
    with p106_summary BC_1257
;

Object I308_pawn_shop_door ""
    class K32_shop_door
    with short_name BC_1258
    with p30_frontside I294_strip_mall_parking_lot_
    with p33_front_description BC_1259
    with p34_back_description BC_1260
    has privately_named
    has scenery
    has ~open
    with vector 0
    with door_dir [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I294_strip_mall_parking_lot_) return I56_southwest; return I52_northeast;],
    with door_to [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I294_strip_mall_parking_lot_) return I309_dave_s_pawn_shop; return I294_strip_mall_parking_lot_;],
    with found_in I294_strip_mall_parking_lot_ I309_dave_s_pawn_shop
    has mark_as_thing
    with IK2_Count 35
    with IK2_Link I319_pawn_light
    with IK4_Count 1
    with IK4_Link I367_bosh_back_door
    with IK30_Count 1
    with IK30_Link nothing
    with IK32_Count 1
    with IK32_Link nothing
    with KD_Count 32
    with parse_name Parse_Name_GV132
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1261
    with initial BC_1262
    with p15_dark_description BC_1263
    with p25_behind_description BC_1264
    with p48_possessive BC_1265
    with list_together BC_1266
    with plural BC_1267
    with article BC_1268
    with p106_summary BC_1269
;

Object I309_dave_s_pawn_shop ""
    class K1_room
    with short_name BC_1270
    with description BC_1271
    with map_region I293_swamp_park
    with p24_destination_name BC_1272
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 12
    with IK1_Link I312_strip_mall_parking_lot_
    with KD_Count 1
    with name 'dave^s' 'pawn' 'shop' 'rooms//p' 
    with p15_dark_description BC_1273
    with p21_preposition BC_1274
    with list_together BC_1275
    with plural BC_1276
    with article BC_1277
    with p106_summary BC_1278
;

Object -> I319_pawn_light ""
    class K27_light_source
    with short_name BC_1279
    has proper
    with p139_fluorescent true
    with vector 0
    with cap_short_name BC_1280
    has mark_as_thing
    with IK2_Count 44
    with IK2_Link I320_dave
    with IK27_Count 0
    with IK27_Link I333_lbr_light
    with KD_Count 27
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1281
    with initial BC_1282
    with p15_dark_description BC_1283
    with p25_behind_description BC_1284
    with p48_possessive BC_1285
    with list_together BC_1286
    with plural BC_1287
    with article BC_1288
    with p106_summary BC_1289
;

Object -> I320_dave ""
    class K10_man
    with short_name BC_1290
    with description BC_1291
    with initial BC_1292
    with p38_how_are_you_reply BC_1293
    with p49_portrait I508_figure_pawn_owner
    has proper
    with vector 0
    has mark_as_thing
    with IK2_Count 45
    with IK2_Link I313_convenience_store_facad
    with IK8_Count 5
    with IK8_Link I341_store_clerk
    with IK10_Count 1
    with IK10_Link I341_store_clerk
    with KD_Count 10
    with name 'dave' 'men//p' 'owner' 
    with parse_name Parse_Name_GV139
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p22_behavior_stack BC_1294
    with p26_remembrances BC_1295
    with p29_queue BC_1296
    with p15_dark_description BC_1297
    with p25_behind_description BC_1298
    with p48_possessive BC_1299
    with list_together BC_1300
    with plural BC_1301
    with article BC_1302
    with p106_summary BC_1303
;

Object I312_strip_mall_parking_lot_ ""
    class K1_room
    with short_name BC_1304
    with description BC_1305
    with map_region I293_swamp_park
    with p21_preposition BC_1306
    with p102_room_condition I157_outdoors
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 13
    with IK1_Link I324_astral_tunnel_1
    with KD_Count 1
    with name 'strip' 'mall' 'parking' 'lot' 'north' 'rooms//p' 
    with parse_name Parse_Name_GV134
    with p15_dark_description BC_1307
    with p24_destination_name BC_1308
    with list_together BC_1309
    with plural BC_1310
    with article BC_1311
    with p106_summary BC_1312
;

Object -> I313_convenience_store_facad ""
    class K18_unenterable_room
    with short_name BC_1313
    with description BC_1314
    has privately_named
    has static
    with vector 0
    has mark_as_thing
    with IK2_Count 38
    with IK2_Link I314_military_facade
    with IK18_Count 5
    with IK18_Link I314_military_facade
    with KD_Count 18
    with parse_name Parse_Name_GV135
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1315
    with p15_dark_description BC_1316
    with p25_behind_description BC_1317
    with p48_possessive BC_1318
    with list_together BC_1319
    with plural BC_1320
    with article BC_1321
    with p106_summary BC_1322
;

Object -> I314_military_facade ""
    class K18_unenterable_room
    with short_name BC_1323
    with description BC_1324
    has privately_named
    has static
    with vector 0
    has mark_as_thing
    with IK2_Count 39
    with IK2_Link I315_patriotic_posters
    with IK18_Count 6
    with IK18_Link nothing
    with KD_Count 18
    with parse_name Parse_Name_GV136
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1325
    with p15_dark_description BC_1326
    with p25_behind_description BC_1327
    with p48_possessive BC_1328
    with list_together BC_1329
    with plural BC_1330
    with article BC_1331
    with p106_summary BC_1332
;

Object -> I315_patriotic_posters ""
    class K2_thing
    with short_name BC_1333
    with description BC_1334
    has proper
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 40
    with IK2_Link I316_busy_road
    with KD_Count 2
    with name 'patriotic' 'posters' 'things//p' 
    with parse_name Parse_Name_GV137
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1335
    with p15_dark_description BC_1336
    with p25_behind_description BC_1337
    with p48_possessive BC_1338
    with list_together BC_1339
    with plural BC_1340
    with article BC_1341
    with p106_summary BC_1342
;

Object -> I316_busy_road ""
    class K2_thing
    with short_name BC_1343
    with description BC_1344
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 41
    with IK2_Link I317_rusty_sign
    with KD_Count 2
    with name 'busy' 'road' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1345
    with p15_dark_description BC_1346
    with p25_behind_description BC_1347
    with p48_possessive BC_1348
    with list_together BC_1349
    with plural BC_1350
    with article BC_1351
    with p106_summary BC_1352
;

Object -> I317_rusty_sign ""
    class K2_thing
    with short_name BC_1353
    with description BC_1354
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 42
    with IK2_Link I318_bosh_headquarters_to_th
    with KD_Count 2
    with name 'rusty' 'sign' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1355
    with p15_dark_description BC_1356
    with p25_behind_description BC_1357
    with p48_possessive BC_1358
    with list_together BC_1359
    with plural BC_1360
    with article BC_1361
    with p106_summary BC_1362
;

Object -> I318_bosh_headquarters_to_th ""
    class K2_thing
    with short_name BC_1363
    with description BC_1364
    has proper
    has privately_named
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 43
    with IK2_Link I321_for_a_screwdriver_pawn
    with KD_Count 2
    with parse_name Parse_Name_GV138
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1365
    with p15_dark_description BC_1366
    with p25_behind_description BC_1367
    with p48_possessive BC_1368
    with list_together BC_1369
    with plural BC_1370
    with article BC_1371
    with p106_summary BC_1372
;

Object I321_for_a_screwdriver_pawn ""
    class K29_quip
    with short_name BC_1373
    with p27_comment BC_1374
    with p28_reply BC_1375
    has proper
    has privately_named
    with p143_quip_condition I223_questioning
    with vector 0
    has mark_as_thing
    with IK2_Count 46
    with IK2_Link I322_screwdriver
    with IK29_Count 8
    with IK29_Link I323_about_the_laundromat_ow
    with KD_Count 29
    with parse_name Parse_Name_GV140
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1376
    with initial BC_1377
    with p15_dark_description BC_1378
    with p25_behind_description BC_1379
    with p48_possessive BC_1380
    with list_together BC_1381
    with plural BC_1382
    with article BC_1383
    with p106_summary BC_1384
;

Object I322_screwdriver ""
    class K2_thing
    with short_name BC_1385
    with vector 0
    has mark_as_thing
    with IK2_Count 47
    with IK2_Link I323_about_the_laundromat_ow
    with KD_Count 2
    with name 'screwdriver' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1386
    with initial BC_1387
    with p15_dark_description BC_1388
    with p25_behind_description BC_1389
    with p48_possessive BC_1390
    with list_together BC_1391
    with plural BC_1392
    with article BC_1393
    with p106_summary BC_1394
;

Object I323_about_the_laundromat_ow ""
    class K29_quip
    with short_name BC_1395
    with p27_comment BC_1396
    with p28_reply BC_1397
    has proper
    with p143_quip_condition I223_questioning
    with vector 0
    with cap_short_name BC_1398
    has mark_as_thing
    with IK2_Count 48
    with IK2_Link I448_dumpster
    with IK29_Count 9
    with IK29_Link I354_for_a_screwdriver_clerk
    with KD_Count 29
    with name 'about' 'the' 'laundromat' 'owner' 'quips//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1399
    with initial BC_1400
    with p15_dark_description BC_1401
    with p25_behind_description BC_1402
    with p48_possessive BC_1403
    with list_together BC_1404
    with plural BC_1405
    with article BC_1406
    with p106_summary BC_1407
;

Object I324_astral_tunnel_1 ""
    class K1_room
    with short_name BC_1408
    with description BC_1409
    with map_region I232_hyperspace
    has privately_named
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 14
    with IK1_Link I325_back_lot
    with KD_Count 1
    with p15_dark_description BC_1410
    with p21_preposition BC_1411
    with p24_destination_name BC_1412
    with list_together BC_1413
    with plural BC_1414
    with article BC_1415
    with p106_summary BC_1416
;

Object I325_back_lot ""
    class K1_room
    with short_name BC_1417
    with description BC_1418
    with map_region I428_bosh_hq
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 15
    with IK1_Link I326_astral_tunnel_2
    with KD_Count 1
    with name 'back' 'lot' 'rooms//p' 
    with p15_dark_description BC_1419
    with p21_preposition BC_1420
    with p24_destination_name BC_1421
    with list_together BC_1422
    with plural BC_1423
    with article BC_1424
    with p106_summary BC_1425
;

Object -> I448_dumpster ""
    class K2_thing
    with short_name BC_1426
    with description BC_1427
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 115
    with IK2_Link I333_lbr_light
    with KD_Count 2
    with name 'dumpster' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1428
    with p15_dark_description BC_1429
    with p25_behind_description BC_1430
    with p48_possessive BC_1431
    with list_together BC_1432
    with plural BC_1433
    with article BC_1434
    with p106_summary BC_1435
;

Object I326_astral_tunnel_2 ""
    class K1_room
    with short_name BC_1436
    with description BC_1437
    with map_region I232_hyperspace
    has privately_named
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 16
    with IK1_Link I329_laundromat_back_room
    with KD_Count 1
    with p15_dark_description BC_1438
    with p21_preposition BC_1439
    with p24_destination_name BC_1440
    with list_together BC_1441
    with plural BC_1442
    with article BC_1443
    with p106_summary BC_1444
;

Object I329_laundromat_back_room ""
    class K1_room
    with short_name BC_1445
    with map_region I327_laundromat_region
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 17
    with IK1_Link I330_laundromat_basement
    with KD_Count 1
    with name 'laundromat' 'back' 'room' 'rooms//p' 
    with description BC_1446
    with p15_dark_description BC_1447
    with p21_preposition BC_1448
    with p24_destination_name BC_1449
    with list_together BC_1450
    with plural BC_1451
    with article BC_1452
    with p106_summary BC_1453
;

Object -> I333_lbr_light ""
    class K27_light_source
    with short_name BC_1454
    has proper
    with p139_fluorescent true
    with vector 0
    with cap_short_name BC_1455
    has mark_as_thing
    with IK2_Count 51
    with IK2_Link I334_lb_light
    with IK27_Count 2
    with IK27_Link I334_lb_light
    with KD_Count 27
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1456
    with initial BC_1457
    with p15_dark_description BC_1458
    with p25_behind_description BC_1459
    with p48_possessive BC_1460
    with list_together BC_1461
    with plural BC_1462
    with article BC_1463
    with p106_summary BC_1464
;

Object I330_laundromat_basement ""
    class K1_room
    with short_name BC_1465
    with map_region I327_laundromat_region
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 18
    with IK1_Link I331_back_basement
    with KD_Count 1
    with name 'laundromat' 'basement' 'rooms//p' 
    with description BC_1466
    with p15_dark_description BC_1467
    with p21_preposition BC_1468
    with p24_destination_name BC_1469
    with list_together BC_1470
    with plural BC_1471
    with article BC_1472
    with p106_summary BC_1473
;

Object -> I334_lb_light ""
    class K27_light_source
    with short_name BC_1474
    has proper
    with p139_fluorescent true
    with vector 0
    with cap_short_name BC_1475
    has mark_as_thing
    with IK2_Count 52
    with IK2_Link I335_bb_light
    with IK27_Count 3
    with IK27_Link I335_bb_light
    with KD_Count 27
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1476
    with initial BC_1477
    with p15_dark_description BC_1478
    with p25_behind_description BC_1479
    with p48_possessive BC_1480
    with list_together BC_1481
    with plural BC_1482
    with article BC_1483
    with p106_summary BC_1484
;

Object I331_back_basement ""
    class K1_room
    with short_name BC_1485
    with map_region I327_laundromat_region
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 19
    with IK1_Link I339_astral_tunnel_3
    with KD_Count 1
    with name 'back' 'basement' 'rooms//p' 
    with description BC_1486
    with p15_dark_description BC_1487
    with p21_preposition BC_1488
    with p24_destination_name BC_1489
    with list_together BC_1490
    with plural BC_1491
    with article BC_1492
    with p106_summary BC_1493
;

Object -> I335_bb_light ""
    class K27_light_source
    with short_name BC_1494
    has proper
    with p139_fluorescent true
    with vector 0
    with cap_short_name BC_1495
    has mark_as_thing
    with IK2_Count 53
    with IK2_Link I337_filing_cabinets
    with IK27_Count 4
    with IK27_Link nothing
    with KD_Count 27
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1496
    with initial BC_1497
    with p15_dark_description BC_1498
    with p25_behind_description BC_1499
    with p48_possessive BC_1500
    with list_together BC_1501
    with plural BC_1502
    with article BC_1503
    with p106_summary BC_1504
;

Object -> I337_filing_cabinets ""
    class K2_thing
    with short_name BC_1505
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 55
    with IK2_Link I338_light_switch
    with KD_Count 2
    with name 'filing' 'cabinets' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1506
    with initial BC_1507
    with p15_dark_description BC_1508
    with p25_behind_description BC_1509
    with p48_possessive BC_1510
    with list_together BC_1511
    with plural BC_1512
    with article BC_1513
    with p106_summary BC_1514
;

Object -> I338_light_switch ""
    class K14_device
    with short_name BC_1515
    has static
    has scenery
    has on
    with vector 0
    has mark_as_thing
    with IK2_Count 56
    with IK2_Link I336_broken_washing_machine
    with IK14_Count 0
    with IK14_Link I349_flashlight
    with KD_Count 14
    with name 'light' 'switch' 'devices//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1516
    with initial BC_1517
    with p15_dark_description BC_1518
    with p25_behind_description BC_1519
    with p48_possessive BC_1520
    with list_together BC_1521
    with plural BC_1522
    with article BC_1523
    with p106_summary BC_1524
;

Object I336_broken_washing_machine ""
    class K5_container
    with short_name BC_1525
    has enterable
    has ~open
    has openable
    with vector 0
    has mark_as_thing
    with IK2_Count 54
    with IK2_Link I341_store_clerk
    with IK5_Count 0
    with IK5_Link I350_glass_case
    with KD_Count 5
    with name 'broken' 'washing' 'machine' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1526
    with initial BC_1527
    with p15_dark_description BC_1528
    with p25_behind_description BC_1529
    with p48_possessive BC_1530
    with list_together BC_1531
    with plural BC_1532
    with article BC_1533
    with p106_summary BC_1534
;

Object I339_astral_tunnel_3 ""
    class K1_room
    with short_name BC_1535
    with description BC_1536
    with map_region I232_hyperspace
    has privately_named
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 20
    with IK1_Link I340_li_l_nectarine_convenie
    with KD_Count 1
    with p15_dark_description BC_1537
    with p21_preposition BC_1538
    with p24_destination_name BC_1539
    with list_together BC_1540
    with plural BC_1541
    with article BC_1542
    with p106_summary BC_1543
;

Object I340_li_l_nectarine_convenie ""
    class K1_room
    with short_name BC_1544
    with description BC_1545
    with map_region I293_swamp_park
    with p24_destination_name BC_1546
    with p102_room_condition I156_indoors
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 21
    with IK1_Link I357_room_of_stuff
    with KD_Count 1
    with name 'li^l' 'nectarine' 'convenience' 'store' 'rooms//p' 
    with p15_dark_description BC_1547
    with p21_preposition BC_1548
    with list_together BC_1549
    with plural BC_1550
    with article BC_1551
    with p106_summary BC_1552
;

Object -> I341_store_clerk ""
    class K10_man
    with short_name BC_1553
    with description BC_1554
    with initial BC_1555
    with p38_how_are_you_reply BC_1556
    with p49_portrait I507_figure_clerk
    with vector 0
    has mark_as_thing
    with IK2_Count 57
    with IK2_Link I342_shop_counter
    with IK8_Count 6
    with IK8_Link selfobj
    with IK10_Count 2
    with IK10_Link I404_ezra_gaunt
    with KD_Count 10
    with name 'store' 'clerk' 'men//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p22_behavior_stack BC_1557
    with p26_remembrances BC_1558
    with p29_queue BC_1559
    with p15_dark_description BC_1560
    with p25_behind_description BC_1561
    with p48_possessive BC_1562
    with list_together BC_1563
    with plural BC_1564
    with article BC_1565
    with p106_summary BC_1566
;

Object -> I342_shop_counter ""
    class K6_supporter
    with short_name BC_1567
    with description BC_1568
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 58
    with IK2_Link I343_cbd_oil
    with IK6_Count 0
    with IK6_Link I430_biff_s_desk
    with KD_Count 6
    with name 'shop' 'counter' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1569
    with p15_dark_description BC_1570
    with p25_behind_description BC_1571
    with p48_possessive BC_1572
    with list_together BC_1573
    with plural BC_1574
    with article BC_1575
    with p106_summary BC_1576
;

Object -> I343_cbd_oil ""
    class K2_thing
    with short_name BC_1577
    with description BC_1578
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 59
    with IK2_Link I344_antacids
    with KD_Count 2
    with name 'cbd' 'oil' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1579
    with p15_dark_description BC_1580
    with p25_behind_description BC_1581
    with p48_possessive BC_1582
    with list_together BC_1583
    with plural BC_1584
    with article BC_1585
    with p106_summary BC_1586
;

Object -> I344_antacids ""
    class K2_thing
    with short_name BC_1587
    with description BC_1588
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 60
    with IK2_Link I345_cigarettes
    with KD_Count 2
    with name 'antacids' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1589
    with p15_dark_description BC_1590
    with p25_behind_description BC_1591
    with p48_possessive BC_1592
    with list_together BC_1593
    with plural BC_1594
    with article BC_1595
    with p106_summary BC_1596
;

Object -> I345_cigarettes ""
    class K2_thing
    with short_name BC_1597
    with description BC_1598
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 61
    with IK2_Link I346_lottery_tickets
    with KD_Count 2
    with name 'cigarettes' 'things//p' 
    with parse_name Parse_Name_GV142
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1599
    with p15_dark_description BC_1600
    with p25_behind_description BC_1601
    with p48_possessive BC_1602
    with list_together BC_1603
    with plural BC_1604
    with article BC_1605
    with p106_summary BC_1606
;

Object -> I346_lottery_tickets ""
    class K2_thing
    with short_name BC_1607
    with description BC_1608
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 62
    with IK2_Link I347_store_shelves
    with KD_Count 2
    with name 'lottery' 'tickets' 'things//p' 
    with parse_name Parse_Name_GV143
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1609
    with p15_dark_description BC_1610
    with p25_behind_description BC_1611
    with p48_possessive BC_1612
    with list_together BC_1613
    with plural BC_1614
    with article BC_1615
    with p106_summary BC_1616
;

Object -> I347_store_shelves ""
    class K2_thing
    with short_name BC_1617
    with description BC_1618
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 63
    with IK2_Link I348_groceries
    with KD_Count 2
    with name 'store' 'shelves' 'things//p' 
    with parse_name Parse_Name_GV144
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1619
    with p15_dark_description BC_1620
    with p25_behind_description BC_1621
    with p48_possessive BC_1622
    with list_together BC_1623
    with plural BC_1624
    with article BC_1625
    with p106_summary BC_1626
;

Object -> I348_groceries ""
    class K2_thing
    with short_name BC_1627
    with description BC_1628
    has pluralname
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 64
    with IK2_Link I350_glass_case
    with KD_Count 2
    with name 'groceries' 'things//p' 
    with parse_name Parse_Name_GV145
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1629
    with p15_dark_description BC_1630
    with p25_behind_description BC_1631
    with p48_possessive BC_1632
    with list_together BC_1633
    with plural BC_1634
    with article BC_1635
    with p106_summary BC_1636
;

Object -> I350_glass_case ""
    class K5_container
    with short_name BC_1637
    has static
    has scenery
    has transparent
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    has mark_as_thing
    with IK2_Count 66
    with IK2_Link I349_flashlight
    with IK5_Count 1
    with IK5_Link I431_biff_s_desk_s_drawer
    with KD_Count 5
    with name 'glass' 'case' 'containers//p' 
    with parse_name Parse_Name_GV147
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1638
    with initial BC_1639
    with p15_dark_description BC_1640
    with p25_behind_description BC_1641
    with p48_possessive BC_1642
    with list_together BC_1643
    with plural BC_1644
    with article BC_1645
    with p106_summary BC_1646
;

Object -> -> I349_flashlight ""
    class K14_device
    with short_name BC_1647
    with p20_price 5
    with p125_owner I341_store_clerk
    with p126_vendor I341_store_clerk
    with vector 0
    has mark_as_thing
    with IK2_Count 65
    with IK2_Link I351_red_screwdriver
    with IK14_Count 1
    with IK14_Link I488_circuit_breaker
    with KD_Count 14
    with name 'flashlight' 'devices//p' 
    with parse_name Parse_Name_GV146
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1648
    with initial BC_1649
    with p15_dark_description BC_1650
    with p25_behind_description BC_1651
    with p48_possessive BC_1652
    with list_together BC_1653
    with plural BC_1654
    with article BC_1655
    with p106_summary BC_1656
;

Object -> -> I351_red_screwdriver ""
    class K2_thing
    with short_name BC_1657
    with description BC_1658
    with p20_price 5
    with p125_owner I341_store_clerk
    with p126_vendor I341_store_clerk
    with vector 0
    has mark_as_thing
    with IK2_Count 67
    with IK2_Link I352_laptop_computer
    with KD_Count 2
    with name 'red' 'screwdriver' 'things//p' 
    with parse_name Parse_Name_GV148
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1659
    with p15_dark_description BC_1660
    with p25_behind_description BC_1661
    with p48_possessive BC_1662
    with list_together BC_1663
    with plural BC_1664
    with article BC_1665
    with p106_summary BC_1666
;

Object -> -> I352_laptop_computer ""
    class K2_thing
    with short_name BC_1667
    with description BC_1668
    with p20_price 1200
    with p125_owner I341_store_clerk
    with p126_vendor I341_store_clerk
    with vector 0
    has mark_as_thing
    with IK2_Count 68
    with IK2_Link I353_wireless_earbuds
    with KD_Count 2
    with name 'laptop' 'computer' 'things//p' 
    with parse_name Parse_Name_GV149
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1669
    with p15_dark_description BC_1670
    with p25_behind_description BC_1671
    with p48_possessive BC_1672
    with list_together BC_1673
    with plural BC_1674
    with article BC_1675
    with p106_summary BC_1676
;

Object -> -> I353_wireless_earbuds ""
    class K2_thing
    with short_name BC_1677
    with description BC_1678
    with p20_price 85
    has pluralname
    with p125_owner I341_store_clerk
    with p126_vendor I341_store_clerk
    with vector 0
    has mark_as_thing
    with IK2_Count 69
    with IK2_Link I354_for_a_screwdriver_clerk
    with KD_Count 2
    with name 'wireless' 'earbuds' 'things//p' 
    with parse_name Parse_Name_GV150
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1679
    with p15_dark_description BC_1680
    with p25_behind_description BC_1681
    with p48_possessive BC_1682
    with list_together BC_1683
    with plural BC_1684
    with article BC_1685
    with p106_summary BC_1686
;

Object I354_for_a_screwdriver_clerk ""
    class K29_quip
    with short_name BC_1687
    with p27_comment BC_1688
    with p28_reply BC_1689
    has proper
    has privately_named
    with p141_one_shot false
    with p143_quip_condition I223_questioning
    with vector 0
    has mark_as_thing
    with IK2_Count 70
    with IK2_Link I355_how_are_you
    with IK29_Count 10
    with IK29_Link I355_how_are_you
    with KD_Count 29
    with parse_name Parse_Name_GV151
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1690
    with initial BC_1691
    with p15_dark_description BC_1692
    with p25_behind_description BC_1693
    with p48_possessive BC_1694
    with list_together BC_1695
    with plural BC_1696
    with article BC_1697
    with p106_summary BC_1698
;

Object I355_how_are_you ""
    class K29_quip
    with short_name BC_1699
    with p27_comment BC_1700
    with p28_reply BC_1701
    has proper
    with p141_one_shot false
    with p143_quip_condition I223_questioning
    with p145_universal true
    with vector 0
    has mark_as_thing
    with IK2_Count 71
    with IK2_Link selfobj
    with IK29_Count 11
    with IK29_Link I359_about_the_whereabouts_o
    with KD_Count 29
    with name 'how-are-you' 'quips//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1702
    with initial BC_1703
    with p15_dark_description BC_1704
    with p25_behind_description BC_1705
    with p48_possessive BC_1706
    with list_together BC_1707
    with plural BC_1708
    with article BC_1709
    with p106_summary BC_1710
;

Object I357_room_of_stuff ""
    class K1_room
    with short_name BC_1711
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 22
    with IK1_Link I370_enigma_lake_town_hall
    with KD_Count 1
    with name 'room' 'of' 'stuff' 'rooms//p' 
    with description BC_1712
    with p15_dark_description BC_1713
    with p21_preposition BC_1714
    with p24_destination_name BC_1715
    with list_together BC_1716
    with plural BC_1717
    with article BC_1718
    with p106_summary BC_1719
;

Object -> selfobj ""
    class K8_person

    	with saved_short_name "yourself",
     
    with short_name BC_1720
    with description BC_1721
    has proper
    has concealed
    with vector 0
    with cap_short_name BC_1722
    has mark_as_thing
    with IK2_Count 0
    with IK2_Link I259_thumb_drive
    with IK8_Count 0
    with IK8_Link I404_ezra_gaunt
    with KD_Count 8
    with name 'yourself' 'people//p' 'player' 
    with parse_name Parse_Name_GV100
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p22_behavior_stack BC_1723
    with p26_remembrances BC_1724
    with p29_queue BC_1725
    with p38_how_are_you_reply BC_1726
    with initial BC_1727
    with p15_dark_description BC_1728
    with p25_behind_description BC_1729
    with p48_possessive BC_1730
    with list_together BC_1731
    with plural BC_1732
    with article BC_1733
    with p106_summary BC_1734
;

Object -> I259_thumb_drive ""
    class K2_thing
    with short_name BC_1735
    with description BC_1736
    with vector 0
    has mark_as_thing
    with component_child I464_strange_symbols
    with IK2_Count 18
    with IK2_Link I356_blue_screwdriver
    with KD_Count 2
    with name 'thumb' 'drive' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1737
    with p15_dark_description BC_1738
    with p25_behind_description BC_1739
    with p48_possessive BC_1740
    with list_together BC_1741
    with plural BC_1742
    with article BC_1743
    with p106_summary BC_1744
;

Object -> I356_blue_screwdriver ""
    class K2_thing
    with short_name BC_1745
    with vector 0
    has mark_as_thing
    with IK2_Count 72
    with IK2_Link I404_ezra_gaunt
    with KD_Count 2
    with name 'blue' 'screwdriver' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1746
    with initial BC_1747
    with p15_dark_description BC_1748
    with p25_behind_description BC_1749
    with p48_possessive BC_1750
    with list_together BC_1751
    with plural BC_1752
    with article BC_1753
    with p106_summary BC_1754
;

Object -> I404_ezra_gaunt ""
    class K10_man
    with short_name BC_1755
    with description BC_1756
    with p49_portrait I502_figure_gaunt
    has proper
    with vector 0
    has mark_as_thing
    with IK2_Count 83
    with IK2_Link I405_petula_goldberg
    with IK8_Count 8
    with IK8_Link I405_petula_goldberg
    with IK10_Count 3
    with IK10_Link I415_senator_savra
    with KD_Count 10
    with name 'ezra' 'gaunt' 'men//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p22_behavior_stack BC_1757
    with p26_remembrances BC_1758
    with p29_queue BC_1759
    with p38_how_are_you_reply BC_1760
    with initial BC_1761
    with p15_dark_description BC_1762
    with p25_behind_description BC_1763
    with p48_possessive BC_1764
    with list_together BC_1765
    with plural BC_1766
    with article BC_1767
    with p106_summary BC_1768
;

Object -> I405_petula_goldberg ""
    class K11_woman
    with short_name BC_1769
    with description BC_1770
    with p49_portrait I501_figure_goldberg
    has proper
    with vector 0
    has mark_as_thing
    with IK2_Count 84
    with IK2_Link I406_larch_faraji
    with IK8_Count 9
    with IK8_Link I406_larch_faraji
    with IK11_Count 3
    with IK11_Link I427_moira_zin
    with KD_Count 11
    with name 'petula' 'goldberg' 'women//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p22_behavior_stack BC_1771
    with p26_remembrances BC_1772
    with p29_queue BC_1773
    with p38_how_are_you_reply BC_1774
    with initial BC_1775
    with p15_dark_description BC_1776
    with p25_behind_description BC_1777
    with p48_possessive BC_1778
    with list_together BC_1779
    with plural BC_1780
    with article BC_1781
    with p106_summary BC_1782
;

Object -> I406_larch_faraji ""
    class K12_nonbinary
    with short_name BC_1783
    with description BC_1784
    with third_singular_pronoun I403_singular_they_pronoun
    with p49_portrait I503_figure_faraji
    has proper
    with vector 0
    has mark_as_thing
    with IK2_Count 85
    with IK2_Link I415_senator_savra
    with IK8_Count 10
    with IK8_Link I415_senator_savra
    with IK12_Count 1
    with IK12_Link nothing
    with KD_Count 12
    with name 'larch' 'faraji' 'nonbinaries//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p22_behavior_stack BC_1785
    with p26_remembrances BC_1786
    with p29_queue BC_1787
    with p38_how_are_you_reply BC_1788
    with initial BC_1789
    with p15_dark_description BC_1790
    with p25_behind_description BC_1791
    with p48_possessive BC_1792
    with list_together BC_1793
    with plural BC_1794
    with article BC_1795
    with p106_summary BC_1796
;

Object -> I415_senator_savra ""
    class K10_man
    with short_name BC_1797
    has proper
    has p97_familiar
    with vector 0
    has mark_as_thing
    with IK2_Count 86
    with IK2_Link I446_white_key
    with IK8_Count 11
    with IK8_Link I419_chief_huffton_klimp
    with IK10_Count 4
    with IK10_Link I419_chief_huffton_klimp
    with KD_Count 10
    with name 'senator' 'savra' 'men//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p22_behavior_stack BC_1798
    with p26_remembrances BC_1799
    with p29_queue BC_1800
    with p38_how_are_you_reply BC_1801
    with description BC_1802
    with initial BC_1803
    with p15_dark_description BC_1804
    with p25_behind_description BC_1805
    with p48_possessive BC_1806
    with list_together BC_1807
    with plural BC_1808
    with article BC_1809
    with p106_summary BC_1810
;

Object -> I446_white_key ""
    class K2_thing
    with short_name BC_1811
    with vector 0
    has mark_as_thing
    with IK2_Count 113
    with IK2_Link I465_finding_the_drive_befor
    with KD_Count 2
    with name 'white' 'key' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1812
    with initial BC_1813
    with p15_dark_description BC_1814
    with p25_behind_description BC_1815
    with p48_possessive BC_1816
    with list_together BC_1817
    with plural BC_1818
    with article BC_1819
    with p106_summary BC_1820
;

Object -> I465_finding_the_drive_befor ""
    class K28_memory
    with short_name BC_1821
    with description BC_1822
    has proper
    with vector 0
    with cap_short_name BC_1823
    has mark_as_thing
    with IK2_Count 127
    with IK2_Link I467_biff_flattened_boxes
    with IK28_Count 0
    with IK28_Link nothing
    with KD_Count 28
    with name 'finding' 'the' 'drive' 'before' 'memories//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1824
    with p15_dark_description BC_1825
    with p25_behind_description BC_1826
    with p48_possessive BC_1827
    with list_together BC_1828
    with plural BC_1829
    with article BC_1830
    with p106_summary BC_1831
;

Object -> I467_biff_flattened_boxes ""
    class K2_thing
    with short_name BC_1832
    with description BC_1833
    has pluralname
    has privately_named
    with vector 0
    has mark_as_thing
    with IK2_Count 129
    with IK2_Link I468_margaret_flattened_boxe
    with KD_Count 2
    with parse_name Parse_Name_GV177
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1834
    with p15_dark_description BC_1835
    with p25_behind_description BC_1836
    with p48_possessive BC_1837
    with list_together BC_1838
    with plural BC_1839
    with article BC_1840
    with p106_summary BC_1841
;

Object -> I468_margaret_flattened_boxe ""
    class K2_thing
    with short_name BC_1842
    with description BC_1843
    has pluralname
    has privately_named
    with vector 0
    has mark_as_thing
    with IK2_Count 130
    with IK2_Link I359_about_the_whereabouts_o
    with KD_Count 2
    with parse_name Parse_Name_GV178
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1844
    with p15_dark_description BC_1845
    with p25_behind_description BC_1846
    with p48_possessive BC_1847
    with list_together BC_1848
    with plural BC_1849
    with article BC_1850
    with p106_summary BC_1851
;

Object I359_about_the_whereabouts_o ""
    class K29_quip
    with short_name BC_1852
    with p27_comment BC_1853
    with p28_reply BC_1854
    has proper
    with p143_quip_condition I223_questioning
    with vector 0
    with cap_short_name BC_1855
    has mark_as_thing
    with IK2_Count 74
    with IK2_Link I361_about_the_status_of_the
    with IK29_Count 12
    with IK29_Link I361_about_the_status_of_the
    with KD_Count 29
    with name 'about' 'the' 'whereabouts' 'of' 'the' 'desk' 'key' 'quips//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1856
    with initial BC_1857
    with p15_dark_description BC_1858
    with p25_behind_description BC_1859
    with p48_possessive BC_1860
    with list_together BC_1861
    with plural BC_1862
    with article BC_1863
    with p106_summary BC_1864
;

Object I361_about_the_status_of_the ""
    class K29_quip
    with short_name BC_1865
    with p27_comment BC_1866
    with p28_reply BC_1867
    has proper
    with p143_quip_condition I223_questioning
    with vector 0
    with cap_short_name BC_1868
    has mark_as_thing
    with IK2_Count 76
    with IK2_Link I362_biff_s_computer
    with IK29_Count 13
    with IK29_Link I363_for_the_wrench
    with KD_Count 29
    with name 'about' 'the' 'status' 'of' 'the' 'computer' 'quips//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1869
    with initial BC_1870
    with p15_dark_description BC_1871
    with p25_behind_description BC_1872
    with p48_possessive BC_1873
    with list_together BC_1874
    with plural BC_1875
    with article BC_1876
    with p106_summary BC_1877
;

Object I362_biff_s_computer ""
    class K2_thing
    with short_name BC_1878
    with description BC_1879
    has proper
    has privately_named
    with p140_behindness_relation_sto I462_front_desk
    with vector 0
    has mark_as_thing
    with IK2_Count 77
    with IK2_Link I363_for_the_wrench
    with KD_Count 2
    with parse_name Parse_Name_GV179
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1880
    with p15_dark_description BC_1881
    with p25_behind_description BC_1882
    with p48_possessive BC_1883
    with list_together BC_1884
    with plural BC_1885
    with article BC_1886
    with p106_summary BC_1887
;

Object I363_for_the_wrench ""
    class K29_quip
    with short_name BC_1888
    with p27_comment BC_1889
    with p28_reply BC_1890
    has proper
    with p143_quip_condition I223_questioning
    with vector 0
    has mark_as_thing
    with IK2_Count 78
    with IK2_Link I365_for_a_screwdriver
    with IK29_Count 14
    with IK29_Link I365_for_a_screwdriver
    with KD_Count 29
    with name 'for' 'the' 'wrench' 'quips//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1891
    with initial BC_1892
    with p15_dark_description BC_1893
    with p25_behind_description BC_1894
    with p48_possessive BC_1895
    with list_together BC_1896
    with plural BC_1897
    with article BC_1898
    with p106_summary BC_1899
;

Object I365_for_a_screwdriver ""
    class K29_quip
    with short_name BC_1900
    with p27_comment BC_1901
    with p28_reply BC_1902
    has proper
    has privately_named
    with p141_one_shot false
    with p143_quip_condition I223_questioning
    with vector 0
    has mark_as_thing
    with IK2_Count 80
    with IK2_Link I366_to_unlock_the_backdoor
    with IK29_Count 15
    with IK29_Link I366_to_unlock_the_backdoor
    with KD_Count 29
    with parse_name Parse_Name_GV152
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1903
    with initial BC_1904
    with p15_dark_description BC_1905
    with p25_behind_description BC_1906
    with p48_possessive BC_1907
    with list_together BC_1908
    with plural BC_1909
    with article BC_1910
    with p106_summary BC_1911
;

Object I366_to_unlock_the_backdoor ""
    class K29_quip
    with short_name BC_1912
    with p27_comment BC_1913
    with p28_reply BC_1914
    has proper
    with p143_quip_condition I223_questioning
    with vector 0
    with cap_short_name BC_1915
    has mark_as_thing
    with IK2_Count 81
    with IK2_Link I367_bosh_back_door
    with IK29_Count 16
    with IK29_Link I423_to_borrow_the_skull
    with KD_Count 29
    with name 'to' 'unlock' 'the' 'backdoor' 'quips//p' 
    with parse_name Parse_Name_GV153
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_1916
    with initial BC_1917
    with p15_dark_description BC_1918
    with p25_behind_description BC_1919
    with p48_possessive BC_1920
    with list_together BC_1921
    with plural BC_1922
    with article BC_1923
    with p106_summary BC_1924
;

Object I367_bosh_back_door ""
    class K4_door
    with short_name BC_1925
    with description BC_1926
    with with_key I446_white_key
    has scenery
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    with door_dir [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I429_biff_s_office) return I58_west; return I57_east;],
    with door_to [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I429_biff_s_office) return I325_back_lot; return I429_biff_s_office;],
    with found_in I429_biff_s_office I325_back_lot
    has mark_as_thing
    with IK2_Count 82
    with IK2_Link I416_spacetime
    with IK4_Count 2
    with IK4_Link I447_laundromat_back_door
    with KD_Count 4
    with name 'bosh' 'back' 'door' 'doors//p' 
    with parse_name Parse_Name_GV171
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_1927
    with p15_dark_description BC_1928
    with p25_behind_description BC_1929
    with p48_possessive BC_1930
    with list_together BC_1931
    with plural BC_1932
    with article BC_1933
    with p106_summary BC_1934
;

Object I368_throw_out_boxes ""
    class K25_behavior
    with short_name BC_1935
    has proper
    with vector 0
    with cap_short_name BC_1936
    with IK25_Count 2
    with IK25_Link I449_locking_back_door
    with KD_Count 25
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_1937
    with plural BC_1938
    with article BC_1939
    with p106_summary BC_1940
;

Object I369_elr ""
    class K9_region
    with short_name BC_1941
    has proper
    with vector 0
    with regional_found_in [ ;
        if (TestRegionalContainment(location, I369_elr)) rtrue; rfalse;],
    with IK9_Count 5
    with IK9_Link I428_bosh_hq
    with KD_Count 9
    with name 'elr' 'regions//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_1942
    with plural BC_1943
    with article BC_1944
    with p106_summary BC_1945
;

Object I370_enigma_lake_town_hall ""
    class K1_room
    with short_name BC_1946
    with map_region I369_elr
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 23
    with IK1_Link I371_enigma_park
    with KD_Count 1
    with name 'enigma' 'lake' 'town' 'hall' 'rooms//p' 
    with description BC_1947
    with p15_dark_description BC_1948
    with p21_preposition BC_1949
    with p24_destination_name BC_1950
    with list_together BC_1951
    with plural BC_1952
    with article BC_1953
    with p106_summary BC_1954
;

Object I371_enigma_park ""
    class K1_room
    with short_name BC_1955
    with map_region I369_elr
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 24
    with IK1_Link I372_main_street_200_block
    with KD_Count 1
    with name 'enigma' 'park' 'rooms//p' 
    with description BC_1956
    with p15_dark_description BC_1957
    with p21_preposition BC_1958
    with p24_destination_name BC_1959
    with list_together BC_1960
    with plural BC_1961
    with article BC_1962
    with p106_summary BC_1963
;

Object I372_main_street_200_block ""
    class K1_room
    with short_name BC_1964
    with map_region I369_elr
    with p21_preposition BC_1965
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 25
    with IK1_Link I373_main_at_solvay
    with KD_Count 1
    with name 'main' 'street' '200' 'block' 'rooms//p' 
    with description BC_1966
    with p15_dark_description BC_1967
    with p24_destination_name BC_1968
    with list_together BC_1969
    with plural BC_1970
    with article BC_1971
    with p106_summary BC_1972
;

Object I373_main_at_solvay ""
    class K1_room
    with short_name BC_1973
    with map_region I369_elr
    with p21_preposition BC_1974
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 26
    with IK1_Link I374_solvay_road_by_the_fire
    with KD_Count 1
    with name 'main' 'at' 'solvay' 'rooms//p' 
    with description BC_1975
    with p15_dark_description BC_1976
    with p24_destination_name BC_1977
    with list_together BC_1978
    with plural BC_1979
    with article BC_1980
    with p106_summary BC_1981
;

Object I374_solvay_road_by_the_fire ""
    class K1_room
    with short_name BC_1982
    with map_region I369_elr
    with p21_preposition BC_1983
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 27
    with IK1_Link I375_solvay_road_leading_out
    with KD_Count 1
    with name 'solvay' 'road' 'by' 'the' 'fire' 'station' 'rooms//p' 
    with description BC_1984
    with p15_dark_description BC_1985
    with p24_destination_name BC_1986
    with list_together BC_1987
    with plural BC_1988
    with article BC_1989
    with p106_summary BC_1990
;

Object I375_solvay_road_leading_out ""
    class K1_room
    with short_name BC_1991
    with map_region I369_elr
    with p21_preposition BC_1992
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 28
    with IK1_Link I376_main_at_lake
    with KD_Count 1
    with name 'solvay' 'road' 'leading' 'out' 'of' 'town' 'rooms//p' 
    with description BC_1993
    with p15_dark_description BC_1994
    with p24_destination_name BC_1995
    with list_together BC_1996
    with plural BC_1997
    with article BC_1998
    with p106_summary BC_1999
;

Object I376_main_at_lake ""
    class K1_room
    with short_name BC_2000
    with map_region I369_elr
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 29
    with IK1_Link I377_lake_street_by_the_cour
    with KD_Count 1
    with name 'main' 'at' 'lake' 'rooms//p' 
    with description BC_2001
    with p15_dark_description BC_2002
    with p21_preposition BC_2003
    with p24_destination_name BC_2004
    with list_together BC_2005
    with plural BC_2006
    with article BC_2007
    with p106_summary BC_2008
;

Object I377_lake_street_by_the_cour ""
    class K1_room
    with short_name BC_2009
    with map_region I369_elr
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 30
    with IK1_Link I378_lake_street_by_the_park
    with KD_Count 1
    with name 'lake' 'street' 'by' 'the' 'courthouse' 'rooms//p' 
    with description BC_2010
    with p15_dark_description BC_2011
    with p21_preposition BC_2012
    with p24_destination_name BC_2013
    with list_together BC_2014
    with plural BC_2015
    with article BC_2016
    with p106_summary BC_2017
;

Object I378_lake_street_by_the_park ""
    class K1_room
    with short_name BC_2018
    with map_region I369_elr
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 31
    with IK1_Link I379_first_unitarian_church_
    with KD_Count 1
    with name 'lake' 'street' 'by' 'the' 'park' 'rooms//p' 
    with description BC_2019
    with p15_dark_description BC_2020
    with p21_preposition BC_2021
    with p24_destination_name BC_2022
    with list_together BC_2023
    with plural BC_2024
    with article BC_2025
    with p106_summary BC_2026
;

Object I379_first_unitarian_church_ ""
    class K1_room
    with short_name BC_2027
    with map_region I369_elr
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 32
    with IK1_Link I380_lake_at_ridge
    with KD_Count 1
    with name 'first' 'unitarian' 'church' 'of' 'enigma' 'lake' 'rooms//p' 
    with description BC_2028
    with p15_dark_description BC_2029
    with p21_preposition BC_2030
    with p24_destination_name BC_2031
    with list_together BC_2032
    with plural BC_2033
    with article BC_2034
    with p106_summary BC_2035
;

Object I380_lake_at_ridge ""
    class K1_room
    with short_name BC_2036
    with map_region I369_elr
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 33
    with IK1_Link I381_lake_shore_north_of_the
    with KD_Count 1
    with name 'lake' 'at' 'ridge' 'rooms//p' 
    with description BC_2037
    with p15_dark_description BC_2038
    with p21_preposition BC_2039
    with p24_destination_name BC_2040
    with list_together BC_2041
    with plural BC_2042
    with article BC_2043
    with p106_summary BC_2044
;

Object I381_lake_shore_north_of_the ""
    class K1_room
    with short_name BC_2045
    with map_region I369_elr
    with p21_preposition BC_2046
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 34
    with IK1_Link I382_lake_shore_west
    with KD_Count 1
    with name 'lake' 'shore' 'north' 'of' 'the' 'park' 'rooms//p' 
    with description BC_2047
    with p15_dark_description BC_2048
    with p24_destination_name BC_2049
    with list_together BC_2050
    with plural BC_2051
    with article BC_2052
    with p106_summary BC_2053
;

Object I382_lake_shore_west ""
    class K1_room
    with short_name BC_2054
    with map_region I369_elr
    with p21_preposition BC_2055
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 35
    with IK1_Link I383_horton_house
    with KD_Count 1
    with name 'lake' 'shore' 'west' 'rooms//p' 
    with description BC_2056
    with p15_dark_description BC_2057
    with p24_destination_name BC_2058
    with list_together BC_2059
    with plural BC_2060
    with article BC_2061
    with p106_summary BC_2062
;

Object I383_horton_house ""
    class K1_room
    with short_name BC_2063
    with map_region I369_elr
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 36
    with IK1_Link I384_hook_n_ladder_company
    with KD_Count 1
    with name 'horton' 'house' 'rooms//p' 
    with description BC_2064
    with p15_dark_description BC_2065
    with p21_preposition BC_2066
    with p24_destination_name BC_2067
    with list_together BC_2068
    with plural BC_2069
    with article BC_2070
    with p106_summary BC_2071
;

Object I384_hook_n_ladder_company ""
    class K1_room
    with short_name BC_2072
    with map_region I369_elr
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 37
    with IK1_Link I385_reading_room
    with KD_Count 1
    with name 'hook' 'n//' 'ladder' 'company' 'rooms//p' 
    with description BC_2073
    with p15_dark_description BC_2074
    with p21_preposition BC_2075
    with p24_destination_name BC_2076
    with list_together BC_2077
    with plural BC_2078
    with article BC_2079
    with p106_summary BC_2080
;

Object I385_reading_room ""
    class K1_room
    with short_name BC_2081
    with map_region I369_elr
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 38
    with IK1_Link I386_fresnel_s_music
    with KD_Count 1
    with name 'reading' 'room' 'rooms//p' 
    with description BC_2082
    with p15_dark_description BC_2083
    with p21_preposition BC_2084
    with p24_destination_name BC_2085
    with list_together BC_2086
    with plural BC_2087
    with article BC_2088
    with p106_summary BC_2089
;

Object I386_fresnel_s_music ""
    class K1_room
    with short_name BC_2090
    with map_region I369_elr
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 39
    with IK1_Link I387_henry_s_hot_skillet
    with KD_Count 1
    with name 'fresnel^s' 'music' 'rooms//p' 
    with description BC_2091
    with p15_dark_description BC_2092
    with p21_preposition BC_2093
    with p24_destination_name BC_2094
    with list_together BC_2095
    with plural BC_2096
    with article BC_2097
    with p106_summary BC_2098
;

Object I387_henry_s_hot_skillet ""
    class K1_room
    with short_name BC_2099
    with map_region I369_elr
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 40
    with IK1_Link I388_rolle_s_department_stor
    with KD_Count 1
    with name 'henry^s' 'hot' 'skillet' 'rooms//p' 
    with description BC_2100
    with p15_dark_description BC_2101
    with p21_preposition BC_2102
    with p24_destination_name BC_2103
    with list_together BC_2104
    with plural BC_2105
    with article BC_2106
    with p106_summary BC_2107
;

Object I388_rolle_s_department_stor ""
    class K1_room
    with short_name BC_2108
    with map_region I369_elr
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 41
    with IK1_Link I389_municipal_courthouse
    with KD_Count 1
    with name 'rolle^s' 'department' 'store' 'rooms//p' 
    with description BC_2109
    with p15_dark_description BC_2110
    with p21_preposition BC_2111
    with p24_destination_name BC_2112
    with list_together BC_2113
    with plural BC_2114
    with article BC_2115
    with p106_summary BC_2116
;

Object I389_municipal_courthouse ""
    class K1_room
    with short_name BC_2117
    with map_region I369_elr
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 42
    with IK1_Link I411_isolation_booth
    with KD_Count 1
    with name 'municipal' 'courthouse' 'rooms//p' 
    with description BC_2118
    with p15_dark_description BC_2119
    with p21_preposition BC_2120
    with p24_destination_name BC_2121
    with list_together BC_2122
    with plural BC_2123
    with article BC_2124
    with p106_summary BC_2125
;

Object I395_i_pronoun ""
    class K36_pronoun
    with short_name BC_2126
    with p40_grammatical_person 1
    with p41_declensions BC_2127
    has proper
    with vector 0
    with IK36_Count 0
    with IK36_Link I396_we_pronoun
    with KD_Count 36
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_2128
    with plural BC_2129
    with article BC_2130
    with p106_summary BC_2131
;

Object I396_we_pronoun ""
    class K36_pronoun
    with short_name BC_2132
    with p40_grammatical_person 1
    with p41_declensions BC_2133
    has pluralname
    has proper
    with vector 0
    with IK36_Count 1
    with IK36_Link I397_it_pronoun
    with KD_Count 36
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_2134
    with plural BC_2135
    with article BC_2136
    with p106_summary BC_2137
;

Object I397_it_pronoun ""
    class K36_pronoun
    with short_name BC_2138
    with p40_grammatical_person 3
    with p41_declensions BC_2139
    has proper
    has neuter
    with vector 0
    with IK36_Count 2
    with IK36_Link I398_he_pronoun
    with KD_Count 36
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_2140
    with plural BC_2141
    with article BC_2142
    with p106_summary BC_2143
;

Object I398_he_pronoun ""
    class K36_pronoun
    with short_name BC_2144
    with p40_grammatical_person 3
    with p41_declensions BC_2145
    has proper
    with vector 0
    with IK36_Count 3
    with IK36_Link I399_she_pronoun
    with KD_Count 36
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_2146
    with plural BC_2147
    with article BC_2148
    with p106_summary BC_2149
;

Object I399_she_pronoun ""
    class K36_pronoun
    with short_name BC_2150
    with p40_grammatical_person 3
    with p41_declensions BC_2151
    has proper
    with vector 0
    with IK36_Count 4
    with IK36_Link I400_singular_you_pronoun
    with KD_Count 36
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_2152
    with plural BC_2153
    with article BC_2154
    with p106_summary BC_2155
;

Object I400_singular_you_pronoun ""
    class K36_pronoun
    with short_name BC_2156
    with p40_grammatical_person 2
    with p41_declensions BC_2157
    has proper
    with vector 0
    with IK36_Count 5
    with IK36_Link I401_plural_you_pronoun
    with KD_Count 36
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_2158
    with plural BC_2159
    with article BC_2160
    with p106_summary BC_2161
;

Object I401_plural_you_pronoun ""
    class K36_pronoun
    with short_name BC_2162
    with p40_grammatical_person 2
    with p41_declensions BC_2163
    has pluralname
    has proper
    with vector 0
    with IK36_Count 6
    with IK36_Link I402_they_pronoun
    with KD_Count 36
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_2164
    with plural BC_2165
    with article BC_2166
    with p106_summary BC_2167
;

Object I402_they_pronoun ""
    class K36_pronoun
    with short_name BC_2168
    with p40_grammatical_person 3
    with p41_declensions BC_2169
    has pluralname
    has proper
    with vector 0
    with IK36_Count 7
    with IK36_Link I403_singular_they_pronoun
    with KD_Count 36
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_2170
    with plural BC_2171
    with article BC_2172
    with p106_summary BC_2173
;

Object I403_singular_they_pronoun ""
    class K36_pronoun
    with short_name BC_2174
    with p40_grammatical_person 3
    with p41_declensions BC_2175
    has pluralname
    has proper
    with vector 0
    with IK36_Count 8
    with IK36_Link nothing
    with KD_Count 36
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_2176
    with plural BC_2177
    with article BC_2178
    with p106_summary BC_2179
;

Object I411_isolation_booth ""
    class K1_room
    with short_name BC_2180
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 43
    with IK1_Link I429_biff_s_office
    with KD_Count 1
    with name 'isolation' 'booth' 'rooms//p' 
    with description BC_2181
    with p15_dark_description BC_2182
    with p21_preposition BC_2183
    with p24_destination_name BC_2184
    with list_together BC_2185
    with plural BC_2186
    with article BC_2187
    with p106_summary BC_2188
;

Object I416_spacetime ""
    class K17_subject
    with short_name BC_2189
    has proper
    with vector 0
    has mark_as_thing
    with IK2_Count 87
    with IK2_Link I417_aliens
    with IK17_Count 1
    with IK17_Link I417_aliens
    with KD_Count 17
    with name 'spacetime' 'subjects//p' 'time' 
    with parse_name Parse_Name_GV157
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2190
    with initial BC_2191
    with p15_dark_description BC_2192
    with p25_behind_description BC_2193
    with p48_possessive BC_2194
    with list_together BC_2195
    with plural BC_2196
    with article BC_2197
    with p106_summary BC_2198
;

Object I417_aliens ""
    class K17_subject
    with short_name BC_2199
    has proper
    with vector 0
    with cap_short_name BC_2200
    has mark_as_thing
    with IK2_Count 88
    with IK2_Link I418_bureau_of_strange_happe
    with IK17_Count 2
    with IK17_Link I418_bureau_of_strange_happe
    with KD_Count 17
    with name 'aliens' 'subjects//p' 
    with parse_name Parse_Name_GV158
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2201
    with initial BC_2202
    with p15_dark_description BC_2203
    with p25_behind_description BC_2204
    with p48_possessive BC_2205
    with list_together BC_2206
    with plural BC_2207
    with article BC_2208
    with p106_summary BC_2209
;

Object I418_bureau_of_strange_happe ""
    class K17_subject
    with short_name BC_2210
    with vector 0
    has mark_as_thing
    with IK2_Count 89
    with IK2_Link I419_chief_huffton_klimp
    with IK17_Count 3
    with IK17_Link nothing
    with KD_Count 17
    with name 'bureau' 'of' 'strange' 'happenings' 'subjects//p' 'bosh' 
    with parse_name Parse_Name_GV159
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2211
    with initial BC_2212
    with p15_dark_description BC_2213
    with p25_behind_description BC_2214
    with p48_possessive BC_2215
    with list_together BC_2216
    with plural BC_2217
    with article BC_2218
    with p106_summary BC_2219
;

Object I419_chief_huffton_klimp ""
    class K10_man
    with short_name BC_2220
    with description BC_2221
    with p38_how_are_you_reply BC_2222
    with p49_portrait I504_figure_klimp
    has proper
    has p97_familiar
    with vector 0
    has mark_as_thing
    with IK2_Count 90
    with IK2_Link I420_klimp_s_mobile_phone
    with IK8_Count 12
    with IK8_Link I427_moira_zin
    with IK10_Count 5
    with IK10_Link nothing
    with KD_Count 10
    with name 'chief' 'huffton' 'klimp' 'men//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p22_behavior_stack BC_2223
    with p26_remembrances BC_2224
    with p29_queue BC_2225
    with initial BC_2226
    with p15_dark_description BC_2227
    with p25_behind_description BC_2228
    with p48_possessive BC_2229
    with list_together BC_2230
    with plural BC_2231
    with article BC_2232
    with p106_summary BC_2233
;

Object -> I420_klimp_s_mobile_phone ""
    class K20_phone
    with short_name BC_2234
    has proper
    has ~static
    has p115_mobile
    with p125_owner I419_chief_huffton_klimp
    with vector 0
    with cap_short_name BC_2235
    has mark_as_thing
    with IK2_Count 91
    with IK2_Link I423_to_borrow_the_skull
    with IK20_Count 0
    with IK20_Link I432_blue_flipphone
    with KD_Count 20
    with name 'klimp^s' 'mobile' 'phone' 'phones//p' 'phone' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2236
    with initial BC_2237
    with p15_dark_description BC_2238
    with p25_behind_description BC_2239
    with p48_possessive BC_2240
    with list_together BC_2241
    with plural BC_2242
    with article BC_2243
    with p106_summary BC_2244
;

Object I421_klimp_s_mobile_phone_nu ""
    class K21_phone_number
    with short_name BC_2245
    has proper
    with p122_reaches_relation_storag I420_klimp_s_mobile_phone
    with vector 0
    with IK19_Count 10
    with IK19_Link I422_biff_s_mobile_number
    with IK21_Count 0
    with IK21_Link I422_biff_s_mobile_number
    with KD_Count 21
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_2246
    with plural BC_2247
    with article BC_2248
    with p106_summary BC_2249
;

Object I422_biff_s_mobile_number ""
    class K21_phone_number
    with short_name BC_2250
    has proper
    with p122_reaches_relation_storag I445_green_smartphone
    with vector 0
    with IK19_Count 11
    with IK19_Link nothing
    with IK21_Count 1
    with IK21_Link nothing
    with KD_Count 21
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_2251
    with plural BC_2252
    with article BC_2253
    with p106_summary BC_2254
;

Object I423_to_borrow_the_skull ""
    class K29_quip
    with short_name BC_2255
    with p27_comment BC_2256
    with p28_reply BC_2257
    has proper
    with p143_quip_condition I223_questioning
    with vector 0
    with cap_short_name BC_2258
    has mark_as_thing
    with IK2_Count 92
    with IK2_Link I425_to_borrow_the_lenses
    with IK29_Count 17
    with IK29_Link I425_to_borrow_the_lenses
    with KD_Count 29
    with name 'to' 'borrow' 'the' 'skull' 'quips//p' 
    with parse_name Parse_Name_GV160
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2259
    with initial BC_2260
    with p15_dark_description BC_2261
    with p25_behind_description BC_2262
    with p48_possessive BC_2263
    with list_together BC_2264
    with plural BC_2265
    with article BC_2266
    with p106_summary BC_2267
;

Object I425_to_borrow_the_lenses ""
    class K29_quip
    with short_name BC_2268
    with p27_comment BC_2269
    with p28_reply BC_2270
    has proper
    with p143_quip_condition I223_questioning
    with vector 0
    with cap_short_name BC_2271
    has mark_as_thing
    with IK2_Count 94
    with IK2_Link I427_moira_zin
    with IK29_Count 18
    with IK29_Link I496_about_the_hyperdimensio
    with KD_Count 29
    with name 'to' 'borrow' 'the' 'lenses' 'quips//p' 
    with parse_name Parse_Name_GV161
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2272
    with initial BC_2273
    with p15_dark_description BC_2274
    with p25_behind_description BC_2275
    with p48_possessive BC_2276
    with list_together BC_2277
    with plural BC_2278
    with article BC_2279
    with p106_summary BC_2280
;

Object I427_moira_zin ""
    class K11_woman
    with short_name BC_2281
    with description BC_2282
    with p38_how_are_you_reply BC_2283
    with p49_portrait I520_figure_moira
    has proper
    has p97_familiar
    with vector 0
    has mark_as_thing
    with IK2_Count 96
    with IK2_Link I430_biff_s_desk
    with IK8_Count 13
    with IK8_Link I498_unknown_voice
    with IK11_Count 4
    with IK11_Link nothing
    with KD_Count 11
    with name 'moira' 'zin' 'women//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p22_behavior_stack BC_2284
    with p26_remembrances BC_2285
    with p29_queue BC_2286
    with initial BC_2287
    with p15_dark_description BC_2288
    with p25_behind_description BC_2289
    with p48_possessive BC_2290
    with list_together BC_2291
    with plural BC_2292
    with article BC_2293
    with p106_summary BC_2294
;

Object I428_bosh_hq ""
    class K9_region
    with short_name BC_2295
    has proper
    with vector 0
    with regional_found_in [ ;
        if (TestRegionalContainment(location, I428_bosh_hq)) rtrue; rfalse;],
    with IK9_Count 6
    with IK9_Link nothing
    with KD_Count 9
    with name 'bosh' 'hq' 'regions//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_2296
    with plural BC_2297
    with article BC_2298
    with p106_summary BC_2299
;

Object I429_biff_s_office ""
    class K1_room
    with short_name BC_2300
    with description BC_2301
    with map_region I428_bosh_hq
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 44
    with IK1_Link I452_bosh_office_hallway
    with KD_Count 1
    with name 'biff^s' 'office' 'rooms//p' 
    with p15_dark_description BC_2302
    with p21_preposition BC_2303
    with p24_destination_name BC_2304
    with list_together BC_2305
    with plural BC_2306
    with article BC_2307
    with p106_summary BC_2308
;

Object -> I430_biff_s_desk ""
    class K24_desk
    with short_name BC_2309
    has proper
    has privately_named
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with component_child I431_biff_s_desk_s_drawer
    with IK2_Count 97
    with IK2_Link I434_biff_s_landline
    with IK6_Count 1
    with IK6_Link I435_biff_s_chair
    with IK24_Count 0
    with IK24_Link nothing
    with KD_Count 24
    with parse_name Parse_Name_GV162
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2310
    with initial BC_2311
    with p15_dark_description BC_2312
    with p25_behind_description BC_2313
    with p48_possessive BC_2314
    with list_together BC_2315
    with plural BC_2316
    with article BC_2317
    with p106_summary BC_2318
;

Object -> -> I434_biff_s_landline ""
    class K2_thing
    with short_name BC_2319
    with description BC_2320
    has proper
    has privately_named
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 101
    with IK2_Link I435_biff_s_chair
    with KD_Count 2
    with parse_name Parse_Name_GV163
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2321
    with p15_dark_description BC_2322
    with p25_behind_description BC_2323
    with p48_possessive BC_2324
    with list_together BC_2325
    with plural BC_2326
    with article BC_2327
    with p106_summary BC_2328
;

Object -> I435_biff_s_chair ""
    class K6_supporter
    with short_name BC_2329
    with description BC_2330
    has proper
    has static
    has scenery
    has enterable
    with vector 0
    has mark_as_thing
    with IK2_Count 102
    with IK2_Link I438_photo_of_pluto
    with IK6_Count 2
    with IK6_Link I471_chief_s_desk
    with KD_Count 6
    with name 'biff^s' 'chair' 'supporters//p' 'seat' 
    with parse_name Parse_Name_GV164
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2331
    with p15_dark_description BC_2332
    with p25_behind_description BC_2333
    with p48_possessive BC_2334
    with list_together BC_2335
    with plural BC_2336
    with article BC_2337
    with p106_summary BC_2338
;

Object -> I438_photo_of_pluto ""
    class K2_thing
    with short_name BC_2339
    with description BC_2340
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 105
    with IK2_Link I439_degree
    with KD_Count 2
    with name 'photo' 'of' 'pluto' 'things//p' 
    with parse_name Parse_Name_GV165
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2341
    with p15_dark_description BC_2342
    with p25_behind_description BC_2343
    with p48_possessive BC_2344
    with list_together BC_2345
    with plural BC_2346
    with article BC_2347
    with p106_summary BC_2348
;

Object -> I439_degree ""
    class K2_thing
    with short_name BC_2349
    with description BC_2350
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 106
    with IK2_Link I440_movie_poster
    with KD_Count 2
    with name 'degree' 'things//p' 'diploma' 
    with parse_name Parse_Name_GV166
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2351
    with p15_dark_description BC_2352
    with p25_behind_description BC_2353
    with p48_possessive BC_2354
    with list_together BC_2355
    with plural BC_2356
    with article BC_2357
    with p106_summary BC_2358
;

Object -> I440_movie_poster ""
    class K2_thing
    with short_name BC_2359
    with description BC_2360
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 107
    with IK2_Link I441_trivia_competition_awar
    with KD_Count 2
    with name 'movie' 'poster' 'things//p' 
    with parse_name Parse_Name_GV167
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2361
    with p15_dark_description BC_2362
    with p25_behind_description BC_2363
    with p48_possessive BC_2364
    with list_together BC_2365
    with plural BC_2366
    with article BC_2367
    with p106_summary BC_2368
;

Object -> I441_trivia_competition_awar ""
    class K2_thing
    with short_name BC_2369
    with description BC_2370
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 108
    with IK2_Link I442_green_pheasant
    with KD_Count 2
    with name 'trivia' 'competition' 'award' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2371
    with p15_dark_description BC_2372
    with p25_behind_description BC_2373
    with p48_possessive BC_2374
    with list_together BC_2375
    with plural BC_2376
    with article BC_2377
    with p106_summary BC_2378
;

Object -> I442_green_pheasant ""
    class K2_thing
    with short_name BC_2379
    with description BC_2380
    has proper
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 109
    with IK2_Link I443_drawing_of_the_pitfall_
    with KD_Count 2
    with name 'green' 'pheasant' 'things//p' 
    with parse_name Parse_Name_GV168
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2381
    with p15_dark_description BC_2382
    with p25_behind_description BC_2383
    with p48_possessive BC_2384
    with list_together BC_2385
    with plural BC_2386
    with article BC_2387
    with p106_summary BC_2388
;

Object -> I443_drawing_of_the_pitfall_ ""
    class K2_thing
    with short_name BC_2389
    with description BC_2390
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 110
    with IK2_Link I444_photo_of_softball_team
    with KD_Count 2
    with name 'drawing' 'of' 'the' 'pitfall' 'snake' 'things//p' 
    with parse_name Parse_Name_GV169
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2391
    with p15_dark_description BC_2392
    with p25_behind_description BC_2393
    with p48_possessive BC_2394
    with list_together BC_2395
    with plural BC_2396
    with article BC_2397
    with p106_summary BC_2398
;

Object -> I444_photo_of_softball_team ""
    class K2_thing
    with short_name BC_2399
    with description BC_2400
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 111
    with IK2_Link I431_biff_s_desk_s_drawer
    with KD_Count 2
    with name 'photo' 'of' 'softball' 'team' 'things//p' 'picture' 
    with parse_name Parse_Name_GV170
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2401
    with p15_dark_description BC_2402
    with p25_behind_description BC_2403
    with p48_possessive BC_2404
    with list_together BC_2405
    with plural BC_2406
    with article BC_2407
    with p106_summary BC_2408
;

Object I431_biff_s_desk_s_drawer ""
    class K23_drawer
    with short_name SN_R_A_0
    has proper
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    with cap_short_name SN_R_A_1
    has mark_as_thing
    with component_parent I430_biff_s_desk
    with IK2_Count 98
    with IK2_Link I360_little_grey_key
    with IK5_Count 2
    with IK5_Link I483_antique_wooden_file_cab
    with IK23_Count 0
    with IK23_Link nothing
    with KD_Count 23
    with name 'biff^s' 'desk^s' 'drawer' 'drawers//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2409
    with initial BC_2410
    with p15_dark_description BC_2411
    with p25_behind_description BC_2412
    with p48_possessive BC_2413
    with list_together BC_2414
    with plural BC_2415
    with article BC_2416
    with p106_summary BC_2417
;

Object -> I360_little_grey_key ""
    class K2_thing
    with short_name BC_2418
    has p97_familiar
    with vector 0
    has mark_as_thing
    with IK2_Count 75
    with IK2_Link I432_blue_flipphone
    with KD_Count 2
    with name 'little' 'grey' 'key' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2419
    with initial BC_2420
    with p15_dark_description BC_2421
    with p25_behind_description BC_2422
    with p48_possessive BC_2423
    with list_together BC_2424
    with plural BC_2425
    with article BC_2426
    with p106_summary BC_2427
;

Object -> I432_blue_flipphone ""
    class K20_phone
    with short_name BC_2428
    with p49_portrait I512_figure_phone
    with vector 0
    has mark_as_thing
    with IK2_Count 99
    with IK2_Link I436_id
    with IK20_Count 1
    with IK20_Link I445_green_smartphone
    with KD_Count 20
    with name 'blue' 'flipphone' 'phones//p' 'phone' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2429
    with initial BC_2430
    with p15_dark_description BC_2431
    with p25_behind_description BC_2432
    with p48_possessive BC_2433
    with list_together BC_2434
    with plural BC_2435
    with article BC_2436
    with p106_summary BC_2437
;

Object -> I436_id ""
    class K2_thing
    with short_name BC_2438
    with vector 0
    has mark_as_thing
    with IK2_Count 103
    with IK2_Link I437_bureau_credit_card
    with KD_Count 2
    with name 'id' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2439
    with initial BC_2440
    with p15_dark_description BC_2441
    with p25_behind_description BC_2442
    with p48_possessive BC_2443
    with list_together BC_2444
    with plural BC_2445
    with article BC_2446
    with p106_summary BC_2447
;

Object -> I437_bureau_credit_card ""
    class K22_money_card
    with short_name BC_2448
    with article BC_2449
    with p19_balance 300
    with p123_mc_enabled false
    with p125_owner selfobj
    with vector 0
    has mark_as_thing
    with IK2_Count 104
    with IK2_Link I433_biff_s_desk_drawer
    with IK22_Count 0
    with IK22_Link nothing
    with KD_Count 22
    with name 'bureau' 'credit' 'card' 'money//p' 'cards//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2450
    with initial BC_2451
    with p15_dark_description BC_2452
    with p25_behind_description BC_2453
    with p48_possessive BC_2454
    with list_together BC_2455
    with plural BC_2456
    with p106_summary BC_2457
;

Object I433_biff_s_desk_drawer ""
    class K2_thing
    with short_name BC_2458
    with with_key I360_little_grey_key
    has proper
    with vector 0
    has mark_as_thing
    with IK2_Count 100
    with IK2_Link I445_green_smartphone
    with KD_Count 2
    with name 'biff^s' 'desk' 'drawer' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2459
    with initial BC_2460
    with p15_dark_description BC_2461
    with p25_behind_description BC_2462
    with p48_possessive BC_2463
    with list_together BC_2464
    with plural BC_2465
    with article BC_2466
    with p106_summary BC_2467
;

Object I445_green_smartphone ""
    class K20_phone
    with short_name BC_2468
    with description BC_2469
    has p115_mobile
    with vector 0
    has mark_as_thing
    with IK2_Count 112
    with IK2_Link I447_laundromat_back_door
    with IK20_Count 2
    with IK20_Link I499_mysterious_phone
    with KD_Count 20
    with name 'green' 'smartphone' 'phones//p' 'phone' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2470
    with p15_dark_description BC_2471
    with p25_behind_description BC_2472
    with p48_possessive BC_2473
    with list_together BC_2474
    with plural BC_2475
    with article BC_2476
    with p106_summary BC_2477
;

Object I447_laundromat_back_door ""
    class K4_door
    with short_name BC_2478
    with description BC_2479
    has scenery
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    with door_dir [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I325_back_lot) return I51_north; return I54_south;],
    with door_to [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I325_back_lot) return I329_laundromat_back_room; return I325_back_lot;],
    with found_in I325_back_lot I329_laundromat_back_room
    has mark_as_thing
    with IK2_Count 114
    with IK2_Link I451_biff_s_door
    with IK4_Count 3
    with IK4_Link I451_biff_s_door
    with KD_Count 4
    with name 'laundromat' 'back' 'door' 'doors//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2480
    with p15_dark_description BC_2481
    with p25_behind_description BC_2482
    with p48_possessive BC_2483
    with list_together BC_2484
    with plural BC_2485
    with article BC_2486
    with p106_summary BC_2487
;

Object I449_locking_back_door ""
    class K25_behavior
    with short_name BC_2488
    has proper
    with vector 0
    with cap_short_name BC_2489
    with IK25_Count 3
    with IK25_Link I450_waiting_for_player
    with KD_Count 25
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_2490
    with plural BC_2491
    with article BC_2492
    with p106_summary BC_2493
;

Object I450_waiting_for_player ""
    class K25_behavior
    with short_name BC_2494
    has proper
    with vector 0
    with cap_short_name BC_2495
    with IK25_Count 4
    with IK25_Link nothing
    with KD_Count 25
    with action_bitmap 0 0 0 0 0 0 0 0 
    with list_together BC_2496
    with plural BC_2497
    with article BC_2498
    with p106_summary BC_2499
;

Object I451_biff_s_door ""
    class K4_door
    with short_name BC_2500
    has proper
    has privately_named
    has scenery
    has open
    with vector 0
    with door_dir [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I429_biff_s_office) return I51_north; return I54_south;],
    with door_to [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I429_biff_s_office) return I452_bosh_office_hallway; return I429_biff_s_office;],
    with found_in I429_biff_s_office I452_bosh_office_hallway
    has mark_as_thing
    with IK2_Count 116
    with IK2_Link I453_klimp_s_door
    with IK4_Count 4
    with IK4_Link I453_klimp_s_door
    with KD_Count 4
    with parse_name Parse_Name_GV172
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2501
    with initial BC_2502
    with p15_dark_description BC_2503
    with p25_behind_description BC_2504
    with p48_possessive BC_2505
    with list_together BC_2506
    with plural BC_2507
    with article BC_2508
    with p106_summary BC_2509
;

Object I452_bosh_office_hallway ""
    class K1_room
    with short_name BC_2510
    with description BC_2511
    with map_region I428_bosh_hq
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 45
    with IK1_Link I454_bosh_chief_s_office
    with KD_Count 1
    with name 'bosh' 'office' 'hallway' 'rooms//p' 
    with p15_dark_description BC_2512
    with p21_preposition BC_2513
    with p24_destination_name BC_2514
    with list_together BC_2515
    with plural BC_2516
    with article BC_2517
    with p106_summary BC_2518
;

Object I453_klimp_s_door ""
    class K4_door
    with short_name BC_2519
    has proper
    has scenery
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    with door_dir [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I452_bosh_office_hallway) return I58_west; return I57_east;],
    with door_to [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I452_bosh_office_hallway) return I454_bosh_chief_s_office; return I452_bosh_office_hallway;],
    with found_in I452_bosh_office_hallway I454_bosh_chief_s_office
    has mark_as_thing
    with IK2_Count 117
    with IK2_Link I471_chief_s_desk
    with IK4_Count 5
    with IK4_Link I455_moira_s_door
    with KD_Count 4
    with name 'klimp^s' 'door' 'doors//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2520
    with initial BC_2521
    with p15_dark_description BC_2522
    with p25_behind_description BC_2523
    with p48_possessive BC_2524
    with list_together BC_2525
    with plural BC_2526
    with article BC_2527
    with p106_summary BC_2528
;

Object I454_bosh_chief_s_office ""
    class K1_room
    with short_name BC_2529
    with description BC_2530
    with map_region I428_bosh_hq
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 46
    with IK1_Link I456_moira_s_office
    with KD_Count 1
    with name 'bosh' 'chief^s' 'office' 'rooms//p' 
    with p15_dark_description BC_2531
    with p21_preposition BC_2532
    with p24_destination_name BC_2533
    with list_together BC_2534
    with plural BC_2535
    with article BC_2536
    with p106_summary BC_2537
;

Object -> I471_chief_s_desk ""
    class K6_supporter
    with short_name BC_2538
    with description BC_2539
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with component_child I473_desk_shelves
    with IK2_Count 133
    with IK2_Link I472_klimp_s_computer
    with IK6_Count 6
    with IK6_Link I475_black_leather_swivel_ch
    with KD_Count 6
    with name 'chief^s' 'desk' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2540
    with p15_dark_description BC_2541
    with p25_behind_description BC_2542
    with p48_possessive BC_2543
    with list_together BC_2544
    with plural BC_2545
    with article BC_2546
    with p106_summary BC_2547
;

Object -> -> I472_klimp_s_computer ""
    class K2_thing
    with short_name BC_2548
    has proper
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 134
    with IK2_Link I475_black_leather_swivel_ch
    with KD_Count 2
    with name 'klimp^s' 'computer' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2549
    with initial BC_2550
    with p15_dark_description BC_2551
    with p25_behind_description BC_2552
    with p48_possessive BC_2553
    with list_together BC_2554
    with plural BC_2555
    with article BC_2556
    with p106_summary BC_2557
;

Object -> I475_black_leather_swivel_ch ""
    class K6_supporter
    with short_name BC_2558
    with description BC_2559
    has static
    has scenery
    has enterable
    with vector 0
    has mark_as_thing
    with IK2_Count 137
    with IK2_Link I476_globe
    with IK6_Count 8
    with IK6_Link I477_armchair
    with KD_Count 6
    with name 'black' 'leather' 'swivel' 'chair' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2560
    with p15_dark_description BC_2561
    with p25_behind_description BC_2562
    with p48_possessive BC_2563
    with list_together BC_2564
    with plural BC_2565
    with article BC_2566
    with p106_summary BC_2567
;

Object -> I476_globe ""
    class K2_thing
    with short_name BC_2568
    with description BC_2569
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 138
    with IK2_Link I477_armchair
    with KD_Count 2
    with name 'globe' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2570
    with p15_dark_description BC_2571
    with p25_behind_description BC_2572
    with p48_possessive BC_2573
    with list_together BC_2574
    with plural BC_2575
    with article BC_2576
    with p106_summary BC_2577
;

Object -> I477_armchair ""
    class K6_supporter
    with short_name BC_2578
    with description BC_2579
    has static
    has scenery
    has enterable
    with vector 0
    has mark_as_thing
    with IK2_Count 139
    with IK2_Link I478_mahogany_side_table
    with IK6_Count 9
    with IK6_Link I482_chief_s_shelves
    with KD_Count 6
    with name 'armchair' 'supporters//p' 'chair' 
    with parse_name Parse_Name_GV183
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2580
    with p15_dark_description BC_2581
    with p25_behind_description BC_2582
    with p48_possessive BC_2583
    with list_together BC_2584
    with plural BC_2585
    with article BC_2586
    with p106_summary BC_2587
;

Object -> I478_mahogany_side_table ""
    class K2_thing
    with short_name BC_2588
    with description BC_2589
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 140
    with IK2_Link I479_bookcase
    with KD_Count 2
    with name 'mahogany' 'side' 'table' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2590
    with p15_dark_description BC_2591
    with p25_behind_description BC_2592
    with p48_possessive BC_2593
    with list_together BC_2594
    with plural BC_2595
    with article BC_2596
    with p106_summary BC_2597
;

Object -> I479_bookcase ""
    class K2_thing
    with short_name BC_2598
    with description BC_2599
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 141
    with IK2_Link I480_waiting_for_the_aliens
    with KD_Count 2
    with name 'bookcase' 'things//p' 'books' 
    with parse_name Parse_Name_GV184
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2600
    with p15_dark_description BC_2601
    with p25_behind_description BC_2602
    with p48_possessive BC_2603
    with list_together BC_2604
    with plural BC_2605
    with article BC_2606
    with p106_summary BC_2607
;

Object -> I480_waiting_for_the_aliens ""
    class K2_thing
    with short_name BC_2608
    with description BC_2609
    has proper
    has privately_named
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 142
    with IK2_Link I481_travels_in_time
    with KD_Count 2
    with parse_name Parse_Name_GV185
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2610
    with p15_dark_description BC_2611
    with p25_behind_description BC_2612
    with p48_possessive BC_2613
    with list_together BC_2614
    with plural BC_2615
    with article BC_2616
    with p106_summary BC_2617
;

Object -> I481_travels_in_time ""
    class K2_thing
    with short_name BC_2618
    with description BC_2619
    has proper
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 143
    with IK2_Link I482_chief_s_shelves
    with KD_Count 2
    with name 'travels' 'in' 'time' 'things//p' 
    with parse_name Parse_Name_GV186
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2620
    with p15_dark_description BC_2621
    with p25_behind_description BC_2622
    with p48_possessive BC_2623
    with list_together BC_2624
    with plural BC_2625
    with article BC_2626
    with p106_summary BC_2627
;

Object -> I482_chief_s_shelves ""
    class K6_supporter
    with short_name BC_2628
    with description BC_2629
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 144
    with IK2_Link I424_juvenile_sasquatch_skul
    with IK6_Count 10
    with IK6_Link I489_moira_s_desk
    with KD_Count 6
    with name 'chief^s' 'shelves' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2630
    with p15_dark_description BC_2631
    with p25_behind_description BC_2632
    with p48_possessive BC_2633
    with list_together BC_2634
    with plural BC_2635
    with article BC_2636
    with p106_summary BC_2637
;

Object -> -> I424_juvenile_sasquatch_skul ""
    class K2_thing
    with short_name BC_2638
    with description BC_2639
    with p125_owner I419_chief_huffton_klimp
    with vector 0
    has mark_as_thing
    with IK2_Count 93
    with IK2_Link I426_astral_lenses
    with KD_Count 2
    with name 'juvenile' 'sasquatch' 'skull' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2640
    with p15_dark_description BC_2641
    with p25_behind_description BC_2642
    with p48_possessive BC_2643
    with list_together BC_2644
    with plural BC_2645
    with article BC_2646
    with p106_summary BC_2647
;

Object -> -> I426_astral_lenses ""
    class K2_thing
    with short_name BC_2648
    with description BC_2649
    has pluralname
    has clothing
    with p125_owner I419_chief_huffton_klimp
    with vector 0
    has mark_as_thing
    with IK2_Count 95
    with IK2_Link I485_oddities
    with KD_Count 2
    with name 'astral' 'lenses' 'things//p' 
    with parse_name Parse_Name_GV188
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2650
    with p15_dark_description BC_2651
    with p25_behind_description BC_2652
    with p48_possessive BC_2653
    with list_together BC_2654
    with plural BC_2655
    with article BC_2656
    with p106_summary BC_2657
;

Object -> -> I485_oddities ""
    class K2_thing
    with short_name BC_2658
    with description BC_2659
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 147
    with IK2_Link I483_antique_wooden_file_cab
    with KD_Count 2
    with name 'oddities' 'things//p' 'memorabilia' 'junk' 'stuff' 
    with parse_name Parse_Name_GV187
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2660
    with p15_dark_description BC_2661
    with p25_behind_description BC_2662
    with p48_possessive BC_2663
    with list_together BC_2664
    with plural BC_2665
    with article BC_2666
    with p106_summary BC_2667
;

Object -> I483_antique_wooden_file_cab ""
    class K5_container
    with short_name BC_2668
    with description BC_2669
    has static
    has scenery
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    has mark_as_thing
    with IK2_Count 145
    with IK2_Link I484_prints
    with IK5_Count 4
    with IK5_Link I486_closet
    with KD_Count 5
    with name 'antique' 'wooden' 'file' 'cabinet' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2670
    with p15_dark_description BC_2671
    with p25_behind_description BC_2672
    with p48_possessive BC_2673
    with list_together BC_2674
    with plural BC_2675
    with article BC_2676
    with p106_summary BC_2677
;

Object -> I484_prints ""
    class K2_thing
    with short_name BC_2678
    with description BC_2679
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 146
    with IK2_Link I455_moira_s_door
    with KD_Count 2
    with name 'prints' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2680
    with p15_dark_description BC_2681
    with p25_behind_description BC_2682
    with p48_possessive BC_2683
    with list_together BC_2684
    with plural BC_2685
    with article BC_2686
    with p106_summary BC_2687
;

Object I455_moira_s_door ""
    class K4_door
    with short_name BC_2688
    has proper
    has scenery
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    with door_dir [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I452_bosh_office_hallway) return I51_north; return I54_south;],
    with door_to [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I452_bosh_office_hallway) return I456_moira_s_office; return I452_bosh_office_hallway;],
    with found_in I452_bosh_office_hallway I456_moira_s_office
    has mark_as_thing
    with IK2_Count 118
    with IK2_Link I486_closet
    with IK4_Count 6
    with IK4_Link I494_closet_door
    with KD_Count 4
    with name 'moira^s' 'door' 'doors//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2689
    with initial BC_2690
    with p15_dark_description BC_2691
    with p25_behind_description BC_2692
    with p48_possessive BC_2693
    with list_together BC_2694
    with plural BC_2695
    with article BC_2696
    with p106_summary BC_2697
;

Object I456_moira_s_office ""
    class K1_room
    with short_name BC_2698
    with description BC_2699
    with map_region I428_bosh_hq
    has proper
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 47
    with IK1_Link I495_utility_closet
    with KD_Count 1
    with name 'moira^s' 'office' 'rooms//p' 
    with p15_dark_description BC_2700
    with p21_preposition BC_2701
    with p24_destination_name BC_2702
    with list_together BC_2703
    with plural BC_2704
    with article BC_2705
    with p106_summary BC_2706
;

Object -> I486_closet ""
    class K5_container
    with short_name BC_2707
    has static
    has scenery
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    has mark_as_thing
    with IK2_Count 148
    with IK2_Link I487_breaker_box
    with IK5_Count 5
    with IK5_Link I487_breaker_box
    with KD_Count 5
    with name 'closet' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2708
    with initial BC_2709
    with p15_dark_description BC_2710
    with p25_behind_description BC_2711
    with p48_possessive BC_2712
    with list_together BC_2713
    with plural BC_2714
    with article BC_2715
    with p106_summary BC_2716
;

Object -> -> I487_breaker_box ""
    class K5_container
    with short_name BC_2717
    with description BC_2718
    has static
    has ~open
    has openable
    with vector 0
    has mark_as_thing
    with IK2_Count 149
    with IK2_Link I488_circuit_breaker
    with IK5_Count 6
    with IK5_Link I490_moira_s_drawer
    with KD_Count 5
    with name 'breaker' 'box' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2719
    with p15_dark_description BC_2720
    with p25_behind_description BC_2721
    with p48_possessive BC_2722
    with list_together BC_2723
    with plural BC_2724
    with article BC_2725
    with p106_summary BC_2726
;

Object -> -> -> I488_circuit_breaker ""
    class K14_device
    with short_name BC_2727
    with description BC_2728
    has static
    with vector 0
    has mark_as_thing
    with IK2_Count 150
    with IK2_Link I489_moira_s_desk
    with IK14_Count 2
    with IK14_Link nothing
    with KD_Count 14
    with name 'circuit' 'breaker' 'devices//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2729
    with p15_dark_description BC_2730
    with p25_behind_description BC_2731
    with p48_possessive BC_2732
    with list_together BC_2733
    with plural BC_2734
    with article BC_2735
    with p106_summary BC_2736
;

Object -> I489_moira_s_desk ""
    class K6_supporter
    with short_name BC_2737
    with description BC_2738
    has proper
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with component_child I490_moira_s_drawer
    with IK2_Count 151
    with IK2_Link I491_moira_s_chair
    with IK6_Count 11
    with IK6_Link I491_moira_s_chair
    with KD_Count 6
    with name 'moira^s' 'desk' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2739
    with p15_dark_description BC_2740
    with p25_behind_description BC_2741
    with p48_possessive BC_2742
    with list_together BC_2743
    with plural BC_2744
    with article BC_2745
    with p106_summary BC_2746
;

Object -> I491_moira_s_chair ""
    class K6_supporter
    with short_name BC_2747
    with description BC_2748
    has proper
    has static
    has scenery
    has enterable
    with vector 0
    has mark_as_thing
    with IK2_Count 153
    with IK2_Link I492_moira_s_bookshelves
    with IK6_Count 12
    with IK6_Link I492_moira_s_bookshelves
    with KD_Count 6
    with name 'moira^s' 'chair' 'supporters//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2749
    with p15_dark_description BC_2750
    with p25_behind_description BC_2751
    with p48_possessive BC_2752
    with list_together BC_2753
    with plural BC_2754
    with article BC_2755
    with p106_summary BC_2756
;

Object -> I492_moira_s_bookshelves ""
    class K6_supporter
    with short_name BC_2757
    with description BC_2758
    has proper
    has static
    has scenery
    with vector 0
    has mark_as_thing
    with IK2_Count 154
    with IK2_Link I493_native_tribes_of_upstat
    with IK6_Count 13
    with IK6_Link I473_desk_shelves
    with KD_Count 6
    with name 'moira^s' 'bookshelves' 'supporters//p' 
    with parse_name Parse_Name_GV189
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2759
    with p15_dark_description BC_2760
    with p25_behind_description BC_2761
    with p48_possessive BC_2762
    with list_together BC_2763
    with plural BC_2764
    with article BC_2765
    with p106_summary BC_2766
;

Object -> -> I493_native_tribes_of_upstat ""
    class K2_thing
    with short_name BC_2767
    has proper
    with vector 0
    has mark_as_thing
    with IK2_Count 155
    with IK2_Link I461_copy_of_the_washington_
    with KD_Count 2
    with name 'native' 'tribes' 'of' 'upstate' 'new' 'york' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2768
    with initial BC_2769
    with p15_dark_description BC_2770
    with p25_behind_description BC_2771
    with p48_possessive BC_2772
    with list_together BC_2773
    with plural BC_2774
    with article BC_2775
    with p106_summary BC_2776
;

Object I461_copy_of_the_washington_ ""
    class K2_thing
    with short_name BC_2777
    with description BC_2778
    with vector 0
    has mark_as_thing
    with IK2_Count 123
    with IK2_Link I464_strange_symbols
    with KD_Count 2
    with name 'copy' 'of' 'the' 'washington' 'herald' 'things//p' 'newspaper' 'paper' 'news' 
    with parse_name Parse_Name_GV174
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2779
    with p15_dark_description BC_2780
    with p25_behind_description BC_2781
    with p48_possessive BC_2782
    with list_together BC_2783
    with plural BC_2784
    with article BC_2785
    with p106_summary BC_2786
;

Object I464_strange_symbols ""
    class K2_thing
    with short_name BC_2787
    with description BC_2788
    has pluralname
    with vector 0
    has mark_as_thing
    with component_parent I259_thumb_drive
    with IK2_Count 126
    with IK2_Link I470_screws
    with KD_Count 2
    with name 'strange' 'symbols' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2789
    with p15_dark_description BC_2790
    with p25_behind_description BC_2791
    with p48_possessive BC_2792
    with list_together BC_2793
    with plural BC_2794
    with article BC_2795
    with p106_summary BC_2796
;

Object I470_screws ""
    class K2_thing
    with short_name BC_2797
    with description BC_2798
    has pluralname
    with vector 0
    has mark_as_thing
    with component_parent I469_heating_vent
    with IK2_Count 132
    with IK2_Link I473_desk_shelves
    with KD_Count 2
    with name 'screws' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2799
    with p15_dark_description BC_2800
    with p25_behind_description BC_2801
    with p48_possessive BC_2802
    with list_together BC_2803
    with plural BC_2804
    with article BC_2805
    with p106_summary BC_2806
;

Object I473_desk_shelves ""
    class K6_supporter
    with short_name BC_2807
    with vector 0
    has mark_as_thing
    with component_parent I471_chief_s_desk
    with IK2_Count 135
    with IK2_Link I474_polished_orange_marble_
    with IK6_Count 7
    with IK6_Link nothing
    with KD_Count 6
    with name 'desk' 'shelves' 'supporters//p' 'legs' 
    with parse_name Parse_Name_GV182
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2808
    with initial BC_2809
    with p15_dark_description BC_2810
    with p25_behind_description BC_2811
    with p48_possessive BC_2812
    with list_together BC_2813
    with plural BC_2814
    with article BC_2815
    with p106_summary BC_2816
;

Object -> I474_polished_orange_marble_ ""
    class K2_thing
    with short_name BC_2817
    with description BC_2818
    with p125_owner I419_chief_huffton_klimp
    with vector 0
    has mark_as_thing
    with IK2_Count 136
    with IK2_Link I490_moira_s_drawer
    with KD_Count 2
    with name 'polished' 'orange' 'marble' 'dodecahedron' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with initial BC_2819
    with p15_dark_description BC_2820
    with p25_behind_description BC_2821
    with p48_possessive BC_2822
    with list_together BC_2823
    with plural BC_2824
    with article BC_2825
    with p106_summary BC_2826
;

Object I490_moira_s_drawer ""
    class K5_container
    with short_name BC_2827
    has proper
    has openable
    with vector 0
    has mark_as_thing
    with component_parent I489_moira_s_desk
    with IK2_Count 152
    with IK2_Link I494_closet_door
    with IK5_Count 7
    with IK5_Link nothing
    with KD_Count 5
    with name 'moira^s' 'drawer' 'containers//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2828
    with initial BC_2829
    with p15_dark_description BC_2830
    with p25_behind_description BC_2831
    with p48_possessive BC_2832
    with list_together BC_2833
    with plural BC_2834
    with article BC_2835
    with p106_summary BC_2836
;

Object I494_closet_door ""
    class K4_door
    with short_name BC_2837
    has scenery
    has ~open
    has openable
    has lockable
    has locked
    with vector 0
    with door_dir [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I456_moira_s_office) return I57_east; return I58_west;],
    with door_to [ 
        loc ! room of actor
        ;
        loc = location;
        if (loc == thedark) loc = real_location;
        if (loc == I456_moira_s_office) return I495_utility_closet; return I456_moira_s_office;],
    with found_in I456_moira_s_office I495_utility_closet
    has mark_as_thing
    with IK2_Count 156
    with IK2_Link I496_about_the_hyperdimensio
    with IK4_Count 7
    with IK4_Link nothing
    with KD_Count 4
    with name 'closet' 'door' 'doors//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2838
    with initial BC_2839
    with p15_dark_description BC_2840
    with p25_behind_description BC_2841
    with p48_possessive BC_2842
    with list_together BC_2843
    with plural BC_2844
    with article BC_2845
    with p106_summary BC_2846
;

Object I495_utility_closet ""
    class K1_room
    with short_name BC_2847
    with map_region I428_bosh_hq
    has ~light
    with vector 0
    with room_index -1
    has mark_as_room
    with IK1_Count 48
    with IK1_Link nothing
    with KD_Count 1
    with name 'utility' 'closet' 'rooms//p' 
    with description BC_2848
    with p15_dark_description BC_2849
    with p21_preposition BC_2850
    with p24_destination_name BC_2851
    with list_together BC_2852
    with plural BC_2853
    with article BC_2854
    with p106_summary BC_2855
;

Object I496_about_the_hyperdimensio ""
    class K29_quip
    with short_name BC_2856
    with p27_comment BC_2857
    with p28_reply BC_2858
    has proper
    with p143_quip_condition I224_informative
    with p144_quip_condition_2 I227_ubiquitous
    with vector 0
    with cap_short_name BC_2859
    has mark_as_thing
    with IK2_Count 157
    with IK2_Link I497_to_wait_for_the_report
    with IK29_Count 19
    with IK29_Link I497_to_wait_for_the_report
    with KD_Count 29
    with name 'about' 'the' 'hyperdimensional' 'portal' 'quips//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2860
    with initial BC_2861
    with p15_dark_description BC_2862
    with p25_behind_description BC_2863
    with p48_possessive BC_2864
    with list_together BC_2865
    with plural BC_2866
    with article BC_2867
    with p106_summary BC_2868
;

Object I497_to_wait_for_the_report ""
    class K29_quip
    with short_name BC_2869
    with p27_comment BC_2870
    with p28_reply BC_2871
    has proper
    with p143_quip_condition I224_informative
    with p144_quip_condition_2 I227_ubiquitous
    with vector 0
    with cap_short_name BC_2872
    has mark_as_thing
    with IK2_Count 158
    with IK2_Link I498_unknown_voice
    with IK29_Count 20
    with IK29_Link nothing
    with KD_Count 29
    with name 'to' 'wait' 'for' 'the' 'report' 'quips//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2873
    with initial BC_2874
    with p15_dark_description BC_2875
    with p25_behind_description BC_2876
    with p48_possessive BC_2877
    with list_together BC_2878
    with plural BC_2879
    with article BC_2880
    with p106_summary BC_2881
;

Object I498_unknown_voice ""
    class K8_person
    with short_name BC_2882
    with p49_portrait I513_figure_caller
    with vector 0
    has mark_as_thing
    with IK2_Count 159
    with IK2_Link I499_mysterious_phone
    with IK8_Count 14
    with IK8_Link nothing
    with KD_Count 8
    with name 'unknown' 'voice' 'people//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with p22_behavior_stack BC_2883
    with p26_remembrances BC_2884
    with p29_queue BC_2885
    with p38_how_are_you_reply BC_2886
    with description BC_2887
    with initial BC_2888
    with p15_dark_description BC_2889
    with p25_behind_description BC_2890
    with p48_possessive BC_2891
    with list_together BC_2892
    with plural BC_2893
    with article BC_2894
    with p106_summary BC_2895
;

Object I499_mysterious_phone ""
    class K20_phone
    with short_name BC_2896
    with p125_owner I498_unknown_voice
    with vector 0
    has mark_as_thing
    with IK2_Count 160
    with IK2_Link I529_draco
    with IK20_Count 3
    with IK20_Link nothing
    with KD_Count 20
    with name 'mysterious' 'phone' 'phones//p' 'phone' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2897
    with initial BC_2898
    with p15_dark_description BC_2899
    with p25_behind_description BC_2900
    with p48_possessive BC_2901
    with list_together BC_2902
    with plural BC_2903
    with article BC_2904
    with p106_summary BC_2905
;

Object I529_draco ""
    class K2_thing
    with short_name BC_2906
    with p49_portrait I506_figure_draco
    has proper
    with vector 0
    has mark_as_thing
    with IK2_Count 161
    with IK2_Link nothing
    with KD_Count 2
    with name 'draco' 'things//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 
    with description BC_2907
    with initial BC_2908
    with p15_dark_description BC_2909
    with p25_behind_description BC_2910
    with p48_possessive BC_2911
    with list_together BC_2912
    with plural BC_2913
    with article BC_2914
    with p106_summary BC_2915
;

Array SN_R_A_0 --> CONSTANT_PACKED_TEXT_STORAGE SN_R_0;
[ SN_R_0 ;
    print (name) I430_biff_s_desk, "'s drawer"; rtrue;];
Array SN_R_A_1 --> CONSTANT_PACKED_TEXT_STORAGE SN_R_1;
[ SN_R_1 ;
    if (I430_biff_s_desk.&cap_short_name) PrintOrRun(I430_biff_s_desk, cap_short_name, true);
    else PrintOrRun(I430_biff_s_desk, short_name, true);
    print "'s drawer"; rtrue;];
Constant I65_neuter_gender = 1;
Constant I66_masculine_gender = 2;
Constant I67_feminine_gender = 3;
Constant I68_neitherine_gender = 4;
Constant I77_german_language = 1;
Constant I78_italian_language = 2;
Constant I79_english_language = 3;
Constant I80_french_language = 4;
Constant I81_swedish_language = 5;
Constant I82_spanish_language = 6;
Constant I83_figure_of_cover = 1;
Constant I84_entire_game = 1;
Constant I86_didn_t_understand_error = 1;
Constant I87_only_understood_as_far_a = 2;
Constant I88_didn_t_understand_that_n = 3;
Constant I89_can_only_do_that_to_some = 4;
Constant I90_can_t_see_any_such_thing = 5;
Constant I91_said_too_little_error = 6;
Constant I92_aren_t_holding_that_erro = 7;
Constant I93_can_t_use_multiple_objec = 8;
Constant I94_can_only_use_multiple_ob = 9;
Constant I95_not_sure_what_it_refers_ = 10;
Constant I96_excepted_something_not_i = 11;
Constant I97_not_a_verb_i_recognise_e = 12;
Constant I98_not_something_you_need_t = 13;
Constant I99_can_t_see_it_at_the_mome = 14;
Constant I100_didn_t_understand_the_w = 15;
Constant I101_not_enough_of_those_ava = 16;
Constant I102_nothing_to_do_error = 17;
Constant I103_noun_did_not_make_sense = 18;
Constant I104_referred_to_a_determina = 19;
Constant I105_i_beg_your_pardon_error = 20;
Constant I106_can_t_again_the_address = 21;
Constant I107_comma_can_t_begin_error = 22;
Constant I108_can_t_see_whom_to_talk_ = 23;
Constant I109_can_t_talk_to_inanimate = 24;
Constant I110_didn_t_understand_addre = 25;
Constant I112_present_tense = 1;
Constant I113_past_tense = 2;
Constant I114_perfect_tense = 3;
Constant I115_past_perfect_tense = 4;
Constant I116_future_tense = 5;
Constant I118_first_person_singular = 1;
Constant I119_second_person_singular = 2;
Constant I120_third_person_singular = 3;
Constant I121_first_person_plural = 4;
Constant I122_second_person_plural = 5;
Constant I123_third_person_plural = 6;
Constant I125_nominative = 1;
Constant I126_accusative = 2;
Constant I129_implicit = 1;
Constant I130_explicit = 2;
Constant I132_all_styles = 1;
Constant I133_normal_style = 2;
Constant I134_italic_style = 3;
Constant I135_fixed_letter_spacing_st = 4;
Constant I136_header_style = 5;
Constant I137_bold_style = 6;
Constant I138_alert_style = 7;
Constant I139_note_style = 8;
Constant I140_blockquote_style = 9;
Constant I141_input_style = 10;
Constant I142_special_style_1 = 11;
Constant I143_special_style_2 = 12;
Constant I145_left_justified = 1;
Constant I146_left_right_justified = 2;
Constant I147_center_justified = 3;
Constant I148_right_justified = 4;
Constant I150_light_weight = 1;
Constant I151_regular_weight = 2;
Constant I152_bold_weight = 3;
Constant I156_indoors = 1;
Constant I157_outdoors = 2;
Constant I158_floating = 3;
Constant I173_very_loud = 1;
Constant I174_loud = 2;
Constant I175_moderately_loud = 3;
Constant I176_faint = 4;
Constant I177_very_faint = 5;
Constant I178_inaudible = 6;
Constant I181_ringing = 1;
Constant I182_idle = 2;
Constant I183_in_use = 3;
Constant I196_bare = 1;
Constant I197_definite = 2;
Constant I198_indefinite = 3;
Constant I200_sequential = 1;
Constant I201_disjunctive = 2;
Constant I202_semi_colon = 3;
Constant I203_comma = 4;
Constant I204_null = 5;
Constant I205_hyperconnective = 6;
Constant I206_fragmentary = 7;
Constant I207_enumerated = 8;
Constant I210_enabled = 1;
Constant I211_disabled = 2;
Constant I213_show_unvisited = 1;
Constant I214_dont_show_unvisited = 2;
Constant I223_questioning = 1;
Constant I224_informative = 2;
Constant I225_performative = 3;
Constant I227_ubiquitous = 1;
Constant I228_ignored = 2;
Constant I229_plausibility_normal = 3;
Constant I266_timer_event = 1;
Constant I267_char_event = 2;
Constant I268_line_event = 3;
Constant I269_mouse_event = 4;
Constant I270_arrange_event = 5;
Constant I271_redraw_event = 6;
Constant I272_sound_notify_event = 7;
Constant I273_hyperlink_event = 8;
Constant I275_g_null = 1;
Constant I276_g_above = 2;
Constant I277_g_below = 3;
Constant I278_g_left = 4;
Constant I279_g_right = 5;
Constant I282_describe_always = 1;
Constant I283_only_open = 2;
Constant I284_never = 3;
Constant I286_front = 1;
Constant I287_xback = 2;
Constant I391_nominal = 1;
Constant I392_pronominal = 2;
Constant I408__startup = 1;
Constant I409__normal = 2;
Constant I410_picking_character = 3;
Constant I412_klimp_in_the_office = 2;
Constant I413_moira_in_the_office = 3;
Constant I414_denouement = 4;
Constant I500_figure_null = 2;
Constant I501_figure_goldberg = 3;
Constant I502_figure_gaunt = 4;
Constant I503_figure_faraji = 5;
Constant I504_figure_klimp = 6;
Constant I505_figure_margaret = 7;
Constant I506_figure_draco = 8;
Constant I507_figure_clerk = 9;
Constant I508_figure_pawn_owner = 10;
Constant I509_figure_doris = 11;
Constant I510_figure_speech_bubble = 12;
Constant I511_figure_phone_handset = 13;
Constant I512_figure_phone = 14;
Constant I513_figure_caller = 15;
Constant I514_figure_parking_lot = 16;
Constant I515_figure_pawn_shop = 17;
Constant I516_figure_bosh = 18;
Constant I517_figure_store = 19;
Constant I518_figure_laundromat = 20;
Constant I519_figure_white_tunnel = 21;
Constant I520_figure_moira = 22;
Constant I521_figure_hyperspace = 23;
Constant I522_figure_enigma_lake = 24;
Constant I523_figure_enigma_park = 25;
Constant I524_figure_engima_shore = 26;
Constant I525_figure_field_office = 27;
Constant I526_figure_maggie = 28;
Constant I527_figure_minerva = 29;
Constant I528_figure_christy = 30;
Array Global_Vars -->
  (false) ! 7 darkness witnessed
  (BC_2916) ! 25 command prompt
  (I79_english_language) ! 29 language of play
  (BC_2917) ! 32 story author
  (BC_2918) ! 33 story headline
  (BC_2919) ! 34 story genre
  (BC_2920) ! 35 story description
  (1) ! 36 release number
  (2023) ! 37 story creation year
  (0) ! 45 locale paragraph count
  (nothing) ! 60 last person referenced
  (nothing) ! 61 current interlocutor
  (I130_explicit) ! 62 greeting type
  (I130_explicit) ! 63 farewell type
  (T2_ordinary_status) ! 64 status bar table
  (14) ! 65 right alignment depth
  (1) ! 66 debug
  (0) ! 67 skip sounds this turn
  (BC_2921) ! 68 audible sounds
  (1) ! 69 first turn
  (BC_2922) ! 70 player's surname
  (I154_room_of_subjects) ! 71 room you tried to leave
  (I196_bare) ! 72 current articulation style
  (BC_2923) ! 73 first delimiter
  (BC_2924) ! 74 second delimiter
  (BC_2925) ! 75 alternate second delimiter
  (I200_sequential) ! 76 current list style
  (0) ! 77 current listing total
  (0) ! 78 current listing index
  (nothing) ! 79 current listed object
  (1) ! 80 dark-exits-invisible
  (T12_exit_status) ! 81 status exit table
  (T13_standard_status) ! 82 standard status table
  (I210_enabled) ! 83 exit listing
  (I213_show_unvisited) ! 84 indicate-unvisited
  (nothing) ! 85 direction-object
  (false) ! 86 listing explained
  (1) ! 87 exit-colour-num
  (1) ! 88 exit-symbol-num
  (BC_2926) ! 89 exit-marker
  (false) ! 90 options printed
  (1) ! 91 first options paragraph
  (BC_2927) ! 93 memory queue
  (nothing) ! 94 what to print
  (I230_generic_quip) ! 95 latest quip
  (BC_2928) ! 97 hyperplane coords
  (1) ! 98 first time in hyperspace
  (false) ! 99 visited hyperspace
  (false) ! 100 encountered astral passages
  (0) ! 101 visited pillar
  (false) ! 103 doris greeted the player
  (0) ! 104 current glulx rock
  (0) ! 105 current glulx rock-ref
  (BC_2929) ! 106 glulx replacement command
  (0) ! 107 library input context
  (0) ! 108 arranging now in gep
  (I83_figure_of_cover) ! 109 currently shown picture 1
  (I83_figure_of_cover) ! 110 currently shown picture 2
  (I83_figure_of_cover) ! 111 currently shown picture 3
  (I83_figure_of_cover) ! 112 currently shown picture 4
  (I83_figure_of_cover) ! 113 currently shown picture 5
  (I83_figure_of_cover) ! 114 internally selected picture 1
  (I83_figure_of_cover) ! 115 internally selected picture 2
  (I83_figure_of_cover) ! 116 internally selected picture 3
  (I83_figure_of_cover) ! 117 internally selected picture 4
  (I83_figure_of_cover) ! 118 internally selected picture 5
  (128) ! 119 graphics window pixel count
  (0) ! 120 graphics window proportion
  (BC_2930) ! 121 graphics background color
  (I278_g_left) ! 122 graphics window position
  (R_1335) ! 123 current graphics drawing rule
  (false) ! 124 looking for the desk key
  (0) ! 125 margaret box counter
  (1) ! 126 prefer neuter gender
  (I66_masculine_gender) ! 127 preferred animate gender
  (I408__startup) ! 129 current play mode
  (BC_2931) ! 131 player's forename
  (BC_2932) ! 132 player's full name
  (0) ! 133 accessible
  (BC_2933) ! 134 postponed action
  (selfobj) ! 135 capture player
  (BC_2934) ! 136 characters
  (0) ! 137 handset count
  (0) ! 138 bubble count
;
Array V2V_Bitmap_71 --> IK8_Count IK19_Count 
  15 ! Number of left instances
  12 ! Number of right instances
    PrintShortName ! To print left instances
  PrintShortName ! To print right instances
  true ! Cache broken flag
  V2V_Route_Cache_71 ! Cache array (if any)
$0c00 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0800 $0000 $0000 ;
Constant V2V_Route_Cache_71 = 0;
Array V2V_Bitmap_75 --> IK8_Count IK8_Count 
  15 ! Number of left instances
  15 ! Number of right instances
    PrintShortName ! To print left instances
  PrintShortName ! To print right instances
  true ! Cache broken flag
  V2V_Route_Cache_75 ! Cache array (if any)
$0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 ;
Constant V2V_Route_Cache_75 = 0;
Array V2V_Bitmap_89 --> IK29_Count IK2_Count 
  21 ! Number of left instances
  162 ! Number of right instances
    PrintShortName ! To print left instances
  PrintShortName ! To print right instances
  true ! Cache broken flag
  V2V_Route_Cache_89 ! Cache array (if any)
$0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0001 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0004 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0010 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0040 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0100 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0400 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $1000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $2000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $8000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $2000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0002 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0008 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0020 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0080 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0200 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $1000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $4000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0040 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0100 $0000 $0000 $0000 $0000 ;
Constant V2V_Route_Cache_89 = 0;
Array V2V_Bitmap_91 --> IK29_Count IK29_Count 
  21 ! Number of left instances
  21 ! Number of right instances
    PrintShortName ! To print left instances
  PrintShortName ! To print right instances
  true ! Cache broken flag
  V2V_Route_Cache_91 ! Cache array (if any)
$0000 $0000 $0000 $0000 $0000 $0000 $2000 $0000 $0004 $0080 $0000 $0000 $0020 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 ;
Constant V2V_Route_Cache_91 = 0;
Array V2V_Bitmap_93 --> IK29_Count IK29_Count 
  21 ! Number of left instances
  21 ! Number of right instances
    PrintShortName ! To print left instances
  PrintShortName ! To print right instances
  true ! Cache broken flag
  V2V_Route_Cache_93 ! Cache array (if any)
$0000 $0000 $2000 $0000 $0002 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0008 $0080 ;
Constant V2V_Route_Cache_93 = 0;
Array V2V_Bitmap_95 --> IK29_Count IK2_Count 
  21 ! Number of left instances
  162 ! Number of right instances
    PrintShortName ! To print left instances
  PrintShortName ! To print right instances
  true ! Cache broken flag
  V2V_Route_Cache_95 ! Cache array (if any)
$0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0040 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0100 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $8000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0008 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0008 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0080 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0800 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $2000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0004 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $8000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0008 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 ;
Constant V2V_Route_Cache_95 = 0;
Array V2V_Bitmap_97 --> IK29_Count IK2_Count 
  21 ! Number of left instances
  162 ! Number of right instances
    PrintShortName ! To print left instances
  PrintShortName ! To print right instances
  true ! Cache broken flag
  V2V_Route_Cache_97 ! Cache array (if any)
$0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 ;
Constant V2V_Route_Cache_97 = 0;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====



Array T0_final_question_options table  tab_0_0 tab_0_1 tab_0_2 tab_0_3 tab_0_4;
Array tab_0_0 table $0664 0 (BC_2935) (BC_2936) (BC_2937) (BC_2938) (BC_2939) ;
Array tab_0_1 table $0465 1 (0) (0) (1) (0) (0) ;
Array tab_0_2 table $2066 2 (Consult_Grammar_191) (Consult_Grammar_192) (Consult_Grammar_193) (Consult_Grammar_194) (Consult_Grammar_195) ;
Array tab_0_3 table $0067 3 (IMMEDIATELY_RESTART_VM_R) (IMMEDIATELY_RESTORE_SAVED_R) ( TABLE_NOVALUE) (IMMEDIATELY_QUIT_R) (IMMEDIATELY_UNDO_R) ;
Array tab_0_4 table $0068 4 ( TABLE_NOVALUE) ( TABLE_NOVALUE) (V27_amusing_a_victorious_pla) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array T1_locale_priorities table  tab_1_0 tab_1_1;
Array tab_1_0 table $0869 NULL ( TABLE_NOVALUE)  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array tab_1_1 table $446a 5 ( TABLE_NOVALUE)  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array T2_ordinary_status table  tab_2_0 tab_2_1 tab_2_2;
Array tab_2_0 table $066b 26 (BC_2940) ;
Array tab_2_1 table $066c 27 (BC_2941) ;
Array tab_2_2 table $066d 28 (BC_2942) ;
Array T3_user_styles table  tab_3_0 tab_3_1 tab_3_2 tab_3_3 tab_3_4 tab_3_5 tab_3_6 tab_3_7 tab_3_8 tab_3_9 tab_3_10;
Array tab_3_0 table $4c6e NULL (I143_special_style_2)  TABLE_NOVALUE;
Array tab_3_1 table $066f 29 ( TABLE_NOVALUE)  TABLE_NOVALUE;
Array tab_3_2 table $0670 30 (BC_2943)  TABLE_NOVALUE;
Array tab_3_3 table $4471 31 (0)  TABLE_NOVALUE;
Array tab_3_4 table $0472 32 ( TABLE_NOVALUE)  TABLE_NOVALUE;
Array tab_3_5 table $4c73 NULL ( TABLE_NOVALUE)  TABLE_NOVALUE;
Array tab_3_6 table $4474 33 (0)  TABLE_NOVALUE;
Array tab_3_7 table $0475 34 (1)  TABLE_NOVALUE;
Array tab_3_8 table $4c76 NULL (I145_left_justified)  TABLE_NOVALUE;
Array tab_3_9 table $4477 35 ( TABLE_NOVALUE)  TABLE_NOVALUE;
Array tab_3_10 table $0478 36 ( TABLE_NOVALUE)  TABLE_NOVALUE;
Array T4_all_known_facts table  tab_4_0 tab_4_1;
Array tab_4_0 table $0879 NULL (I162_generic_truth) (I163_vent_screws) (I164_desk_locked) (I165_pawn_shop_screwdriver) (I166_pawn_shop_dave) (I167_key_is_lost) (I168_screwdriver_in_laundrom) (I169_hex_screws) (I170_break_in_to_laundromat) (I171_back_door_is_locked) ;
Array tab_4_1 table $067a 37 (BC_2944) (BC_2945) (BC_2946) (BC_2947) (BC_2948) (BC_2949) (BC_2950) (BC_2951) (BC_2952) (BC_2953) ;
Array T5_walls table  tab_5_0 tab_5_1 tab_5_2 tab_5_3;
Array tab_5_0 table $087b NULL  TABLE_NOVALUE;
Array tab_5_1 table $047c 39  TABLE_NOVALUE;
Array tab_5_2 table $067d 40  TABLE_NOVALUE;
Array tab_5_3 table $067e 41  TABLE_NOVALUE;
Array T6_floors table  tab_6_0 tab_6_1 tab_6_2 tab_6_3;
Array tab_6_0 table $087b NULL (I294_strip_mall_parking_lot_) (I312_strip_mall_parking_lot_) (I340_li_l_nectarine_convenie) (I309_dave_s_pawn_shop)  TABLE_NOVALUE;
Array tab_6_1 table $047f 42 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE)  TABLE_NOVALUE;
Array tab_6_2 table $0680 43 (BC_2954) (BC_2955) (BC_2956) (BC_2957)  TABLE_NOVALUE;
Array tab_6_3 table $067e 44 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE)  TABLE_NOVALUE;
Array T7_ceilings table  tab_7_0 tab_7_1 tab_7_2 tab_7_3 tab_7_4;
Array tab_7_0 table $087b NULL  TABLE_NOVALUE;
Array tab_7_1 table $0481 45  TABLE_NOVALUE;
Array tab_7_2 table $0682 46  TABLE_NOVALUE;
Array tab_7_3 table $067e 47  TABLE_NOVALUE;
Array tab_7_4 table $0483 48  TABLE_NOVALUE;
Array T8_excuses table  tab_8_0 tab_8_1 tab_8_2;
Array tab_8_0 table $0884 NULL  TABLE_NOVALUE;
Array tab_8_1 table $0685 49  TABLE_NOVALUE;
Array tab_8_2 table $0686 50  TABLE_NOVALUE;
Array T9_frustrated_taking table  tab_9_0 tab_9_1 tab_9_2;
Array tab_9_0 table $0887 NULL  TABLE_NOVALUE;
Array tab_9_1 table $0688 51  TABLE_NOVALUE;
Array tab_9_2 table $0689 52  TABLE_NOVALUE;
Array T10_scored_listing table  tab_10_0 tab_10_1;
Array tab_10_0 table $088a NULL ( TABLE_NOVALUE)  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array tab_10_1 table $448b 53 ( TABLE_NOVALUE)  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array T11_list_style_assignments table  tab_11_0 tab_11_1 tab_11_2 tab_11_3 tab_11_4 tab_11_5;
Array tab_11_0 table $5c8c NULL (I200_sequential) (I201_disjunctive) (I202_semi_colon) (I203_comma) (I204_null) (I205_hyperconnective) (I206_fragmentary) (I207_enumerated) ;
Array tab_11_1 table $168d 57 (BC_2958) (BC_2959) (BC_2960) (BC_2961) (BC_2962) (BC_2963) (BC_2964) (BC_2965) ;
Array tab_11_2 table $168e 58 (BC_2966) (BC_2967) (BC_2968) (BC_2969) (BC_2970) (BC_2971) (BC_2972) (BC_2973) ;
Array tab_11_3 table $168f 59 (BC_2974) (BC_2975) (BC_2976) (BC_2977) (BC_2978) (BC_2979) (BC_2980) (BC_2981) ;
Array tab_11_4 table $1690 60 (BC_2982) (BC_2983) (BC_2984) (BC_2985) (BC_2986) (BC_2987) (BC_2988) (BC_2989) ;
Array tab_11_5 table $1691 61 (BC_2990) (BC_2991) (BC_2992) (BC_2993) (BC_2994) (BC_2995) (BC_2996) (BC_2997) ;
Array T12_exit_status table  tab_12_0 tab_12_1 tab_12_2;
Array tab_12_0 table $066b 62 (BC_2998) (BC_2999) ;
Array tab_12_1 table $066c 63 (BC_3000) (BC_3001) ;
Array tab_12_2 table $066d 64 (BC_3002) (BC_3003) ;
Array T13_standard_status table  tab_13_0 tab_13_1 tab_13_2;
Array tab_13_0 table $066b 65 (BC_3004) ;
Array tab_13_1 table $066c 66 (BC_3005) ;
Array tab_13_2 table $066d 67 (BC_3006) ;
Array T14_exit_symbols --> 1 tab_14_0;
Array tab_14_0 table $0692 68 (BC_3007) (BC_3008) (BC_3009) (BC_3010) (BC_3011) ;
Array T18_fancy_status table  tab_18_0 tab_18_1 tab_18_2;
Array tab_18_0 table $066b 69 (BC_3012) ;
Array tab_18_1 table $066c 70 ( TABLE_NOVALUE) ;
Array tab_18_2 table $066d 71 (BC_3013) ;
Array T19_transitions table  tab_19_0 tab_19_1 tab_19_2 tab_19_3;
Array tab_19_0 table $0884 NULL (I294_strip_mall_parking_lot_) (I312_strip_mall_parking_lot_) (I294_strip_mall_parking_lot_) (I295_the_front_office) (I312_strip_mall_parking_lot_) (I340_li_l_nectarine_convenie) (I294_strip_mall_parking_lot_) (I309_dave_s_pawn_shop) ;
Array tab_19_1 table $0893 NULL (I312_strip_mall_parking_lot_) (I294_strip_mall_parking_lot_) (I295_the_front_office) (I294_strip_mall_parking_lot_) (I340_li_l_nectarine_convenie) (I312_strip_mall_parking_lot_) (I309_dave_s_pawn_shop) (I294_strip_mall_parking_lot_) ;
Array tab_19_2 table $0694 72 (BC_3014) (BC_3015) (BC_3016) (BC_3017) (BC_3018) (BC_3019) (BC_3020) (BC_3021) ;
Array tab_19_3 table $0495 73 ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ( TABLE_NOVALUE) ;
Array TB_Blanks -> 
  ! For table T0_final_question_options
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  $04  ! Column 3
  $1b  ! Column 4
  
  ! For table T1_locale_priorities
  $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $07  ! Column 1
  
  ! For table T2_ordinary_status
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  
  ! For table T3_user_styles
  $03  ! Column 1
  $02  ! Column 2
  $02  ! Column 3
  $03  ! Column 4
  $02  ! Column 6
  $02  ! Column 7
  $03  ! Column 9
  $03  ! Column 10
  
  ! For table T4_all_known_facts
  $00 $00  ! Column 1
  
  ! For table T5_walls
  $01  ! Column 1
  $01  ! Column 2
  $01  ! Column 3
  
  ! For table T6_floors
  $1f  ! Column 1
  $10  ! Column 2
  $1f  ! Column 3
  
  ! For table T7_ceilings
  $01  ! Column 1
  $01  ! Column 2
  $01  ! Column 3
  $01  ! Column 4
  
  ! For table T8_excuses
  $01  ! Column 1
  $01  ! Column 2
  
  ! For table T9_frustrated_taking
  $01  ! Column 1
  $01  ! Column 2
  
  ! For table T10_scored_listing
  $ff $ff $ff $7f  ! Column 1
  
  ! For table T11_list_style_assignments
  $00  ! Column 1
  $00  ! Column 2
  $00  ! Column 3
  $00  ! Column 4
  $00  ! Column 5
  
  ! For table T12_exit_status
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  
  ! For table T13_standard_status
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  
  ! For table T14_exit_symbols
  $00  ! Column 0
  
  ! For table T18_fancy_status
  $00  ! Column 0
  $01  ! Column 1
  $00  ! Column 2
  
  ! For table T19_transitions
  $00  ! Column 2
  $ff  ! Column 3
  
  ! End of table
  NULL NULL;
Array TableOfTables --> TheEmptyTable T0_final_question_options  T1_locale_priorities  T2_ordinary_status  T3_user_styles  T4_all_known_facts  T5_walls  T6_floors  T7_ceilings  T8_excuses  T9_frustrated_taking  T10_scored_listing  T11_list_style_assignments  T12_exit_status  T13_standard_status  T14_exit_symbols  T18_fancy_status  T19_transitions  0 0;
[ TC_KOV 
    tc ! Implied call parameter
    ;
    switch (tc) {
        100: return TEXT_TY; ! final question wording: text
        101: return TRUTH_STATE_TY; ! only if victorious: truth state
        102: return UNDERSTANDING_TY; ! topic: topic
        103: return KD5_rule; ! final response rule: rule
        104: return KD6_activity; ! final response activity: activity
        105: return OBJECT_TY; ! notable-object: object
        106: return NUMBER_TY; ! locale description priority: number
        107: return TEXT_TY; ! left: text
        108: return TEXT_TY; ! central: text
        109: return TEXT_TY; ! right: text
        110: return 54; ! style name: glulx text style
        111: return TEXT_TY; ! background color: text
        112: return TEXT_TY; ! color: text
        113: return NUMBER_TY; ! first line indentation: number
        114: return TRUTH_STATE_TY; ! fixed width: truth state
        115: return 56; ! font weight: font weight
        116: return NUMBER_TY; ! indentation: number
        117: return TRUTH_STATE_TY; ! italic: truth state
        118: return 55; ! justification: text justification
        119: return NUMBER_TY; ! relative size: number
        120: return TRUTH_STATE_TY; ! reversed: truth state
        121: return OBJECT_TY; ! fact: object
        122: return TEXT_TY; ! summary: text
        123: return 10; ! locale: room
        124: return TRUTH_STATE_TY; ! has walls: truth state
        125: return TEXT_TY; ! wall description: text
        126: return TEXT_TY; ! touch description: text
        127: return TRUTH_STATE_TY; ! has floor: truth state
        128: return TEXT_TY; ! floor description: text
        129: return TRUTH_STATE_TY; ! has ceiling: truth state
        130: return TEXT_TY; ! ceiling description: text
        131: return TRUTH_STATE_TY; ! low ceiling: truth state
        132: return 10; ! source room: room
        133: return KD7_list_of_directions; ! dirs: list of directions
        134: return TEXT_TY; ! excuse: text
        135: return 10; ! target: thing
        136: return TEXT_TY; ! message: text
        137: return TEXT_TY; ! move message: text
        138: return OBJECT_TY; ! output: object
        139: return NUMBER_TY; ! assigned score: number
        140: return 62; ! list style: list style
        141: return TEXT_TY; ! first delimiter: text
        142: return TEXT_TY; ! second delimiter: text
        143: return TEXT_TY; ! alternate second delimiter: text
        144: return TEXT_TY; ! indefinite name phrase: text
        145: return TEXT_TY; ! definite name phrase: text
        146: return TEXT_TY; ! exit-symbol: text
        147: return 10; ! target room: room
        148: return TEXT_TY; ! transition text: text
        149: return TRUTH_STATE_TY; ! used: truth state
    }
    return UNKNOWN_TY;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Equations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====





! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Actions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


[ NAP_0 ;
    if ((((action ==##A68_implicit_asking)))) rtrue;
    if ((((action ==##A69_implicit_telling)))) rtrue;
    if ((((action ==##A70_implicit_quizzing)))) rtrue;
    if ((((action ==##A71_implicit_informing)))) rtrue;
    if ((((action ==##A72_implicit_requesting)))) rtrue;
    if ((((action ==##A73_implicit_imploring)))) rtrue;
    if ((((action ==##Yes)))) rtrue;
    if ((((action ==##No)))) rtrue;
    if ((((action ==##Sorry)))) rtrue;
    rfalse;
];
[ NAP_1 ;
    if ((((action ==##Ask) && ((noun ofclass K8_person)) && (true)))) rtrue;
    if ((((action ==##Tell) && ((noun ofclass K8_person)) && (true)))) rtrue;
    if ((((action ==##A66_quizzing_it_about) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))))) rtrue;
    if ((((action ==##A67_informing_it_about) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))))) rtrue;
    if ((((action ==##Answer) && ((noun ofclass K8_person)) && (true)))) rtrue;
    if ((((action ==##AskFor) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))))) rtrue;
    if ((((action ==##A64_requesting_it_for) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))))) rtrue;
    if ((((action ==##A65_imploring_it_for) && ((noun ofclass K8_person)) && (true)))) rtrue;
    rfalse;
];
[ NAP_2 ;
    if ((((action ==##Ask) && ((noun ofclass K8_person)) && (true)))) rtrue;
    if ((((action ==##Tell) && ((noun ofclass K8_person)) && (true)))) rtrue;
    if ((((action ==##A66_quizzing_it_about) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))))) rtrue;
    if ((((action ==##A67_informing_it_about) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))))) rtrue;
    if ((((action ==##Answer) && ((noun ofclass K8_person)) && (true)))) rtrue;
    if ((((action ==##AskFor) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))))) rtrue;
    if ((((action ==##A64_requesting_it_for) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))))) rtrue;
    if ((((action ==##A65_imploring_it_for) && ((noun ofclass K8_person)) && (true)))) rtrue;
    if ((((action ==##Yes)))) rtrue;
    if ((((action ==##No)))) rtrue;
    if ((((action ==##Sorry)))) rtrue;
    rfalse;
];
[ NAP_3 ;
    if ((((action ==##Take) && ((noun == I434_biff_s_landline) && (true))))) rtrue;
    rfalse;
];


Array ActionData table
  ##Inv  $$00000000  OBJECT_TY OBJECT_TY  0 20000
  ##Take  $$00001001  OBJECT_TY OBJECT_TY  0 20001
  ##Remove  $$00011011  OBJECT_TY OBJECT_TY  0 20002
  ##Drop  $$00001001  OBJECT_TY OBJECT_TY  0 20003
  ##PutOn  $$00011011  OBJECT_TY OBJECT_TY  0 20004
  ##Insert  $$00011011  OBJECT_TY OBJECT_TY  0 20005
  ##Eat  $$00001001  OBJECT_TY OBJECT_TY  0 20006
  ##Go  $$00001000  OBJECT_TY OBJECT_TY  ANSTVC_7 20007
  ##Enter  $$00001001  OBJECT_TY OBJECT_TY  0 20008
  ##Exit  $$00000000  OBJECT_TY OBJECT_TY  ANSTVC_9 20009
  ##GetOff  $$00001001  OBJECT_TY OBJECT_TY  0 20010
  ##Look  $$00000000  OBJECT_TY OBJECT_TY  ANSTVC_11 20011
  ##Examine  $$00001100  OBJECT_TY OBJECT_TY  ANSTVC_12 20012
  ##LookUnder  $$00001100  OBJECT_TY OBJECT_TY  0 20013
  ##Search  $$00001101  OBJECT_TY OBJECT_TY  0 20014
  ##Consult  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20015
  ##Lock  $$10011011  OBJECT_TY OBJECT_TY  0 20016
  ##Unlock  $$10011011  OBJECT_TY OBJECT_TY  0 20017
  ##SwitchOn  $$00001001  OBJECT_TY OBJECT_TY  0 20018
  ##SwitchOff  $$00001001  OBJECT_TY OBJECT_TY  0 20019
  ##Open  $$00001001  OBJECT_TY OBJECT_TY  0 20020
  ##Close  $$00001001  OBJECT_TY OBJECT_TY  0 20021
  ##Wear  $$01001001  OBJECT_TY OBJECT_TY  0 20022
  ##Disrobe  $$00001001  OBJECT_TY OBJECT_TY  0 20023
  ##Give  $$01011011  OBJECT_TY OBJECT_TY  0 20024
  ##Show  $$01011001  OBJECT_TY OBJECT_TY  0 20025
  ##WakeOther  $$00001001  OBJECT_TY OBJECT_TY  0 20026
  ##ThrowAt  $$01011001  OBJECT_TY OBJECT_TY  0 20027
  ##Attack  $$00001001  OBJECT_TY OBJECT_TY  0 20028
  ##Kiss  $$00001001  OBJECT_TY OBJECT_TY  0 20029
  ##Answer  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20030
  ##Tell  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20031
  ##Ask  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20032
  ##AskFor  $$00011011  OBJECT_TY OBJECT_TY  0 20033
  ##Wait  $$00000000  OBJECT_TY OBJECT_TY  0 20034
  ##Touch  $$00001001  OBJECT_TY OBJECT_TY  0 20035
  ##Wave  $$00001001  OBJECT_TY OBJECT_TY  0 20036
  ##Pull  $$00001001  OBJECT_TY OBJECT_TY  0 20037
  ##Push  $$00001001  OBJECT_TY OBJECT_TY  0 20038
  ##Turn  $$00001001  OBJECT_TY OBJECT_TY  0 20039
  ##PushDir  $$00011001  OBJECT_TY OBJECT_TY  0 20040
  ##Squeeze  $$00001001  OBJECT_TY OBJECT_TY  0 20041
  ##Yes  $$00000000  OBJECT_TY OBJECT_TY  0 20042
  ##No  $$00000000  OBJECT_TY OBJECT_TY  0 20043
  ##Cut  $$00001001  OBJECT_TY OBJECT_TY  0 20044
  ##Sorry  $$00000000  OBJECT_TY OBJECT_TY  0 20045
  ##Rub  $$00001001  OBJECT_TY OBJECT_TY  0 20046
  ##Buy  $$00001001  OBJECT_TY OBJECT_TY  0 20047
  ##Quit  $$00100000  OBJECT_TY OBJECT_TY  0 20048
  ##Save  $$00100000  OBJECT_TY OBJECT_TY  0 20049
  ##Restore  $$00100000  OBJECT_TY OBJECT_TY  0 20050
  ##Restart  $$00100000  OBJECT_TY OBJECT_TY  0 20051
  ##Verify  $$00100000  OBJECT_TY OBJECT_TY  0 20052
  ##ScriptOn  $$00100000  OBJECT_TY OBJECT_TY  0 20053
  ##ScriptOff  $$00100000  OBJECT_TY OBJECT_TY  0 20054
  ##Version  $$00100000  OBJECT_TY OBJECT_TY  0 20055
  ##Score  $$00100000  OBJECT_TY OBJECT_TY  0 20056
  ##LMode3  $$00100000  OBJECT_TY OBJECT_TY  0 20057
  ##LMode2  $$00100000  OBJECT_TY OBJECT_TY  0 20058
  ##LMode1  $$00100000  OBJECT_TY OBJECT_TY  0 20059
  ##NotifyOn  $$00100000  OBJECT_TY OBJECT_TY  0 20060
  ##NotifyOff  $$00100000  OBJECT_TY OBJECT_TY  0 20061
  ##Pronouns  $$00100000  OBJECT_TY OBJECT_TY  0 20062
  ##A63_requesting_epistemic_sta  $$00101000  OBJECT_TY OBJECT_TY  0 20063
  ##A64_requesting_it_for  $$00011000  OBJECT_TY OBJECT_TY  0 20064
  ##A65_imploring_it_for  $$00011000  OBJECT_TY UNDERSTANDING_TY  0 20065
  ##A66_quizzing_it_about  $$00011000  OBJECT_TY OBJECT_TY  0 20066
  ##A67_informing_it_about  $$00011000  OBJECT_TY OBJECT_TY  0 20067
  ##A68_implicit_asking  $$00001000  UNDERSTANDING_TY OBJECT_TY  0 20068
  ##A69_implicit_telling  $$00001000  UNDERSTANDING_TY OBJECT_TY  0 20069
  ##A70_implicit_quizzing  $$00001000  OBJECT_TY OBJECT_TY  0 20070
  ##A71_implicit_informing  $$00001000  OBJECT_TY OBJECT_TY  0 20071
  ##A72_implicit_requesting  $$00001000  OBJECT_TY OBJECT_TY  0 20072
  ##A73_implicit_imploring  $$00001000  UNDERSTANDING_TY OBJECT_TY  0 20073
  ##A74_saying_hello_to  $$00001000  OBJECT_TY OBJECT_TY  0 20074
  ##A75_hailing  $$00000000  OBJECT_TY OBJECT_TY  0 20075
  ##A76_leavetaking  $$00000000  OBJECT_TY OBJECT_TY  0 20076
  ##A77_saying_goodbye_to  $$00001000  OBJECT_TY OBJECT_TY  0 20077
  ##A78_helping  $$00100000  OBJECT_TY OBJECT_TY  0 20078
  ##A79_asking_for_identificatio  $$00000000  OBJECT_TY OBJECT_TY  0 20079
  ##A80_questioning_motives  $$00000000  OBJECT_TY OBJECT_TY  0 20080
  ##A81_promising  $$00000000  OBJECT_TY OBJECT_TY  0 20081
  ##A82_calling_it_on  $$00011000  OBJECT_TY OBJECT_TY  0 20082
  ##A83_cold_calling_it_on  $$00011010  UNDERSTANDING_TY OBJECT_TY  0 20083
  ##A84_answering  $$00001001  OBJECT_TY OBJECT_TY  0 20084
  ##A85_picking_up  $$00001001  OBJECT_TY OBJECT_TY  0 20085
  ##A86_ending_a_call  $$00000000  OBJECT_TY OBJECT_TY  0 20086
  ##A87_hanging_up  $$00001001  OBJECT_TY OBJECT_TY  0 20087
  ##A88_signing_off_with  $$00001000  OBJECT_TY OBJECT_TY  0 20088
  ##A89_buying_it_with  $$10011010  OBJECT_TY OBJECT_TY  0 20089
  ##A90_pricing_it  $$00001000  OBJECT_TY OBJECT_TY  0 20090
  ##A91_accounting  $$00000000  OBJECT_TY OBJECT_TY  0 20091
  ##A92_attributing_it  $$00001000  OBJECT_TY OBJECT_TY  0 20092
  ##A93_exitstarting  $$00100000  OBJECT_TY OBJECT_TY  0 20093
  ##A94_exitstopping  $$00100000  OBJECT_TY OBJECT_TY  0 20094
  ##A95_exitlisting  $$00100000  OBJECT_TY OBJECT_TY  0 20095
  ##A96_exit_colouring  $$00100000  OBJECT_TY OBJECT_TY  0 20096
  ##A97_exit_symboling  $$00100000  OBJECT_TY OBJECT_TY  0 20097
  ##A98_choosing  $$00001001  OBJECT_TY OBJECT_TY  0 20098
  ##A99_looking_behind  $$00001001  OBJECT_TY OBJECT_TY  ANSTVC_99 20099
  ##A100_printing_memories  $$00000000  OBJECT_TY OBJECT_TY  0 20100
  ##A101_remembering  $$00001001  OBJECT_TY OBJECT_TY  0 20101
  ##A102_discussing_it_with  $$00011011  OBJECT_TY OBJECT_TY  0 20102
  ##A103_discussing  $$00001001  OBJECT_TY OBJECT_TY  0 20103
  ##A104_frumping  $$00000000  OBJECT_TY OBJECT_TY  0 20104
  ##A105_helping_about_hyperspac  $$00100000  OBJECT_TY OBJECT_TY  0 20105
  ##A106_swiping_it_through  $$01011011  OBJECT_TY OBJECT_TY  0 20106
  ##A107_moving_it_with  $$00011011  OBJECT_TY OBJECT_TY  0 20107
  ##A108_howdeedoing  $$00000000  OBJECT_TY OBJECT_TY  0 20108
  ##A109_howdeedoing_someone  $$00001001  OBJECT_TY OBJECT_TY  0 20109
  ##A110_knocking_on  $$00001001  OBJECT_TY OBJECT_TY  0 20110
  ##A111_lensing  $$00000000  OBJECT_TY OBJECT_TY  0 20111
;
Constant AD_RECORDS = 112;
[ ANSTVC_7 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = I154_room_of_subjects; pos++;
        MStack-->pos = nothing; pos++;
        MStack-->pos = nothing; pos++;
        MStack-->pos = nothing; pos++;
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
        pos++;
        pos++;
        pos++;
        pos++;
    }
    return 5;
];
[ ANSTVC_9 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
    }
    return 1;
];
[ ANSTVC_11 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = ##Wait; pos++;
        MStack-->pos = false; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
        pos++;
        pos++;
        pos++;
    }
    return 4;
];
[ ANSTVC_12 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = false; pos++;
    } else {
        pos++;
    }
    return 1;
];
[ ANSTVC_99 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = BlkValueCreate(KD3_list_of_things); pos++;
    } else {
        BlkValueFree(MStack-->pos);
        pos++;
    }
    return 1;
];
[ DB_Action_Details 
    act ! Implied call parameter
    n ! Implied call parameter
    s ! Implied call parameter
    for_say ! Implied call parameter
    ;
    switch (act) {
        ##Inv: print "taking inventory"; 
        ##Take: print "taking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Remove: print "removing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "from"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Drop: print "dropping"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##PutOn: print "putting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "on"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Insert: print "inserting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "into"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Eat: print "eating"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Go: print "going"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Enter: print "entering"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Exit: print "exiting"; 
        ##GetOff: print "getting off"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Look: print "looking"; 
        ##Examine: print "examining"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##LookUnder: print "looking under"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Search: print "searching"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Consult: print "consulting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Topic(100*consult_from + consult_words); }
        ##Lock: print "locking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "with"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Unlock: print "unlocking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "with"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##SwitchOn: print "switching on"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##SwitchOff: print "switching off"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Open: print "opening"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Close: print "closing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Wear: print "wearing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Disrobe: print "taking off"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Give: print "giving"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Show: print "showing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##WakeOther: print "waking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##ThrowAt: print "throwing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "at"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Attack: print "attacking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Kiss: print "kissing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Answer: print "answering"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "that"; if (for_say ~= 2) { print " "; DA_Topic(100*consult_from + consult_words); }
        ##Tell: print "telling"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Topic(100*consult_from + consult_words); }
        ##Ask: print "asking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Topic(100*consult_from + consult_words); }
        ##AskFor: print "asking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "for"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Wait: print "waiting"; 
        ##Touch: print "touching"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Wave: print "waving"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Pull: print "pulling"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Push: print "pushing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Turn: print "turning"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##PushDir: print "pushing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Squeeze: print "squeezing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Yes: print "saying yes"; 
        ##No: print "saying no"; 
        ##Cut: print "cutting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Sorry: print "saying sorry"; 
        ##Rub: print "rubbing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Buy: print "buying"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Quit: print "quitting the game"; 
        ##Save: print "saving the game"; 
        ##Restore: print "restoring the game"; 
        ##Restart: print "restarting the game"; 
        ##Verify: print "verifying the story file"; 
        ##ScriptOn: print "switching the story transcript on"; 
        ##ScriptOff: print "switching the story transcript off"; 
        ##Version: print "requesting the story file version"; 
        ##Score: print "requesting the score"; 
        ##LMode3: print "preferring abbreviated room descriptions"; 
        ##LMode2: print "preferring unabbreviated room descriptions"; 
        ##LMode1: print "preferring sometimes abbreviated room descriptions"; 
        ##NotifyOn: print "switching score notification on"; 
        ##NotifyOff: print "switching score notification off"; 
        ##Pronouns: print "requesting the pronoun meanings"; 
        ##A63_requesting_epistemic_sta: print "requesting epistemic status of"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A64_requesting_it_for: print "requesting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "for"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A65_imploring_it_for: print "imploring"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "for"; if (for_say ~= 2) { print " "; DA_Topic(100*consult_from + consult_words); }
        ##A66_quizzing_it_about: print "quizzing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A67_informing_it_about: print "informing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A68_implicit_asking: print "implicit-asking"; if (for_say ~= 2) { print " "; DA_Topic(100*consult_from + consult_words); }
        ##A69_implicit_telling: print "implicit-telling"; if (for_say ~= 2) { print " "; DA_Topic(100*consult_from + consult_words); }
        ##A70_implicit_quizzing: print "implicit-quizzing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A71_implicit_informing: print "implicit-informing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A72_implicit_requesting: print "implicit-requesting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A73_implicit_imploring: print "implicit-imploring"; if (for_say ~= 2) { print " "; DA_Topic(100*consult_from + consult_words); }
        ##A74_saying_hello_to: print "saying hello to"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A75_hailing: print "hailing"; 
        ##A76_leavetaking: print "leavetaking"; 
        ##A77_saying_goodbye_to: print "saying goodbye to"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A78_helping: print "helping"; 
        ##A79_asking_for_identificatio: print "asking for identification"; 
        ##A80_questioning_motives: print "questioning motives"; 
        ##A81_promising: print "promising"; 
        ##A82_calling_it_on: print "calling"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "on"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A83_cold_calling_it_on: print "cold-calling"; print " "; if (for_say == 2) print "it"; else DA_Topic(100*consult_from + consult_words); print " "; print "on"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A84_answering: print "answering"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A85_picking_up: print "picking up"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A86_ending_a_call: print "ending a call"; 
        ##A87_hanging_up: print "hanging up"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A88_signing_off_with: print "signing off with"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A89_buying_it_with: print "buying"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "with"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A90_pricing_it: print "pricing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); 
        ##A91_accounting: print "accounting"; 
        ##A92_attributing_it: print "attributing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); 
        ##A93_exitstarting: print "exitstarting"; 
        ##A94_exitstopping: print "exitstopping"; 
        ##A95_exitlisting: print "exitlisting"; 
        ##A96_exit_colouring: print "exit colouring"; 
        ##A97_exit_symboling: print "exit symboling"; 
        ##A98_choosing: print "choosing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A99_looking_behind: print "looking behind"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A100_printing_memories: print "printing memories"; 
        ##A101_remembering: print "remembering"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A102_discussing_it_with: print "discussing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "with"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A103_discussing: print "discussing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A104_frumping: print "frumping"; 
        ##A105_helping_about_hyperspac: print "helping about hyperspace"; 
        ##A106_swiping_it_through: print "swiping"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "through"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A107_moving_it_with: print "moving"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "with"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A108_howdeedoing: print "howdeedoing"; 
        ##A109_howdeedoing_someone: print "howdeedoing-someone"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A110_knocking_on: print "knocking on"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A111_lensing: print "lensing"; 
    }
];

Array ActionCoding -->
    ##Inv ##Take ##Remove ##Drop ##PutOn ##Insert ##Eat ##Go
    ##Enter ##Exit ##GetOff ##Look ##Examine ##LookUnder ##Search ##Consult
    ##Lock ##Unlock ##SwitchOn ##SwitchOff ##Open ##Close ##Wear ##Disrobe
    ##Give ##Show ##WakeOther ##ThrowAt ##Attack ##Kiss ##Answer ##Tell
    ##Ask ##AskFor ##Wait ##Touch ##Wave ##Pull ##Push ##Turn
    ##PushDir ##Squeeze ##Yes ##No ##Cut ##Sorry ##Rub ##Buy
    ##Quit ##Save ##Restore ##Restart ##Verify ##ScriptOn ##ScriptOff ##Version
    ##Score ##LMode3 ##LMode2 ##LMode1 ##NotifyOn ##NotifyOff ##Pronouns ##A63_requesting_epistemic_sta
    ##A64_requesting_it_for ##A65_imploring_it_for ##A66_quizzing_it_about ##A67_informing_it_about ##A68_implicit_asking ##A69_implicit_telling ##A70_implicit_quizzing ##A71_implicit_informing
    ##A72_implicit_requesting ##A73_implicit_imploring ##A74_saying_hello_to ##A75_hailing ##A76_leavetaking ##A77_saying_goodbye_to ##A78_helping ##A79_asking_for_identificatio
    ##A80_questioning_motives ##A81_promising ##A82_calling_it_on ##A83_cold_calling_it_on ##A84_answering ##A85_picking_up ##A86_ending_a_call ##A87_hanging_up
    ##A88_signing_off_with ##A89_buying_it_with ##A90_pricing_it ##A91_accounting ##A92_attributing_it ##A93_exitstarting ##A94_exitstopping ##A95_exitlisting
    ##A96_exit_colouring ##A97_exit_symboling ##A98_choosing ##A99_looking_behind ##A100_printing_memories ##A101_remembering ##A102_discussing_it_with ##A103_discussing
    ##A104_frumping ##A105_helping_about_hyperspac ##A106_swiping_it_through ##A107_moving_it_with ##A108_howdeedoing ##A109_howdeedoing_someone ##A110_knocking_on ##A111_lensing;


Array ActionHappened --> 0 0 0 0 0 0 0 0;


[ InvSub ;
    return GenericVerbSub(131,132,133);
];
[ TakeSub ;
    return GenericVerbSub(134,135,136);
];
[ RemoveSub ;
    return GenericVerbSub(137,138,139);
];
[ DropSub ;
    return GenericVerbSub(140,141,142);
];
[ PutOnSub ;
    return GenericVerbSub(143,144,145);
];
[ InsertSub ;
    return GenericVerbSub(146,147,148);
];
[ EatSub ;
    return GenericVerbSub(149,150,151);
];
[ GoSub ;
    return GenericVerbSub(152,153,154);
];
[ EnterSub ;
    return GenericVerbSub(155,156,157);
];
[ ExitSub ;
    return GenericVerbSub(158,159,160);
];
[ GetOffSub ;
    return GenericVerbSub(161,162,163);
];
[ LookSub ;
    return GenericVerbSub(164,165,166);
];
[ ExamineSub ;
    return GenericVerbSub(167,168,169);
];
[ LookUnderSub ;
    return GenericVerbSub(170,171,172);
];
[ SearchSub ;
    return GenericVerbSub(173,174,175);
];
[ ConsultSub ;
    return GenericVerbSub(176,177,178);
];
[ LockSub ;
    return GenericVerbSub(179,180,181);
];
[ UnlockSub ;
    return GenericVerbSub(182,183,184);
];
[ SwitchOnSub ;
    return GenericVerbSub(185,186,187);
];
[ SwitchOffSub ;
    return GenericVerbSub(188,189,190);
];
[ OpenSub ;
    return GenericVerbSub(191,192,193);
];
[ CloseSub ;
    return GenericVerbSub(194,195,196);
];
[ WearSub ;
    return GenericVerbSub(197,198,199);
];
[ DisrobeSub ;
    return GenericVerbSub(200,201,202);
];
[ GiveSub ;
    return GenericVerbSub(203,204,205);
];
[ ShowSub ;
    return GenericVerbSub(206,207,208);
];
[ WakeOtherSub ;
    return GenericVerbSub(209,210,211);
];
[ ThrowAtSub ;
    return GenericVerbSub(212,213,214);
];
[ AttackSub ;
    return GenericVerbSub(215,216,217);
];
[ KissSub ;
    return GenericVerbSub(218,219,220);
];
[ AnswerSub ;
    return GenericVerbSub(221,222,223);
];
[ TellSub ;
    return GenericVerbSub(224,225,226);
];
[ AskSub ;
    return GenericVerbSub(227,228,229);
];
[ AskForSub ;
    return GenericVerbSub(230,231,232);
];
[ WaitSub ;
    return GenericVerbSub(233,234,235);
];
[ TouchSub ;
    return GenericVerbSub(236,237,238);
];
[ WaveSub ;
    return GenericVerbSub(239,240,241);
];
[ PullSub ;
    return GenericVerbSub(242,243,244);
];
[ PushSub ;
    return GenericVerbSub(245,246,247);
];
[ TurnSub ;
    return GenericVerbSub(248,249,250);
];
[ PushDirSub ;
    return GenericVerbSub(251,252,253);
];
[ SqueezeSub ;
    return GenericVerbSub(254,255,256);
];
[ YesSub ;
    return GenericVerbSub(257,258,259);
];
[ NoSub ;
    return GenericVerbSub(260,261,262);
];
[ CutSub ;
    return GenericVerbSub(263,264,265);
];
[ SorrySub ;
    return GenericVerbSub(266,267,268);
];
[ RubSub ;
    return GenericVerbSub(269,270,271);
];
[ BuySub ;
    return GenericVerbSub(272,273,274);
];
[ QuitSub ;
    return GenericVerbSub(275,276,277);
];
[ SaveSub ;
    return GenericVerbSub(278,279,280);
];
[ RestoreSub ;
    return GenericVerbSub(281,282,283);
];
[ RestartSub ;
    return GenericVerbSub(284,285,286);
];
[ VerifySub ;
    return GenericVerbSub(287,288,289);
];
[ ScriptOnSub ;
    return GenericVerbSub(290,291,292);
];
[ ScriptOffSub ;
    return GenericVerbSub(293,294,295);
];
[ VersionSub ;
    return GenericVerbSub(296,297,298);
];
[ ScoreSub ;
    return GenericVerbSub(299,300,301);
];
[ LMode3Sub ;
    return GenericVerbSub(302,303,304);
];
[ LMode2Sub ;
    return GenericVerbSub(305,306,307);
];
[ LMode1Sub ;
    return GenericVerbSub(308,309,310);
];
[ NotifyOnSub ;
    return GenericVerbSub(311,312,313);
];
[ NotifyOffSub ;
    return GenericVerbSub(314,315,316);
];
[ PronounsSub ;
    return GenericVerbSub(317,318,319);
];
[ A63_requesting_epistemic_staSub ;
    return GenericVerbSub(320,321,322);
];
[ A64_requesting_it_forSub ;
    return GenericVerbSub(323,324,325);
];
[ A65_imploring_it_forSub ;
    return GenericVerbSub(326,327,328);
];
[ A66_quizzing_it_aboutSub ;
    return GenericVerbSub(329,330,331);
];
[ A67_informing_it_aboutSub ;
    return GenericVerbSub(332,333,334);
];
[ A68_implicit_askingSub ;
    return GenericVerbSub(335,336,337);
];
[ A69_implicit_tellingSub ;
    return GenericVerbSub(338,339,340);
];
[ A70_implicit_quizzingSub ;
    return GenericVerbSub(341,342,343);
];
[ A71_implicit_informingSub ;
    return GenericVerbSub(344,345,346);
];
[ A72_implicit_requestingSub ;
    return GenericVerbSub(347,348,349);
];
[ A73_implicit_imploringSub ;
    return GenericVerbSub(350,351,352);
];
[ A74_saying_hello_toSub ;
    return GenericVerbSub(353,354,355);
];
[ A75_hailingSub ;
    return GenericVerbSub(356,357,358);
];
[ A76_leavetakingSub ;
    return GenericVerbSub(359,360,361);
];
[ A77_saying_goodbye_toSub ;
    return GenericVerbSub(362,363,364);
];
[ A78_helpingSub ;
    return GenericVerbSub(384,385,386);
];
[ A79_asking_for_identificatioSub ;
    return GenericVerbSub(387,388,389);
];
[ A80_questioning_motivesSub ;
    return GenericVerbSub(390,391,392);
];
[ A81_promisingSub ;
    return GenericVerbSub(393,394,395);
];
[ A82_calling_it_onSub ;
    return GenericVerbSub(413,414,415);
];
[ A83_cold_calling_it_onSub ;
    return GenericVerbSub(416,417,418);
];
[ A84_answeringSub ;
    return GenericVerbSub(419,420,421);
];
[ A85_picking_upSub ;
    return GenericVerbSub(422,423,424);
];
[ A86_ending_a_callSub ;
    return GenericVerbSub(425,426,427);
];
[ A87_hanging_upSub ;
    return GenericVerbSub(428,429,430);
];
[ A88_signing_off_withSub ;
    return GenericVerbSub(431,432,433);
];
[ A89_buying_it_withSub ;
    return GenericVerbSub(434,435,436);
];
[ A90_pricing_itSub ;
    return GenericVerbSub(437,438,439);
];
[ A91_accountingSub ;
    return GenericVerbSub(440,441,442);
];
[ A92_attributing_itSub ;
    return GenericVerbSub(443,444,445);
];
[ A93_exitstartingSub ;
    return GenericVerbSub(474,475,476);
];
[ A94_exitstoppingSub ;
    return GenericVerbSub(477,478,479);
];
[ A95_exitlistingSub ;
    return GenericVerbSub(480,481,482);
];
[ A96_exit_colouringSub ;
    return GenericVerbSub(483,484,485);
];
[ A97_exit_symbolingSub ;
    return GenericVerbSub(486,487,488);
];
[ A98_choosingSub ;
    return GenericVerbSub(492,493,494);
];
[ A99_looking_behindSub ;
    return GenericVerbSub(498,499,500);
];
[ A100_printing_memoriesSub ;
    return GenericVerbSub(501,502,503);
];
[ A101_rememberingSub ;
    return GenericVerbSub(504,505,506);
];
[ A102_discussing_it_withSub ;
    return GenericVerbSub(507,508,509);
];
[ A103_discussingSub ;
    return GenericVerbSub(510,511,512);
];
[ A104_frumpingSub ;
    return GenericVerbSub(524,525,526);
];
[ A105_helping_about_hyperspacSub ;
    return GenericVerbSub(527,528,529);
];
[ A106_swiping_it_throughSub ;
    return GenericVerbSub(552,553,554);
];
[ A107_moving_it_withSub ;
    return GenericVerbSub(555,556,557);
];
[ A108_howdeedoingSub ;
    return GenericVerbSub(558,559,560);
];
[ A109_howdeedoing_someoneSub ;
    return GenericVerbSub(561,562,563);
];
[ A110_knocking_onSub ;
    return GenericVerbSub(564,565,566);
];
[ A111_lensingSub ;
    return GenericVerbSub(573,574,575);
];

[ MistakeActionSub ;
    switch(understand_as_mistake_number) {
        default: "I didn't understand that sentence.";
    }
    say__p = 1;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Phrases
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! Definitions of rules in rulebooks


! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Startup (B0_startup)
! ----------------------------------------------------------------------------------------------------
! Rule 1/11: INITIALISE_MEMORY_R
!   === equally specific with ===
! Rule 2/11: VIRTUAL_MACHINE_STARTUP_R
!   === equally specific with ===
! Rule 3/11: SEED_RANDOM_NUMBER_GENERATOR_R
!   === equally specific with ===
! Rule 4/11: UPDATE_CHRONOLOGICAL_RECORDS_R
!   === equally specific with ===
! Rule 5/11 ! This is the declare everything initially unmentioned rule:
!   === equally specific with ===
! Rule 6/11: POSITION_PLAYER_IN_MODEL_R
!   === equally specific with ===
! Rule 7/11 ! This is the start in the correct scenes rule:
! --- now the mid-placed rules ---
! Rule 8/11 ! This is the when play begins stage rule:
!   === equally specific with ===
! Rule 9/11 ! This is the fix baseline scoring rule:
!   === equally specific with ===
! Rule 10/11 ! This is the display banner rule:
!   === equally specific with ===
! Rule 11/11 ! This is the initial room description rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! This is the declare everything initially unmentioned rule:
[ R_9 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (debug_rules) DB_Rule(R_9, 9);
    ! [2: repeat with item running through things]
    for (tmp_0=Prop_0(0), tmp_1=Prop_0(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_0(tmp_1))
    {! [3: now the item is not mentioned]
        (Adj_96_t3_v10(tmp_0));
        }
        rfalse;
];
! From the Standard Rules
! No specific request
! This is the start in the correct scenes rule:
[ R_10 ;
    if (debug_rules) DB_Rule(R_10, 10);
    ! [2: follow the scene changing rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(3));
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the when play begins stage rule:
[ R_11 ;
    if (debug_rules) DB_Rule(R_11, 11);
    ! [2: follow the when play begins rulebook]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(4));
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the fix baseline scoring rule:
[ R_12 ;
    if (debug_rules) DB_Rule(R_12, 12);
    ! [2: now the last notified score is the score]
    last_score = score;
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the display banner rule:
[ R_13 ;
    if (debug_rules) DB_Rule(R_13, 13);
    ! [2: say ~[banner text]~]
    say__p=1;! [3: banner text]
    ParaContent(); Banner(); .L_Say0; .L_SayX0;rfalse;
];
! From the Standard Rules
! No specific request
! This is the initial room description rule:
[ R_14 ;
    if (debug_rules) DB_Rule(R_14, 14);
    ! [2: try looking]
    TryAction(0, player, ##Look, 0, 0);
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Turn sequence (B1_turn_sequence)
! ----------------------------------------------------------------------------------------------------
! Rule 1/16: PARSE_COMMAND_R
!   === equally specific with ===
! Rule 2/16 ! This is the declare everything initially unmentioned rule:
!   === equally specific with ===
! Rule 3/16: GENERATE_ACTION_R
!   === equally specific with ===
! Rule 4/16 ! A first turn sequence rule:
!   === equally specific with ===
! Rule 5/16 ! This is the postponement rule:
!   === equally specific with ===
! Rule 6/16 ! A first turn sequence rule ( this is the every turn stage rule ):
! --- now the mid-placed rules ---
! Rule 7/16 ! This is the queue quips rule:
!   === equally specific with ===
! Rule 8/16 ! This is the ruling out quips rule:
!   >>> IV - Action requirement >>>
! Rule 9/16: TIMED_EVENTS_R
!   === equally specific with ===
! Rule 10/16: ADVANCE_TIME_R
!   === equally specific with ===
! Rule 11/16: UPDATE_CHRONOLOGICAL_RECORDS_R
! --- now the last-placed rules ---
! Rule 12/16 ! A last turn sequence rule:
!   === equally specific with ===
! Rule 13/16: ADJUST_LIGHT_R
!   === equally specific with ===
! Rule 14/16 ! This is the options paragraph stage rule:
!   === equally specific with ===
! Rule 15/16: NOTE_OBJECT_ACQUISITIONS_R
!   === equally specific with ===
! Rule 16/16 ! This is the notify score changes rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! A first turn sequence rule:
[ R_16 ;
    if (debug_rules) DB_Rule(R_16, 16);
    ! [2: follow the scene changing rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(3));
    rfalse;
];
! No specific request
! This is the postponement rule:
[ R_1457 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(3);
    BlkValueCreateOnStack(2, STORED_ACTION_TY);
    BlkValueCreateOnStack(1, STORED_ACTION_TY);
    BlkValueCreateOnStack(0, STORED_ACTION_TY);
    I7RBLK = KERNEL_0();
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(1);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_0 ;
    if (debug_rules) DB_Rule(R_1457, 1457);
    ! [2: if the postponed action is not waiting]
    if (((~~(( BlkValueCompare((Global_Vars-->79), TryAction(0, player, ##Wait, 0, 0, STORED_ACTION_TY_Current(I7SFRAME))) == 0)))))
    {! [3: silently try the postponed action]
        STORED_ACTION_TY_Try(BlkValueCopy((I7SFRAME+WORDSIZE), (Global_Vars-->79)), true);
        ! [4: now the postponed action is waiting]
        BlkValueCopy((Global_Vars-->79), TryAction(0, player, ##Wait, 0, 0, STORED_ACTION_TY_Current((I7SFRAME+WORDSIZE*2))));
        }
        rfalse;
];
! From the Standard Rules
! No specific request
! A first turn sequence rule ( this is the every turn stage rule ):
[ R_15 ;
    if (debug_rules) DB_Rule(R_15, 15);
    ! [2: follow the every turn rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(8));
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! This is the queue quips rule:
[ R_1206 ;
    if (debug_rules) DB_Rule(R_1206, 1206);
    ! [2: carry out the queueing quips following activity with the latest quip]
    CarryOutActivity(V47_queueing_quips_following, (Global_Vars-->44));
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! This is the ruling out quips rule:
[ R_1210 ;
    if (debug_rules) DB_Rule(R_1210, 1210);
    ! [2: carry out the ruling out quips following activity with the latest quip]
    CarryOutActivity(V48_ruling_out_quips_followi, (Global_Vars-->44));
    rfalse;
];
! From the Standard Rules
! No specific request
! A last turn sequence rule:
[ R_17 ;
    if (debug_rules) DB_Rule(R_17, 17);
    ! [2: follow the scene changing rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(3));
    rfalse;
];
! From "Options Paragraph" by Philip Riley
! No specific request
! This is the options paragraph stage rule:
[ R_1166 ;
    if (debug_rules) DB_Rule(R_1166, 1166);
    ! [2: carry out the printing the options paragraph activity]
    CarryOutActivity(V45_printing_the_options_par);
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the notify score changes rule:
[ R_18 ;
    if (debug_rules) DB_Rule(R_18, 18);
    ! [2: if the score is not the last notified score]
    if (((~~((score == last_score)))))
    {! [3: issue score notification message]
        NotifyTheScore();
        ! [4: now the last notified score is the score]
        last_score = score;
        }
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Shutdown (B2_shutdown)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! This is the when play ends stage rule:
! --- now the last-placed rules ---
! Rule 2/4: RESURRECT_PLAYER_IF_ASKED_R
!   === equally specific with ===
! Rule 3/4 ! This is the print player's obituary rule:
!   === equally specific with ===
! Rule 4/4: ASK_FINAL_QUESTION_R
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! This is the when play ends stage rule:
[ R_19 ;
    if (debug_rules) DB_Rule(R_19, 19);
    ! [2: follow the when play ends rulebook]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(5));
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the print player's obituary rule:
[ R_20 ;
    if (debug_rules) DB_Rule(R_20, 20);
    ! [2: carry out the printing the player's obituary activity]
    CarryOutActivity(V28_printing_the_player_s_ob);
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: When play begins (B4_when_play_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/9 ! When play begins:
!   === equally specific with ===
! Rule 2/9 ! When play begins:
!   === equally specific with ===
! Rule 3/9 ! When play begins:
!   === equally specific with ===
! Rule 4/9 ! When play begins:
!   === equally specific with ===
! Rule 5/9 ! When play begins:
!   === equally specific with ===
! Rule 6/9 ! When play begins:
!   === equally specific with ===
! Rule 7/9 ! When play begins ( this is the graphics window construction rule ):
!   === equally specific with ===
! Rule 8/9 ! When play begins:
!   === equally specific with ===
! Rule 9/9 ! When play begins:
! ----------------------------------------------------------------------------------------------------
! From "Conversation Framework" by Eric Eve
! No specific request
! When play begins:
[ R_829 ;
    if (debug_rules) DB_Rule(R_829, 829);
    ! [2: reset the interlocutor]
    (PHR_830_r1 ());
    rfalse;
];
! From "Essentials" by Philip Riley
! No specific request
! When play begins:
[ R_962 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (debug_rules) DB_Rule(R_962, 962);
    ! [2: repeat with s running through subjects]
    for (tmp_0=Prop_1(0), tmp_1=Prop_1(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_1(tmp_1))
    {! [3: move s to the room of subjects]
        MoveObject(tmp_0, I154_room_of_subjects, 0, false);
        }
        rfalse;
];
! From "PBR Common" by Philip Riley
! No specific request
! When play begins:
[ R_1058 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (debug_rules) DB_Rule(R_1058, 1058);
    ! [2: repeat with x running through objects]
    for (tmp_0=Prop_2(0), tmp_1=Prop_2(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_2(tmp_1))
    {! [3: carry out the initializing activity with x]
        CarryOutActivity(V42_initializing, tmp_0);
        }
        rfalse;
];
! From "Choices" by Philip Riley
! No specific request
! When play begins:
[ R_1172 ;
    if (debug_rules) DB_Rule(R_1172, 1172);
    ! [2: now all choices are in the room of choices]
    Prop_3();
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! When play begins:
[ R_1198 ;
    if (debug_rules) DB_Rule(R_1198, 1198);
    ! [2: now every quip is in the room of quips]
    Prop_4();
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! When play begins:
[ R_1208 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(3);
    BlkValueCreateOnStack(2, KD1_list_of_quips);
    BlkValueCreateOnStack(1, KD1_list_of_quips);
    BlkValueCreateOnStack(0, KD8_list_of_people);
    I7RBLK = KERNEL_1();
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(1);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_1 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value: number
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    ;
    if (debug_rules) DB_Rule(R_1208, 1208);
    ! [2: repeat with p running through the list of all people]
    for (tmp_2=(Prop_5(I7SFRAME,10)), tmp_1=1, tmp_0=LIST_OF_TY_GetItem(tmp_2, tmp_1, true): tmp_1<=LIST_OF_TY_GetLength(tmp_2): tmp_1++, tmp_0=LIST_OF_TY_GetItem(tmp_2, tmp_1, true))
    {! [3: let x be the list of quips that stock p]
        tmp_3 = (I7SFRAME+WORDSIZE); 
        		BlkValueCopy(tmp_3, (Prop_6(tmp_0,(I7SFRAME+WORDSIZE*2),10)));
        ! [4: add x to the queue of p]
        LIST_OF_TY_AppendList(GProperty(10, tmp_0,p29_queue), tmp_3, 0, 0, 0);
        }
        rfalse;
];
! From "Image Strip" by Philip Riley
! No specific request
! When play begins ( this is the graphics window construction rule ):
[ R_1315 ;
    if (debug_rules) DB_Rule(R_1315, 1315);
    ! [2: if glulx graphics is supported]
    if ((( glk_gestalt(gestalt_Graphics, 0) )))
    {! [3: build graphics window]
        MakeGraphicsWindow();
        	    MakeGraphicsWindowHidewin();
        ! [4: follow the current graphics drawing rule]
        FollowRulebook((Global_Vars-->70));
        }
        rfalse;
];
! No specific request
! When play begins:
[ R_1439 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (debug_rules) DB_Rule(R_1439, 1439);
    ! [2: now the story viewpoint is third person singular]
    story_viewpoint = I120_third_person_singular;
    ! [3: repeat with s running through subjects]
    for (tmp_0=Prop_7(0), tmp_1=Prop_7(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_7(tmp_1))
    {! [4: move s to the room of subjects]
        MoveObject(tmp_0, I154_room_of_subjects, 0, false);
        }
    ! [5: say ~[bold type]Department of Homeland Security, Washington, DC[roman type][line break]~]
    say__p=1;! [6: bold type]
    ParaContent(); (PHR_352_r2 ());! [7: ~Department of Homeland Security, Washington, DC~]
    ParaContent(); print "Department of Homeland Security, Washington, DC";! [8: roman type]
    ParaContent(); (PHR_354_r3 ());! [9: line break]
    ParaContent(); new_line; .L_Say1; .L_SayX1;! [10: say ~Open on a drab office with decor dating to the mid-eighties. The DHS assistant to the associate sub-director looks longingly at the office clock nearing five, then leans across the desk and impatiently states his demands:[paragraph break]~]
    say__p=1;! [11: ~Open on a drab office with decor dating to the mid-eighties. The DHS assistant to the associate sub-director looks longingly at the office clock nearing five, then leans across the desk and impatiently states his demands:~]
    ParaContent(); print "Open on a drab office with decor dating to the mid-eighties. The DHS assistant to the associate sub-director looks longingly at the office clock nearing five, then leans across the desk and impatiently states his demands:";! [12: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say2; .L_SayX2;! [13: say ~'First name, last name, pronouns?'[paragraph break]~]
    say__p=1;! [14: ~'First name, last name, pronouns?'~]
    ParaContent(); print "~First name, last name, pronouns?~";! [15: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say3; .L_SayX3;! [16: say ~(1) Ezra Gaunt (he/him), winner of the 2006 Baltimore County Edgar Allan Poe Trivia Competition;[paragraph break]~]
    say__p=1;! [17: ~(1) Ezra Gaunt (he/him), winner of the 2006 Baltimore County Edgar Allan Poe Trivia Competition;~]
    ParaContent(); print "(1) Ezra Gaunt (he/him), winner of the 2006 Baltimore County Edgar Allan Poe Trivia Competition;";! [18: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say4; .L_SayX4;! [19: say ~(2) Petula Clark Goldberg (she/her), former award-winning dog groomer of the avant-garde school;[paragraph break]~]
    say__p=1;! [20: ~(2) Petula Clark Goldberg (she/her), former award-winning dog groomer of the avant-garde school;~]
    ParaContent(); print "(2) Petula Clark Goldberg (she/her), former award-winning dog groomer of the avant-garde school;";! [21: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say5; .L_SayX5;! [22: say ~or (3) Larch Faraji (they/them), lead singer of the third wave neo-old-school punk band DC Trash.~]
    say__p=1;! [23: ~or (3) Larch Faraji (they/them), lead singer of the third wave neo-old-school punk band DC Trash.~]
    ParaContent(); print "or (3) Larch Faraji (they/them), lead singer of the third wave neo-old-school punk band DC Trash."; new_line; .L_Say6; .L_SayX6;! [24: now current play mode is picking character]
    (Global_Vars-->75) = I410_picking_character;
    ! [25: follow the current graphics drawing rule]
    FollowRulebook((Global_Vars-->70));
    ! [26: if debug is false]
    if (((((Global_Vars-->16) && true) == (0 && true))))
    {! [27: now the command prompt is ~1, 2, or 3? > ~]
        BlkValueCopy((Global_Vars-->1), TX_L_474);
        ! [28: now current play mode is picking character]
        (Global_Vars-->75) = I410_picking_character;
        } else {
        ! [29: now player's forename is ~Larch~]
        BlkValueCopy((Global_Vars-->76), TX_L_475);
        ! [30: now player's full name is ~Larch Faraji~]
        BlkValueCopy((Global_Vars-->77), TX_L_290);
        ! [31: now player's surname is ~Faraji~]
        BlkValueCopy((Global_Vars-->20), TX_L_476);
        ! [32: now the player is larch faraji]
        ChangePlayer(I406_larch_faraji);
        ! [33: init player]
        (PHR_1441_r4 ());
        ! [34: init office]
        (PHR_1485_r5 ());
        ! [35: move the player to the strip mall parking lot south]
        MoveObject(player, I294_strip_mall_parking_lot_, 0, false);
        ! [36: try unknown voice calling the blue flipphone on mysterious phone]
        TryAction(0, I498_unknown_voice, ##A82_calling_it_on, I432_blue_flipphone, I499_mysterious_phone);
        ! [37: move klimp to the room of stuff]
        MoveObject(I419_chief_huffton_klimp, I357_room_of_stuff, 0, false);
        ! [38: move moira to the room of stuff]
        MoveObject(I427_moira_zin, I357_room_of_stuff, 0, false);
        ! [39: now the current play mode is _normal]
        (Global_Vars-->75) = I409__normal;
        ! [40: set possessives]
        (PHR_1442_r6 ());
        }
        rfalse;
];
! No specific request
! When play begins:
[ R_1489 ;
    if (debug_rules) DB_Rule(R_1489, 1489);
    ! [2: now margaret carries the white key]
    MoveObject(I446_white_key,I358_margaret_chao);
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: When scene begins (B6_when_scene_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When a scene ( called the event ) begins ( this is the scene description text rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! When a scene ( called the event ) begins ( this is the scene description text rule ):
[ R_65 
    tmp_0 ! Let/loop value, e.g., 'event': scene
    ;
    if ((((tmp_0 = parameter_value, (((true) && (tmp_0=(parameter_value), true))))) || (tmp_0 = I84_entire_game,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_65, 65);
    ! [2: if the description of the event is not ~~]
    if (((~~(( BlkValueCompare(GProperty(SCENE_TY, tmp_0,description), EMPTY_TEXT_VALUE) == 0)))))
    {! [3: say ~[description of the event][paragraph break]~]
        say__p=1;! [4: description of the event]
        ParaContent(); @push self; print (TEXT_TY_Say) GProperty(SCENE_TY, self=tmp_0,description);@pull self; ! [5: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say7; .L_SayX7;}
        } else if (debug_rules > 1) DB_Rule(R_65, 65, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Every turn (B8_every_turn)
! ----------------------------------------------------------------------------------------------------
! Rule 1/10 ! Every turn when player is calling something ( called P ) and player is talking with nobody:
!   >>> I - Number of aspects constrained >>>
! Rule 2/10 ! Every turn ( this is the reset protocol rule ):
!   === equally specific with ===
! Rule 3/10 ! Every turn:
!   === equally specific with ===
! Rule 4/10 ! Every turn:
!   === equally specific with ===
! Rule 5/10 ! Every turn ( this is the run behavior rule ):
!   === equally specific with ===
! Rule 6/10 ! Every turn:
!   === equally specific with ===
! Rule 7/10 ! Every turn ( this is the autolock countdown rule ):
!   === equally specific with ===
! Rule 8/10 ! Every turn ( this is the autoclose countdown rule ):
!   === equally specific with ===
! Rule 9/10 ! Every turn:
!   === equally specific with ===
! Rule 10/10 ! Every turn:
! ----------------------------------------------------------------------------------------------------
! From "Phones" by Philip Riley
! No specific request
! Every turn when player is calling something ( called P ) and player is talking with nobody:
[ R_1002 
    tmp_0 ! Let/loop value, e.g., 'P': thing
    ;
    if ((((((((RGuard_f1_5(player)) ofclass K20_phone) && (tmp_0=((RGuard_f1_5(player))), true))) && ((((Prop_8())))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1002, 1002);
    ! [2: say ~[We] [are] calling [P]. The other phone is ringing.~]
    say__p=1;! [3: we]
    ParaContent(); (PHR_764_r7 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ calling ~]
    ParaContent(); print " calling ";! [7: p]
    ParaContent(); PrintShortName(tmp_0);! [8: ~. The other phone is ringing.~]
    ParaContent(); print ". The other phone is ringing."; new_line; .L_Say8; .L_SayX8;} else if (debug_rules > 1) DB_Rule(R_1002, 1002, 'context');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Every turn ( this is the reset protocol rule ):
[ R_839 ;
    if (debug_rules) DB_Rule(R_839, 839);
    ! [2: now the farewell type is explicit]
    (Global_Vars-->13) = I130_explicit;
    ! [3: now the greeting type is explicit]
    (Global_Vars-->12) = I130_explicit;
    rfalse;
];
! From "Hearing" by Philip Riley
! No specific request
! Every turn:
[ R_981 ;
    if (debug_rules) DB_Rule(R_981, 981);
    ! [2: if skip sounds this turn is false]
    if (((((Global_Vars-->17) && true) == (0 && true))))
    {! [3: remove audible sounds from audible sounds]
        LIST_OF_TY_Remove_List((Global_Vars-->18), (Global_Vars-->18), 0);
        ! [4: carry out the printing insistent sounds activity]
        CarryOutActivity(V35_printing_insistent_sound);
        }
        rfalse;
];
! From "Phones" by Philip Riley
! No specific request
! Every turn:
[ R_997 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (debug_rules) DB_Rule(R_997, 997);
    ! [2: repeat with p running through people who are talking with someone]
    for (tmp_0=Prop_9(0), tmp_1=Prop_9(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_9(tmp_1))
    {! [3: if location of p is not nothing]
        if (((~~((LocationOf(tmp_0) == nothing)))))
        {! [4: if reception of location of p is false]
            if ((((GProperty(10, LocationOf(tmp_0),p18_reception) && true) == (0 && true))))
            {! [5: break connection of p]
                (PHR_996_r8 (tmp_0));
                }
                }
                }
                rfalse;
];
! From "Real People" by Philip Riley
! No specific request
! Every turn ( this is the run behavior rule ):
[ R_1045 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (debug_rules) DB_Rule(R_1045, 1045);
    ! [2: repeat with p running through people who are not the player]
    for (tmp_0=Prop_10(0), tmp_1=Prop_10(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_10(tmp_1))
    {! [3: carry out the acting as activity with p]
        CarryOutActivity(V40_acting_as, tmp_0);
        }
        rfalse;
];
! From "Memories" by Philip Riley
! No specific request
! Every turn:
[ R_1190 ;
    if (debug_rules) DB_Rule(R_1190, 1190);
    ! [2: if memory queue is not empty]
    if (((~~(((Adj_17_t1_v34((Global_Vars-->42))))))))
    {! [3: say ~[italic type][We] can remember [memory queue].[roman type][line break]~]
        say__p=1;! [4: italic type]
        ParaContent(); (PHR_353_r9 ());! [5: we]
        ParaContent(); (PHR_764_r7 ());! [6: ~ can remember ~]
        ParaContent(); print " can remember ";! [7: memory queue]
        ParaContent(); LIST_OF_TY_Say((Global_Vars-->42));! [8: ~.~]
        ParaContent(); print ".";! [9: roman type]
        ParaContent(); (PHR_354_r3 ());! [10: line break]
        ParaContent(); new_line; .L_Say9; .L_SayX9;! [11: truncate memory queue to 0 entries]
        LIST_OF_TY_SetLength((Global_Vars-->42), 0, -1, 1);
        }
        rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Every turn ( this is the autolock countdown rule ):
[ R_1374 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (debug_rules) DB_Rule(R_1374, 1374);
    ! [2: repeat with tsd running through two-sided doors]
    for (tmp_0=Prop_11(0), tmp_1=Prop_11(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_11(tmp_1))
    {! [3: if tsd is closed]
        if ((((Adj_102_t1_v10(tmp_0)))))
        {! [4: if the lock countdown of tsd is 0]
            if (((GProperty(10, tmp_0,p36_lock_countdown) == 0)))
            {! [5: autolock tsd]
                (PHR_1373_r10 (tmp_0));
                ! [6: now the lock countdown of tsd is -1]
                WriteGProperty(10, tmp_0,p36_lock_countdown,-1);
                } else {
                ! [7: if the lock countdown of tsd > 0]
                if (((GProperty(10, tmp_0,p36_lock_countdown) > 0)))
                {! [8: decrement lock countdown of tsd]
                    WriteGProperty(10, tmp_0,p36_lock_countdown,GProperty(10, tmp_0,p36_lock_countdown) - 1);;
                    }
                    }
                    }
                    }
                    rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Every turn ( this is the autoclose countdown rule ):
[ R_1377 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (debug_rules) DB_Rule(R_1377, 1377);
    ! [2: repeat with tsd running through two-sided doors]
    for (tmp_0=Prop_12(0), tmp_1=Prop_12(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_12(tmp_1))
    {! [3: if the close countdown of tsd is 0]
        if (((GProperty(10, tmp_0,p37_close_countdown) == 0)))
        {! [4: autoclose tsd]
            (PHR_1376_r11 (tmp_0));
            ! [5: now the close countdown of tsd is -1]
            WriteGProperty(10, tmp_0,p37_close_countdown,-1);
            } else {
            ! [6: if the close countdown of tsd > 0]
            if (((GProperty(10, tmp_0,p37_close_countdown) > 0)))
            {! [7: decrement close countdown of tsd]
                WriteGProperty(10, tmp_0,p37_close_countdown,GProperty(10, tmp_0,p37_close_countdown) - 1);;
                }
                }
                }
                rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! Every turn:
[ R_1414 ;
    if (debug_rules) DB_Rule(R_1414, 1414);
    ! [2: if the location is fluorescent-lit and the player is wearing the astral lenses and not in darkness]
    if (((((Adj_62_t1_v10(real_location))))) && ((((player == WearerOf(I426_astral_lenses)))) && ((~~((((location==thedark))))))))
    {! [3: say ~Wearing the astral lenses in fluorescent light is blinding. [We] quickly [remove] the glasses.~]
        say__p=1;! [4: ~Wearing the astral lenses in fluorescent light is blinding. ~]
        ParaContent(); print "Wearing the astral lenses in fluorescent light is blinding. ";! [5: we]
        ParaContent(); (PHR_764_r7 ());! [6: ~ quickly ~]
        ParaContent(); print " quickly ";! [7: remove]
        ConjugateVerb_101(CV_POS, PNToVP(), story_tense); say__p=1; ! [8: ~ the glasses.~]
        ParaContent(); print " the glasses."; new_line; .L_Say10; .L_SayX10;! [9: now the hyperlight is unlit]
        (Adj_83_t2_v10(I218_hyperlight));
        ! [10: now the player carries the astral lenses]
        MoveObject(I426_astral_lenses,player);
        }
        rfalse;
];
! No specific request
! Every turn:
[ R_1509 
    tmp_0 ! Let/loop value, e.g., 'P': person
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    tmp_4 ! Let/loop value: number
    tmp_5 ! Let/loop value: number
    ;
    if (debug_rules) DB_Rule(R_1509, 1509);
    ! [2: follow the current graphics drawing rule]
    FollowRulebook((Global_Vars-->70));
    ! [3: if the player is talking with someone ( called p )]
    if ((((Prop_13() && (tmp_0=deferred_calling_list-->0, true)) || (tmp_0 = 0,false))))
    {! [4: if the portrait of p is listed in characters]
        if (((LIST_OF_TY_FindItem((Global_Vars-->81), GProperty(10, tmp_0,p49_portrait)))))
        {! [5: let local count be 0]

            		tmp_1 = 0;
            ! [6: repeat with c running through characters]
            for (tmp_4=(Global_Vars-->81), tmp_3=1, tmp_2=LIST_OF_TY_GetItem(tmp_4, tmp_3, true): tmp_3<=LIST_OF_TY_GetLength(tmp_4): tmp_3++, tmp_2=LIST_OF_TY_GetItem(tmp_4, tmp_3, true))
            {! [7: increment local count]
                tmp_1 = tmp_1 + 1;;
                ! [8: if c is the portrait of p]
                if (((tmp_2 == GProperty(10, tmp_0,p49_portrait))))
                {! [9: now handset count is local count]
                    (Global_Vars-->82) = tmp_1;
                    ! [10: draw phone handset]
                    DrawPhoneHandset();
                    }
                    }
                    }
                    }
    ! [11: if the current interlocutor is something]
    if ((((Global_Vars-->11) ofclass K2_thing)))
    {! [12: let local count be 0]

        		tmp_1 = 0;
        ! [13: repeat with c running through characters]
        for (tmp_5=(Global_Vars-->81), tmp_3=1, tmp_2=LIST_OF_TY_GetItem(tmp_5, tmp_3, true): tmp_3<=LIST_OF_TY_GetLength(tmp_5): tmp_3++, tmp_2=LIST_OF_TY_GetItem(tmp_5, tmp_3, true))
        {! [14: increment local count]
            tmp_1 = tmp_1 + 1;;
            ! [15: if c is the portrait of current interlocutor]
            if (((tmp_2 == GProperty(OBJECT_TY, (Global_Vars-->11),p49_portrait))))
            {! [16: now bubble count is local count]
                (Global_Vars-->83) = tmp_1;
                }
                }
        ! [17: draw speech bubble]
        DrawSpeechBubble();
        }
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Action-processing (B9_action_processing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/11 ! This is the announce items from multiple object lists rule:
!   === equally specific with ===
! Rule 2/11 ! This is the set pronouns from items from multiple object lists rule:
!   === equally specific with ===
! Rule 3/11 ! This is the before stage rule:
! --- now the mid-placed rules ---
! Rule 4/11: BASIC_VISIBILITY_R
!   === equally specific with ===
! Rule 5/11: BASIC_ACCESSIBILITY_R
!   === equally specific with ===
! Rule 6/11: CARRYING_REQUIREMENTS_R
! --- now the last-placed rules ---
! Rule 7/11 ! This is the instead stage rule:
!   === equally specific with ===
! Rule 8/11: REQUESTED_ACTIONS_REQUIRE_R
!   === equally specific with ===
! Rule 9/11: CARRY_OUT_REQUESTED_ACTIONS_R
!   === equally specific with ===
! Rule 10/11: DESCEND_TO_SPECIFIC_ACTION_R
!   === equally specific with ===
! Rule 11/11 ! This is the end action-processing in success rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! This is the announce items from multiple object lists rule:
[ R_22 ;
    if (debug_rules) DB_Rule(R_22, 22);
    ! [2: if the current item from the multiple object list is not nothing]
    if (((~~((multiple_object_item == nothing)))))
    {! [3: say ~[current item from the multiple object list]: [run paragraph on]~ ( a )]
        say__p=1;! [4: ~[current item from the multiple object list]: [run paragraph on]~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_134); .L_Say11; .L_SayX11;}
        rfalse;
];
! From the Standard Rules
! No specific request
! This is the set pronouns from items from multiple object lists rule:
[ R_21 ;
    if (debug_rules) DB_Rule(R_21, 21);
    ! [2: if the current item from the multiple object list is not nothing]
    if (((~~((multiple_object_item == nothing)))))
    {! [3: set pronouns from the current item from the multiple object list]
        PronounNotice(multiple_object_item);
        }
        rfalse;
];
! From the Standard Rules
! No specific request
! This is the before stage rule:
[ R_23 ;
    if (debug_rules) DB_Rule(R_23, 23);
    ! [2: abide by the before rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(19))) rtrue;
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the instead stage rule:
[ R_24 ;
    if (debug_rules) DB_Rule(R_24, 24);
    ! [2: abide by the instead rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(20))) rtrue;
    rfalse;
];
! From the Standard Rules
! No specific request
! This is the end action-processing in success rule:
[ R_25 ;
    if (debug_rules) DB_Rule(R_25, 25);
    ! [2: rule succeeds]
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Setting action variables (B10_setting_action_variables)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Rule for setting action variables for going ( this is the standard set going variables rule ):
!   === equally specific with ===
! Rule 2/3 ! Setting action variables for exiting:
!   === equally specific with ===
! Rule 3/3 ! Setting action variables for looking ( this is the determine visibility ceiling rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Rule for setting action variables for going ( this is the standard set going variables rule ):
[ R_149 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_2();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_2 
    tmp_0 ! Let/loop value, e.g., 'carriage': vehicle
    tmp_1 ! Let/loop value, e.g., 'target': object
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((action ==##Go)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_149, 149);
    ! [2: now the thing gone with is the item-pushed-between-rooms]
    (MStack-->MstVO(20007,4)) = move_pushing;
    ! [3: now the room gone from is the location of the actor]
    (MStack-->MstVO(20007,0)) = LocationOf(actor);
    ! [4: if the actor is in an enterable vehicle ( called the carriage )]
    if (((ContainerOf(actor) ofclass K15_vehicle) && ((Adj_98_t1_v10(ContainerOf(actor)))) && (tmp_0=(ContainerOf(actor)), true)))
    {! [5: now the vehicle gone by is the carriage]
        (MStack-->MstVO(20007,3)) = tmp_0;
        }
    ! [6: let the target be nothing]

    		tmp_1 = nothing;
    ! [7: if the noun is a direction]
    if (((noun ofclass K3_direction)))
    {! [8: let direction d be the noun]

        		tmp_2 = noun;
        ! [9: let the target be the room-or-door direction d from the room gone from]
        tmp_1 = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par0 ofclass K3_direction) && (formal_par0 ofclass K3_direction))))) && ((
                        formal_rv = RoomOrDoorFrom(formal_par1,formal_par0)) | 1)
                        )|| (ArgumentTypeFailed(2287, 1))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = (MStack-->MstVO(20007,0))) +
                    (formal_par0 = tmp_2)
                    ))
            )

        ! Resolution complete
        ;
        } else {
        ! [10: if the noun is a door]
        if (((noun ofclass K4_door)))
        {! [11: let the target be the noun]
            tmp_1 = noun;
            }
            }
    ! [12: if the target is a door]
    if (((tmp_1 ofclass K4_door)))
    {! [13: now the door gone through is the target]
        (MStack-->MstVO(20007,2)) = tmp_1;
        ! [14: now the target is the other side of the target from the room gone from]
        tmp_1 = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par0 ofclass K4_door) && (formal_par0 ofclass K4_door))))) && ((
                        formal_rv = OtherSideOfDoor(formal_par0,formal_par1)) | 1)
                        )|| (ArgumentTypeFailed(2292, 1))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = (MStack-->MstVO(20007,0))) +
                    (formal_par0 = tmp_1)
                    ))
            )

        ! Resolution complete
        ;
        }
    ! [15: now the room gone to is the target]
    (MStack-->MstVO(20007,1)) = tmp_1;
    } else if (debug_rules > 1) DB_Rule(R_149, 149, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Setting action variables for exiting:
[ R_172 ;
    if ((((action ==##Exit)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_172, 172);
    ! [2: now the container exited from is the holder of the actor]
    (MStack-->MstVO(20009,0)) = (HolderOf(actor));
    } else if (debug_rules > 1) DB_Rule(R_172, 172, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Setting action variables for looking ( this is the determine visibility ceiling rule ):
[ R_184 ;
    if ((((action ==##Look)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_184, 184);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: calculate visibility ceiling at low level]
        FindVisibilityLevels();
        }
    ! [4: now the visibility level count is the visibility ceiling count calculated]
    (MStack-->MstVO(20011,2)) = visibility_levels;
    ! [5: now the visibility ceiling is the visibility ceiling calculated]
    (MStack-->MstVO(20011,3)) = visibility_ceiling;
    ! [6: now the room-describing action is the looking action]
    (MStack-->MstVO(20011,0)) = ##Look;
    } else if (debug_rules > 1) DB_Rule(R_184, 184, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: specific action-processing (B11_specific_action_processi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/8: WORK_OUT_DETAILS_OF_SPECIFIC_R
! --- now the mid-placed rules ---
! Rule 2/8 ! A specific action-processing rule ( this is the investigate player's awareness before action rule ):
!   === equally specific with ===
! Rule 3/8 ! A specific action-processing rule ( this is the check stage rule ):
!   === equally specific with ===
! Rule 4/8 ! A specific action-processing rule ( this is the carry out stage rule ):
!   === equally specific with ===
! Rule 5/8 ! A specific action-processing rule ( this is the after stage rule ):
!   === equally specific with ===
! Rule 6/8 ! A specific action-processing rule ( this is the investigate player's awareness after action rule ):
!   === equally specific with ===
! Rule 7/8 ! A specific action-processing rule ( this is the report stage rule ):
! --- now the last-placed rules ---
! Rule 8/8 ! The last specific action-processing rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! A specific action-processing rule ( this is the investigate player's awareness before action rule ):
[ R_26 ;
    if (debug_rules) DB_Rule(R_26, 26);
    ! [2: follow the player's action awareness rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(12));
    ! [3: if rule succeeded]
    if (((RulebookSucceeded())))
    {! [4: now within the player's sight is true]
        (MStack-->MstVO(11,5)) = 1;
        } else {
        ! [5: now within the player's sight is false]
        (MStack-->MstVO(11,5)) = 0;
        }
        rfalse;
];
! From the Standard Rules
! No specific request
! A specific action-processing rule ( this is the check stage rule ):
[ R_27 ;
    if (debug_rules) DB_Rule(R_27, 27);
    ! [2: anonymously abide by the specific check rulebook]
    if (temporary_value = FollowRulebook(RULEBOOK_TY_to_RULE_TY((MStack-->MstVO(11,2))))) {
    		if (RulebookSucceeded()) ActRulebookSucceeds(temporary_value);
    		else ActRulebookFails(temporary_value);
    		return 2;
    	}
    rfalse;
];
! From the Standard Rules
! No specific request
! A specific action-processing rule ( this is the carry out stage rule ):
[ R_28 ;
    if (debug_rules) DB_Rule(R_28, 28);
    ! [2: follow the specific carry out rulebook]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY((MStack-->MstVO(11,3))));
    rfalse;
];
! From the Standard Rules
! No specific request
! A specific action-processing rule ( this is the after stage rule ):
[ R_29 ;
    if (debug_rules) DB_Rule(R_29, 29);
    ! [2: if action in world is true]
    if (((((MStack-->MstVO(11,0)) && true) == (1 && true))))
    {! [3: abide by the after rules]
        if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(23))) rtrue;
        }
        rfalse;
];
! From the Standard Rules
! No specific request
! A specific action-processing rule ( this is the investigate player's awareness after action rule ):
[ R_30 ;
    if (debug_rules) DB_Rule(R_30, 30);
    ! [2: if within the player's sight is false]
    if (((((MStack-->MstVO(11,5)) && true) == (0 && true))))
    {! [3: follow the player's action awareness rules]
        FollowRulebook(RULEBOOK_TY_to_RULE_TY(12));
        ! [4: if rule succeeded]
        if (((RulebookSucceeded())))
        {! [5: now within the player's sight is true]
            (MStack-->MstVO(11,5)) = 1;
            }
            }
            rfalse;
];
! From the Standard Rules
! No specific request
! A specific action-processing rule ( this is the report stage rule ):
[ R_31 ;
    if (debug_rules) DB_Rule(R_31, 31);
    ! [2: if within the player's sight is true and action keeping silent is false]
    if ((((((MStack-->MstVO(11,5)) && true) == (1 && true)))) && (((((MStack-->MstVO(11,1)) && true) == (0 && true)))))
    {! [3: follow the specific report rulebook]
        FollowRulebook(RULEBOOK_TY_to_RULE_TY((MStack-->MstVO(11,4))));
        }
        rfalse;
];
! From the Standard Rules
! No specific request
! The last specific action-processing rule:
[ R_32 ;
    if (debug_rules) DB_Rule(R_32, 32);
    ! [2: rule succeeds]
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: player's action awareness (B12_player_s_action_awarenes)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! A player's action awareness rule ( this is the player aware of his own actions rule ):
!   === equally specific with ===
! Rule 2/4 ! A player's action awareness rule ( this is the player aware of actions by visible actors rule ):
!   === equally specific with ===
! Rule 3/4 ! A player's action awareness rule ( this is the player aware of actions on visible nouns rule ):
!   === equally specific with ===
! Rule 4/4 ! A player's action awareness rule ( this is the player aware of actions on visible second nouns rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! A player's action awareness rule ( this is the player aware of his own actions rule ):
[ R_33 ;
    if (debug_rules) DB_Rule(R_33, 33);
    ! [2: if the player is the actor]
    if (((player == actor)))
    {! [3: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
        rfalse;
];
! From the Standard Rules
! No specific request
! A player's action awareness rule ( this is the player aware of actions by visible actors rule ):
[ R_34 ;
    if (debug_rules) DB_Rule(R_34, 34);
    ! [2: if the player is not the actor and the player can see the actor]
    if ((((~~((player == actor))))) && (((TestVisibility(player,actor)))))
    {! [3: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
        rfalse;
];
! From the Standard Rules
! No specific request
! A player's action awareness rule ( this is the player aware of actions on visible nouns rule ):
[ R_35 ;
    if (debug_rules) DB_Rule(R_35, 35);
    ! [2: if the noun is a thing and the player can see the noun]
    if ((((noun ofclass K2_thing))) && (((TestVisibility(player,noun)))))
    {! [3: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
        rfalse;
];
! From the Standard Rules
! No specific request
! A player's action awareness rule ( this is the player aware of actions on visible second nouns rule ):
[ R_36 ;
    if (debug_rules) DB_Rule(R_36, 36);
    ! [2: if the second noun is a thing and the player can see the second noun]
    if ((((second ofclass K2_thing))) && (((TestVisibility(player,second)))))
    {! [3: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Reaching inside (B14_reaching_inside)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! A rule for reaching inside the room of choices:
!   === equally specific with ===
! Rule 2/5 ! rule for reaching inside the room of quips:
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 3/5 ! A rule for reaching inside a room ( called R ) ( this is the long-distance speaking rule ):
! --- now the last-placed rules ---
! Rule 4/5: CANT_REACH_INSIDE_ROOMS_R
!   === equally specific with ===
! Rule 5/5: CANT_REACH_INSIDE_CLOSED_R
! ----------------------------------------------------------------------------------------------------
! From "Choices" by Philip Riley
! No specific request
! A rule for reaching inside the room of choices:
[ R_1173 ;
    if (((((parameter_value == I216_room_of_choices) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1173, 1173);
    ! [2: allow access]
    RulebookSucceeds(22, RBNO_0); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1173, 1173, 'action');
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! rule for reaching inside the room of quips:
[ R_1200 ;
    if (((((parameter_value == I231_room_of_quips) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1200, 1200);
    ! [2: allow access]
    RulebookSucceeds(22, RBNO_0); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1200, 1200, 'action');
    rfalse;
];
! From "Phones" by Philip Riley
! No specific request
! A rule for reaching inside a room ( called R ) ( this is the long-distance speaking rule ):
[ R_1029 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K1_room) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1029, 1029);
    ! [2: if the current interlocutor is enclosed by r]
    if (((IndirectlyContains(tmp_0,(Global_Vars-->11)))))
    {! [3: if the current interlocutor is talking with the player]
        if ((((RGuard_T_4((Global_Vars-->11),player)))))
        {! [4: allow access]
            RulebookSucceeds(22, RBNO_0); rtrue;

            }
            }
            } else if (debug_rules > 1) DB_Rule(R_1029, 1029, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Visibility (B16_visibility)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last visibility rule ( this is the can't act in the dark rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! The last visibility rule ( this is the can't act in the dark rule ):
[ R_37 ;
    if (debug_rules) DB_Rule(R_37, 37);
    ! [2: if in darkness]
    if (((location==thedark)))
    {! [3: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Persuasion (B17_persuasion)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Persuasion rule for asking people to try hailing ( this is the allow hailing rule ):
!   === equally specific with ===
! Rule 2/3 ! Persuasion rule for asking people to try leavetaking ( this is the alllow leavetaking rule ):
!   === equally specific with ===
! Rule 3/3 ! Persuasion rule for asking people to try howdeedoing:
! ----------------------------------------------------------------------------------------------------
! From "Conversation Framework" by Eric Eve
! No specific request
! Persuasion rule for asking people to try hailing ( this is the allow hailing rule ):
[ R_828 ;
    if ((((action ==##A75_hailing) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_828, 828);
    ! [2: persuasion succeeds]
    RulebookSucceeds(22, RBNO_4); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_828, 828, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Persuasion rule for asking people to try leavetaking ( this is the alllow leavetaking rule ):
[ R_835 ;
    if ((((action ==##A76_leavetaking) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_835, 835);
    ! [2: persuasion succeeds]
    RulebookSucceeds(22, RBNO_4); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_835, 835, 'action');
    rfalse;
];
! From "Conversations General" by Philip Riley
! No specific request
! Persuasion rule for asking people to try howdeedoing:
[ R_1419 ;
    if ((((action ==##A108_howdeedoing) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1419, 1419);
    ! [2: try howdeedoing]
    TryAction(0, player, ##A108_howdeedoing, 0, 0);
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1419, 1419, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Before (B19_before)
! ----------------------------------------------------------------------------------------------------
! Rule 1/17 ! Before showing something to someone when the second noun is not the current interlocutor ( this is the showing needs an interlocutor rule ):
!   === equally specific with ===
! Rule 2/17 ! Before giving something to someone when the second noun is not the current interlocutor ( this is the giving needs an interlocutor rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 3/17 ! Before opening BOSH back door when BOSH back door is locked:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 4/17 ! Before saying hello to someone when the greeting type is implicit ( this is the skip sounds on implicit hello rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 5/17 ! Before asking someone to try hailing ( this is the change greeting command to greeting rule ):
!   <<< I - Number of aspects constrained <<<
! Rule 6/17 ! Before asking someone to try doing something when the person asked is not the current interlocutor ( this is the giving orders needs an interlocutor rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 7/17 ! Before answering someone that ~yes~ ( this is the change answering yes to saying yes rule ):
!   === equally specific with ===
! Rule 8/17 ! Before answering someone that ~no~ ( this is the change answering no to saying no rule ):
!   === equally specific with ===
! Rule 9/17 ! Before answering someone that ~sorry~ ( this is the change answering sorry to saying sorry rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 10/17 ! Before examining the heating vent ( this is the now you know vent-screws rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 11/17 ! Before asking someone to try saying yes ( this is the greet before saying yes rule ):
!   === equally specific with ===
! Rule 12/17 ! Before asking someone to try saying no ( this is the greet before saying no rule ):
!   === equally specific with ===
! Rule 13/17 ! Before asking someone to try saying sorry ( this is the greet before saying sorry rule ):
!   >>> III.3.3 - Action/What/Actor Performing Action >>>
! Rule 14/17 ! Before implicit-conversing when the current interlocutor is not visible and the current interlocutor is not nothing ( this is the can't converse with absent interlocutor rule ):
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 15/17 ! Before conversing when the noun is not the current interlocutor ( this is the greet a new interlocutor rule ):
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 16/17 ! Before implicit-conversing when the current interlocutor is nothing ( this is the implicit-conversing needs current interlocutor rule ):
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 17/17 ! Before doing something other than answering that while player is talking with someone ( called P ) ( this is the can't touch through the phone rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversation Framework" by Eric Eve
! No specific request
! Before showing something to someone when the second noun is not the current interlocutor ( this is the showing needs an interlocutor rule ):
[ R_816 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    I7RBLK = KERNEL_3();
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_3 ;
    if ((((action ==##Show) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person)) && (self=actor,true) && (((~~((second == (Global_Vars-->11))))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_816, 816);
    ! [2: implicitly greet the second noun]

    ! Resolution of run-time phrase ambiguity (to phrase):
        formal_par0 = second;
        if (((((formal_par0 ofclass K2_thing) && (formal_par0 ofclass K2_thing))))) { (PHR_819_r12 (formal_par0)); }
        else ArgumentTypeFailed(178, 4);

    ! Resolution complete

    ! [3: if the second noun is not the current interlocutor]
    if (((~~((second == (Global_Vars-->11))))))
    {! [4: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_816, 816, 'action');
        rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Before giving something to someone when the second noun is not the current interlocutor ( this is the giving needs an interlocutor rule ):
[ R_817 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    I7RBLK = KERNEL_4();
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_4 ;
    if ((((action ==##Give) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person)) && (self=actor,true) && (((~~((second == (Global_Vars-->11))))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_817, 817);
    ! [2: if the current interlocutor is not a person]
    if (((~~(((Global_Vars-->11) ofclass K8_person)))))
    {! [3: abide by the implicit-conversing needs current interlocutor rule]
        if (FollowRulebook(R_807)) rtrue;
        }
    ! [4: implicitly greet the second noun]

    ! Resolution of run-time phrase ambiguity (to phrase):
        formal_par0 = second;
        if (((((formal_par0 ofclass K2_thing) && (formal_par0 ofclass K2_thing))))) { (PHR_819_r12 (formal_par0)); }
        else ArgumentTypeFailed(183, 4);

    ! Resolution complete

    ! [5: if the second noun is not the current interlocutor]
    if (((~~((second == (Global_Vars-->11))))))
    {! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_817, 817, 'action');
        rfalse;
];
! No specific request
! Before opening BOSH back door when BOSH back door is locked:
[ R_1488 ;
    if ((((action ==##Open) &&  (actor==player) && ((noun == I367_bosh_back_door) && (true)) && (self=actor,true) && ((((Adj_106_t1_v10(I367_bosh_back_door)))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1488, 1488);
    ! [2: now player knows back-door-is-locked]
    (RGuard_MT_2(player,I171_back_door_is_locked));
    } else if (debug_rules > 1) DB_Rule(R_1488, 1488, 'action');
    rfalse;
];
! No specific request
! Before saying hello to someone when the greeting type is implicit ( this is the skip sounds on implicit hello rule ):
[ R_1454 ;
    if ((((action ==##A74_saying_hello_to) &&  (actor==player) && ((noun ofclass K8_person)) && (self=actor,true) && ((((Global_Vars-->12) == I129_implicit)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1454, 1454);
    ! [2: now skip sounds this turn is true]
    (Global_Vars-->17) = 1;
    } else if (debug_rules > 1) DB_Rule(R_1454, 1454, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Before asking someone to try hailing ( this is the change greeting command to greeting rule ):
[ R_825 ;
    if ((((action ==##A75_hailing) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_825, 825);
    ! [2: now the greeting type is explicit]
    (Global_Vars-->12) = I130_explicit;
    ! [3: try saying hello to the person asked]
    TryAction(0, player, ##A74_saying_hello_to, actor, 0);
    ! [4: rule succeeds]
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_825, 825, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Before asking someone to try doing something when the person asked is not the current interlocutor ( this is the giving orders needs an interlocutor rule ):
[ R_818 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    I7RBLK = KERNEL_5();
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_5 ;
    if ((( (actor~=player) && (act_requester) && ((actor ofclass K8_person)) && (self=actor,true) && (((~~((actor == (Global_Vars-->11))))))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_818, 818);
    ! [2: implicitly greet the person asked]

    ! Resolution of run-time phrase ambiguity (to phrase):
        formal_par0 = actor;
        if (((((formal_par0 ofclass K2_thing) && (formal_par0 ofclass K2_thing))))) { (PHR_819_r12 (formal_par0)); }
        else ArgumentTypeFailed(187, 4);

    ! Resolution complete

    ! [3: if the person asked is not the current interlocutor]
    if (((~~((actor == (Global_Vars-->11))))))
    {! [4: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_818, 818, 'action');
        rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Before answering someone that ~yes~ ( this is the change answering yes to saying yes rule ):
[ R_843 ;
    if ((((action ==##Answer) &&  (actor==player) && ((noun ofclass K8_person)) && (Consult_Grammar_196(consult_from, consult_words)~=GPR_FAIL)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_843, 843);
    ! [2: try saying yes]
    TryAction(0, player, ##Yes, 0, 0);
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_843, 843, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Before answering someone that ~no~ ( this is the change answering no to saying no rule ):
[ R_844 ;
    if ((((action ==##Answer) &&  (actor==player) && ((noun ofclass K8_person)) && (Consult_Grammar_197(consult_from, consult_words)~=GPR_FAIL)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_844, 844);
    ! [2: try saying no]
    TryAction(0, player, ##No, 0, 0);
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_844, 844, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Before answering someone that ~sorry~ ( this is the change answering sorry to saying sorry rule ):
[ R_845 ;
    if ((((action ==##Answer) &&  (actor==player) && ((noun ofclass K8_person)) && (Consult_Grammar_198(consult_from, consult_words)~=GPR_FAIL)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_845, 845);
    ! [2: try asking the noun to try saying sorry]
    TryAction(1, noun, ##Sorry, 0, 0);
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_845, 845, 'action');
    rfalse;
];
! No specific request
! Before examining the heating vent ( this is the now you know vent-screws rule ):
[ R_1498 ;
    if ((((action ==##Examine) &&  (actor==player) && ((noun == I469_heating_vent) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1498, 1498);
    ! [2: now the player knows vent-screws]
    (RGuard_MT_2(player,I163_vent_screws));
    } else if (debug_rules > 1) DB_Rule(R_1498, 1498, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Before asking someone to try saying yes ( this is the greet before saying yes rule ):
[ R_840 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    I7RBLK = KERNEL_6();
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_6 ;
    if ((((action ==##Yes) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_840, 840);
    ! [2: if the person asked is not the current interlocutor]
    if (((~~((actor == (Global_Vars-->11))))))
    {! [3: implicitly greet the person asked]

        ! Resolution of run-time phrase ambiguity (to phrase):
            formal_par0 = actor;
            if (((((formal_par0 ofclass K2_thing) && (formal_par0 ofclass K2_thing))))) { (PHR_819_r12 (formal_par0)); }
            else ArgumentTypeFailed(314, 4);

        ! Resolution complete

        }
    ! [4: try saying yes]
    TryAction(0, player, ##Yes, 0, 0);
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_840, 840, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Before asking someone to try saying no ( this is the greet before saying no rule ):
[ R_841 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    I7RBLK = KERNEL_7();
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_7 ;
    if ((((action ==##No) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_841, 841);
    ! [2: if the person asked is not the current interlocutor]
    if (((~~((actor == (Global_Vars-->11))))))
    {! [3: implicitly greet the person asked]

        ! Resolution of run-time phrase ambiguity (to phrase):
            formal_par0 = actor;
            if (((((formal_par0 ofclass K2_thing) && (formal_par0 ofclass K2_thing))))) { (PHR_819_r12 (formal_par0)); }
            else ArgumentTypeFailed(318, 4);

        ! Resolution complete

        }
    ! [4: try saying no]
    TryAction(0, player, ##No, 0, 0);
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_841, 841, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Before asking someone to try saying sorry ( this is the greet before saying sorry rule ):
[ R_842 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    I7RBLK = KERNEL_8();
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_8 ;
    if ((((action ==##Sorry) &&  (actor~=player) && (act_requester) && ((actor ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_842, 842);
    ! [2: if the person asked is not the current interlocutor]
    if (((~~((actor == (Global_Vars-->11))))))
    {! [3: implicitly greet the person asked]

        ! Resolution of run-time phrase ambiguity (to phrase):
            formal_par0 = actor;
            if (((((formal_par0 ofclass K2_thing) && (formal_par0 ofclass K2_thing))))) { (PHR_819_r12 (formal_par0)); }
            else ArgumentTypeFailed(322, 4);

        ! Resolution complete

        }
    ! [4: try saying sorry]
    TryAction(0, player, ##Sorry, 0, 0);
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_842, 842, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Before implicit-conversing when the current interlocutor is not visible and the current interlocutor is not nothing ( this is the can't converse with absent interlocutor rule ):
[ R_808 ;
    if (((((NAP_0())) &&  (actor==player) && (self=actor,true) && ((((~~(((Adj_3_t1_v10((Global_Vars-->11)))))))) && (((~~(((Global_Vars-->11) == nothing))))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_808, 808);
    ! [2: say ~[The current interlocutor] [aren't] [here].~ ( a )]
    say__p=1;! [3: ~[The current interlocutor] [aren't] [here].~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_135); new_line; .L_Say12; .L_SayX12;! [4: reset the interlocutor]
    (PHR_830_r1 ());
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_808, 808, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Before conversing when the noun is not the current interlocutor ( this is the greet a new interlocutor rule ):
[ R_815 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    I7RBLK = KERNEL_9();
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_9 ;
    if (((((NAP_1())) &&  (actor==player) && (self=actor,true) && (((~~((noun == (Global_Vars-->11))))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_815, 815);
    ! [2: implicitly greet the noun]

    ! Resolution of run-time phrase ambiguity (to phrase):
        formal_par0 = noun;
        if (((((formal_par0 ofclass K2_thing) && (formal_par0 ofclass K2_thing))))) { (PHR_819_r12 (formal_par0)); }
        else ArgumentTypeFailed(174, 4);

    ! Resolution complete

    ! [3: if the noun is not the current interlocutor]
    if (((~~((noun == (Global_Vars-->11))))))
    {! [4: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_815, 815, 'action');
        rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Before implicit-conversing when the current interlocutor is nothing ( this is the implicit-conversing needs current interlocutor rule ):
[ R_807 
    tmp_0 ! Let/loop value, e.g., 'np': number
    tmp_1 ! Let/loop value, e.g., 'interlocutor': thing
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if (((((NAP_0())) &&  (actor==player) && (self=actor,true) && ((((Global_Vars-->11) == nothing)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_807, 807);
    ! [2: let np be the number of visible people who are not the player]

    		tmp_0 = (Prop_14());
    ! [3: if np is 0]
    if (((tmp_0 == 0)))
    {! [4: say ~[There's] no one [here] to talk to.~ ( a )]
        say__p=1;! [5: ~[There's] no one [here] to talk to.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_136); new_line; .L_Say13; .L_SayX13;}
    ! [6: if np > 1]
    if (((tmp_0 > 1)))
    {! [7: say ~You need to specify who you want to speak to.~ ( b )]
        say__p=1;! [8: ~You need to specify who you want to speak to.~ ( b )]
        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_137); new_line; .L_Say14; .L_SayX14;}
    ! [9: if np is not 1]
    if (((~~((tmp_0 == 1)))))
    {! [10: stop the action]
        rtrue;
        }
    ! [11: let the interlocutor be a random visible person who is not the player]

    		tmp_1 = (Prop_15());
    ! [12: if the interlocutor is a person]
    if (((tmp_1 ofclass K8_person)))
    {! [13: say ~(addressing [the interlocutor])~ ( c )]
        say__p=1;! [14: ~(addressing [the interlocutor])~ ( c )]
        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_138); .L_Say15; .L_SayX15;! [15: let sn be the second noun]

        		tmp_2 = second;
        ! [16: implicitly greet the interlocutor]
        (PHR_819_r12 (tmp_1));
        ! [17: if the current interlocutor is not the interlocutor]
        if (((~~(((Global_Vars-->11) == tmp_1)))))
        {! [18: stop the action]
            rtrue;
            }
        ! [19: now the second noun is sn]
        second = tmp_2;
        } else {
        ! [20: say ~[We] [aren't] talking to anyone.~ ( d )]
        say__p=1;! [21: ~[We] [aren't] talking to anyone.~ ( d )]
        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_139); new_line; .L_Say16; .L_SayX16;! [22: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_807, 807, 'action');
        rfalse;
];
! From "Phones" by Philip Riley
! No specific request
! Before doing something other than answering that while player is talking with someone ( called P ) ( this is the can't touch through the phone rule ):
[ R_1017 
    tmp_0 ! Let/loop value, e.g., 'P': person
    ;
    if ((( (actor==player) && (~~((action ==##Answer))) && (self=actor,true) && ((((Prop_16() && (tmp_0=deferred_calling_list-->0, true)) || (tmp_0 = 0,false))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1017, 1017);
    ! [2: if action requires a touchable noun and the noun is p and p is not in the location]
    if ((((NeedToTouchNoun()))) && ((((noun == tmp_0))) && (((~~((real_location == ContainerOf(tmp_0))))))))
    {! [3: say ~You can't touch [P].~ ( a )]
        say__p=1;! [4: ~You can't touch [P].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_140); new_line; .L_Say17; .L_SayX17;! [5: stop the action]
        rtrue;
        }
    ! [6: if action requires a touchable second noun and the second noun is p and p is not in the location]
    if ((((NeedToTouchSecondNoun()))) && ((((second == tmp_0))) && (((~~((real_location == ContainerOf(tmp_0))))))))
    {! [7: say ~You can't touch [P].~]
        say__p=1;! [8: ~You can't touch ~]
        ParaContent(); print "You can't touch ";! [9: p]
        ParaContent(); PrintShortName(tmp_0);! [10: ~.~]
        ParaContent(); print "."; new_line; .L_Say18; .L_SayX18;! [11: stop the action]
        rtrue;
        }
    ! [12: if action requires light and the noun is p and p is not in the location]
    if ((((NeedLightForAction()))) && ((((noun == tmp_0))) && (((~~((real_location == ContainerOf(tmp_0))))))))
    {! [13: say ~You can't see [P].~ ( b )]
        say__p=1;! [14: ~You can't see [P].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_141); new_line; .L_Say19; .L_SayX19;! [15: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_1017, 1017, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Instead (B20_instead)
! ----------------------------------------------------------------------------------------------------
! Rule 1/49 ! Instead of going nowhere from the Parking Lot South:
!   === equally specific with ===
! Rule 2/49 ! Instead of going nowhere from the Parking Lot North:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 3/49 ! Instead of removing hex wrench from heating vent when the heating vent is closed:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 4/49 ! Instead of quizzing someone about something when the noun is busy with respect to the actor:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 5/49 ! Instead of examining Biff's computer when the thumb drive is not seen:
!   === equally specific with ===
! Rule 6/49 ! Instead of knocking on the closet door when the location is the utility closet and the closet door is locked and the closet door is closed:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 7/49 ! Instead of examining the mystic compass when the location is Featureless Hyperplane:
!   === equally specific with ===
! Rule 8/49 ! Instead of opening the heating vent when the heating vent is locked:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 9/49 ! Instead of player saying goodbye to someone ( called callee ) while the actor is talking with the callee and the current interlocutor is not nothing:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 10/49 ! Instead of player saying goodbye to someone ( called callee ) while the actor is talking with the callee and the current interlocutor is nothing:
!   >>> III.3.3 - Action/What/Actor Performing Action >>>
! Rule 11/49 ! Instead of examining a phone ( called P ) when the noun is ringing:
!   === equally specific with ===
! Rule 12/49 ! Instead of an actor saying hello to someone when the noun is busy with respect to the actor:
!   >>> I - Number of aspects constrained >>>
! Rule 13/49 ! Instead of moving the filing cabinets with the handtruck:
!   === equally specific with ===
! Rule 14/49 ! Instead of an actor inserting biff-flattened-boxes into the dumpster:
!   === equally specific with ===
! Rule 15/49 ! Instead of an actor inserting margaret-flattened-boxes into the dumpster:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 16/49 ! Instead of asking a female person about ~herself~ ( this is the asking a woman about herself rule ):
!   === equally specific with ===
! Rule 17/49 ! Instead of asking a male person about ~himself~ ( this is the asking a man about himself rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 18/49 ! Instead of examining walls ( this is the standard examine wall rule ):
!   === equally specific with ===
! Rule 19/49 ! Instead of touching walls ( this is the standard touch walls rule ):
!   === equally specific with ===
! Rule 20/49 ! Instead of examining Floor ( this is the standard examine floor rule ):
!   === equally specific with ===
! Rule 21/49 ! Instead of touching Floor ( this is the standard touch floor rule ):
!   === equally specific with ===
! Rule 22/49 ! Instead of examining Ceiling ( this is the standard examine ceiling rule ):
!   === equally specific with ===
! Rule 23/49 ! Instead of touching Ceiling ( this is the standard touch ceiling rule ):
!   === equally specific with ===
! Rule 24/49 ! Instead of entering the office_:
!   === equally specific with ===
! Rule 25/49 ! Instead of entering car 1:
!   === equally specific with ===
! Rule 26/49 ! Instead of entering the laundromat-facade:
!   === equally specific with ===
! Rule 27/49 ! Instead of entering the swamp-facade:
!   === equally specific with ===
! Rule 28/49 ! Instead of entering the pawn-shop-facade:
!   === equally specific with ===
! Rule 29/49 ! Instead of entering the automatic car wash:
!   === equally specific with ===
! Rule 30/49 ! Instead of entering the convenience-store-facade:
!   === equally specific with ===
! Rule 31/49 ! Instead of entering the military-facade:
!   === equally specific with ===
! Rule 32/49 ! Instead of taking the handtruck:
!   === equally specific with ===
! Rule 33/49 ! Instead of switching on the flashlight:
!   === equally specific with ===
! Rule 34/49 ! Instead of switching off the flashlight:
!   === equally specific with ===
! Rule 35/49 ! Instead of taking the cardboard boxes:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 36/49 ! Instead of entering an unenterable room:
!   === equally specific with ===
! Rule 37/49 ! Instead of opening a desk ( called D ):
!   === equally specific with ===
! Rule 38/49 ! Instead of closing a desk ( called D ):
!   === equally specific with ===
! Rule 39/49 ! Instead of examining a room:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 40/49 ! Instead of promising when the current interlocutor is not nothing:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 41/49 ! Instead of looking when current play mode is picking character:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 42/49 ! Instead of going nowhere:
!   >>> I - Number of aspects constrained >>>
! Rule 43/49 ! Instead of stealing equipment:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 44/49 ! Instead of implicit-asking:
!   === equally specific with ===
! Rule 45/49 ! Instead of implicit-telling:
!   === equally specific with ===
! Rule 46/49 ! Instead of implicit-quizzing:
!   === equally specific with ===
! Rule 47/49 ! Instead of implicit-informing:
!   === equally specific with ===
! Rule 48/49 ! Instead of implicit-requesting:
!   === equally specific with ===
! Rule 49/49 ! Instead of implicit-imploring:
! ----------------------------------------------------------------------------------------------------
! From "Swamp Park" by Philip Riley
! No specific request
! Instead of going nowhere from the Parking Lot South:
[ R_1399 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(1);
    BlkValueCreateOnStack(0, STORED_ACTION_TY);
    I7RBLK = KERNEL_10();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_10 
    tmp_0 ! Let/loop value, e.g., 'dir': object
    ;
    if ((((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) == I294_strip_mall_parking_lot_) && ((MStack-->MstVON(20007,0)) ofclass K1_room)) && ((MStack-->MstVON(20007,1)) == nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1399, 1399);
    ! [2: let dir be noun part of current action]

    		tmp_0 = (STORED_ACTION_TY_Part(STORED_ACTION_TY_Current(I7SFRAME), STORA_NOUN_F));
    ! [3: if dir is south]
    if (((tmp_0 == I54_south)))
    {! [4: say ~The swamp would just muck up [agent]'s clothes.~]
        say__p=1;! [5: ~The swamp would just muck up ~]
        ParaContent(); print "The swamp would just muck up ";! [6: agent]
        ParaContent(); (PHR_1445_r13 ());! [7: ~'s clothes.~]
        ParaContent(); print "'s clothes."; new_line; .L_Say20; .L_SayX20;} else {
        ! [8: if dir is east]
        if (((tmp_0 == I57_east)))
        {! [9: say ~An automatic car wash isn't of much use when one is on foot.~]
            say__p=1;! [10: ~An automatic car wash isn't of much use when one is on foot.~]
            ParaContent(); print "An automatic car wash isn't of much use when one is on foot."; new_line; .L_Say21; .L_SayX21;} else {
            ! [11: continue the action]
            rfalse;
            }
            }
    ! [12: stop the action]
    rtrue;
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1399, 1399, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! Instead of going nowhere from the Parking Lot North:
[ R_1401 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(1);
    BlkValueCreateOnStack(0, STORED_ACTION_TY);
    I7RBLK = KERNEL_11();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_11 
    tmp_0 ! Let/loop value, e.g., 'dir': object
    ;
    if ((((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) == I312_strip_mall_parking_lot_) && ((MStack-->MstVON(20007,0)) ofclass K1_room)) && ((MStack-->MstVON(20007,1)) == nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1401, 1401);
    ! [2: let dir be noun part of current action]

    		tmp_0 = (STORED_ACTION_TY_Part(STORED_ACTION_TY_Current(I7SFRAME), STORA_NOUN_F));
    ! [3: if dir is north]
    if (((tmp_0 == I51_north)))
    {! [4: say ~[We] [have] things to do here.~]
        say__p=1;! [5: we]
        ParaContent(); (PHR_764_r7 ());! [6: ~ ~]
        ParaContent(); print " ";! [7: have]
        ConjugateVerb_2(CV_POS, PNToVP(), story_tense); say__p=1; ! [8: ~ things to do here.~]
        ParaContent(); print " things to do here."; new_line; .L_Say22; .L_SayX22;} else {
        ! [9: if dir is west]
        if (((tmp_0 == I58_west)))
        {! [10: say ~[We] will think about joining the military once the Bureau shuts down.~]
            say__p=1;! [11: we]
            ParaContent(); (PHR_764_r7 ());! [12: ~ will think about joining the military once the Bureau shuts down.~]
            ParaContent(); print " will think about joining the military once the Bureau shuts down."; new_line; .L_Say23; .L_SayX23;} else {
            ! [13: continue the action]
            rfalse;
            }
            }
    ! [14: stop the action]
    rtrue;
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1401, 1401, 'action');
    rfalse;
];
! No specific request
! Instead of removing hex wrench from heating vent when the heating vent is closed:
[ R_1499 ;
    if ((((action ==##Remove) &&  (actor==player) && ((noun == I364_hex_wrench) && (true)) && ((second == I469_heating_vent) && (true)) && (self=actor,true) && ((((Adj_102_t1_v10(I469_heating_vent)))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1499, 1499);
    ! [2: say ~[Our] fingers won't fit through the openings in the vent. [We]'ll have to open it first.~]
    say__p=1;! [3: our]
    ParaContent(); (PHR_770_r14 ());! [4: ~ fingers won't fit through the openings in the vent. ~]
    ParaContent(); print " fingers won't fit through the openings in the vent. ";! [5: we]
    ParaContent(); (PHR_764_r7 ());! [6: ~'ll have to open it first.~]
    ParaContent(); print "~ll have to open it first."; new_line; .L_Say24; .L_SayX24;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1499, 1499, 'action');
    rfalse;
];
! No specific request
! Instead of quizzing someone about something when the noun is busy with respect to the actor:
[ R_1463 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_12();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_12 ;
    if ((((action ==##A66_quizzing_it_about) &&  (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing)) && (self=actor,true) && (
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K8_person) && (formal_par0 ofclass K8_person))))) && ((
                    formal_rv = ((PHR_1461_r15 (formal_par0,formal_par1)))) | 1)
                    )|| (ArgumentTypeFailed(397))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par1 = actor) +
                (formal_par0 = noun)
                ))
        )

    ! Resolution complete
    )))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1463, 1463);
    ! [2: say ~[The noun] is on the phone.~]
    say__p=1;! [3: the noun]
    ParaContent(); print (The) noun;! [4: ~ is on the phone.~]
    ParaContent(); print " is on the phone."; new_line; .L_Say25; .L_SayX25;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1463, 1463, 'action');
    rfalse;
];
! No specific request
! Instead of examining Biff's computer when the thumb drive is not seen:
[ R_1497 ;
    if ((((action ==##Examine) &&  (actor==player) && ((noun == I362_biff_s_computer) && (true)) && (self=actor,true) && (((~~(((Adj_116_t1_v10(I259_thumb_drive)))))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1497, 1497);
    ! [2: say ~[description of biff's computer] But [we] [do] find a thumb drive and [take] it.~]
    say__p=1;! [3: description of biff's computer]
    ParaContent(); @push self; print (TEXT_TY_Say) GProperty(10, self=I362_biff_s_computer,description);@pull self; ! [4: ~ But ~]
    ParaContent(); print " But ";! [5: we]
    ParaContent(); (PHR_757_r16 ());! [6: ~ ~]
    ParaContent(); print " ";! [7: do]
    ConjugateVerb_3(CV_POS, PNToVP(), story_tense); say__p=1; ! [8: ~ find a thumb drive and ~]
    ParaContent(); print " find a thumb drive and ";! [9: take]
    ConjugateVerb_61(CV_POS, PNToVP(), story_tense); say__p=1; ! [10: ~ it.~]
    ParaContent(); print " it."; new_line; .L_Say26; .L_SayX26;! [11: now the player carries the thumb drive]
    MoveObject(I259_thumb_drive,player);
    ! [12: now the thumb drive is seen]
    (Adj_116_t2_v10(I259_thumb_drive));
    ! [13: remember finding the drive before for the player]
    (PHR_1188_r17 (I465_finding_the_drive_befor,player));
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1497, 1497, 'action');
    rfalse;
];
! No specific request
! Instead of knocking on the closet door when the location is the utility closet and the closet door is locked and the closet door is closed:
[ R_1501 ;
    if ((((action ==##A110_knocking_on) &&  (actor==player) && ((noun == I494_closet_door) && (true)) && (self=actor,true) && ((((real_location == I495_utility_closet))) && (((((Adj_106_t1_v10(I494_closet_door))))) && ((((Adj_102_t1_v10(I494_closet_door)))))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1501, 1501);
    ! [2: move moira zin to moira's office]
    MoveObject(I427_moira_zin, I456_moira_s_office, 0, false);
    ! [3: now moira's door is unlocked]
    (Adj_107_t2_v10(I455_moira_s_door));
    ! [4: if moira zin is in moira's office]
    if (((I456_moira_s_office == ContainerOf(I427_moira_zin))))
    {! [5: say ~After a few seconds, someone inserts a key in the lock and opens the door. It's [player's surname]'s colleague Moira Zin. 'How'd you get in there, [player's forename]?'^^You exit the closet.~]
        say__p=1;! [6: ~After a few seconds, someone inserts a key in the lock and opens the door. It's ~]
        ParaContent(); print "After a few seconds, someone inserts a key in the lock and opens the door. It's ";! [7: player's surname]
        ParaContent(); print (TEXT_TY_Say) (Global_Vars-->20);! [8: ~'s colleague Moira Zin. 'How'd you get in there, ~]
        ParaContent(); print "'s colleague Moira Zin. ~How'd you get in there, ";! [9: player's forename]
        ParaContent(); print (TEXT_TY_Say) (Global_Vars-->76);! [10: ~?'^^You exit the closet.~]
        ParaContent(); print "?~^^You exit the closet."; new_line; .L_Say27; .L_SayX27;! [11: move the player to moira's office]
        MoveObject(player, I456_moira_s_office, 0, false);
        ! [12: queue moira zin with about the hyperdimensional portal]
        (PHR_1209_r18 (I427_moira_zin,I496_about_the_hyperdimensio));
        ! [13: queue moira zin with to wait for the report]
        (PHR_1209_r18 (I427_moira_zin,I497_to_wait_for_the_report));
        ! [14: now the current interlocutor is moira zin]
        (Global_Vars-->11) = I427_moira_zin;
        ! [15: now the closet door is unlocked]
        (Adj_107_t2_v10(I494_closet_door));
        ! [16: now the closet door is open]
        (Adj_101_t2_v10(I494_closet_door));
        }
        RulebookFails(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1501, 1501, 'action');
        rfalse;
];
! From "Hyperspace" by Philip Riley
! No specific request
! Instead of examining the mystic compass when the location is Featureless Hyperplane:
[ R_1257 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(6);
    BlkValueCreateOnStack(5, KD9_list_of_numbers);
    BlkValueCreateOnStack(4, KD9_list_of_numbers);
    BlkValueCreateOnStack(3, KD9_list_of_numbers);
    BlkValueCreateOnStack(2, KD9_list_of_numbers);
    BlkValueCreateOnStack(1, KD9_list_of_numbers);
    BlkValueCreateOnStack(0, KD9_list_of_numbers);
    I7RBLK = KERNEL_13();
    BlkValueFreeOnStack(5);
    BlkValueFreeOnStack(4);
    BlkValueFreeOnStack(3);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(1);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_13 ;
    if ((((action ==##Examine) &&  (actor==player) && ((noun == I243_mystic_compass) && (true)) && (self=actor,true) && (((real_location == I244_featureless_hyperplane)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1257, 1257);
    ! [2: if player carries the mystic compass]
    if (((player == CarrierOf(I243_mystic_compass))))
    {! [3: say ~On the readout of the mystic compass floats a set of ethereal symbols: [symbols for convert entry 1 of hyperplane coords to base five] : [symbols for convert entry 2 of hyperplane coords to base five] : [symbols for convert entry 3 of hyperplane coords to base five][paragraph break]~]
        say__p=1;! [4: ~On the readout of the mystic compass floats a set of ethereal symbols: ~]
        ParaContent(); print "On the readout of the mystic compass floats a set of ethereal symbols: ";! [5: symbols for convert entry 1 of hyperplane coords to base five]
        ParaContent(); (PHR_1249_r19 (BlkValueCopy(I7SFRAME, (PHR_1251_r20 ((I7SFRAME+WORDSIZE),LIST_OF_TY_GetItem((Global_Vars-->45),1))))));! [6: ~ : ~]
        ParaContent(); print " : ";! [7: symbols for convert entry 2 of hyperplane coords to base five]
        ParaContent(); (PHR_1249_r19 (BlkValueCopy((I7SFRAME+WORDSIZE*2), (PHR_1251_r20 ((I7SFRAME+WORDSIZE*3),LIST_OF_TY_GetItem((Global_Vars-->45),2))))));! [8: ~ : ~]
        ParaContent(); print " : ";! [9: symbols for convert entry 3 of hyperplane coords to base five]
        ParaContent(); (PHR_1249_r19 (BlkValueCopy((I7SFRAME+WORDSIZE*4), (PHR_1251_r20 ((I7SFRAME+WORDSIZE*5),LIST_OF_TY_GetItem((Global_Vars-->45),3))))));! [10: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say28; .L_SayX28;}
        RulebookFails(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1257, 1257, 'action');
        rfalse;
];
! No specific request
! Instead of opening the heating vent when the heating vent is locked:
[ R_1500 ;
    if ((((action ==##Open) &&  (actor==player) && ((noun == I469_heating_vent) && (true)) && (self=actor,true) && ((((Adj_106_t1_v10(I469_heating_vent)))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1500, 1500);
    ! [2: say ~The vent is held closed by four screws.~]
    say__p=1;! [3: ~The vent is held closed by four screws.~]
    ParaContent(); print "The vent is held closed by four screws."; new_line; .L_Say29; .L_SayX29;! [4: now the player knows vent-screws]
    (RGuard_MT_2(player,I163_vent_screws));
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1500, 1500, 'action');
    rfalse;
];
! From "Phones" by Philip Riley
! No specific request
! Instead of player saying goodbye to someone ( called callee ) while the actor is talking with the callee and the current interlocutor is not nothing:
[ R_1026 
    tmp_0 ! Let/loop value, e.g., 'callee': person
    ;
    if ((((action ==##A77_saying_goodbye_to) &&  (actor==player) && (tmp_0 = noun, (((noun ofclass K8_person) && (tmp_0=(noun), true)))) && (self=actor,true) && (((((RGuard_T_4(actor,tmp_0))))) && (((~~(((Global_Vars-->11) == nothing))))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1026, 1026);
    ! [2: reset the interlocutor]
    (PHR_830_r1 ());
    ! [3: try ending a call]
    TryAction(0, player, ##A86_ending_a_call, 0, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1026, 1026, 'action');
    rfalse;
];
! From "Phones" by Philip Riley
! No specific request
! Instead of player saying goodbye to someone ( called callee ) while the actor is talking with the callee and the current interlocutor is nothing:
[ R_1027 
    tmp_0 ! Let/loop value, e.g., 'callee': person
    ;
    if ((((action ==##A77_saying_goodbye_to) &&  (actor==player) && (tmp_0 = noun, (((noun ofclass K8_person) && (tmp_0=(noun), true)))) && (self=actor,true) && (((((RGuard_T_4(actor,tmp_0))))) && ((((Global_Vars-->11) == nothing))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1027, 1027);
    ! [2: rule succeeds]
    RulebookSucceeds(); rtrue;
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1027, 1027, 'action');
    rfalse;
];
! From "Phones" by Philip Riley
! No specific request
! Instead of examining a phone ( called P ) when the noun is ringing:
[ R_1030 
    tmp_0 ! Let/loop value, e.g., 'P': phone
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value, e.g., 'caller phone': phone
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((action ==##Examine) &&  (actor==player) && (tmp_0 = noun, (((noun ofclass K20_phone) && (tmp_0=(noun), true)))) && (self=actor,true) && ((((Adj_133_t1_v10(noun)))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1030, 1030);
    ! [2: if p is caller id]
    if ((((Adj_136_t1_v10(tmp_0)))))
    {! [3: let caller be a random person who is calling the p]

        		tmp_1 = (Prop_17(tmp_0));
        ! [4: if caller is talking on a phone ( called caller phone )]
        if ((((RGuard_f1_3(tmp_1)) ofclass K20_phone) && (tmp_2=((RGuard_f1_3(tmp_1))), true)))
        {! [5: if caller phone is unidentifiable]
            if ((((Adj_140_t1_v10(tmp_2)))))
            {! [6: say ~The caller ID says 'Unknown Caller'.~]
                say__p=1;! [7: ~The caller ID says 'Unknown Caller'.~]
                ParaContent(); print "The caller ID says ~Unknown Caller~."; new_line; .L_Say30; .L_SayX30;} else {
                ! [8: let caller number be a random phone number which reaches caller phone]

                		tmp_3 = (Prop_18(tmp_2));
                ! [9: if the player knows caller number]
                if ((((RGuard_T_2(player,tmp_3)))))
                {! [10: say ~The caller ID says [Caller].~]
                    say__p=1;! [11: ~The caller ID says ~]
                    ParaContent(); print "The caller ID says ";! [12: caller]
                    ParaContent(); PrintShortName(tmp_1);! [13: ~.~]
                    ParaContent(); print "."; new_line; .L_Say31; .L_SayX31;} else {
                    ! [14: say ~[We] [don't] recognize the number.~]
                    say__p=1;! [15: we]
                    ParaContent(); (PHR_764_r7 ());! [16: ~ ~]
                    ParaContent(); print " ";! [17: don't]
                    ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ! [18: ~ recognize the number.~]
                    ParaContent(); print " recognize the number."; new_line; .L_Say32; .L_SayX32;}
                    }
                    }
                    } else {
        ! [19: say ~You better answer it.~]
        say__p=1;! [20: ~You better answer it.~]
        ParaContent(); print "You better answer it."; new_line; .L_Say33; .L_SayX33;}
        RulebookFails(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1030, 1030, 'action');
        rfalse;
];
! No specific request
! Instead of an actor saying hello to someone when the noun is busy with respect to the actor:
[ R_1462 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_14();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_14 ;
    if ((((action ==##A74_saying_hello_to) && (act_requester==nothing) && ((noun ofclass K8_person)) && (self=actor,true) && (
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K8_person) && (formal_par0 ofclass K8_person))))) && ((
                    formal_rv = ((PHR_1461_r15 (formal_par0,formal_par1)))) | 1)
                    )|| (ArgumentTypeFailed(394))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par1 = actor) +
                (formal_par0 = noun)
                ))
        )

    ! Resolution complete
    )))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1462, 1462);
    ! [2: say ~[The noun] is on the phone.~]
    say__p=1;! [3: the noun]
    ParaContent(); print (The) noun;! [4: ~ is on the phone.~]
    ParaContent(); print " is on the phone."; new_line; .L_Say34; .L_SayX34;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1462, 1462, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! Instead of moving the filing cabinets with the handtruck:
[ R_1410 ;
    if ((((action ==##A107_moving_it_with) &&  (actor==player) && ((noun == I337_filing_cabinets) && (true)) && ((second == I328_handtruck) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1410, 1410);
    ! [2: if the broken washing machine is nowhere]
    if (((LocationOf(I336_broken_washing_machine) == nothing)))
    {! [3: say ~You move the filing cabinets out of the way and uncover an old front-loading washing machine. There is a strange glow inside the drum.~]
        say__p=1;! [4: ~You move the filing cabinets out of the way and uncover an old front-loading washing machine. There is a strange glow inside the drum.~]
        ParaContent(); print "You move the filing cabinets out of the way and uncover an old front-loading washing machine. There is a strange glow inside the drum."; new_line; .L_Say35; .L_SayX35;! [5: now the broken washing machine is in the back basement]
        MoveObject(I336_broken_washing_machine,I331_back_basement);
        } else {
        ! [6: say ~There's no point in moving the cabinets around any further.~]
        say__p=1;! [7: ~There's no point in moving the cabinets around any further.~]
        ParaContent(); print "There's no point in moving the cabinets around any further."; new_line; .L_Say36; .L_SayX36;}
        RulebookFails(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1410, 1410, 'action');
        rfalse;
];
! No specific request
! Instead of an actor inserting biff-flattened-boxes into the dumpster:
[ R_1490 ;
    if ((((action ==##Insert) && (act_requester==nothing) && ((noun == I467_biff_flattened_boxes) && (true)) && ((second == I448_dumpster) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1490, 1490);
    ! [2: now the biff-flattened-boxes are in the room of stuff]
    MoveObject(I467_biff_flattened_boxes,I357_room_of_stuff);
    ! [3: if the actor is the player]
    if (((actor == player)))
    {! [4: say ~[We] [toss] the flattened boxes over the edge of the dumpster.~]
        say__p=1;! [5: we]
        ParaContent(); (PHR_764_r7 ());! [6: ~ ~]
        ParaContent(); print " ";! [7: toss]
        ConjugateVerb_141(CV_POS, PNToVP(), story_tense); say__p=1; ! [8: ~ the flattened boxes over the edge of the dumpster.~]
        ParaContent(); print " the flattened boxes over the edge of the dumpster."; new_line; .L_Say37; .L_SayX37;} else {
        ! [9: if the actor is in the location]
        if (((real_location == ContainerOf(actor))))
        {! [10: say ~[The actor] [toss] the flattened boxes over the edge of the dumpster.~]
            say__p=1;! [11: the actor]
            ParaContent(); print (The) actor;! [12: ~ ~]
            ParaContent(); print " ";! [13: toss]
            ConjugateVerb_141(CV_POS, PNToVP(), story_tense); say__p=1; ! [14: ~ the flattened boxes over the edge of the dumpster.~]
            ParaContent(); print " the flattened boxes over the edge of the dumpster."; new_line; .L_Say38; .L_SayX38;}
            }
            RulebookFails(); rtrue;
            } else if (debug_rules > 1) DB_Rule(R_1490, 1490, 'action');
            rfalse;
];
! No specific request
! Instead of an actor inserting margaret-flattened-boxes into the dumpster:
[ R_1491 ;
    if ((((action ==##Insert) && (act_requester==nothing) && ((noun == I468_margaret_flattened_boxe) && (true)) && ((second == I448_dumpster) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1491, 1491);
    ! [2: now the margaret-flattened-boxes are in the room of stuff]
    MoveObject(I468_margaret_flattened_boxe,I357_room_of_stuff);
    ! [3: if the actor is the player]
    if (((actor == player)))
    {! [4: say ~[We] [toss] the flattened boxes over the edge of the dumpster.~]
        say__p=1;! [5: we]
        ParaContent(); (PHR_764_r7 ());! [6: ~ ~]
        ParaContent(); print " ";! [7: toss]
        ConjugateVerb_141(CV_POS, PNToVP(), story_tense); say__p=1; ! [8: ~ the flattened boxes over the edge of the dumpster.~]
        ParaContent(); print " the flattened boxes over the edge of the dumpster."; new_line; .L_Say39; .L_SayX39;} else {
        ! [9: if the actor is in the location]
        if (((real_location == ContainerOf(actor))))
        {! [10: say ~[The actor] [toss] the flattened boxes over the edge of the dumpster.~]
            say__p=1;! [11: the actor]
            ParaContent(); print (The) actor;! [12: ~ ~]
            ParaContent(); print " ";! [13: toss]
            ConjugateVerb_141(CV_POS, PNToVP(), story_tense); say__p=1; ! [14: ~ the flattened boxes over the edge of the dumpster.~]
            ParaContent(); print " the flattened boxes over the edge of the dumpster."; new_line; .L_Say40; .L_SayX40;}
            }
            RulebookFails(); rtrue;
            } else if (debug_rules > 1) DB_Rule(R_1491, 1491, 'action');
            rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Instead of asking a female person about ~herself~ ( this is the asking a woman about herself rule ):
[ R_805 ;
    if ((((action ==##Ask) &&  (actor==player) && ((noun ofclass K8_person) && ((Adj_110_t1_v10(noun)))) && (Consult_Grammar_199(consult_from, consult_words)~=GPR_FAIL)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_805, 805);
    ! [2: try quizzing the noun about the noun]
    TryAction(0, player, ##A66_quizzing_it_about, noun, noun);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_805, 805, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Instead of asking a male person about ~himself~ ( this is the asking a man about himself rule ):
[ R_806 ;
    if ((((action ==##Ask) &&  (actor==player) && ((noun ofclass K8_person) && ((Adj_109_t1_v10(noun)))) && (Consult_Grammar_200(consult_from, consult_words)~=GPR_FAIL)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_806, 806);
    ! [2: try quizzing the noun about the noun]
    TryAction(0, player, ##A66_quizzing_it_about, noun, noun);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_806, 806, 'action');
    rfalse;
];
! From "Walls" by Philip Riley
! No specific request
! Instead of examining walls ( this is the standard examine wall rule ):
[ R_1064 ;
    if ((((action ==##Examine) &&  (actor==player) && ((noun == I192_walls) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1064, 1064);
    ! [2: say ~[wall description for location][line break]~ ( a )]
    say__p=1;! [3: ~[wall description for location][line break]~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_142); .L_Say41; .L_SayX41;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1064, 1064, 'action');
    rfalse;
];
! From "Walls" by Philip Riley
! No specific request
! Instead of touching walls ( this is the standard touch walls rule ):
[ R_1067 ;
    if ((((action ==##Touch) &&  (actor==player) && ((noun == I192_walls) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1067, 1067);
    ! [2: say ~[wall touch description for location][line break]~ ( a )]
    say__p=1;! [3: ~[wall touch description for location][line break]~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_143); .L_Say42; .L_SayX42;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1067, 1067, 'action');
    rfalse;
];
! From "Floors" by Philip Riley
! No specific request
! Instead of examining Floor ( this is the standard examine floor rule ):
[ R_1078 ;
    if ((((action ==##Examine) &&  (actor==player) && ((noun == I193_floor) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1078, 1078);
    ! [2: say ~[floor description for location][line break]~ ( a )]
    say__p=1;! [3: ~[floor description for location][line break]~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_144); .L_Say43; .L_SayX43;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1078, 1078, 'action');
    rfalse;
];
! From "Floors" by Philip Riley
! No specific request
! Instead of touching Floor ( this is the standard touch floor rule ):
[ R_1081 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    @push formal_par0;
    I7RBLK = KERNEL_15();
    @pull formal_par0;
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_15 ;
    if ((((action ==##Touch) &&  (actor==player) && ((noun == I193_floor) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1081, 1081);
    ! [2: say ~[floor touch description for location][line break]~]
    say__p=1;! [3: floor touch description for location]
    ParaContent(); print (TEXT_TY_Say) 
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K1_room) && (formal_par0 ofclass K1_room))))) && ((
                    formal_rv = (PHR_1080_r21 (I7SFRAME,formal_par0))) | 1)
                    )|| (ArgumentTypeFailed(1))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par0 = real_location)
                ))
        )

    ! Resolution complete
    ;! [4: line break]
    ParaContent(); new_line; .L_Say44; .L_SayX44;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1081, 1081, 'action');
    rfalse;
];
! From "Ceilings" by Philip Riley
! No specific request
! Instead of examining Ceiling ( this is the standard examine ceiling rule ):
[ R_1093 ;
    if ((((action ==##Examine) &&  (actor==player) && ((noun == I194_ceiling) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1093, 1093);
    ! [2: say ~[ceiling description for location][line break]~ ( a )]
    say__p=1;! [3: ~[ceiling description for location][line break]~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_145); .L_Say45; .L_SayX45;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1093, 1093, 'action');
    rfalse;
];
! From "Ceilings" by Philip Riley
! No specific request
! Instead of touching Ceiling ( this is the standard touch ceiling rule ):
[ R_1096 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    @push formal_par0;
    I7RBLK = KERNEL_16();
    @pull formal_par0;
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_16 ;
    if ((((action ==##Touch) &&  (actor==player) && ((noun == I194_ceiling) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1096, 1096);
    ! [2: say ~[ceiling touch description for location][line break]~]
    say__p=1;! [3: ceiling touch description for location]
    ParaContent(); print (TEXT_TY_Say) 
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K1_room) && (formal_par0 ofclass K1_room))))) && ((
                    formal_rv = (PHR_1095_r22 (I7SFRAME,formal_par0))) | 1)
                    )|| (ArgumentTypeFailed(1))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par0 = real_location)
                ))
        )

    ! Resolution complete
    ;! [4: line break]
    ParaContent(); new_line; .L_Say46; .L_SayX46;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1096, 1096, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! Instead of entering the office_:
[ R_1390 ;
    if ((((action ==##Enter) &&  (actor==player) && ((noun == I296_office_) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1390, 1390);
    ! [2: try going west]
    TryAction(0, player, ##Go, I58_west, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1390, 1390, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! Instead of entering car 1:
[ R_1391 ;
    if ((((action ==##Enter) &&  (actor==player) && ((noun == I299_car_1) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1391, 1391);
    ! [2: say ~[Our] job is here for now.~]
    say__p=1;! [3: our]
    ParaContent(); (PHR_770_r14 ());! [4: ~ job is here for now.~]
    ParaContent(); print " job is here for now."; new_line; .L_Say47; .L_SayX47;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1391, 1391, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! Instead of entering the laundromat-facade:
[ R_1394 ;
    if ((((action ==##Enter) &&  (actor==player) && ((noun == I301_laundromat_facade) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1394, 1394);
    ! [2: try going northwest]
    TryAction(0, player, ##Go, I53_northwest, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1394, 1394, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! Instead of entering the swamp-facade:
[ R_1397 ;
    if ((((action ==##Enter) &&  (actor==player) && ((noun == I305_swamp_facade) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1397, 1397);
    ! [2: try going south]
    TryAction(0, player, ##Go, I54_south, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1397, 1397, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! Instead of entering the pawn-shop-facade:
[ R_1398 ;
    if ((((action ==##Enter) &&  (actor==player) && ((noun == I306_pawn_shop_facade) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1398, 1398);
    ! [2: try going southwest]
    TryAction(0, player, ##Go, I56_southwest, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1398, 1398, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! Instead of entering the automatic car wash:
[ R_1400 ;
    if ((((action ==##Enter) &&  (actor==player) && ((noun == I310_automatic_car_wash) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1400, 1400);
    ! [2: try going east]
    TryAction(0, player, ##Go, I57_east, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1400, 1400, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! Instead of entering the convenience-store-facade:
[ R_1402 ;
    if ((((action ==##Enter) &&  (actor==player) && ((noun == I313_convenience_store_facad) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1402, 1402);
    ! [2: try going east]
    TryAction(0, player, ##Go, I57_east, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1402, 1402, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! Instead of entering the military-facade:
[ R_1403 ;
    if ((((action ==##Enter) &&  (actor==player) && ((noun == I314_military_facade) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1403, 1403);
    ! [2: try going west]
    TryAction(0, player, ##Go, I58_west, 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1403, 1403, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! Instead of taking the handtruck:
[ R_1408 ;
    if ((((action ==##Take) &&  (actor==player) && ((noun == I328_handtruck) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1408, 1408);
    ! [2: say ~The handtruck is a bit unwieldy to carry. Better push it instead.~]
    say__p=1;! [3: ~The handtruck is a bit unwieldy to carry. Better push it instead.~]
    ParaContent(); print "The handtruck is a bit unwieldy to carry. Better push it instead."; new_line; .L_Say48; .L_SayX48;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1408, 1408, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! Instead of switching on the flashlight:
[ R_1415 ;
    if ((((action ==##SwitchOn) &&  (actor==player) && ((noun == I349_flashlight) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1415, 1415);
    ! [2: now the flashlight is lit]
    (Adj_82_t2_v10(I349_flashlight));
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1415, 1415, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! Instead of switching off the flashlight:
[ R_1416 ;
    if ((((action ==##SwitchOff) &&  (actor==player) && ((noun == I349_flashlight) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1416, 1416);
    ! [2: now the flashlight is not lit]
    (Adj_82_t3_v10(I349_flashlight));
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1416, 1416, 'action');
    rfalse;
];
! No specific request
! Instead of taking the cardboard boxes:
[ R_1496 ;
    if ((((action ==##Take) &&  (actor==player) && ((noun == I466_cardboard_boxes) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1496, 1496);
    ! [2: if the biff-flattened-boxes are not in the room of stuff]
    if (((~~((I357_room_of_stuff == ContainerOf(I467_biff_flattened_boxes))))))
    {! [3: say ~[We] already [have] as many boxes as [we] [can] carry.~]
        say__p=1;! [4: we]
        ParaContent(); (PHR_764_r7 ());! [5: ~ already ~]
        ParaContent(); print " already ";! [6: have]
        ConjugateVerb_2(CV_POS, PNToVP(), story_tense); say__p=1; ! [7: ~ as many boxes as ~]
        ParaContent(); print " as many boxes as ";! [8: we]
        ParaContent(); (PHR_757_r16 ());! [9: ~ ~]
        ParaContent(); print " ";! [10: can]
        ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [11: ~ carry.~]
        ParaContent(); print " carry."; new_line; .L_Say49; .L_SayX49;} else {
        ! [12: say ~[We] [pick] up a couple of boxes and [flatten] them.[paragraph break]~]
        say__p=1;! [13: we]
        ParaContent(); (PHR_764_r7 ());! [14: ~ ~]
        ParaContent(); print " ";! [15: pick]
        ConjugateVerb_47(CV_POS, PNToVP(), story_tense); say__p=1; ! [16: ~ up a couple of boxes and ~]
        ParaContent(); print " up a couple of boxes and ";! [17: flatten]
        ConjugateVerb_142(CV_POS, PNToVP(), story_tense); say__p=1; ! [18: ~ them.~]
        ParaContent(); print " them.";! [19: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say50; .L_SayX50;! [20: now the player carries the biff-flattened-boxes]
        MoveObject(I467_biff_flattened_boxes,player);
        ! [21: if margaret is in the location]
        if (((real_location == ContainerOf(I358_margaret_chao))))
        {! [22: initiate margaret's box routine]
            (PHR_1430_r23 ());
            }
            }
            RulebookFails(); rtrue;
            } else if (debug_rules > 1) DB_Rule(R_1496, 1496, 'action');
            rfalse;
];
! From "Essentials" by Philip Riley
! No specific request
! Instead of entering an unenterable room:
[ R_961 ;
    if ((((action ==##Enter) &&  (actor==player) && ((noun ofclass K18_unenterable_room))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_961, 961);
    ! [2: say ~You can't enter that.~]
    say__p=1;! [3: ~You can't enter that.~]
    ParaContent(); print "You can't enter that."; new_line; .L_Say51; .L_SayX51;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_961, 961, 'action');
    rfalse;
];
! From "Furniture" by Philip Riley
! No specific request
! Instead of opening a desk ( called D ):
[ R_1039 
    tmp_0 ! Let/loop value, e.g., 'D': desk
    tmp_1 ! Let/loop value, e.g., 'Dr': drawer
    ;
    if ((((action ==##Open) &&  (actor==player) && (tmp_0 = noun, (((noun ofclass K24_desk) && (tmp_0=(noun), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1039, 1039);
    ! [2: if a drawer ( called dr ) is part of d]
    if ((((Prop_19(tmp_0) && (tmp_1=deferred_calling_list-->0, true)) || (tmp_1 = 0,false))))
    {! [3: try opening dr]
        TryAction(0, player, ##Open, tmp_1, 0);
        }
        RulebookFails(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1039, 1039, 'action');
        rfalse;
];
! From "Furniture" by Philip Riley
! No specific request
! Instead of closing a desk ( called D ):
[ R_1040 
    tmp_0 ! Let/loop value, e.g., 'D': desk
    tmp_1 ! Let/loop value, e.g., 'Dr': drawer
    ;
    if ((((action ==##Close) &&  (actor==player) && (tmp_0 = noun, (((noun ofclass K24_desk) && (tmp_0=(noun), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1040, 1040);
    ! [2: if a drawer ( called dr ) is part of d]
    if ((((Prop_20(tmp_0) && (tmp_1=deferred_calling_list-->0, true)) || (tmp_1 = 0,false))))
    {! [3: try closing dr]
        TryAction(0, player, ##Close, tmp_1, 0);
        }
        RulebookFails(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1040, 1040, 'action');
        rfalse;
];
! From "Visible Rooms" by Philip Riley
! No specific request
! Instead of examining a room:
[ R_1057 ;
    if ((((action ==##Examine) &&  (actor==player) && ((noun ofclass K1_room))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1057, 1057);
    ! [2: try looking]
    TryAction(0, player, ##Look, 0, 0);
    rtrue;
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1057, 1057, 'action');
    rfalse;
];
! From "Essentials" by Philip Riley
! No specific request
! Instead of promising when the current interlocutor is not nothing:
[ R_972 ;
    if ((((action ==##A81_promising) &&  (actor==player) && (self=actor,true) && (((~~(((Global_Vars-->11) == nothing)))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_972, 972);
    ! [2: try answering the current interlocutor that ~I promise~]
    TryAction(32, player, ##Answer, (Global_Vars-->11), TX_L_477);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_972, 972, 'action');
    rfalse;
];
! No specific request
! Instead of looking when current play mode is picking character:
[ R_1446 ;
    if ((((action ==##Look) &&  (actor==player) && (self=actor,true) && ((((Global_Vars-->75) == I410_picking_character)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1446, 1446);
    ! [2: do nothing]
    ;
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1446, 1446, 'action');
    rfalse;
];
! From "Can't Go That Way" by Philip Riley
! No specific request
! Instead of going nowhere:
[ R_1106 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(4);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_17();
    @pull formal_par1;
    @pull formal_par0;
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_17 
    tmp_0 ! Let/loop value, e.g., 'ex': text
    ;
    if ((((action ==##Go) &&  (actor==player) && ((MStack-->MstVON(20007,1)) == nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1106, 1106);
    ! [2: let ex be the excuse for location to the noun]
    tmp_0 = I7SFRAME; 
    		BlkValueCopy(tmp_0, 
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K1_room) && (formal_par0 ofclass K1_room))) && (((formal_par1 ofclass K3_direction) && (formal_par1 ofclass K3_direction))))) && ((
                    formal_rv = (PHR_1105_r24 ((I7SFRAME+WORDSIZE*2),formal_par0,formal_par1))) | 1)
                    )|| (ArgumentTypeFailed(41, 40))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par1 = noun) +
                (formal_par0 = real_location)
                ))
        )

    ! Resolution complete
    );
    ! [3: say ~[ex][paragraph break]~]
    say__p=1;! [4: ex]
    ParaContent(); print (TEXT_TY_Say) tmp_0;! [5: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say52; .L_SayX52;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1106, 1106, 'action');
    rfalse;
];
! No specific request
! Instead of stealing equipment:
[ R_1481 ;
    if (((((NAP_3())) &&  (actor==player)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1481, 1481);
    ! [2: say ~The Federal government frowns upon employees taking office equipment home with them.~]
    say__p=1;! [3: ~The Federal government frowns upon employees taking office equipment home with them.~]
    ParaContent(); print "The Federal government frowns upon employees taking office equipment home with them."; new_line; .L_Say53; .L_SayX53;RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1481, 1481, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Instead of implicit-asking:
[ R_809 ;
    if ((((action ==##A68_implicit_asking) &&  (actor==player)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_809, 809);
    ! [2: try asking the current interlocutor about it]
    TryAction(0, player, ##Ask, (Global_Vars-->11), 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_809, 809, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Instead of implicit-telling:
[ R_810 ;
    if ((((action ==##A69_implicit_telling) &&  (actor==player)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_810, 810);
    ! [2: try telling the current interlocutor about it]
    TryAction(0, player, ##Tell, (Global_Vars-->11), 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_810, 810, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Instead of implicit-quizzing:
[ R_811 ;
    if ((((action ==##A70_implicit_quizzing) &&  (actor==player)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_811, 811);
    ! [2: try quizzing the current interlocutor about the noun]
    TryAction(0, player, ##A66_quizzing_it_about, (Global_Vars-->11), noun);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_811, 811, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Instead of implicit-informing:
[ R_812 ;
    if ((((action ==##A71_implicit_informing) &&  (actor==player)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_812, 812);
    ! [2: try informing the current interlocutor about the noun]
    TryAction(0, player, ##A67_informing_it_about, (Global_Vars-->11), noun);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_812, 812, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Instead of implicit-requesting:
[ R_813 ;
    if ((((action ==##A72_implicit_requesting) &&  (actor==player)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_813, 813);
    ! [2: try requesting the current interlocutor for the noun]
    TryAction(0, player, ##A64_requesting_it_for, (Global_Vars-->11), noun);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_813, 813, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Instead of implicit-imploring:
[ R_814 ;
    if ((((action ==##A73_implicit_imploring) &&  (actor==player)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_814, 814);
    ! [2: try imploring the current interlocutor for it]
    TryAction(0, player, ##A65_imploring_it_for, (Global_Vars-->11), 0);
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_814, 814, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: After (B23_after)
! ----------------------------------------------------------------------------------------------------
! Rule 1/22 ! After margaret going to Front Office when the location is front office ( this is the speak to margaret when she enters the front office rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/22 ! After going from the Front Office to the BOSH office hallway for the first time:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 3/22 ! After opening Biff's desk's drawer for the first time:
!   >>> III.5.1 - Action/When/Duration >>>
! Rule 4/22 ! After dropping the mystic compass when the Ethereal Pillar is nowhere:
!   === equally specific with ===
! Rule 5/22 ! After dropping the mystic compass when the Ethereal Pillar is in the Featureless Hyperplane:
!   >>> I - Number of aspects constrained >>>
! Rule 6/22 ! After going from a room ( called R1 ) to a room ( called R2 ):
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 7/22 ! After going to hyperspace:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 8/22 ! After going to a room:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 9/22 ! After quizzing the clerk about the glass case:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 10/22 ! After discussing yes-thumb-drive:
!   === equally specific with ===
! Rule 11/22 ! After discussing hand over the thumb drive:
!   === equally specific with ===
! Rule 12/22 ! After discussing for-a-screwdriver-pawn:
!   === equally specific with ===
! Rule 13/22 ! After discussing about the laundromat owner:
!   === equally specific with ===
! Rule 14/22 ! After entering the broken washing machine:
!   === equally specific with ===
! Rule 15/22 ! After switching off the light switch:
!   === equally specific with ===
! Rule 16/22 ! After switching on the light switch:
!   === equally specific with ===
! Rule 17/22 ! After discussing the whereabouts of the desk key:
!   === equally specific with ===
! Rule 18/22 ! After examining the juvenile sasquatch skull:
!   === equally specific with ===
! Rule 19/22 ! After examining the astral lenses:
!   === equally specific with ===
! Rule 20/22 ! After discussing to borrow the lenses:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 21/22 ! After examining the desk:
!   >>> I - Number of aspects constrained >>>
! Rule 22/22 ! After an actor going ( this is the clear current interlocutor on going rule ):
! ----------------------------------------------------------------------------------------------------
! From "Margaret" by Philip Riley
! No specific request
! After margaret going to Front Office when the location is front office ( this is the speak to margaret when she enters the front office rule ):
[ R_1433 ;
    if ((((action ==##Go) &&  (actor~=player) && (act_requester==nothing) && ((actor == I358_margaret_chao) && (true)) && (((MStack-->MstVON(20007,1)) == I295_the_front_office) && (true)) && (self=actor,true) && (((real_location == I295_the_front_office)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1433, 1433);
    ! [2: if the current interlocutor is not a person]
    if (((~~(((Global_Vars-->11) ofclass K8_person)))))
    {! [3: now the current interlocutor is margaret]
        (Global_Vars-->11) = I358_margaret_chao;
        }
    ! [4: continue the action]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1433, 1433, 'action');
    rfalse;
];
! No specific request
! After going from the Front Office to the BOSH office hallway for the first time:
[ R_1505 ;
    if ((PAPR_0() && (((TimesActionHasHappened-->0) == 1) && (ActionCurrentlyHappeningFlag->0)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1505, 1505);
    ! [2: if the current interlocutor was margaret]
    if ((TestSinglePastState(1, 0, false, 1)))
    {! [3: say ~[We] [extricate] [ourselves] from talking with Margaret.~]
        say__p=1;! [4: we]
        ParaContent(); (PHR_764_r7 ());! [5: ~ ~]
        ParaContent(); print " ";! [6: extricate]
        ConjugateVerb_140(CV_POS, PNToVP(), story_tense); say__p=1; ! [7: ~ ~]
        ParaContent(); print " ";! [8: ourselves]
        ParaContent(); (PHR_762_r25 ());! [9: ~ from talking with Margaret.~]
        ParaContent(); print " from talking with Margaret."; new_line; .L_Say54; .L_SayX54;}
    ! [10: continue the action]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1505, 1505, 'action');
    rfalse;
];
! No specific request
! After opening Biff's desk's drawer for the first time:
[ R_1487 ;
    if ((PAPR_1() && (((TimesActionHasHappened-->1) == 1) && (ActionCurrentlyHappeningFlag->1)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1487, 1487);
    ! [2: now the player does not know desk-locked]
    (RGuard_MF_2(player,I164_desk_locked));
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1487, 1487, 'action');
    rfalse;
];
! From "Hyperspace" by Philip Riley
! No specific request
! After dropping the mystic compass when the Ethereal Pillar is nowhere:
[ R_1246 ;
    if ((((action ==##Drop) &&  (actor==player) && ((noun == I243_mystic_compass) && (true)) && (self=actor,true) && (((LocationOf(I246_ethereal_pillar) == nothing)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1246, 1246);
    ! [2: say ~The mystic compass vanishes!~]
    say__p=1;! [3: ~The mystic compass vanishes!~]
    ParaContent(); print "The mystic compass vanishes!"; new_line; .L_Say55; .L_SayX55;! [4: now the mystic compass is nowhere]
    RemoveFromPlay(I243_mystic_compass);;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1246, 1246, 'action');
    rfalse;
];
! From "Hyperspace" by Philip Riley
! No specific request
! After dropping the mystic compass when the Ethereal Pillar is in the Featureless Hyperplane:
[ R_1247 ;
    if ((((action ==##Drop) &&  (actor==player) && ((noun == I243_mystic_compass) && (true)) && (self=actor,true) && (((I244_featureless_hyperplane == ContainerOf(I246_ethereal_pillar))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1247, 1247);
    ! [2: say ~The mystic compass vanishes and reappears, dangling from the pillar!~]
    say__p=1;! [3: ~The mystic compass vanishes and reappears, dangling from the pillar!~]
    ParaContent(); print "The mystic compass vanishes and reappears, dangling from the pillar!"; new_line; .L_Say56; .L_SayX56;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1247, 1247, 'action');
    rfalse;
];
! No specific request
! After going from a room ( called R1 ) to a room ( called R2 ):
[ R_1504 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(4);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_18();
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_18 
    tmp_0 ! Let/loop value, e.g., 'R1': room
    tmp_1 ! Let/loop value, e.g., 'R2': room
    tmp_2 ! Let/loop value, e.g., 'transition text': text
    ;
    if ((((action ==##Go) &&  (actor==player) && (tmp_0 = (MStack-->MstVON(20007,0)), ((((MStack-->MstVON(20007,0)) ofclass K1_room) && (tmp_0=((MStack-->MstVON(20007,0))), true)))) && (tmp_1 = (MStack-->MstVON(20007,1)), ((((MStack-->MstVON(20007,1)) ofclass K1_room) && (tmp_1=((MStack-->MstVON(20007,1))), true))))) || (tmp_1 = 0,tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1504, 1504);
    ! [2: let transition text be the transition for r1 to r2]
    tmp_2 = I7SFRAME; 
    		BlkValueCopy(tmp_2, (PHR_1502_r26 ((I7SFRAME+WORDSIZE*2),tmp_0,tmp_1)));
    ! [3: if transition text is not ~none~]
    if (((~~(( BlkValueCompare(tmp_2, TX_L_478) == 0)))))
    {! [4: say ~[transition text][paragraph break]~]
        say__p=1;! [5: transition text]
        ParaContent(); print (TEXT_TY_Say) tmp_2;! [6: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say57; .L_SayX57;! [7: mark transition from r1 to r2 as used]
        (PHR_1503_r27 (tmp_0,tmp_1));
        }
    ! [8: continue the action]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1504, 1504, 'action');
    rfalse;
];
! From "Hyperspace" by Philip Riley
! No specific request
! After going to hyperspace:
[ R_1240 ;
    if ((((action ==##Go) &&  (actor==player) && (TestRegionalContainment((MStack-->MstVON(20007,1)),I232_hyperspace))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1240, 1240);
    ! [2: now visited hyperspace is true]
    (Global_Vars-->47) = 1;
    ! [3: continue the action]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1240, 1240, 'action');
    rfalse;
];
! No specific request
! After going to a room:
[ R_1455 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(1, STORED_ACTION_TY);
    BlkValueCreateOnStack(0, STORED_ACTION_TY);
    I7RBLK = KERNEL_19();
    BlkValueFreeOnStack(1);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_19 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) ofclass K1_room))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1455, 1455);
    ! [2: if the current interlocutor is nothing]
    if ((((Global_Vars-->11) == nothing)))
    {! [3: repeat with p running through the people in the location]
        for (tmp_0=Prop_21(0), tmp_1=Prop_21(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_21(tmp_1))
        {! [4: if p is not the player]
            if (((~~((tmp_0 == player)))))
            {! [5: postpone saying hello to p]
                (PHR_1456_r28 (BlkValueCopy(I7SFRAME, TryAction(0, player, ##A74_saying_hello_to, tmp_0, 0, STORED_ACTION_TY_Current((I7SFRAME+WORDSIZE))))));
                ! [6: continue the activity]
                rfalse;
                }
                }
                }
    ! [7: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1455, 1455, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! After quizzing the clerk about the glass case:
[ R_1417 ;
    if ((((action ==##A66_quizzing_it_about) &&  (actor==player) && ((noun == I341_store_clerk) && (true)) && ((second == I350_glass_case) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1417, 1417);
    ! [2: say ~'You want something? Name it.'~]
    say__p=1;! [3: ~'You want something? Name it.'~]
    ParaContent(); print "~You want something? Name it.~"; new_line; .L_Say58; .L_SayX58;rtrue;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1417, 1417, 'action');
    rfalse;
];
! From "Hyperspace" by Philip Riley
! No specific request
! After discussing yes-thumb-drive:
[ R_1262 ;
    if ((((action ==##A103_discussing) &&  (actor==player) && ((noun == I260_yes_thumb_drive) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1262, 1262);
    ! [2: queue doris with hand over the thumb drive]
    (PHR_1209_r18 (I254_doris,I261_hand_over_the_thumb_dri));
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1262, 1262, 'action');
    rfalse;
];
! From "Hyperspace" by Philip Riley
! No specific request
! After discussing hand over the thumb drive:
[ R_1264 ;
    if ((((action ==##A103_discussing) &&  (actor==player) && ((noun == I261_hand_over_the_thumb_dri) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1264, 1264);
    ! [2: silently try giving the thumb drive to doris]
    @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
    ClearParagraphing(1);
    TryAction(0, player, ##Give, I259_thumb_drive, I254_doris);
    DivideParagraphPoint();
    @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1264, 1264, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! After discussing for-a-screwdriver-pawn:
[ R_1406 ;
    if ((((action ==##A103_discussing) &&  (actor==player) && ((noun == I321_for_a_screwdriver_pawn) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1406, 1406);
    ! [2: now player knows screwdriver-in-laundromat]
    (RGuard_MT_2(player,I168_screwdriver_in_laundrom));
    ! [3: continue the action]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1406, 1406, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! After discussing about the laundromat owner:
[ R_1407 ;
    if ((((action ==##A103_discussing) &&  (actor==player) && ((noun == I323_about_the_laundromat_ow) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1407, 1407);
    ! [2: now player knows break-in-to-laundromat]
    (RGuard_MT_2(player,I170_break_in_to_laundromat));
    ! [3: move chief klimp to chief's office]
    MoveObject(I419_chief_huffton_klimp, I454_bosh_chief_s_office, 0, false);
    ! [4: now klimp's door is unlocked]
    (Adj_107_t2_v10(I453_klimp_s_door));
    ! [5: now klimp's door is open]
    (Adj_101_t2_v10(I453_klimp_s_door));
    ! [6: move car 2 to strip mall parking lot north]
    MoveObject(I300_car_2, I312_strip_mall_parking_lot_, 0, false);
    ! [7: continue the action]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1407, 1407, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! After entering the broken washing machine:
[ R_1411 ;
    if ((((action ==##Enter) &&  (actor==player) && ((noun == I336_broken_washing_machine) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1411, 1411);
    ! [2: say ~There is a flash of light and you find yourself somewhere else...~]
    say__p=1;! [3: ~There is a flash of light and you find yourself somewhere else...~]
    ParaContent(); print "There is a flash of light and you find yourself somewhere else..."; new_line; .L_Say59; .L_SayX59;! [4: move the player to the featureless hyperplane]
    MoveObject(player, I244_featureless_hyperplane, 0, false);
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1411, 1411, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! After switching off the light switch:
[ R_1412 ;
    if ((((action ==##SwitchOff) &&  (actor==player) && ((noun == I338_light_switch) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1412, 1412);
    ! [2: now ls-light is not lit]
    (Adj_82_t3_v10(I332_ls_light));
    ! [3: now lbr-light is not lit]
    (Adj_82_t3_v10(I333_lbr_light));
    ! [4: now lb-light is not lit]
    (Adj_82_t3_v10(I334_lb_light));
    ! [5: now bb-light is not lit]
    (Adj_82_t3_v10(I335_bb_light));
    ! [6: continue the action]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1412, 1412, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! After switching on the light switch:
[ R_1413 ;
    if ((((action ==##SwitchOn) &&  (actor==player) && ((noun == I338_light_switch) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1413, 1413);
    ! [2: now ls-light is lit]
    (Adj_82_t2_v10(I332_ls_light));
    ! [3: now lbr-light is lit]
    (Adj_82_t2_v10(I333_lbr_light));
    ! [4: now lb-light is lit]
    (Adj_82_t2_v10(I334_lb_light));
    ! [5: now bb-light is lit]
    (Adj_82_t2_v10(I335_bb_light));
    ! [6: continue the action]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1413, 1413, 'action');
    rfalse;
];
! From "Margaret" by Philip Riley
! No specific request
! After discussing the whereabouts of the desk key:
[ R_1425 ;
    if ((((action ==##A103_discussing) &&  (actor==player) && ((noun == I359_about_the_whereabouts_o) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1425, 1425);
    ! [2: now player knows key-is-lost]
    (RGuard_MT_2(player,I167_key_is_lost));
    ! [3: continue the action]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1425, 1425, 'action');
    rfalse;
];
! No specific request
! After examining the juvenile sasquatch skull:
[ R_1471 ;
    if ((((action ==##Examine) &&  (actor==player) && ((noun == I424_juvenile_sasquatch_skul) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1471, 1471);
    ! [2: queue chief klimp with to borrow the skull]
    (PHR_1209_r18 (I419_chief_huffton_klimp,I423_to_borrow_the_skull));
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1471, 1471, 'action');
    rfalse;
];
! No specific request
! After examining the astral lenses:
[ R_1472 ;
    if ((((action ==##Examine) &&  (actor==player) && ((noun == I426_astral_lenses) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1472, 1472);
    ! [2: queue chief klimp with to borrow the lenses]
    (PHR_1209_r18 (I419_chief_huffton_klimp,I425_to_borrow_the_lenses));
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1472, 1472, 'action');
    rfalse;
];
! No specific request
! After discussing to borrow the lenses:
[ R_1473 ;
    if ((((action ==##A103_discussing) &&  (actor==player) && ((noun == I425_to_borrow_the_lenses) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1473, 1473);
    ! [2: now the player owns the astral lenses]
    (RGuard_MT_7(player,I426_astral_lenses));
    ! [3: silently try taking the astral lenses]
    @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
    ClearParagraphing(1);
    TryAction(0, player, ##Take, I426_astral_lenses, 0);
    DivideParagraphPoint();
    @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

    ! [4: if the player carries the astral lenses]
    if (((player == CarrierOf(I426_astral_lenses))))
    {! [5: say ~[We] [take] the astral lenses.~]
        say__p=1;! [6: we]
        ParaContent(); (PHR_764_r7 ());! [7: ~ ~]
        ParaContent(); print " ";! [8: take]
        ConjugateVerb_61(CV_POS, PNToVP(), story_tense); say__p=1; ! [9: ~ the astral lenses.~]
        ParaContent(); print " the astral lenses."; new_line; .L_Say60; .L_SayX60;}
    ! [10: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1473, 1473, 'action');
    rfalse;
];
! No specific request
! After examining the desk:
[ R_1482 ;
    if ((((action ==##Examine) &&  (actor==player) && ((noun ofclass K24_desk))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1482, 1482);
    ! [2: now player knows hex-screws]
    (RGuard_MT_2(player,I169_hex_screws));
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1482, 1482, 'action');
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! After an actor going ( this is the clear current interlocutor on going rule ):
[ R_1201 ;
    if ((((action ==##Go) && (act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1201, 1201);
    ! [2: if the actor is the current interlocutor and the actor is not visible]
    if ((((actor == (Global_Vars-->11)))) && (((~~(((Adj_3_t1_v10(actor))))))))
    {! [3: now the current interlocutor is nothing]
        (Global_Vars-->11) = nothing;
        }
    ! [4: continue the action]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1201, 1201, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: does the player mean (B25_does_the_player_mean)
! ----------------------------------------------------------------------------------------------------
! Rule 1/12 ! Does the player mean answering a phone ( called P ) when P is not ringing:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 2/12 ! Does the player mean answering a phone ( called P ) when P is ringing:
!   >>> I - Number of aspects constrained >>>
! Rule 3/12 ! Does the player mean discussing an off-limits quip ( called Q ) with the current interlocutor:
!   === equally specific with ===
! Rule 4/12 ! Does the player mean discussing an q-available quip with the current interlocutor:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 5/12 ! Does the player mean discussing an off-limits quip ( called Q ) with someone ( called P ):
!   === equally specific with ===
! Rule 6/12 ! Does the player mean discussing an q-available quip with someone:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 7/12 ! Does the player mean answering the player:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 8/12 ! Does the player mean doing anything to the location:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 9/12 ! Does the player mean taking something which is carried by the player ( this is the very unlikely to mean taking what's already carried rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 10/12 ! Does the player mean discussing an off-limits quip ( called Q ):
!   === equally specific with ===
! Rule 11/12 ! Does the player mean discussing an q-available quip:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 12/12 ! Does the player mean taking off something worn:
! ----------------------------------------------------------------------------------------------------
! From "Phones" by Philip Riley
! No specific request
! Does the player mean answering a phone ( called P ) when P is not ringing:
[ R_1014 
    tmp_0 ! Let/loop value, e.g., 'P': phone
    ;
    if ((((action ==##A84_answering) &&  (actor==player) && (tmp_0 = noun, (((noun ofclass K20_phone) && (tmp_0=(noun), true)))) && (self=actor,true) && (((~~(((Adj_133_t1_v10(tmp_0)))))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1014, 1014);
    ! [2: it is very unlikely]
    RulebookSucceeds(22, RBNO_10); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1014, 1014, 'action');
    rfalse;
];
! From "Phones" by Philip Riley
! No specific request
! Does the player mean answering a phone ( called P ) when P is ringing:
[ R_1013 
    tmp_0 ! Let/loop value, e.g., 'P': phone
    ;
    if ((((action ==##A84_answering) &&  (actor==player) && (tmp_0 = noun, (((noun ofclass K20_phone) && (tmp_0=(noun), true)))) && (self=actor,true) && ((((Adj_133_t1_v10(tmp_0)))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1013, 1013);
    ! [2: it is very likely]
    RulebookSucceeds(22, RBNO_6); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1013, 1013, 'action');
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! Does the player mean discussing an off-limits quip ( called Q ) with the current interlocutor:
[ R_1235 
    tmp_0 ! Let/loop value, e.g., 'Q': quip
    ;
    if ((((action ==##A102_discussing_it_with) &&  (actor==player) && (tmp_0 = noun, (((noun ofclass K29_quip) && ((Adj_65_t1_v10(noun))) && (tmp_0=(noun), true)))) && ((second == (Global_Vars-->11)) && (true))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1235, 1235);
    ! [2: if q quip-supplies the current interlocutor]
    if ((((RGuard_T_11(tmp_0,(Global_Vars-->11))))))
    {! [3: it is unlikely]
        RulebookSucceeds(22, RBNO_9); rtrue;

        }
    ! [4: it is very unlikely]
    RulebookSucceeds(22, RBNO_10); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1235, 1235, 'action');
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! Does the player mean discussing an q-available quip with the current interlocutor:
[ R_1238 ;
    if ((((action ==##A102_discussing_it_with) &&  (actor==player) && ((noun ofclass K29_quip) && ((Adj_64_t1_v10(noun)))) && ((second == (Global_Vars-->11)) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1238, 1238);
    ! [2: it is very likely]
    RulebookSucceeds(22, RBNO_6); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1238, 1238, 'action');
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! Does the player mean discussing an off-limits quip ( called Q ) with someone ( called P ):
[ R_1236 
    tmp_0 ! Let/loop value, e.g., 'Q': quip
    tmp_1 ! Let/loop value, e.g., 'P': person
    ;
    if ((((action ==##A102_discussing_it_with) &&  (actor==player) && (tmp_0 = noun, (((noun ofclass K29_quip) && ((Adj_65_t1_v10(noun))) && (tmp_0=(noun), true)))) && (tmp_1 = second, (((second ofclass K8_person) && (tmp_1=(second), true))))) || (tmp_1 = 0,tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1236, 1236);
    ! [2: if the current interlocutor is not p]
    if (((~~(((Global_Vars-->11) == tmp_1)))))
    {! [3: if q is listed in the queue of p]
        if (((LIST_OF_TY_FindItem(GProperty(10, tmp_1,p29_queue), tmp_0))))
        {! [4: it is likely]
            RulebookSucceeds(22, RBNO_7); rtrue;

            } else {
            ! [5: if p is touchable]
            if ((((Adj_5_t1_v10(tmp_1)))))
            {! [6: it is unlikely]
                RulebookSucceeds(22, RBNO_9); rtrue;

                } else {
                ! [7: it is very unlikely]
                RulebookSucceeds(22, RBNO_10); rtrue;

                }
                }
                }
    ! [8: it is very unlikely]
    RulebookSucceeds(22, RBNO_10); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1236, 1236, 'action');
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! Does the player mean discussing an q-available quip with someone:
[ R_1239 ;
    if ((((action ==##A102_discussing_it_with) &&  (actor==player) && ((noun ofclass K29_quip) && ((Adj_64_t1_v10(noun)))) && ((second ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1239, 1239);
    ! [2: it is likely]
    RulebookSucceeds(22, RBNO_7); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1239, 1239, 'action');
    rfalse;
];
! From "Phones" by Philip Riley
! No specific request
! Does the player mean answering the player:
[ R_1015 ;
    if ((((action ==##A84_answering) &&  (actor==player) && ((noun == player) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1015, 1015);
    ! [2: it is very unlikely]
    RulebookSucceeds(22, RBNO_10); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1015, 1015, 'action');
    rfalse;
];
! From "Visible Rooms" by Philip Riley
! No specific request
! Does the player mean doing anything to the location:
[ R_1056 ;
    if ((( (actor==player) &&  (noun) && (noun == inp1) && ((noun == real_location) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1056, 1056);
    ! [2: it is unlikely]
    RulebookSucceeds(22, RBNO_9); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1056, 1056, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Does the player mean taking something which is carried by the player ( this is the very unlikely to mean taking what's already carried rule ):
[ R_38 ;
    if ((((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing) && (player == CarrierOf(noun)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_38, 38);
    ! [2: it is very unlikely]
    RulebookSucceeds(22, RBNO_10); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_38, 38, 'action');
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! Does the player mean discussing an off-limits quip ( called Q ):
[ R_1233 
    tmp_0 ! Let/loop value, e.g., 'Q': quip
    tmp_1 ! Let/loop value, e.g., 'P': person
    ;
    if ((((action ==##A103_discussing) &&  (actor==player) && (tmp_0 = noun, (((noun ofclass K29_quip) && ((Adj_65_t1_v10(noun))) && (tmp_0=(noun), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1233, 1233);
    ! [2: if q quip-supplies the current interlocutor]
    if ((((RGuard_T_11(tmp_0,(Global_Vars-->11))))))
    {! [3: it is unlikely]
        RulebookSucceeds(22, RBNO_9); rtrue;

        }
    ! [4: if q quip-supplies a visible person ( called p )]
    if ((((Prop_22(tmp_0) && (tmp_1=deferred_calling_list-->0, true)) || (tmp_1 = 0,false))))
    {! [5: it is very likely]
        RulebookSucceeds(22, RBNO_6); rtrue;

        }
    ! [6: it is very unlikely]
    RulebookSucceeds(22, RBNO_10); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1233, 1233, 'action');
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! Does the player mean discussing an q-available quip:
[ R_1237 ;
    if ((((action ==##A103_discussing) &&  (actor==player) && ((noun ofclass K29_quip) && ((Adj_64_t1_v10(noun))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1237, 1237);
    ! [2: it is very likely]
    RulebookSucceeds(22, RBNO_6); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1237, 1237, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Does the player mean taking off something worn:
[ R_240 ;
    if ((((action ==##Disrobe) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_0_t1_v10(noun))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_240, 240);
    ! [2: it is very likely]
    RulebookSucceeds(22, RBNO_6); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_240, 240, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Printing the name (B29_before_printing_the_name)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Before printing the name of a fact ( called target ) while an actor discussing something ( this is the broadcast spoken facts rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/5 ! Before printing the name of a person ( called P ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 3/5 ! Before printing the name of a thing ( called the item being printed ) ( this is the make named things mentioned rule ):
!   === equally specific with ===
! Rule 4/5 ! Before printing the name of a fact ( called target ) ( this is the player learns facts rule ):
!   === equally specific with ===
! Rule 5/5 ! Before printing the name of a thing ( called item ):
! ----------------------------------------------------------------------------------------------------
! From "Facts" by Philip Riley
! No specific request
! Before printing the name of a fact ( called target ) while an actor discussing something ( this is the broadcast spoken facts rule ):
[ R_973 
    tmp_0 ! Let/loop value, e.g., 'target': fact
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K19_fact) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (((((((action ==##A103_discussing) && (act_requester==nothing) && ((noun ofclass K2_thing)))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_973, 973);
    ! [2: repeat with listener running through people who can see the person asked]
    for (tmp_1=Prop_23(0), tmp_2=Prop_23(tmp_1): tmp_1: tmp_1=tmp_2, tmp_2=Prop_23(tmp_2))
    {! [3: now the listener knows the target]
        (RGuard_MT_2(tmp_1,tmp_0));
        }
        } else if (debug_rules > 1) DB_Rule(R_973, 973, 'context');
        } else if (debug_rules > 1) DB_Rule(R_973, 973, 'action');
        rfalse;
];
! From "Gender Options" by Nathanael Nerode
! No specific request
! Before printing the name of a person ( called P ):
[ R_754 
    tmp_0 ! Let/loop value, e.g., 'P': person
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K8_person) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_754, 754);
    ! [2: if not expanding text for comparison purposes]
    if ((~~(((say__comp)))))
    {! [3: now most recent reference of p is nominal]
        WriteGProperty(10, tmp_0,most_recent_reference,I391_nominal);
        ! [4: now last person referenced is p]
        (Global_Vars-->10) = tmp_0;
        }
        } else if (debug_rules > 1) DB_Rule(R_754, 754, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Before printing the name of a thing ( called the item being printed ) ( this is the make named things mentioned rule ):
[ R_66 
    tmp_0 ! Let/loop value, e.g., 'item being printed': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_66, 66);
    ! [2: if expanding text for comparison purposes]
    if ((say__comp))
    {! [3: continue the activity]
        rfalse;
        }
    ! [4: now the item being printed is mentioned]
    (Adj_96_t2_v10(tmp_0));
    } else if (debug_rules > 1) DB_Rule(R_66, 66, 'action');
    rfalse;
];
! From "Facts" by Philip Riley
! No specific request
! Before printing the name of a fact ( called target ) ( this is the player learns facts rule ):
[ R_974 
    tmp_0 ! Let/loop value, e.g., 'target': fact
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K19_fact) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_974, 974);
    ! [2: now the player knows the target]
    (RGuard_MT_2(player,tmp_0));
    } else if (debug_rules > 1) DB_Rule(R_974, 974, 'action');
    rfalse;
];
! From "Gender Options" by Nathanael Nerode
! No specific request
! Before printing the name of a thing ( called item ):
[ R_1434 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1434, 1434);
    ! [2: now the most recent reference of the item is nominal]
    WriteGProperty(10, tmp_0,most_recent_reference,I391_nominal);
    } else if (debug_rules > 1) DB_Rule(R_1434, 1434, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the name (B30_for_printing_the_name)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Rule for printing the name of an informative quip ( called Q ) while listing the available quips:
!   === equally specific with ===
! Rule 2/7 ! Rule for printing the name of a questioning quip ( called Q ) while listing the available quips:
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 3/7 ! Rule for printing the name of a direction ( called dir ) while listing the available choices:
!   >>> I - Number of aspects constrained >>>
! Rule 4/7 ! Rule for printing the name of Margaret Chao:
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 5/7 ! Rule for printing the name of the player:
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 6/7 ! Rule for printing the name of a fact ( this is the silence actual output of facts rule ):
! --- now the last-placed rules ---
! Rule 7/7: STANDARD_NAME_PRINTING_R
! ----------------------------------------------------------------------------------------------------
! From "Simple Conversation" by Philip Riley
! No specific request
! Rule for printing the name of an informative quip ( called Q ) while listing the available quips:
[ R_1196 
    tmp_0 ! Let/loop value, e.g., 'Q': quip
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K29_quip) && ((Adj_152_t1_v10(parameter_value))) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (((TestActivity(V49_listing_the_available_qu)))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1196, 1196);
    ! [2: now what to print is q]
    (Global_Vars-->43) = tmp_0;
    ! [3: say ~tell [the current interlocutor] ~]
    say__p=1;! [4: ~tell ~]
    ParaContent(); print "tell ";! [5: the current interlocutor]
    ParaContent(); print (the) (Global_Vars-->11);! [6: ~ ~]
    ParaContent(); print " "; .L_Say61; .L_SayX61;! [7: print base name]
    STANDARD_NAME_PRINTING_R((Global_Vars-->43));
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1196, 1196, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1196, 1196, 'action');
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! Rule for printing the name of a questioning quip ( called Q ) while listing the available quips:
[ R_1197 
    tmp_0 ! Let/loop value, e.g., 'Q': quip
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K29_quip) && ((Adj_151_t1_v10(parameter_value))) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (((TestActivity(V49_listing_the_available_qu)))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1197, 1197);
    ! [2: now what to print is q]
    (Global_Vars-->43) = tmp_0;
    ! [3: say ~ask ~]
    say__p=1;! [4: ~ask ~]
    ParaContent(); print "ask "; .L_Say62; .L_SayX62;! [5: print base name]
    STANDARD_NAME_PRINTING_R((Global_Vars-->43));
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1197, 1197, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1197, 1197, 'action');
    rfalse;
];
! From "Choices" by Philip Riley
! No specific request
! Rule for printing the name of a direction ( called dir ) while listing the available choices:
[ R_1176 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_20();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_20 
    tmp_0 ! Let/loop value, e.g., 'dir': direction
    tmp_1 ! Let/loop value, e.g., 'farplace': room
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K3_direction) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (((TestActivity(V46_listing_the_available_ch)))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1176, 1176);
    ! [2: let farplace be the room dir from the location]

    		tmp_1 = 
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par1 ofclass K1_room) && (formal_par1 ofclass K1_room))))) && ((
                    formal_rv = MapConnection(formal_par1,formal_par0)) | 1)
                    )|| (ArgumentTypeFailed(65, 21))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par1 = real_location) +
                (formal_par0 = tmp_0)
                ))
        )

    ! Resolution complete
    ;
    ! [3: now what to print is dir]
    (Global_Vars-->43) = tmp_0;
    ! [4: if farplace is visited]
    if ((((Adj_80_t1_v10(tmp_1)))))
    {! [5: print base name]
        STANDARD_NAME_PRINTING_R((Global_Vars-->43));
        ! [6: say ~ ([to-preposition] [destname farplace])~]
        say__p=1;! [7: ~ (~]
        ParaContent(); print " (";! [8: to-preposition]
        ParaContent(); (PHR_1157_r29 ());! [9: ~ ~]
        ParaContent(); print " ";! [10: destname farplace]
        ParaContent(); (PHR_1159_r30 (tmp_1));! [11: ~)~]
        ParaContent(); print ")"; .L_Say63; .L_SayX63;} else {
        ! [12: print base name]
        STANDARD_NAME_PRINTING_R((Global_Vars-->43));
        }
        RulebookSucceeds(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1176, 1176, 'context');
        } else if (debug_rules > 1) DB_Rule(R_1176, 1176, 'action');
        rfalse;
];
! From "Margaret" by Philip Riley
! No specific request
! Rule for printing the name of Margaret Chao:
[ R_1423 ;
    if (((((parameter_value == I358_margaret_chao) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1423, 1423);
    ! [2: say ~Margaret~]
    say__p=1;! [3: ~Margaret~]
    ParaContent(); print "Margaret"; .L_Say64; .L_SayX64;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1423, 1423, 'action');
    rfalse;
];
! From "Third Person Narration" by Philip Riley
! No specific request
! Rule for printing the name of the player:
[ R_1041 ;
    if (((((parameter_value == player) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1041, 1041);
    ! [2: say player's surname]
    say__p=1;! [3: player's surname]
    ParaContent(); print (TEXT_TY_Say) (Global_Vars-->20); .L_Say65; .L_SayX65;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1041, 1041, 'action');
    rfalse;
];
! From "Facts" by Philip Riley
! No specific request
! Rule for printing the name of a fact ( this is the silence actual output of facts rule ):
[ R_975 ;
    if (((((parameter_value ofclass K19_fact))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_975, 975);
    ! [2: do nothing]
    ;
    rtrue;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_975, 975, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the plural name (B33_for_printing_the_plural_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for printing the plural name of something ( called the item ) ( this is the standard printing the plural name rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Rule for printing the plural name of something ( called the item ) ( this is the standard printing the plural name rule ):
[ R_67 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_67, 67);
    ! [2: say the printed plural name of the item]
    say__p=1;! [3: the printed plural name of the item]
    ParaContent(); @push self; print (TEXT_TY_Say) GProperty(10, self=tmp_0,plural);@pull self;  .L_Say66; .L_SayX66;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_67, 67, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing a number (B36_for_printing_a_number)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for printing a number of something ( called the item ) ( this is the standard printing a number of something rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Rule for printing a number of something ( called the item ) ( this is the standard printing a number of something rule ):
[ R_68 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_68, 68);
    ! [2: say ~[listing group size in words] ~]
    say__p=1;! [3: listing group size in words]
    ParaContent(); print (number) say__n=(listing_size);! [4: ~ ~]
    ParaContent(); print " "; .L_Say67; .L_SayX67;! [5: carry out the printing the plural name activity with the item]
    CarryOutActivity(V1_printing_the_plural_name, tmp_0);
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_68, 68, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Writing a paragraph about (B51_for_writing_a_paragraph_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Rule for writing a paragraph about a two-sided door ( called D ) when D is not describable:
!   >>> III - When/while requirement >>>
! Rule 2/6 ! Rule for writing a paragraph about Margaret Chao when the location is the front office:
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 3/6 ! Rule for writing a paragraph about a person ( called P ) when P is phoning:
!   === equally specific with ===
! Rule 4/6 ! Rule for writing a paragraph about a two-sided door ( called D ) when D is describable:
!   >>> I - Number of aspects constrained >>>
! Rule 5/6 ! Rule for writing a paragraph about the Ethereal Pillar:
!   === equally specific with ===
! Rule 6/6 ! Rule for writing a paragraph about the mystic compass:
! ----------------------------------------------------------------------------------------------------
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Rule for writing a paragraph about a two-sided door ( called D ) when D is not describable:
[ R_1351 
    tmp_0 ! Let/loop value, e.g., 'D': two-sided door
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K30_two_sided_door) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if ((((((~~(((Adj_70_t1_v10(tmp_0)))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1351, 1351);
    ! [2: set locale priority of d to 0]
    (PHR_80_r31 (tmp_0,0));
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1351, 1351, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1351, 1351, 'action');
    rfalse;
];
! No specific request
! Rule for writing a paragraph about Margaret Chao when the location is the front office:
[ R_1474 ;
    if (((((parameter_value == I358_margaret_chao) && (true))))) { ! Runs only when pattern matches
    if ((((((real_location == I295_the_front_office)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1474, 1474);
    ! [2: say ~The Bureau's latest office manager, [Margaret Chao] is bustling around with unrestrained enthusiasm~]
    say__p=1;! [3: ~The Bureau's latest office manager, ~]
    ParaContent(); print "The Bureau's latest office manager, ";! [4: margaret chao]
    ParaContent(); PrintShortName(I358_margaret_chao);! [5: ~ is bustling around with unrestrained enthusiasm~]
    ParaContent(); print " is bustling around with unrestrained enthusiasm"; .L_Say68; .L_SayX68;! [6: if the front office is not visited]
    if (((~~(((Adj_80_t1_v10(I295_the_front_office)))))))
    {! [7: say ~, unpacking boxes and assembling an approximation of a respectable front office, all as if the Bureau isn't going to be shut down before the year is out~]
        say__p=1;! [8: ~, unpacking boxes and assembling an approximation of a respectable front office, all as if the Bureau isn't going to be shut down before the year is out~]
        ParaContent(); print ", unpacking boxes and assembling an approximation of a respectable front office, all as if the Bureau isn't going to be shut down before the year is out"; .L_Say69; .L_SayX69;! [9: say ~. She sees [player's surname] and practically [squeal]. '[agent]! I'm sorry -- [player's forename]! How are you? I hope you don't mind -- I took the liberty of putting your desk together. I just love hex wrenches, don't you? Also, your new phone is here. I put it in your desk. Good timing! Now I just need you to give me your old phone so I can deactivate it.'[paragraph break]~]
        say__p=1;! [10: ~. She sees ~]
        ParaContent(); print ". She sees ";! [11: player's surname]
        ParaContent(); print (TEXT_TY_Say) (Global_Vars-->20);! [12: ~ and practically ~]
        ParaContent(); print " and practically ";! [13: squeal]
        ConjugateVerb_117(CV_POS, PNToVP(), story_tense); say__p=1; ! [14: ~. '~]
        ParaContent(); print ". ~";! [15: agent]
        ParaContent(); (PHR_1445_r13 ());! [16: ~! I'm sorry -- ~]
        ParaContent(); print "! I'm sorry -- ";! [17: player's forename]
        ParaContent(); print (TEXT_TY_Say) (Global_Vars-->76);! [18: ~! How are you? I hope you don't mind -- I took the liberty of putting your desk together. I just love hex wrenches, don't you? Also, your new phone is here. I put it in your desk. Good timing! Now I just need you to give me your old phone so I can deactivate it.'~]
        ParaContent(); print "! How are you? I hope you don't mind -- I took the liberty of putting your desk together. I just love hex wrenches, don't you? Also, your new phone is here. I put it in your desk. Good timing! Now I just need you to give me your old phone so I can deactivate it.~";! [19: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say70; .L_SayX70;! [20: say ~[Player] [hand] Margaret [our] old phone. [Margaret] [tap] a few keys on [their] computer and [say] 'There! All settled.'~]
        say__p=1;! [21: player]
        ParaContent(); PrintShortName(player);! [22: ~ ~]
        ParaContent(); print " ";! [23: hand]
        ConjugateVerb_115(CV_POS, PNToVP(), story_tense); say__p=1; ! [24: ~ Margaret ~]
        ParaContent(); print " Margaret ";! [25: our]
        ParaContent(); (PHR_763_r32 ());! [26: ~ old phone. ~]
        ParaContent(); print " old phone. ";! [27: margaret]
        ParaContent(); PrintShortName(I358_margaret_chao);! [28: ~ ~]
        ParaContent(); print " ";! [29: tap]
        ConjugateVerb_118(CV_POS, PNToVP(), story_tense); say__p=1; ! [30: ~ a few keys on ~]
        ParaContent(); print " a few keys on ";! [31: their]
        ParaContent(); (PHR_777_r33 ());! [32: ~ computer and ~]
        ParaContent(); print " computer and ";! [33: say]
        ConjugateVerb_53(CV_POS, PNToVP(), story_tense); say__p=1; ! [34: ~ 'There! All settled.'~]
        ParaContent(); print " ~There! All settled.~"; new_line; .L_Say71; .L_SayX71;! [35: lb]
        (PHR_1437_r34 ());
        ! [36: say ~'Oh, good', [we] [say]. 'Our phone downgrades have arrived from our bureaucratic betters.'~]
        say__p=1;! [37: ~'Oh, good', ~]
        ParaContent(); print "~Oh, good~, ";! [38: we]
        ParaContent(); (PHR_757_r16 ());! [39: ~ ~]
        ParaContent(); print " ";! [40: say]
        ConjugateVerb_53(CV_POS, PNToVP(), story_tense); say__p=1; ! [41: ~. 'Our phone downgrades have arrived from our bureaucratic betters.'~]
        ParaContent(); print ". ~Our phone downgrades have arrived from our bureaucratic betters.~"; new_line; .L_Say72; .L_SayX72;! [42: now the green smartphone is nowhere]
        RemoveFromPlay(I445_green_smartphone);;
        ! [43: now biff's mobile number reaches the blue flipphone]
        (RGuard_MT_6(I422_biff_s_mobile_number,I432_blue_flipphone));
        } else {
        ! [44: say ~.~]
        say__p=1;! [45: ~.~]
        ParaContent(); print "."; new_line; .L_Say73; .L_SayX73;}
        RulebookSucceeds(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1474, 1474, 'context');
        } else if (debug_rules > 1) DB_Rule(R_1474, 1474, 'action');
        rfalse;
];
! From "Phones" by Philip Riley
! No specific request
! Rule for writing a paragraph about a person ( called P ) when P is phoning:
[ R_1031 
    tmp_0 ! Let/loop value, e.g., 'P': person
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K8_person) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (((((((Adj_49_t1_v10(tmp_0)))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1031, 1031);
    ! [2: say ~[The P] is on the phone.~]
    say__p=1;! [3: the p]
    ParaContent(); print (The) tmp_0;! [4: ~ is on the phone.~]
    ParaContent(); print " is on the phone."; new_line; .L_Say74; .L_SayX74;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1031, 1031, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1031, 1031, 'action');
    rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Rule for writing a paragraph about a two-sided door ( called D ) when D is describable:
[ R_1350 
    tmp_0 ! Let/loop value, e.g., 'D': two-sided door
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K30_two_sided_door) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (((((((Adj_70_t1_v10(tmp_0)))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1350, 1350);
    ! [2: say ~[The D] is [if D is closed]closed[otherwise]open[end if].~]
    say__p=1;! [3: the d]
    ParaContent(); print (The) tmp_0;! [4: ~ is ~]
    ParaContent(); print " is ";! [5: if d is closed]

    	if (~~(((((Adj_102_t1_v10(tmp_0))))))) jump L_Say75;! [6: ~closed~]
    ParaContent(); print "closed";! [7: otherwise]

    	jump L_SayX75; .L_Say75;! [8: ~open~]
    ParaContent(); print "open";! [9: end if]

    	.L_Say76; .L_SayX75;! [10: ~.~]
    ParaContent(); print "."; new_line; .L_Say77; .L_SayX76;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1350, 1350, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1350, 1350, 'action');
    rfalse;
];
! From "Hyperspace" by Philip Riley
! No specific request
! Rule for writing a paragraph about the Ethereal Pillar:
[ R_1253 ;
    if (((((parameter_value == I246_ethereal_pillar) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1253, 1253);
    ! [2: now visited pillar is true]
    (Global_Vars-->49) = 1;
    ! [3: say ~There is an ethereal pillar here. A message carved into the pillar says 'Seek the origin. -Doris'[line break]~]
    say__p=1;! [4: ~There is an ethereal pillar here. A message carved into the pillar says 'Seek the origin. -Doris'~]
    ParaContent(); print "There is an ethereal pillar here. A message carved into the pillar says ~Seek the origin. -Doris~";! [5: line break]
    ParaContent(); new_line; .L_Say78; .L_SayX77;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1253, 1253, 'action');
    rfalse;
];
! From "Hyperspace" by Philip Riley
! No specific request
! Rule for writing a paragraph about the mystic compass:
[ R_1254 ;
    if (((((parameter_value == I243_mystic_compass) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1254, 1254);
    ! [2: say ~A mystic compass dangles from an outcropping of the pillar.~]
    say__p=1;! [3: ~A mystic compass dangles from an outcropping of the pillar.~]
    ParaContent(); print "A mystic compass dangles from an outcropping of the pillar."; new_line; .L_Say79; .L_SayX78;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1254, 1254, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the announcement of light (B66_for_printing_the_announc)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! This is the look around once light available rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! This is the look around once light available rule:
[ R_69 ;
    if (debug_rules) DB_Rule(R_69, 69);
    ! [2: try looking]
    TryAction(0, player, ##Look, 0, 0);
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Constructing the status line (B72_for_constructing_the_sta)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Rule for constructing the status line when current play mode is picking character:
!   >>> I - Number of aspects constrained >>>
! Rule 2/3 ! Rule for constructing the status line ( this is the exit lister status line rule ):
!   === equally specific with ===
! Rule 3/3 ! Rule for constructing the status line:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Rule for constructing the status line when current play mode is picking character:
[ R_1448 ;
    if (((((((Global_Vars-->75) == I410_picking_character)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1448, 1448);
    ! [2: do nothing]
    ;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1448, 1448, 'context');
    rfalse;
];
! From "Exit Lister" by Eric Eve
! No specific request
! Rule for constructing the status line ( this is the exit lister status line rule ):
[ R_1142 ;
    if (debug_rules) DB_Rule(R_1142, 1142);
    ! [2: if exit listing is enabled]
    if ((((Global_Vars-->33) == I210_enabled)))
    {! [3: fill status bar with the status exit table]
        (PHR_906_r35 ((Global_Vars-->31)));
        } else {
        ! [4: fill status bar with the standard status table]
        (PHR_906_r35 ((Global_Vars-->32)));
        }
    ! [5: rule succeeds]
    RulebookSucceeds(); rtrue;
    RulebookSucceeds(); rtrue;
    rfalse;
];
! No specific request
! Rule for constructing the status line:
[ R_1450 ;
    if (debug_rules) DB_Rule(R_1450, 1450);
    ! [2: fill status bar with table of fancy status]
    (PHR_906_r35 (T18_fancy_status));
    ! [3: rule succeeds]
    RulebookSucceeds(); rtrue;
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the banner text (B75_for_printing_the_banner_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for printing the banner text when current play mode is picking character:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Rule for printing the banner text when current play mode is picking character:
[ R_1447 ;
    if (((((((Global_Vars-->75) == I410_picking_character)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1447, 1447);
    ! [2: do nothing]
    ;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1447, 1447, 'context');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Reading a command (B77_before_reading_a_command)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Before reading a command ( this is the clear LPR rule ):
!   === equally specific with ===
! Rule 2/2 ! Before reading a command ( this is the reset skip sounds rule ):
! ----------------------------------------------------------------------------------------------------
! From "Gender Options" by Nathanael Nerode
! No specific request
! Before reading a command ( this is the clear LPR rule ):
[ R_753 ;
    if (debug_rules) DB_Rule(R_753, 753);
    ! [2: now last person referenced is nothing]
    (Global_Vars-->10) = nothing;
    rfalse;
];
! No specific request
! Before reading a command ( this is the reset skip sounds rule ):
[ R_1453 ;
    if (debug_rules) DB_Rule(R_1453, 1453);
    ! [2: now skip sounds this turn is false]
    (Global_Vars-->17) = 0;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Reading a command (B79_after_reading_a_command)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! After reading a command when current play mode is picking character:
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! After reading a command:
! ----------------------------------------------------------------------------------------------------
! No specific request
! After reading a command when current play mode is picking character:
[ R_1440 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_21();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_21 ;
    if (((((((Global_Vars-->75) == I410_picking_character)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1440, 1440);
    ! [2: if the player's command matches ~1~]
    if (((SnippetMatches(players_command, Consult_Grammar_201))))
    {! [3: now the player is ezra gaunt]
        ChangePlayer(I404_ezra_gaunt);
        ! [4: now player's forename is ~Ezra~]
        BlkValueCopy((Global_Vars-->76), TX_L_479);
        ! [5: now player's full name is ~Ezra Gaunt~]
        BlkValueCopy((Global_Vars-->77), TX_L_286);
        ! [6: now player's surname is ~Gaunt~]
        BlkValueCopy((Global_Vars-->20), TX_L_480);
        } else {
        ! [7: if the player's command matches ~2~]
        if (((SnippetMatches(players_command, Consult_Grammar_202))))
        {! [8: now the player is petula goldberg]
            ChangePlayer(I405_petula_goldberg);
            ! [9: now player's forename is ~Petula~]
            BlkValueCopy((Global_Vars-->76), TX_L_481);
            ! [10: now player's full name is ~Petula Goldberg~]
            BlkValueCopy((Global_Vars-->77), TX_L_288);
            ! [11: now player's surname is ~Goldberg~]
            BlkValueCopy((Global_Vars-->20), TX_L_482);
            } else {
            ! [12: if the player's command matches ~3~]
            if (((SnippetMatches(players_command, Consult_Grammar_203))))
            {! [13: now the player is larch faraji]
                ChangePlayer(I406_larch_faraji);
                ! [14: now player's forename is ~Larch~]
                BlkValueCopy((Global_Vars-->76), TX_L_475);
                ! [15: now player's full name is ~Larch Faraji~]
                BlkValueCopy((Global_Vars-->77), TX_L_290);
                ! [16: now player's surname is ~Faraji~]
                BlkValueCopy((Global_Vars-->20), TX_L_476);
                } else {
                ! [17: say ~Please select 1, 2, or 3.~]
                say__p=1;! [18: ~Please select 1, 2, or 3.~]
                ParaContent(); print "Please select 1, 2, or 3."; new_line; .L_Say80; .L_SayX79;! [19: reject the player's command]
                RulebookFails(); rtrue;
                }
                }
                }
    ! [20: set possessives]
    (PHR_1442_r6 ());
    ! [21: now the command prompt is ~>~]
    BlkValueCopy((Global_Vars-->1), TX_L_452);
    ! [22: now current play mode is _normal]
    (Global_Vars-->75) = I409__normal;
    ! [23: move the player to the isolation booth]
    MoveObject(player, I411_isolation_booth, 0, false);
    ! [24: follow the current graphics drawing rule]
    FollowRulebook((Global_Vars-->70));
    ! [25: say line break]
    say__p=1;! [26: line break]
    ParaContent(); new_line; .L_Say81; .L_SayX80;! [27: say ~The government functionary cracks, 'You can hold the life story.' He punches a few keys on his computer, stands up and says 'Thank you, Agent [player's surname]. You're all processed for the move to the new BOSH offices. Now if you'll excuse me, it's time to go home.'[paragraph break]~]
    say__p=1;! [28: ~The government functionary cracks, 'You can hold the life story.' He punches a few keys on his computer, stands up and says 'Thank you, Agent ~]
    ParaContent(); print "The government functionary cracks, ~You can hold the life story.~ He punches a few keys on his computer, stands up and says ~Thank you, Agent ";! [29: player's surname]
    ParaContent(); print (TEXT_TY_Say) (Global_Vars-->20);! [30: ~. You're all processed for the move to the new BOSH offices. Now if you'll excuse me, it's time to go home.'~]
    ParaContent(); print ". You're all processed for the move to the new BOSH offices. Now if you'll excuse me, it's time to go home.~";! [31: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say82; .L_SayX81;! [32: say ~[Player] stands, and collecting [our] briefcase, turns and strides out of the office.[paragraph break]~]
    say__p=1;! [33: player]
    ParaContent(); PrintShortName(player);! [34: ~ stands, and collecting ~]
    ParaContent(); print " stands, and collecting ";! [35: our]
    ParaContent(); (PHR_763_r32 ());! [36: ~ briefcase, turns and strides out of the office.~]
    ParaContent(); print " briefcase, turns and strides out of the office.";! [37: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say83; .L_SayX82;! [38: continue]
    (PHR_1444_r36 ());
    ! [39: say ~[banner text][line break]~]
    say__p=1;! [40: banner text]
    ParaContent(); Banner();! [41: line break]
    ParaContent(); new_line; .L_Say84; .L_SayX83;! [42: continue]
    (PHR_1444_r36 ());
    ! [43: say intro text]
    say__p=1;! [44: intro text]
    ParaContent(); print (TEXT_TY_Say) (TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_247)); .L_Say85; .L_SayX84;! [45: continue]
    (PHR_1444_r36 ());
    ! [46: init player]
    (PHR_1441_r4 ());
    ! [47: init office]
    (PHR_1485_r5 ());
    ! [48: try unknown voice calling the blue flipphone on mysterious phone]
    TryAction(0, I498_unknown_voice, ##A82_calling_it_on, I432_blue_flipphone, I499_mysterious_phone);
    ! [49: move klimp to the room of stuff]
    MoveObject(I419_chief_huffton_klimp, I357_room_of_stuff, 0, false);
    ! [50: move moira to the room of stuff]
    MoveObject(I427_moira_zin, I357_room_of_stuff, 0, false);
    ! [51: move the player to the strip mall parking lot south]
    MoveObject(player, I294_strip_mall_parking_lot_, 0, false);
    ! [52: follow the current graphics drawing rule]
    FollowRulebook((Global_Vars-->70));
    ! [53: reject the player's command]
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1440, 1440, 'context');
    rfalse;
];
! No specific request
! After reading a command:
[ R_1443 ;
    if (debug_rules) DB_Rule(R_1443, 1443);
    ! [2: remove stray punctuation]
    PunctuationStripping(); players_command = 100 + WordCount();
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Deciding the scope (B82_after_deciding_the_scope)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! After deciding the scope of the player while discussing , discussing something with ( this is the quip scope handling rule ):
!   >>> III - When/while requirement >>>
! Rule 2/3 ! After deciding the scope of the player while the player is talking with someone ( called callee ) ( this is the place callee in scope rule ):
!   >>> III - When/while requirement >>>
! Rule 3/3 ! After deciding the scope of the player while examining ( this is the place the room in scope while looking rule ):
! ----------------------------------------------------------------------------------------------------
! From "Simple Conversation" by Philip Riley
! No specific request
! After deciding the scope of the player while discussing , discussing something with ( this is the quip scope handling rule ):
[ R_1199 ;
    if (((((parameter_value == player) && (true))))) { ! Runs only when pattern matches
    if (((((((action ==##A103_discussing) &&  (actor==player))))) || (((((action ==##A102_discussing_it_with) &&  (actor==player) && ((noun ofclass K2_thing)))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1199, 1199);
    ! [2: place the contents of the room of quips in scope]
    ScopeWithin(I231_room_of_quips);
    } else if (debug_rules > 1) DB_Rule(R_1199, 1199, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1199, 1199, 'action');
    rfalse;
];
! From "Phones" by Philip Riley
! No specific request
! After deciding the scope of the player while the player is talking with someone ( called callee ) ( this is the place callee in scope rule ):
[ R_1018 
    tmp_0 ! Let/loop value, e.g., 'callee': person
    ;
    if (((((parameter_value == player) && (true))))) { ! Runs only when pattern matches
    if (((((((Prop_24() && (tmp_0=deferred_calling_list-->0, true)) || (tmp_0 = 0,false))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1018, 1018);
    ! [2: place callee in scope]
    PlaceInScope(tmp_0, 0);
    } else if (debug_rules > 1) DB_Rule(R_1018, 1018, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1018, 1018, 'action');
    rfalse;
];
! From "Visible Rooms" by Philip Riley
! No specific request
! After deciding the scope of the player while examining ( this is the place the room in scope while looking rule ):
[ R_1055 ;
    if (((((parameter_value == player) && (true))))) { ! Runs only when pattern matches
    if (((((((action ==##Examine) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1055, 1055);
    ! [2: place the location in scope , but not its contents]
    PlaceInScope(real_location, 1);
    } else if (debug_rules > 1) DB_Rule(R_1055, 1055, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1055, 1055, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Deciding the concealed possessions (B84_for_deciding_the_conceal)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for deciding the concealed possessions of margaret:
! ----------------------------------------------------------------------------------------------------
! From "Margaret" by Philip Riley
! No specific request
! Rule for deciding the concealed possessions of margaret:
[ R_1432 ;
    if (((((parameter_value == I358_margaret_chao) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1432, 1432);
    ! [2: if the particular possession is the margaret-flattened-boxes]
    if (((particular_possession == I468_margaret_flattened_boxe)))
    {! [3: no]
        rfalse;
        } else {
        ! [4: yes]
        rtrue;
        }
        RulebookSucceeds(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1432, 1432, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Deciding whether all includes (B87_for_deciding_whether_all)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Rule for deciding whether all includes a person while dropping or throwing or inserting or putting ( this is the exclude people from drop all rule ):
!   >>> III - When/while requirement >>>
! Rule 2/5 ! Rule for deciding whether all includes scenery while taking or taking off or removing ( this is the exclude scenery from take all rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 3/5 ! Rule for deciding whether all includes things enclosed by the person reaching while taking or taking off or removing ( this is the exclude indirect possessions from take all rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 4/5 ! Rule for deciding whether all includes fixed in place things while taking or taking off or removing ( this is the exclude fixed in place things from take all rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 5/5 ! Rule for deciding whether all includes people while taking or taking off or removing ( this is the exclude people from take all rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Rule for deciding whether all includes a person while dropping or throwing or inserting or putting ( this is the exclude people from drop all rule ):
[ R_74 ;
    if (((((parameter_value ofclass K8_person))))) { ! Runs only when pattern matches
    if (((((((action ==##Drop) &&  (actor==player))))) || (((((action ==##ThrowAt) &&  (actor==player))))) || (((((action ==##Insert) &&  (actor==player))))) || (((((action ==##PutOn) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_74, 74);
    ! [2: it does not]
    RulebookFails(22, RBNO_11); rtrue;

    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_74, 74, 'context');
    } else if (debug_rules > 1) DB_Rule(R_74, 74, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Rule for deciding whether all includes scenery while taking or taking off or removing ( this is the exclude scenery from take all rule ):
[ R_70 ;
    if ((((((Adj_88_t1_v10(parameter_value))) && (true))))) { ! Runs only when pattern matches
    if (((((((action ==##Take) &&  (actor==player))))) || (((((action ==##Disrobe) &&  (actor==player))))) || (((((action ==##Remove) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_70, 70);
    ! [2: it does not]
    RulebookFails(22, RBNO_11); rtrue;

    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_70, 70, 'context');
    } else if (debug_rules > 1) DB_Rule(R_70, 70, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Rule for deciding whether all includes things enclosed by the person reaching while taking or taking off or removing ( this is the exclude indirect possessions from take all rule ):
[ R_73 ;
    if (((((parameter_value ofclass K2_thing) && (IndirectlyContains(actor,parameter_value)))))) { ! Runs only when pattern matches
    if (((((((action ==##Take) &&  (actor==player))))) || (((((action ==##Disrobe) &&  (actor==player))))) || (((((action ==##Remove) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_73, 73);
    ! [2: it does not]
    RulebookFails(22, RBNO_11); rtrue;

    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_73, 73, 'context');
    } else if (debug_rules > 1) DB_Rule(R_73, 73, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Rule for deciding whether all includes fixed in place things while taking or taking off or removing ( this is the exclude fixed in place things from take all rule ):
[ R_72 ;
    if (((((parameter_value ofclass K2_thing) && ((Adj_86_t1_v10(parameter_value))))))) { ! Runs only when pattern matches
    if (((((((action ==##Take) &&  (actor==player))))) || (((((action ==##Disrobe) &&  (actor==player))))) || (((((action ==##Remove) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_72, 72);
    ! [2: it does not]
    RulebookFails(22, RBNO_11); rtrue;

    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_72, 72, 'context');
    } else if (debug_rules > 1) DB_Rule(R_72, 72, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Rule for deciding whether all includes people while taking or taking off or removing ( this is the exclude people from take all rule ):
[ R_71 ;
    if (((((parameter_value ofclass K8_person))))) { ! Runs only when pattern matches
    if (((((((action ==##Take) &&  (actor==player))))) || (((((action ==##Disrobe) &&  (actor==player))))) || (((((action ==##Remove) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_71, 71);
    ! [2: it does not]
    RulebookFails(22, RBNO_11); rtrue;

    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_71, 71, 'context');
    } else if (debug_rules > 1) DB_Rule(R_71, 71, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Clarifying the parser's choice (B90_for_clarifying_the_parse)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for clarifying the parser's choice of a quip ( called Q ):
! ----------------------------------------------------------------------------------------------------
! From "Simple Conversation" by Philip Riley
! No specific request
! Rule for clarifying the parser's choice of a quip ( called Q ):
[ R_1232 
    tmp_0 ! Let/loop value, e.g., 'Q': quip
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K29_quip) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1232, 1232);
    ! [2: now the current interlocutor is a random visible thing quip-supplied by q]
    (Global_Vars-->11) = (Prop_25(tmp_0));
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1232, 1232, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Supplying a missing noun (B99_for_supplying_a_missing_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Rule for supplying a missing noun while an actor going ( this is the block vaguely going rule ):
! --- now the last-placed rules ---
! Rule 2/2 ! Rule for supplying a missing noun while entering ( this is the find what to enter rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Rule for supplying a missing noun while an actor going ( this is the block vaguely going rule ):
[ R_75 ;
    if (((((((action ==##Go) && (act_requester==nothing))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_75, 75);
    ! [2: say ~You'll have to say which compass direction to go in.~ ( a )]
    say__p=1;! [3: ~You'll have to say which compass direction to go in.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_146); new_line; .L_Say86; .L_SayX85;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_75, 75, 'context');
    rfalse;
];
! From the Standard Rules
! No specific request
! Rule for supplying a missing noun while entering ( this is the find what to enter rule ):
[ R_160 
    tmp_0 ! Let/loop value, e.g., 'box': thing
    ;
    if (((((((action ==##Enter) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_160, 160);
    ! [2: if something enterable ( called the box ) is in the location]
    if ((((Prop_26() && (tmp_0=deferred_calling_list-->0, true)) || (tmp_0 = 0,false))))
    {! [3: now the noun is the box]
        noun = tmp_0;
        } else {
        ! [4: continue the activity]
        rfalse;
        }
        RulebookSucceeds(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_160, 160, 'context');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Supplying a missing second noun (B102_for_supplying_a_missing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Rule for supplying a missing second noun while cold-calling:
!   === equally specific with ===
! Rule 2/2 ! Rule for supplying a missing second noun while buying something ( called the product ) with:
! ----------------------------------------------------------------------------------------------------
! From "Phones" by Philip Riley
! No specific request
! Rule for supplying a missing second noun while cold-calling:
[ R_1005 ;
    if (((((((action ==##A83_cold_calling_it_on) &&  (actor==player))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1005, 1005);
    ! [2: say ~You don't know the number for [topic understood].~]
    say__p=1;! [3: ~You don't know the number for ~]
    ParaContent(); print "You don't know the number for ";! [4: topic understood]
    ParaContent(); PrintSnippet(parsed_number);! [5: ~.~]
    ParaContent(); print "."; new_line; .L_Say87; .L_SayX86;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1005, 1005, 'context');
    rfalse;
];
! From "Commerce" by Philip Riley
! No specific request
! Rule for supplying a missing second noun while buying something ( called the product ) with:
[ R_1032 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(3);
    BlkValueCreateOnStack(2, KD3_list_of_things);
    BlkValueCreateOnStack(1, KD10_list_of_money_cards);
    BlkValueCreateOnStack(0, KD10_list_of_money_cards);
    I7RBLK = KERNEL_22();
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(1);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_22 
    tmp_0 ! Let/loop value, e.g., 'product': thing
    tmp_1 ! Let/loop value, e.g., 'M': list of money cards
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    tmp_4 ! Let/loop value (deallocated by end of phrase)
    tmp_5 ! Let/loop value: number
    ;
    if (((((((action ==##A89_buying_it_with) &&  (actor==player) && (tmp_0 = noun, (((noun ofclass K2_thing) && (tmp_0=(noun), true))))) || (tmp_0 = 0,false)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1032, 1032);
    ! [2: if the player owns the product]
    if (((player == (RGuard_f0_7(tmp_0)))))
    {! [3: say ~You already own that!~]
        say__p=1;! [4: ~You already own that!~]
        ParaContent(); print "You already own that!"; new_line; .L_Say88; .L_SayX87;rtrue;
        }
    ! [6: let m be the list of money cards]
    tmp_1 = I7SFRAME; 
    		BlkValueCopy(tmp_1, (Prop_27((I7SFRAME+WORDSIZE),10)));
    ! [7: if m is empty]
    if ((((Adj_17_t1_v34(tmp_1)))))
    {! [8: say ~You have no way to pay.~]
        say__p=1;! [9: ~You have no way to pay.~]
        ParaContent(); print "You have no way to pay."; new_line; .L_Say89; .L_SayX88;rtrue;
        } else {
        ! [11: let d be a list of things]
        tmp_2 = (I7SFRAME+WORDSIZE*2); 
        		
        ! [12: repeat with dollaz running through m]
        for (tmp_5=tmp_1, tmp_4=1, tmp_3=LIST_OF_TY_GetItem(tmp_5, tmp_4, true): tmp_4<=LIST_OF_TY_GetLength(tmp_5): tmp_4++, tmp_3=LIST_OF_TY_GetItem(tmp_5, tmp_4, true))
        {! [13: if player owns dollaz]
            if (((player == (RGuard_f0_7(tmp_3)))))
            {! [14: add dollaz to d]
                LIST_OF_TY_InsertItem(tmp_2, tmp_3, 0, 0, 0);
                }
                }
        ! [15: if d is empty]
        if ((((Adj_17_t1_v34(tmp_2)))))
        {! [16: say ~You have no way to pay.~]
            say__p=1;! [17: ~You have no way to pay.~]
            ParaContent(); print "You have no way to pay."; new_line; .L_Say90; .L_SayX89;rtrue;
            }
        ! [19: if the number of entries in d is greater than one]
        if (((LIST_OF_TY_GetLength(tmp_2) > 1)))
        {! [20: say ~You must specify how you want to pay.~]
            say__p=1;! [21: ~You must specify how you want to pay.~]
            ParaContent(); print "You must specify how you want to pay."; new_line; .L_Say91; .L_SayX90;rtrue;
            } else {
            ! [23: say ~(with the [entry 1 of D])~]
            say__p=1;! [24: ~(with the ~]
            ParaContent(); print "(with the ";! [25: entry 1 of d]
            ParaContent(); PrintShortName(LIST_OF_TY_GetItem(tmp_2,1));! [26: ~)~]
            ParaContent(); print ")"; .L_Say92; .L_SayX91;! [27: now the second noun is entry 1 of d]
            second = LIST_OF_TY_GetItem(tmp_2,1);
            }
            }
            RulebookSucceeds(); rtrue;
            } else if (debug_rules > 1) DB_Rule(R_1032, 1032, 'context');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Starting the virtual machine (B107_before_starting_the_vir)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Before starting the virtual machine ( this is the sort the Table of User Styles rule ):
!   === equally specific with ===
! Rule 2/3 ! Before starting the virtual machine:
! --- now the last-placed rules ---
! Rule 3/3 ! Last before starting the virtual machine ( this is the set text styles rule ):
! ----------------------------------------------------------------------------------------------------
! From "Glulx Text Effects" by Emily Short
! No specific request
! Before starting the virtual machine ( this is the sort the Table of User Styles rule ):
[ R_914 
    tmp_0 ! Let/loop value, e.g., 'row1': number
    tmp_1 ! Let/loop value, e.g., 'row2': number
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_914, 914);
    ! [2: repeat through the table of user styles]
    @push ct_0; @push ct_1;
    		for (tmp_0=T3_user_styles, tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [3: if there is no style name entry]
        if (((ExistsTableLookUpEntry(ct_0,110,ct_1) == false)))
        {! [4: now the style name entry is all-styles]
            TableLookUpEntry(ct_0,110,ct_1,1,I132_all_styles);
            }
            }
            @pull ct_1; @pull ct_0;! [5: sort the table of user styles in style name order]
    TableSort(T3_user_styles, 110, 1);
    ! [6: let row1 be 1]

    		tmp_0 = 1;
    ! [7: let row2 be 2]

    		tmp_1 = 2;
    ! [8: while row2 <= the number of rows in the table of user styles]
    while (((tmp_1 <= TableRows(T3_user_styles))))
    {! [9: choose row row2 in the table of user styles]
        ct_0 = T3_user_styles; ct_1 = tmp_1;
        ! [10: if there is a style name entry]
        if (((ExistsTableLookUpEntry(ct_0,110,ct_1))))
        {! [11: if ( the style name in row row1 of the table of user styles ) is the style name entry]
            if (((TableLookUpEntry(T3_user_styles,110,tmp_0) == TableLookUpEntry(ct_0,110,ct_1))))
            {! [12: if there is a background color entry]
                if (((ExistsTableLookUpEntry(ct_0,111,ct_1))))
                {! [13: now the background color in row row1 of the table of user styles is the background color entry]
                    BlkValueCopy(TableLookUpEntry(T3_user_styles,111,tmp_0,5), TableLookUpEntry(ct_0,111,ct_1));
                    }
                ! [14: if there is a color entry]
                if (((ExistsTableLookUpEntry(ct_0,112,ct_1))))
                {! [15: now the color in row row1 of the table of user styles is the color entry]
                    BlkValueCopy(TableLookUpEntry(T3_user_styles,112,tmp_0,5), TableLookUpEntry(ct_0,112,ct_1));
                    }
                ! [16: if there is a first line indentation entry]
                if (((ExistsTableLookUpEntry(ct_0,113,ct_1))))
                {! [17: now the first line indentation in row row1 of the table of user styles is the first line indentation entry]
                    TableLookUpEntry(T3_user_styles,113,tmp_0,1,TableLookUpEntry(ct_0,113,ct_1));
                    }
                ! [18: if there is a fixed width entry]
                if (((ExistsTableLookUpEntry(ct_0,114,ct_1))))
                {! [19: now the fixed width in row row1 of the table of user styles is the fixed width entry]
                    TableLookUpEntry(T3_user_styles,114,tmp_0,1,TableLookUpEntry(ct_0,114,ct_1));
                    }
                ! [20: if there is a font weight entry]
                if (((ExistsTableLookUpEntry(ct_0,115,ct_1))))
                {! [21: now the font weight in row row1 of the table of user styles is the font weight entry]
                    TableLookUpEntry(T3_user_styles,115,tmp_0,1,TableLookUpEntry(ct_0,115,ct_1));
                    }
                ! [22: if there is a indentation entry]
                if (((ExistsTableLookUpEntry(ct_0,116,ct_1))))
                {! [23: now the indentation in row row1 of the table of user styles is the indentation entry]
                    TableLookUpEntry(T3_user_styles,116,tmp_0,1,TableLookUpEntry(ct_0,116,ct_1));
                    }
                ! [24: if there is a italic entry]
                if (((ExistsTableLookUpEntry(ct_0,117,ct_1))))
                {! [25: now the italic in row row1 of the table of user styles is the italic entry]
                    TableLookUpEntry(T3_user_styles,117,tmp_0,1,TableLookUpEntry(ct_0,117,ct_1));
                    }
                ! [26: if there is a justification entry]
                if (((ExistsTableLookUpEntry(ct_0,118,ct_1))))
                {! [27: now the justification in row row1 of the table of user styles is the justification entry]
                    TableLookUpEntry(T3_user_styles,118,tmp_0,1,TableLookUpEntry(ct_0,118,ct_1));
                    }
                ! [28: if there is a relative size entry]
                if (((ExistsTableLookUpEntry(ct_0,119,ct_1))))
                {! [29: now the relative size in row row1 of the table of user styles is the relative size entry]
                    TableLookUpEntry(T3_user_styles,119,tmp_0,1,TableLookUpEntry(ct_0,119,ct_1));
                    }
                ! [30: if there is a reversed entry]
                if (((ExistsTableLookUpEntry(ct_0,120,ct_1))))
                {! [31: now the reversed in row row1 of the table of user styles is the reversed entry]
                    TableLookUpEntry(T3_user_styles,120,tmp_0,1,TableLookUpEntry(ct_0,120,ct_1));
                    }
                ! [32: blank out the whole row]
                TableBlankOutRow(ct_0, ct_1);
                } else {
                ! [33: now row1 is row2]
                tmp_0 = tmp_1;
                }
                }
        ! [34: increment row2]
        tmp_1 = tmp_1 + 1;;
        }
        rfalse;
];
! From "Image Strip" by Philip Riley
! No specific request
! Before starting the virtual machine:
[ R_1314 ;
    if (debug_rules) DB_Rule(R_1314, 1314);
    ! [2: do nothing]
    ;
    rfalse;
];
! From "Glulx Text Effects" by Emily Short
! No specific request
! Last before starting the virtual machine ( this is the set text styles rule ):
[ R_915 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(4);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_23();
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_23 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_915, 915);
    ! [2: repeat through the table of user styles]
    @push ct_0; @push ct_1;
    		for (tmp_0=T3_user_styles, tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [3: if there is a background color entry]
        if (((ExistsTableLookUpEntry(ct_0,111,ct_1))))
        {! [4: set the background color for the style name entry to the background color entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,110,ct_1), stylehint_BackColor, GTE_ConvertColour( BlkValueCopy(I7SFRAME, TableLookUpEntry(ct_0,111,ct_1)) ) );
            }
        ! [5: if there is a color entry]
        if (((ExistsTableLookUpEntry(ct_0,112,ct_1))))
        {! [6: set the color for the style name entry to the color entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,110,ct_1), stylehint_TextColor, GTE_ConvertColour( BlkValueCopy((I7SFRAME+WORDSIZE*2), TableLookUpEntry(ct_0,112,ct_1)) ) );
            }
        ! [7: if there is a first line indentation entry]
        if (((ExistsTableLookUpEntry(ct_0,113,ct_1))))
        {! [8: set the first line indentation for the style name entry to the first line indentation entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,110,ct_1), stylehint_ParaIndentation, TableLookUpEntry(ct_0,113,ct_1) );
            }
        ! [9: if there is a fixed width entry]
        if (((ExistsTableLookUpEntry(ct_0,114,ct_1))))
        {! [10: set fixed width for the style name entry to the fixed width entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,110,ct_1), stylehint_Proportional, ( TableLookUpEntry(ct_0,114,ct_1) + 1 ) % 2 );
            }
        ! [11: if there is a font weight entry]
        if (((ExistsTableLookUpEntry(ct_0,115,ct_1))))
        {! [12: set the font weight for the style name entry to the font weight entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,110,ct_1), stylehint_Weight, TableLookUpEntry(ct_0,115,ct_1) - 2 );
            }
        ! [13: if there is a indentation entry]
        if (((ExistsTableLookUpEntry(ct_0,116,ct_1))))
        {! [14: set the indentation for the style name entry to the indentation entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,110,ct_1), stylehint_Indentation, TableLookUpEntry(ct_0,116,ct_1) );
            }
        ! [15: if there is a italic entry]
        if (((ExistsTableLookUpEntry(ct_0,117,ct_1))))
        {! [16: set italic for the style name entry to the italic entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,110,ct_1), stylehint_Oblique, TableLookUpEntry(ct_0,117,ct_1) );
            }
        ! [17: if there is a justification entry]
        if (((ExistsTableLookUpEntry(ct_0,118,ct_1))))
        {! [18: set the justification for the style name entry to the justification entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,110,ct_1), stylehint_Justification, TableLookUpEntry(ct_0,118,ct_1) - 1 );
            }
        ! [19: if there is a relative size entry]
        if (((ExistsTableLookUpEntry(ct_0,119,ct_1))))
        {! [20: set the relative size for the style name entry to the relative size entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,110,ct_1), stylehint_Size, TableLookUpEntry(ct_0,119,ct_1) );
            }
        ! [21: if there is a reversed entry]
        if (((ExistsTableLookUpEntry(ct_0,120,ct_1))))
        {! [22: set reversed for the style name entry to the reversed entry]
            GTE_SetStylehint( wintype_TextBuffer, TableLookUpEntry(ct_0,110,ct_1), stylehint_ReverseColor, TableLookUpEntry(ct_0,120,ct_1) );
            }
            }
            @pull ct_1; @pull ct_0;rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Starting the virtual machine (B108_for_starting_the_virtua)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2: ENABLE_GLULX_ACCEL_R
! --- now the mid-placed rules ---
! Rule 2/2 ! Rule for starting the virtual machine:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Rule for starting the virtual machine:
[ R_1506 ;
    if (debug_rules) DB_Rule(R_1506, 1506);
    ! [2: now the current graphics drawing rule is the standard placement rule]
    (Global_Vars-->70) = R_1335;
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Handling the final question (B116_before_handling_the_fin)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! This is the print the final question rule:
!   === equally specific with ===
! Rule 2/3 ! This is the print the final prompt rule:
! --- now the last-placed rules ---
! Rule 3/3: READ_FINAL_ANSWER_R
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! This is the print the final question rule:
[ R_77 
    tmp_0 ! Let/loop value, e.g., 'named options count': number
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_77, 77);
    ! [2: let named options count be 0]

    		tmp_0 = 0;
    ! [3: repeat through the table of final question options]
    @push ct_0; @push ct_1;
    		for (tmp_1=T0_final_question_options, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [4: if the only if victorious entry is false or the story has ended finally]
        if (((((TableLookUpEntry(ct_0,101,ct_1) && true) == (0 && true)))) || (((story_complete))))
        {! [5: if there is a final response rule entry or the final response activity entry is not empty]
            if ((((ExistsTableLookUpEntry(ct_0,103,ct_1)))) || (((~~(((Adj_17_t1_v33(TableLookUpEntry(ct_0,104,ct_1)))))))))
            {! [6: if there is a final question wording entry]
                if (((ExistsTableLookUpEntry(ct_0,100,ct_1))))
                {! [7: increase named options count by 1]
                    tmp_0 = tmp_0 + 1;;
                    }
                    }
                    }
                    }
                    @pull ct_1; @pull ct_0;! [8: if the named options count is less than 1]
    if (((tmp_0 < 1)))
    {! [9: abide by the immediately quit rule]
        if (FollowRulebook(IMMEDIATELY_QUIT_R)) rtrue;
        }
    ! [10: say ~Would you like to ~ ( a )]
    say__p=1;! [11: ~Would you like to ~ ( a )]
    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),(LocalParking-->3=tmp_1),(LocalParking-->4=tmp_2),TX_R_147); .L_Say93; .L_SayX92;! [12: repeat through the table of final question options]
    @push ct_0; @push ct_1;
    		for (tmp_1=T0_final_question_options, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [13: if the only if victorious entry is false or the story has ended finally]
        if (((((TableLookUpEntry(ct_0,101,ct_1) && true) == (0 && true)))) || (((story_complete))))
        {! [14: if there is a final response rule entry or the final response activity entry is not empty]
            if ((((ExistsTableLookUpEntry(ct_0,103,ct_1)))) || (((~~(((Adj_17_t1_v33(TableLookUpEntry(ct_0,104,ct_1)))))))))
            {! [15: if there is a final question wording entry]
                if (((ExistsTableLookUpEntry(ct_0,100,ct_1))))
                {! [16: say final question wording entry]
                    say__p=1;! [17: final question wording entry]
                    ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,100,ct_1); .L_Say94; .L_SayX93;! [18: decrease named options count by 1]
                    tmp_0 = tmp_0 - 1;;
                    ! [19: if the named options count is 1]
                    if (((tmp_0 == 1)))
                    {! [20: if the serial comma option is active]
                        if ((((Adj_25_t1_v16(6)))))
                        {! [21: say ~,~]
                            say__p=1;! [22: ~,~]
                            ParaContent(); print ","; .L_Say95; .L_SayX94;}
                        ! [23: say ~ or ~ ( b )]
                        say__p=1;! [24: ~ or ~ ( b )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),(LocalParking-->3=tmp_1),(LocalParking-->4=tmp_2),TX_R_148); .L_Say96; .L_SayX95;} else {
                        ! [25: if the named options count is 0]
                        if (((tmp_0 == 0)))
                        {! [26: say ~?[line break]~]
                            say__p=1;! [27: ~?~]
                            ParaContent(); print "?";! [28: line break]
                            ParaContent(); new_line; .L_Say97; .L_SayX96;} else {
                            ! [29: say ~, ~]
                            say__p=1;! [30: ~, ~]
                            ParaContent(); print ", "; .L_Say98; .L_SayX97;}
                            }
                            }
                            }
                            }
                            }
                            @pull ct_1; @pull ct_0;rfalse;
];
! From the Standard Rules
! No specific request
! This is the print the final prompt rule:
[ R_76 ;
    if (debug_rules) DB_Rule(R_76, 76);
    ! [2: say ~> [run paragraph on]~ ( a )]
    say__p=1;! [3: ~> [run paragraph on]~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_149); .L_Say99; .L_SayX98;rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Handling the final question (B117_for_handling_the_final_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! This is the standard respond to final question rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! This is the standard respond to final question rule:
[ R_78 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_78, 78);
    ! [2: repeat through the table of final question options]
    @push ct_0; @push ct_1;
    		for (tmp_0=T0_final_question_options, tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [3: if the only if victorious entry is false or the story has ended finally]
        if (((((TableLookUpEntry(ct_0,101,ct_1) && true) == (0 && true)))) || (((story_complete))))
        {! [4: if there is a final response rule entry or the final response activity entry is not empty]
            if ((((ExistsTableLookUpEntry(ct_0,103,ct_1)))) || (((~~(((Adj_17_t1_v33(TableLookUpEntry(ct_0,104,ct_1)))))))))
            {! [5: if the player's command matches the topic entry]
                if (((SnippetMatches(players_command, TableLookUpEntry(ct_0,102,ct_1)))))
                {! [6: if there is a final response rule entry]
                    if (((ExistsTableLookUpEntry(ct_0,103,ct_1))))
                    {! [7: abide by final response rule entry]
                        if (FollowRulebook(TableLookUpEntry(ct_0,103,ct_1))) rtrue;
                        } else {
                        ! [8: carry out the final response activity entry activity]
                        CarryOutActivity(TableLookUpEntry(ct_0,104,ct_1));
                        }
                    ! [9: rule succeeds]
                    RulebookSucceeds(); rtrue;
                    }
                    }
                    }
                    }
                    @pull ct_1; @pull ct_0;! [10: say ~Please give one of the answers above.~ ( a )]
    say__p=1;! [11: ~Please give one of the answers above.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=ct_0),(LocalParking-->1=ct_1),(LocalParking-->2=tmp_0),(LocalParking-->3=tmp_1),TX_R_150); new_line; .L_Say100; .L_SayX99;rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Printing the locale description (B119_before_printing_the_loc)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Before printing the locale description ( this is the initialise locale description rule ):
!   === equally specific with ===
! Rule 2/2 ! Before printing the locale description ( this is the find notable locale objects rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Before printing the locale description ( this is the initialise locale description rule ):
[ R_81 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    if (debug_rules) DB_Rule(R_81, 81);
    ! [2: now the locale paragraph count is 0]
    (Global_Vars-->9) = 0;
    ! [3: repeat through the table of locale priorities]
    @push ct_0; @push ct_1;
    		for (tmp_0=T1_locale_priorities, tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [4: blank out the whole row]
        TableBlankOutRow(ct_0, ct_1);
        }
        @pull ct_1; @pull ct_0;rfalse;
];
! From the Standard Rules
! No specific request
! Before printing the locale description ( this is the find notable locale objects rule ):
[ R_82 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    ;
    if (debug_rules) DB_Rule(R_82, 82);
    ! [2: let the domain be the parameter-object]

    		tmp_0 = parameter_value;
    ! [3: carry out the choosing notable locale objects activity with the domain]
    CarryOutActivity(V31_choosing_notable_locale_, tmp_0);
    ! [4: continue the activity]
    rfalse;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the locale description (B120_for_printing_the_locale)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! For printing the locale description ( this is the interesting locale paragraphs rule ):
!   === equally specific with ===
! Rule 2/2 ! For printing the locale description ( this is the new you-can-also-see rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! For printing the locale description ( this is the interesting locale paragraphs rule ):
[ R_83 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_83, 83);
    ! [2: let the domain be the parameter-object]

    		tmp_0 = parameter_value;
    ! [3: sort the table of locale priorities in locale description priority order]
    TableSort(T1_locale_priorities, 106, 1);
    ! [4: repeat through the table of locale priorities]
    @push ct_0; @push ct_1;
    		for (tmp_1=T1_locale_priorities, tmp_2=1, ct_0=tmp_1, ct_1=tmp_2:
    			tmp_2<=TableRows(tmp_1):
    			tmp_2++, ct_0=tmp_1, ct_1=tmp_2)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [5: carry out the printing a locale paragraph about activity with the notable-object entry]
        CarryOutActivity(V32_printing_a_locale_paragr, TableLookUpEntry(ct_0,105,ct_1));
        }
        @pull ct_1; @pull ct_0;! [6: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    rfalse;
];
! From "Third Person Narration" by Philip Riley
! No specific request
! For printing the locale description ( this is the new you-can-also-see rule ):
[ R_1043 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    tmp_4 ! Let/loop value (deallocated by end of phrase)
    tmp_5 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_1043, 1043);
    ! [2: let the domain be the parameter-object]

    		tmp_0 = parameter_value;
    ! [3: let the mentionable count be 0]

    		tmp_1 = 0;
    ! [4: repeat with item running through things]
    for (tmp_2=Prop_28(0), tmp_3=Prop_28(tmp_2): tmp_2: tmp_2=tmp_3, tmp_3=Prop_28(tmp_3))
    {! [5: now the item is not marked for listing]
        (Adj_94_t3_v10(tmp_2));
        }
    ! [6: repeat through the table of locale priorities]
    @push ct_0; @push ct_1;
    		for (tmp_2=T1_locale_priorities, tmp_3=1, ct_0=tmp_2, ct_1=tmp_3:
    			tmp_3<=TableRows(tmp_2):
    			tmp_3++, ct_0=tmp_2, ct_1=tmp_3)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [7: if the locale description priority entry is greater than 0]
        if (((TableLookUpEntry(ct_0,106,ct_1) > 0)))
        {! [8: now the notable-object entry is marked for listing]
            (Adj_94_t2_v10(TableLookUpEntry(ct_0,105,ct_1)));
            }
        ! [9: increase the mentionable count by 1]
        tmp_1 = tmp_1 + 1;;
        }
        @pull ct_1; @pull ct_0;! [10: if the mentionable count is greater than 0]
    if (((tmp_1 > 0)))
    {! [11: repeat with item running through things]
        for (tmp_2=Prop_29(0), tmp_3=Prop_29(tmp_2): tmp_2: tmp_2=tmp_3, tmp_3=Prop_29(tmp_3))
        {! [12: if the item is mentioned]
            if ((((Adj_96_t1_v10(tmp_2)))))
            {! [13: now the item is not marked for listing]
                (Adj_94_t3_v10(tmp_2));
                }
                }
        ! [14: begin the listing nondescript items activity with the domain]
        BeginActivity(V8_listing_nondescript_items, tmp_0);
        ! [15: if the number of marked for listing things is 0]
        if ((((Prop_30()) == 0)))
        {! [16: abandon the listing nondescript items activity with the domain]
            AbandonActivity(V8_listing_nondescript_items, tmp_0);
            } else {
            ! [17: if handling the listing nondescript items activity with the domain]
            if (((~~(ForActivity(V8_listing_nondescript_items, tmp_0)))))
            {! [18: if the domain is the location]
                if (((tmp_0 == real_location)))
                {! [19: say ~Also here ~ ( a )]
                    say__p=1;! [20: ~Also here ~ ( a )]
                    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),TX_R_151); .L_Say101; .L_SayX100;} else {
                    ! [21: if the domain is a supporter or the domain is an animal]
                    if ((((tmp_0 ofclass K6_supporter))) || (((tmp_0 ofclass K13_animal))))
                    {! [22: say ~On [the domain] ~ ( b )]
                        say__p=1;! [23: ~On [the domain] ~ ( b )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),TX_R_152); .L_Say102; .L_SayX101;} else {
                        ! [24: say ~In [the domain] ~ ( c )]
                        say__p=1;! [25: ~In [the domain] ~ ( c )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),TX_R_153); .L_Say103; .L_SayX102;}
                        }
                ! [26: let the common holder be nothing]

                		tmp_2 = nothing;
                ! [27: let contents form of list be true]

                		tmp_3 = 1;
                ! [28: repeat with list item running through marked for listing things]
                for (tmp_4=Prop_31(0), tmp_5=Prop_31(tmp_4): tmp_4: tmp_4=tmp_5, tmp_5=Prop_31(tmp_5))
                {! [29: if the holder of the list item is not the common holder]
                    if (((~~(((HolderOf(tmp_4)) == tmp_2)))))
                    {! [30: if the common holder is nothing]
                        if (((tmp_2 == nothing)))
                        {! [31: now the common holder is the holder of the list item]
                            tmp_2 = (HolderOf(tmp_4));
                            } else {
                            ! [32: now contents form of list is false]
                            tmp_3 = 0;
                            }
                            }
                    ! [33: if the list item is mentioned]
                    if ((((Adj_96_t1_v10(tmp_4)))))
                    {! [34: now the list item is not marked for listing]
                        (Adj_94_t3_v10(tmp_4));
                        }
                        }
                ! [35: filter list recursion to unmentioned things]
                list_filter_routine = Prop_32;
                ! [36: if contents form of list is true and the common holder is not nothing]
                if (((((tmp_3 && true) == (1 && true)))) && (((~~((tmp_2 == nothing))))))
                {! [37: list the contents of the common holder , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , listing marked items only , prefacing with is/are]
                    WriteListFrom(child(tmp_2), 3800);
                    } else {
                    ! [38: say ~[a list of marked for listing things including contents]~]
                    say__p=1;! [39: a list of marked for listing things including contents]
                    ParaContent(); objectloop(tmp_4 ofclass Object)
                    			if (((tmp_4 ofclass K2_thing) && ((Adj_94_t1_v10(tmp_4)))))
                    				give tmp_4 workflag2;
                    			else
                    				give tmp_4 ~workflag2;
                    		WriteListOfMarkedObjects(ENGLISH_BIT+RECURSE_BIT+PARTINV_BIT+
                    			TERSE_BIT+CONCEAL_BIT); .L_Say104; .L_SayX103;}
                ! [40: say ~.[line break]~]
                say__p=1;! [41: ~.~]
                ParaContent(); print ".";! [42: line break]
                ParaContent(); new_line; .L_Say105; .L_SayX104;! [43: unfilter list recursion]
                list_filter_routine = 0;
                }
            ! [44: end the listing nondescript items activity with the domain]
            EndActivity(V8_listing_nondescript_items, tmp_0);
            }
            }
    ! [45: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Printing the locale description (B121_after_printing_the_loca)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! After printing the locale description when the location is the front office for the first time during denouement:
!   >>> I - Number of aspects constrained >>>
! Rule 2/5 ! After printing the locale description when player is in the field office chief's office and Doris greeted the player is false:
!   >>> III - When/while requirement >>>
! Rule 3/5 ! After printing the locale description when first options paragraph is true:
!   === equally specific with ===
! Rule 4/5 ! After printing the locale description when the location is Featureless Hyperplane:
!   >>> I - Number of aspects constrained >>>
! Rule 5/5 ! After printing the locale description:
! ----------------------------------------------------------------------------------------------------
! No specific request
! After printing the locale description when the location is the front office for the first time during denouement:
[ R_1460 ;
    if (scene_status-->3 == 1) { ! Runs only during scene
    if (((((TestSinglePastState(0, 1, false, 1) == 1 ))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1460, 1460);
    ! [2: say ~[We] [trip] over a newspaper left up against the door. [We] [pick] it up.~]
    say__p=1;! [3: we]
    ParaContent(); (PHR_764_r7 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: trip]
    ConjugateVerb_144(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ over a newspaper left up against the door. ~]
    ParaContent(); print " over a newspaper left up against the door. ";! [7: we]
    ParaContent(); (PHR_764_r7 ());! [8: ~ ~]
    ParaContent(); print " ";! [9: pick]
    ConjugateVerb_47(CV_POS, PNToVP(), story_tense); say__p=1; ! [10: ~ it up.~]
    ParaContent(); print " it up."; new_line; .L_Say106; .L_SayX105;! [11: now the player carries the copy of the washington herald]
    MoveObject(I461_copy_of_the_washington_,player);
    } else if (debug_rules > 1) DB_Rule(R_1460, 1460, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1460, 1460, 'scene');
    rfalse;
];
! From "Hyperspace" by Philip Riley
! No specific request
! After printing the locale description when player is in the field office chief's office and Doris greeted the player is false:
[ R_1265 ;
    if (((((((I253_field_office_chief_s_of == ContainerOf(player)))) && (((((Global_Vars-->50) && true) == (0 && true)))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1265, 1265);
    ! [2: now doris greeted the player is true]
    (Global_Vars-->50) = 1;
    ! [3: say ~'Ah, [player's forename],' Doris exclaims, standing up to shake [our] hand. 'I've been waiting for you to pay us a visit. Did you bring the thumb drive?'~]
    say__p=1;! [4: ~'Ah, ~]
    ParaContent(); print "~Ah, ";! [5: player's forename]
    ParaContent(); print (TEXT_TY_Say) (Global_Vars-->76);! [6: ~,' Doris exclaims, standing up to shake ~]
    ParaContent(); print ",~ Doris exclaims, standing up to shake ";! [7: our]
    ParaContent(); (PHR_763_r32 ());! [8: ~ hand. 'I've been waiting for you to pay us a visit. Did you bring the thumb drive?'~]
    ParaContent(); print " hand. ~I've been waiting for you to pay us a visit. Did you bring the thumb drive?~"; new_line; .L_Say107; .L_SayX106;! [9: if player carries the thumb drive]
    if (((player == CarrierOf(I259_thumb_drive))))
    {! [10: queue doris with yes-thumb-drive]
        (PHR_1209_r18 (I254_doris,I260_yes_thumb_drive));
        } else {
        ! [11: queue doris with no-thumb-drive]
        (PHR_1209_r18 (I254_doris,I258_no_thumb_drive));
        }
        } else if (debug_rules > 1) DB_Rule(R_1265, 1265, 'context');
        rfalse;
];
! From "Options Paragraph" by Philip Riley
! No specific request
! After printing the locale description when first options paragraph is true:
[ R_1169 ;
    if ((((((((Global_Vars-->41) && true) == (1 && true))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1169, 1169);
    ! [2: carry out the printing the options paragraph activity]
    CarryOutActivity(V45_printing_the_options_par);
    ! [3: now first options paragraph is false]
    (Global_Vars-->41) = 0;
    } else if (debug_rules > 1) DB_Rule(R_1169, 1169, 'context');
    rfalse;
];
! From "Hyperspace" by Philip Riley
! No specific request
! After printing the locale description when the location is Featureless Hyperplane:
[ R_1258 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(4);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_24();
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_24 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((((real_location == I244_featureless_hyperplane)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1258, 1258);
    ! [2: try examining the mystic compass]
    TryAction(0, player, ##Examine, I243_mystic_compass, 0);
    ! [3: if hyperplane coords is not coordinates of pillar]
    if (((~~(( BlkValueCompare((Global_Vars-->45), BC_3022) == 0)))))
    {! [4: let t be the dirstring]
        tmp_0 = I7SFRAME; 
        		BlkValueCopy(tmp_0, (PHR_1252_r37 ((I7SFRAME+WORDSIZE*2))));
        ! [5: let dist be the distance]

        		tmp_1 = (PHR_1256_r38 ());
        ! [6: if dist > 30]
        if (((REAL_NUMBER_TY_Compare(tmp_1, NUMBER_TY_to_REAL_NUMBER_TY(30)) > 0)))
        {! [7: say ~Far off in the distance is some kind of structure, roughly to the [t].~]
            say__p=1;! [8: ~Far off in the distance is some kind of structure, roughly to the ~]
            ParaContent(); print "Far off in the distance is some kind of structure, roughly to the ";! [9: t]
            ParaContent(); print (TEXT_TY_Say) tmp_0;! [10: ~.~]
            ParaContent(); print "."; new_line; .L_Say108; .L_SayX107;} else {
            ! [11: if dist > 10]
            if (((REAL_NUMBER_TY_Compare(tmp_1, NUMBER_TY_to_REAL_NUMBER_TY(10)) > 0)))
            {! [12: say ~In the middle distance is some kind of structure, roughly to the [t].~]
                say__p=1;! [13: ~In the middle distance is some kind of structure, roughly to the ~]
                ParaContent(); print "In the middle distance is some kind of structure, roughly to the ";! [14: t]
                ParaContent(); print (TEXT_TY_Say) tmp_0;! [15: ~.~]
                ParaContent(); print "."; new_line; .L_Say109; .L_SayX108;} else {
                ! [16: if dist > 2]
                if (((REAL_NUMBER_TY_Compare(tmp_1, NUMBER_TY_to_REAL_NUMBER_TY(2)) > 0)))
                {! [17: say ~Not too far off is some kind of structure, roughly to the [t].~]
                    say__p=1;! [18: ~Not too far off is some kind of structure, roughly to the ~]
                    ParaContent(); print "Not too far off is some kind of structure, roughly to the ";! [19: t]
                    ParaContent(); print (TEXT_TY_Say) tmp_0;! [20: ~.~]
                    ParaContent(); print "."; new_line; .L_Say110; .L_SayX109;} else {
                    ! [21: if dist > 0]
                    if (((REAL_NUMBER_TY_Compare(tmp_1, NUMBER_TY_to_REAL_NUMBER_TY(0)) > 0)))
                    {! [22: say ~Close by is some kind of structure to the [t].~]
                        say__p=1;! [23: ~Close by is some kind of structure to the ~]
                        ParaContent(); print "Close by is some kind of structure to the ";! [24: t]
                        ParaContent(); print (TEXT_TY_Say) tmp_0;! [25: ~.~]
                        ParaContent(); print "."; new_line; .L_Say111; .L_SayX110;}
                        }
                        }
                        }
                        }
                        } else if (debug_rules > 1) DB_Rule(R_1258, 1258, 'context');
                        rfalse;
];
! From "Hearing" by Philip Riley
! No specific request
! After printing the locale description:
[ R_982 ;
    if (debug_rules) DB_Rule(R_982, 982);
    ! [2: carry out the printing background sounds activity]
    CarryOutActivity(V36_printing_background_soun);
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Choosing notable locale objects (B123_for_choosing_notable_lo)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! For choosing notable locale objects ( this is the standard notable locale objects rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! For choosing notable locale objects ( this is the standard notable locale objects rule ):
[ R_85 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'held item': object
    ;
    if (debug_rules) DB_Rule(R_85, 85);
    ! [2: let the domain be the parameter-object]

    		tmp_0 = parameter_value;
    ! [3: let the held item be the first thing held by the domain]

    		tmp_1 = (child(tmp_0));
    ! [4: while the held item is a thing]
    while (((tmp_1 ofclass K2_thing)))
    {! [5: set the locale priority of the held item to 5]
        (PHR_80_r31 (tmp_1,5));
        ! [6: now the held item is the next thing held after the held item]
        tmp_1 = (sibling(tmp_1));
        }
    ! [7: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing a locale paragraph about (B126_for_printing_a_locale_p)
! ----------------------------------------------------------------------------------------------------
! Rule 1/9 ! For printing a locale paragraph about a supporter ( called the tabletop ) ( this is the initial appearance on supporters rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 2/9 ! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention player's supporter in room descriptions rule ):
!   === equally specific with ===
! Rule 3/9 ! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention scenery in room descriptions rule ):
!   === equally specific with ===
! Rule 4/9 ! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention undescribed items in room descriptions rule ):
!   === equally specific with ===
! Rule 5/9 ! For printing a locale paragraph about a thing ( called the item ) ( this is the set pronouns from items in room descriptions rule ):
!   === equally specific with ===
! Rule 6/9 ! For printing a locale paragraph about a thing ( called the item ) ( this is the offer items to writing a paragraph about rule ):
!   === equally specific with ===
! Rule 7/9 ! For printing a locale paragraph about a thing ( called the item ) ( this is the use initial appearance in room descriptions rule ):
!   === equally specific with ===
! Rule 8/9 ! For printing a locale paragraph about a thing ( called the item ) ( this is the describe what's on scenery supporters in room descriptions rule ):
!   === equally specific with ===
! Rule 9/9 ! For printing a locale paragraph about a thing ( called the item ) ( this is the describe what's on mentioned supporters in room descriptions rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a supporter ( called the tabletop ) ( this is the initial appearance on supporters rule ):
[ R_92 
    tmp_0 ! Let/loop value, e.g., 'tabletop': supporter
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K6_supporter) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_92, 92);
    ! [2: repeat with item running through not handled things on the tabletop which provide the property initial appearance]
    for (tmp_1=Prop_33(tmp_0,tmp_0,tmp_0,0), tmp_2=Prop_33(tmp_0,tmp_0,tmp_0,tmp_1): tmp_1: tmp_1=tmp_2, tmp_2=Prop_33(tmp_0,tmp_0,tmp_0,tmp_2))
    {! [3: if the item is not a person and the initial appearance of the item is not ~~ and the item is not undescribed]
        if ((((~~((tmp_1 ofclass K8_person))))) && ((((~~(( BlkValueCompare(GProperty(10, tmp_1,initial), EMPTY_TEXT_VALUE) == 0))))) && (((~~(((Adj_93_t1_v10(tmp_1)))))))))
        {! [4: now the item is mentioned]
            (Adj_96_t2_v10(tmp_1));
            ! [5: say initial appearance of the item]
            say__p=1;! [6: initial appearance of the item]
            ParaContent(); @push self; print (TEXT_TY_Say) GProperty(10, self=tmp_1,initial);@pull self;  .L_Say112; .L_SayX111;! [7: say paragraph break]
            say__p=1;! [8: paragraph break]
            ParaContent(); DivideParagraphPoint(); new_line; .L_Say113; .L_SayX112;}
            }
    ! [9: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_92, 92, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention player's supporter in room descriptions rule ):
[ R_86 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_86, 86);
    ! [2: if the item encloses the player]
    if (((IndirectlyContains(tmp_0,player))))
    {! [3: set the locale priority of the item to 0]
        (PHR_80_r31 (tmp_0,0));
        }
    ! [4: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_86, 86, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention scenery in room descriptions rule ):
[ R_87 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_87, 87);
    ! [2: if the item is scenery]
    if ((((Adj_88_t1_v10(tmp_0)))))
    {! [3: set the locale priority of the item to 0]
        (PHR_80_r31 (tmp_0,0));
        }
    ! [4: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_87, 87, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention undescribed items in room descriptions rule ):
[ R_88 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_88, 88);
    ! [2: if the item is undescribed]
    if ((((Adj_93_t1_v10(tmp_0)))))
    {! [3: set the locale priority of the item to 0]
        (PHR_80_r31 (tmp_0,0));
        }
    ! [4: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_88, 88, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the set pronouns from items in room descriptions rule ):
[ R_89 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_89, 89);
    ! [2: if the item is not mentioned]
    if (((~~(((Adj_96_t1_v10(tmp_0)))))))
    {! [3: set pronouns from the item]
        PronounNotice(tmp_0);
        }
    ! [4: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_89, 89, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the offer items to writing a paragraph about rule ):
[ R_90 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_90, 90);
    ! [2: if the item is not mentioned]
    if (((~~(((Adj_96_t1_v10(tmp_0)))))))
    {! [3: if a paragraph break is pending]
        if (((say__p)))
        {! [4: say ~[conditional paragraph break]~]
            say__p=1;! [5: conditional paragraph break]
            ParaContent(); DivideParagraphPoint(); .L_Say114; .L_SayX113;}
        ! [6: carry out the writing a paragraph about activity with the item]
        CarryOutActivity(V7_writing_a_paragraph_about, tmp_0);
        ! [7: if a paragraph break is pending]
        if (((say__p)))
        {! [8: increase the locale paragraph count by 1]
            (Global_Vars-->9) = (Global_Vars-->9) + 1;;
            ! [9: now the item is mentioned]
            (Adj_96_t2_v10(tmp_0));
            ! [10: say ~[conditional paragraph break]~]
            say__p=1;! [11: conditional paragraph break]
            ParaContent(); DivideParagraphPoint(); .L_Say115; .L_SayX114;}
            }
    ! [12: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_90, 90, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the use initial appearance in room descriptions rule ):
[ R_91 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_91, 91);
    ! [2: if the item is not mentioned]
    if (((~~(((Adj_96_t1_v10(tmp_0)))))))
    {! [3: if the item provides the property initial appearance and the item is not handled and the initial appearance of the item is not ~~]
        if ((((WhetherProvides(tmp_0, false, initial)))) && ((((~~(((Adj_91_t1_v10(tmp_0))))))) && (((~~(( BlkValueCompare(GProperty(10, tmp_0,initial), EMPTY_TEXT_VALUE) == 0)))))))
        {! [4: increase the locale paragraph count by 1]
            (Global_Vars-->9) = (Global_Vars-->9) + 1;;
            ! [5: say ~[initial appearance of the item]~]
            say__p=1;! [6: initial appearance of the item]
            ParaContent(); @push self; print (TEXT_TY_Say) GProperty(10, self=tmp_0,initial);@pull self;  .L_Say116; .L_SayX115;! [7: say ~[paragraph break]~]
            say__p=1;! [8: paragraph break]
            ParaContent(); DivideParagraphPoint(); new_line; .L_Say117; .L_SayX116;! [9: if a locale-supportable thing is on the item]
            if ((((Prop_34(tmp_0)))))
            {! [10: repeat with possibility running through things on the item]
                for (tmp_1=Prop_35(tmp_0,0), tmp_2=Prop_35(tmp_0,tmp_1): tmp_1: tmp_1=tmp_2, tmp_2=Prop_35(tmp_0,tmp_2))
                {! [11: now the possibility is marked for listing]
                    (Adj_94_t2_v10(tmp_1));
                    ! [12: if the possibility is mentioned]
                    if ((((Adj_96_t1_v10(tmp_1)))))
                    {! [13: now the possibility is not marked for listing]
                        (Adj_94_t3_v10(tmp_1));
                        }
                        }
                ! [14: say ~On [the item] ~ ( a )]
                say__p=1;! [15: ~On [the item] ~ ( a )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_154); .L_Say118; .L_SayX117;! [16: list the contents of the item , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , prefacing with is/are , listing marked items only]
                WriteListFrom(child(tmp_0), 3800);
                ! [17: say ~.[paragraph break]~]
                say__p=1;! [18: ~.~]
                ParaContent(); print ".";! [19: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say119; .L_SayX118;}
            ! [20: now the item is mentioned]
            (Adj_96_t2_v10(tmp_0));
            }
            }
    ! [21: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_91, 91, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the describe what's on scenery supporters in room descriptions rule ):
[ R_94 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_94, 94);
    ! [2: if the item is scenery and the item does not enclose the player]
    if (((((Adj_88_t1_v10(tmp_0))))) && (((~~((IndirectlyContains(tmp_0,player)))))))
    {! [3: if a locale-supportable thing is on the item]
        if ((((Prop_36(tmp_0)))))
        {! [4: set pronouns from the item]
            PronounNotice(tmp_0);
            ! [5: repeat with possibility running through things on the item]
            for (tmp_1=Prop_37(tmp_0,0), tmp_2=Prop_37(tmp_0,tmp_1): tmp_1: tmp_1=tmp_2, tmp_2=Prop_37(tmp_0,tmp_2))
            {! [6: now the possibility is marked for listing]
                (Adj_94_t2_v10(tmp_1));
                ! [7: if the possibility is mentioned]
                if ((((Adj_96_t1_v10(tmp_1)))))
                {! [8: now the possibility is not marked for listing]
                    (Adj_94_t3_v10(tmp_1));
                    }
                    }
            ! [9: increase the locale paragraph count by 1]
            (Global_Vars-->9) = (Global_Vars-->9) + 1;;
            ! [10: say ~On [the item] ~ ( a )]
            say__p=1;! [11: ~On [the item] ~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_155); .L_Say120; .L_SayX119;! [12: list the contents of the item , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , prefacing with is/are , listing marked items only]
            WriteListFrom(child(tmp_0), 3800);
            ! [13: say ~.[paragraph break]~]
            say__p=1;! [14: ~.~]
            ParaContent(); print ".";! [15: paragraph break]
            ParaContent(); DivideParagraphPoint(); new_line; .L_Say121; .L_SayX120;}
            }
    ! [16: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_94, 94, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! For printing a locale paragraph about a thing ( called the item ) ( this is the describe what's on mentioned supporters in room descriptions rule ):
[ R_95 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_95, 95);
    ! [2: if the item is mentioned and the item is not undescribed and the item is not scenery and the item does not enclose the player]
    if (((((Adj_96_t1_v10(tmp_0))))) && ((((~~(((Adj_93_t1_v10(tmp_0))))))) && ((((~~(((Adj_88_t1_v10(tmp_0))))))) && (((~~((IndirectlyContains(tmp_0,player)))))))))
    {! [3: if a locale-supportable thing is on the item]
        if ((((Prop_38(tmp_0)))))
        {! [4: set pronouns from the item]
            PronounNotice(tmp_0);
            ! [5: repeat with possibility running through things on the item]
            for (tmp_1=Prop_39(tmp_0,0), tmp_2=Prop_39(tmp_0,tmp_1): tmp_1: tmp_1=tmp_2, tmp_2=Prop_39(tmp_0,tmp_2))
            {! [6: now the possibility is marked for listing]
                (Adj_94_t2_v10(tmp_1));
                ! [7: if the possibility is mentioned]
                if ((((Adj_96_t1_v10(tmp_1)))))
                {! [8: now the possibility is not marked for listing]
                    (Adj_94_t3_v10(tmp_1));
                    }
                    }
            ! [9: increase the locale paragraph count by 1]
            (Global_Vars-->9) = (Global_Vars-->9) + 1;;
            ! [10: say ~On [the item] ~ ( a )]
            say__p=1;! [11: ~On [the item] ~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_156); .L_Say122; .L_SayX121;! [12: list the contents of the item , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , prefacing with is/are , listing marked items only]
            WriteListFrom(child(tmp_0), 3800);
            ! [13: say ~.[paragraph break]~]
            say__p=1;! [14: ~.~]
            ParaContent(); print ".";! [15: paragraph break]
            ParaContent(); DivideParagraphPoint(); new_line; .L_Say123; .L_SayX122;}
            }
    ! [16: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_95, 95, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking inventory (B132_carry_out_taking_invent)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out taking inventory ( this is the print empty inventory rule ):
!   === equally specific with ===
! Rule 2/2 ! Carry out taking inventory ( this is the print standard inventory rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out taking inventory ( this is the print empty inventory rule ):
[ R_96 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_96, 96);
    ! [2: if the first thing held by the player is nothing]
    if ((((child(player)) == nothing)))
    {! [3: say ~[We] [are] carrying nothing.~ ( a )]
        say__p=1;! [4: ~[We] [are] carrying nothing.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_157); new_line; .L_Say124; .L_SayX123;rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_96, 96, 'actor');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out taking inventory ( this is the print standard inventory rule ):
[ R_97 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_97, 97);
    ! [2: say ~[We] [are] carrying:[line break]~ ( a )]
    say__p=1;! [3: ~[We] [are] carrying:[line break]~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_158); .L_Say125; .L_SayX124;! [4: list the contents of the player , with newlines , indented , including contents , giving inventory information , with extra indentation]
    WriteListFrom(child(player), 8215);
    } else if (debug_rules > 1) DB_Rule(R_97, 97, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking inventory (B133_report_taking_inventory)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking inventory ( this is the report other people taking inventory rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor taking inventory ( this is the report other people taking inventory rule ):
[ R_98 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_98, 98);
    ! [2: if the actor is not the player and the action is not silent]
    if ((((~~((actor == player))))) && (((keep_silent == false))))
    {! [3: say ~[The actor] [look] through [their] possessions.~ ( a )]
        say__p=1;! [4: ~[The actor] [look] through [their] possessions.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_159); new_line; .L_Say126; .L_SayX125;}
        } else if (debug_rules > 1) DB_Rule(R_98, 98, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Taking (B134_check_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/16 ! Check taking the walls when the location is not walled ( this is the block taking non-existent walls rule ):
!   === equally specific with ===
! Rule 2/16 ! Check taking the floor when the location is not floored ( this is the block taking non-existent floor rule ):
!   === equally specific with ===
! Rule 3/16 ! Check taking the ceiling when the location is not ceilinged ( this is the block taking non-existent ceiling rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 4/16 ! Check taking something ( called target ):
!   >>> I - Number of aspects constrained >>>
! Rule 5/16 ! Check an actor taking ( this is the can't take yourself rule ):
!   === equally specific with ===
! Rule 6/16 ! Check an actor taking ( this is the can't take other people rule ):
!   === equally specific with ===
! Rule 7/16 ! Check an actor taking ( this is the can't take component parts rule ):
!   === equally specific with ===
! Rule 8/16 ! Check an actor taking ( this is the can't take people's possessions rule ):
!   === equally specific with ===
! Rule 9/16 ! Check an actor taking ( this is the can't take items out of play rule ):
!   === equally specific with ===
! Rule 10/16 ! Check an actor taking ( this is the can't take what you're inside rule ):
!   === equally specific with ===
! Rule 11/16 ! Check an actor taking ( this is the can't take what's already taken rule ):
!   === equally specific with ===
! Rule 12/16 ! Check an actor taking ( this is the can't take scenery rule ):
!   === equally specific with ===
! Rule 13/16 ! Check an actor taking ( this is the can only take things rule ):
!   === equally specific with ===
! Rule 14/16 ! Check an actor taking ( this is the can't take what's fixed in place rule ):
!   === equally specific with ===
! Rule 15/16 ! Check an actor taking ( this is the use player's holdall to avoid exceeding carrying capacity rule ):
!   === equally specific with ===
! Rule 16/16 ! Check an actor taking ( this is the can't exceed carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! From "Walls" by Philip Riley
! No specific request
! Check taking the walls when the location is not walled ( this is the block taking non-existent walls rule ):
[ R_1073 ;
    if ((( (actor==player) && ((noun == I192_walls) && (true)) && (self=actor,true) && (((~~(((Adj_51_t1_v10(real_location)))))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1073, 1073);
    ! [2: say ~There are no walls.~ ( a )]
    say__p=1;! [3: ~There are no walls.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_160); new_line; .L_Say127; .L_SayX126;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1073, 1073, 'action');
    rfalse;
];
! From "Floors" by Philip Riley
! No specific request
! Check taking the floor when the location is not floored ( this is the block taking non-existent floor rule ):
[ R_1085 ;
    if ((( (actor==player) && ((noun == I193_floor) && (true)) && (self=actor,true) && (((~~(((Adj_53_t1_v10(real_location)))))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1085, 1085);
    ! [2: say ~There is no floor.~ ( a )]
    say__p=1;! [3: ~There is no floor.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_161); new_line; .L_Say128; .L_SayX127;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1085, 1085, 'action');
    rfalse;
];
! From "Ceilings" by Philip Riley
! No specific request
! Check taking the ceiling when the location is not ceilinged ( this is the block taking non-existent ceiling rule ):
[ R_1102 ;
    if ((( (actor==player) && ((noun == I194_ceiling) && (true)) && (self=actor,true) && (((~~(((Adj_55_t1_v10(real_location)))))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1102, 1102);
    ! [2: say ~There is no ceiling.~ ( a )]
    say__p=1;! [3: ~There is no ceiling.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_162); new_line; .L_Say129; .L_SayX128;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1102, 1102, 'action');
    rfalse;
];
! From "Commerce" by Philip Riley
! No specific request
! Check taking something ( called target ):
[ R_1037 
    tmp_0 ! Let/loop value, e.g., 'target': thing
    ;
    if ((( (actor==player) && (tmp_0 = noun, (((noun ofclass K2_thing) && (tmp_0=(noun), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1037, 1037);
    ! [2: if someone owns the target and the player does not own the target]
    if (((((RGuard_f0_7(tmp_0)) ofclass K8_person))) && (((~~((player == (RGuard_f0_7(tmp_0))))))))
    {! [3: say ~[regarding the target][Those] [belong] to [the owner of the noun].~]
        say__p=1;! [4: regarding the target]
        ParaContent(); RegardingSingleObject(tmp_0);! [5: those]
        ParaContent(); (PHR_772_r39 ());! [6: ~ ~]
        ParaContent(); print " ";! [7: belong]
        ConjugateVerb_91(CV_POS, PNToVP(), story_tense); say__p=1; ! [8: ~ to ~]
        ParaContent(); print " to ";! [9: the owner of the noun]
        ParaContent(); @push self; print (the) GProperty(OBJECT_TY, self=noun,p125_owner);@pull self; ! [10: ~.~]
        ParaContent(); print "."; new_line; .L_Say130; .L_SayX129;rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_1037, 1037, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take yourself rule ):
[ R_99 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_99, 99);
    ! [2: if the actor is the noun]
    if (((actor == noun)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [are] always self-possessed.~ ( a )]
            say__p=1;! [5: ~[We] [are] always self-possessed.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_163); new_line; .L_Say131; .L_SayX130;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_99, 99, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take other people rule ):
[ R_100 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_100, 100);
    ! [2: if the noun is a person]
    if (((noun ofclass K8_person)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~I don't suppose [the noun] [would care] for that.~ ( a )]
            say__p=1;! [5: ~I don't suppose [the noun] [would care] for that.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_164); new_line; .L_Say132; .L_SayX131;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_100, 100, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take component parts rule ):
[ R_101 
    tmp_0 ! Let/loop value, e.g., 'whole': thing
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_101, 101);
    ! [2: if the noun is part of something ( called the whole )]
    if ((((noun.component_parent) ofclass K2_thing) && (tmp_0=((noun.component_parent)), true)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][Those] [seem] to be a part of [the whole].~ ( a )]
            say__p=1;! [5: ~[regarding the noun][Those] [seem] to be a part of [the whole].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_165); new_line; .L_Say133; .L_SayX132;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_101, 101, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take people's possessions rule ):
[ R_102 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'owner': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_102, 102);
    ! [2: let the local ceiling be the common ancestor of the actor with the noun]

    		tmp_0 = (CommonAncestor(actor, noun));
    ! [3: let the owner be the not-counting-parts holder of the noun]

    		tmp_1 = (CoreOfParentOfCoreOf(noun));
    ! [4: while the owner is not nothing and the owner is not the local ceiling]
    while ((((~~((tmp_1 == nothing))))) && (((~~((tmp_1 == tmp_0))))))
    {! [5: if the owner is a person]
        if (((tmp_1 ofclass K8_person)))
        {! [6: if the actor is the player]
            if (((actor == player)))
            {! [7: say ~[regarding the noun][Those] [seem] to belong to [the owner].~ ( a )]
                say__p=1;! [8: ~[regarding the noun][Those] [seem] to belong to [the owner].~ ( a )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_166); new_line; .L_Say134; .L_SayX133;}
            ! [9: stop the action]
            rtrue;
            }
        ! [10: let the owner be the not-counting-parts holder of the owner]
        tmp_1 = (CoreOfParentOfCoreOf(tmp_1));
        }
        } else if (debug_rules > 1) DB_Rule(R_102, 102, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take items out of play rule ):
[ R_103 
    tmp_0 ! Let/loop value, e.g., 'H': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_103, 103);
    ! [2: let h be the noun]

    		tmp_0 = noun;
    ! [3: while h is not nothing and h is not a room]
    while ((((~~((tmp_0 == nothing))))) && (((~~((tmp_0 ofclass K1_room))))))
    {! [4: let h be the not-counting-parts holder of h]
        tmp_0 = (CoreOfParentOfCoreOf(tmp_0));
        }
    ! [5: if h is nothing]
    if (((tmp_0 == nothing)))
    {! [6: if the actor is the player]
        if (((actor == player)))
        {! [7: say ~[regarding the noun][Those] [aren't] available.~ ( a )]
            say__p=1;! [8: ~[regarding the noun][Those] [aren't] available.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_167); new_line; .L_Say135; .L_SayX134;}
        ! [9: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_103, 103, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take what you're inside rule ):
[ R_104 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_104, 104);
    ! [2: let the local ceiling be the common ancestor of the actor with the noun]

    		tmp_0 = (CommonAncestor(actor, noun));
    ! [3: if the local ceiling is the noun]
    if (((tmp_0 == noun)))
    {! [4: if the actor is the player]
        if (((actor == player)))
        {! [5: say ~[We] [would have] to get [if noun is a supporter]off[otherwise]out of[end if] [the noun] first.~ ( a )]
            say__p=1;! [6: ~[We] [would have] to get [if noun is a supporter]off[otherwise]out of[end if] [the noun] first.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_168); new_line; .L_Say136; .L_SayX135;}
        ! [7: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_104, 104, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take what's already taken rule ):
[ R_105 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_105, 105);
    ! [2: if the actor is carrying the noun or the actor is wearing the noun]
    if ((((actor == CarrierOf(noun)))) || (((actor == WearerOf(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] already [have] [regarding the noun][those].~ ( a )]
            say__p=1;! [5: ~[We] already [have] [regarding the noun][those].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_169); new_line; .L_Say137; .L_SayX136;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_105, 105, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take scenery rule ):
[ R_106 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_106, 106);
    ! [2: if the noun is scenery]
    if ((((Adj_88_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They're] hardly portable.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They're] hardly portable.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_170); new_line; .L_Say138; .L_SayX137;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_106, 106, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can only take things rule ):
[ R_107 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_107, 107);
    ! [2: if the noun is not a thing]
    if (((~~((noun ofclass K2_thing)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [cannot] carry [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [cannot] carry [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_171); new_line; .L_Say139; .L_SayX138;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_107, 107, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't take what's fixed in place rule ):
[ R_108 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_108, 108);
    ! [2: if the noun is fixed in place]
    if ((((Adj_86_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They're] fixed in place.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They're] fixed in place.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_172); new_line; .L_Say140; .L_SayX139;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_108, 108, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the use player's holdall to avoid exceeding carrying capacity rule ):
[ R_109 
    tmp_0 ! Let/loop value, e.g., 'current working sack': player's holdall
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_109, 109);
    ! [2: if the number of things carried by the actor is at least the carrying capacity of the actor]
    if ((((Prop_40()) >= GProperty(10, actor,capacity))))
    {! [3: if the actor is holding a player's holdall ( called the current working sack )]
        if ((((Prop_41() && (tmp_0=deferred_calling_list-->0, true)) || (tmp_0 = 0,false))))
        {! [4: let the transferred item be nothing]

            		tmp_1 = nothing;
            ! [5: repeat with the possible item running through things carried by the actor]
            for (tmp_2=Prop_42(0), tmp_3=Prop_42(tmp_2): tmp_2: tmp_2=tmp_3, tmp_3=Prop_42(tmp_3))
            {! [6: if the possible item is not lit and the possible item is not the current working sack]
                if ((((~~(((Adj_82_t1_v10(tmp_2))))))) && (((~~((tmp_2 == tmp_0))))))
                {! [7: let the transferred item be the possible item]
                    tmp_1 = tmp_2;
                    }
                    }
            ! [8: if the transferred item is not nothing]
            if (((~~((tmp_1 == nothing)))))
            {! [9: if the actor is the player]
                if (((actor == player)))
                {! [10: say ~(putting [the transferred item] into [the current working sack] to make room)[command clarification break]~ ( a )]
                    say__p=1;! [11: ~(putting [the transferred item] into [the current working sack] to make room)[command clarification break]~ ( a )]
                    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),TX_R_173); .L_Say141; .L_SayX140;}
                ! [12: silently try the actor trying inserting the transferred item into the current working sack]
                @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
                ClearParagraphing(1);
                TryAction(0, actor, ##Insert, tmp_1, tmp_0);
                DivideParagraphPoint();
                @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

                ! [13: if the transferred item is not in the current working sack]
                if (((~~((tmp_0 == ContainerOf(tmp_1))))))
                {! [14: stop the action]
                    rtrue;
                    }
                    }
                    }
                    }
                    } else if (debug_rules > 1) DB_Rule(R_109, 109, 'action');
                    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking ( this is the can't exceed carrying capacity rule ):
[ R_110 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_110, 110);
    ! [2: if the number of things carried by the actor is at least the carrying capacity of the actor]
    if ((((Prop_43()) >= GProperty(10, actor,capacity))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We]['re] carrying too many things already.~ ( a )]
            say__p=1;! [5: ~[We]['re] carrying too many things already.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_174); new_line; .L_Say142; .L_SayX141;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_110, 110, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking (B135_carry_out_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor taking ( this is the standard taking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor taking ( this is the standard taking rule ):
[ R_111 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_111, 111);
    ! [2: now the actor carries the noun]
    MoveObject(noun,actor);
    ! [3: if the actor is the player]
    if (((actor == player)))
    {! [4: now the noun is handled]
        (Adj_91_t2_v10(noun));
        }
        } else if (debug_rules > 1) DB_Rule(R_111, 111, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking (B136_report_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking ( this is the standard report taking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor taking ( this is the standard report taking rule ):
[ R_112 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_112, 112);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~Taken.~ ( a )]
            say__p=1;! [5: ~Taken.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_175); new_line; .L_Say143; .L_SayX142;} else {
            ! [6: say ~[The actor] [pick] up [the noun].~ ( b )]
            say__p=1;! [7: ~[The actor] [pick] up [the noun].~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_176); new_line; .L_Say144; .L_SayX143;}
            }
            } else if (debug_rules > 1) DB_Rule(R_112, 112, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Removing it from (B137_check_removing_it_from)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor taking ( this is the can't take component parts rule ):
!   <<< I - Number of aspects constrained <<<
! Rule 2/4 ! Check an actor removing something from ( this is the can't remove what's not inside rule ):
!   === equally specific with ===
! Rule 3/4 ! Check an actor removing something from ( this is the can't remove from people rule ):
!   === equally specific with ===
! Rule 4/4 ! Check an actor removing something from ( this is the convert remove to take rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor removing something from ( this is the can't remove what's not inside rule ):
[ R_113 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_113, 113);
    ! [2: if the holder of the noun is not the second noun]
    if (((~~(((HolderOf(noun)) == second)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~But [regarding the noun][they] [aren't] there now.~ ( a )]
            say__p=1;! [5: ~But [regarding the noun][they] [aren't] there now.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_177); new_line; .L_Say145; .L_SayX144;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_113, 113, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor removing something from ( this is the can't remove from people rule ):
[ R_114 
    tmp_0 ! Let/loop value, e.g., 'owner': object
    ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_114, 114);
    ! [2: let the owner be the holder of the noun]

    		tmp_0 = (HolderOf(noun));
    ! [3: if the owner is a person]
    if (((tmp_0 ofclass K8_person)))
    {! [4: if the owner is the actor]
        if (((tmp_0 == actor)))
        {! [5: convert to the taking off action on the noun]
            return GVS_Convert(##Disrobe,noun,0);
            }
        ! [6: if the actor is the player]
        if (((actor == player)))
        {! [7: say ~[regarding the noun][Those] [seem] to belong to [the owner].~ ( a )]
            say__p=1;! [8: ~[regarding the noun][Those] [seem] to belong to [the owner].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_178); new_line; .L_Say146; .L_SayX145;}
        ! [9: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_114, 114, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor removing something from ( this is the convert remove to take rule ):
[ R_115 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_115, 115);
    ! [2: convert to the taking action on the noun]
    return GVS_Convert(##Take,noun,0);
    } else if (debug_rules > 1) DB_Rule(R_115, 115, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Dropping (B140_check_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Check dropping the green smartphone:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 2/7 ! Check an actor dropping something which is part of the actor ( this is the can't drop body parts rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 3/7 ! Check an actor dropping ( this is the can't drop yourself rule ):
!   === equally specific with ===
! Rule 4/7 ! Check an actor dropping ( this is the can't drop what's already dropped rule ):
!   === equally specific with ===
! Rule 5/7 ! Check an actor dropping ( this is the can't drop what's not held rule ):
!   === equally specific with ===
! Rule 6/7 ! Check an actor dropping ( this is the can't drop clothes being worn rule ):
!   === equally specific with ===
! Rule 7/7 ! Check an actor dropping ( this is the can't drop if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check dropping the green smartphone:
[ R_1484 ;
    if ((( (actor==player) && ((noun == I445_green_smartphone) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1484, 1484);
    ! [2: say ~You decide against leaving the phone behind.~]
    say__p=1;! [3: ~You decide against leaving the phone behind.~]
    ParaContent(); print "You decide against leaving the phone behind."; new_line; .L_Say147; .L_SayX146;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1484, 1484, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor dropping something which is part of the actor ( this is the can't drop body parts rule ):
[ R_117 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing) && (actor == (noun.component_parent)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_117, 117);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~[We] [can't drop] part of [ourselves].~ ( a )]
        say__p=1;! [4: ~[We] [can't drop] part of [ourselves].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_179); new_line; .L_Say148; .L_SayX147;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_117, 117, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor dropping ( this is the can't drop yourself rule ):
[ R_116 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_116, 116);
    ! [2: if the noun is the actor]
    if (((noun == actor)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [lack] the dexterity.~ ( a )]
            say__p=1;! [5: ~[We] [lack] the dexterity.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_180); new_line; .L_Say149; .L_SayX148;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_116, 116, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor dropping ( this is the can't drop what's already dropped rule ):
[ R_118 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_118, 118);
    ! [2: if the noun is in the holder of the actor]
    if ((((HolderOf(actor)) == ContainerOf(noun))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The noun] [are] already here.~ ( a )]
            say__p=1;! [5: ~[The noun] [are] already here.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_181); new_line; .L_Say150; .L_SayX149;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_118, 118, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor dropping ( this is the can't drop what's not held rule ):
[ R_119 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_119, 119);
    ! [2: if the actor is carrying the noun]
    if (((actor == CarrierOf(noun))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [5: continue the action]
        rfalse;
        }
    ! [6: if the actor is the player]
    if (((actor == player)))
    {! [7: say ~[We] [haven't] got [regarding the noun][those].~ ( a )]
        say__p=1;! [8: ~[We] [haven't] got [regarding the noun][those].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_182); new_line; .L_Say151; .L_SayX150;}
    ! [9: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_119, 119, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor dropping ( this is the can't drop clothes being worn rule ):
[ R_120 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_120, 120);
    ! [2: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~(first taking [the noun] off)[command clarification break]~ ( a )]
            say__p=1;! [5: ~(first taking [the noun] off)[command clarification break]~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_183); .L_Say152; .L_SayX151;}
        ! [6: silently try the actor trying taking off the noun]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        ClearParagraphing(1);
        TryAction(0, actor, ##Disrobe, noun, 0);
        DivideParagraphPoint();
        @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

        ! [7: if the actor is wearing the noun]
        if (((actor == WearerOf(noun))))
        {! [8: stop the action]
            rtrue;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_120, 120, 'action');
            rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor dropping ( this is the can't drop if this exceeds carrying capacity rule ):
[ R_121 
    tmp_0 ! Let/loop value, e.g., 'receptacle': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_121, 121);
    ! [2: let the receptacle be the holder of the actor]

    		tmp_0 = (HolderOf(actor));
    ! [3: if the receptacle is a room]
    if (((tmp_0 ofclass K1_room)))
    {! [4: continue the action]
        rfalse;
        }
    ! [5: if the receptacle provides the property carrying capacity]
    if (((WhetherProvides(tmp_0, false, capacity))))
    {! [6: if the receptacle is a supporter]
        if (((tmp_0 ofclass K6_supporter)))
        {! [7: if the number of things on the receptacle is at least the carrying capacity of the receptacle]
            if ((((Prop_44(tmp_0)) >= GProperty(OBJECT_TY, tmp_0,capacity))))
            {! [8: if the actor is the player]
                if (((actor == player)))
                {! [9: now the prior named object is nothing]
                    prior_named_noun = nothing;
                    ! [10: say ~[There] [are] no more room on [the receptacle].~ ( a )]
                    say__p=1;! [11: ~[There] [are] no more room on [the receptacle].~ ( a )]
                    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_184); new_line; .L_Say153; .L_SayX152;}
                ! [12: stop the action]
                rtrue;
                }
                } else {
            ! [13: if the receptacle is a container]
            if (((tmp_0 ofclass K5_container)))
            {! [14: if the number of things in the receptacle is at least the carrying capacity of the receptacle]
                if ((((Prop_45(tmp_0)) >= GProperty(OBJECT_TY, tmp_0,capacity))))
                {! [15: if the actor is the player]
                    if (((actor == player)))
                    {! [16: now the prior named object is nothing]
                        prior_named_noun = nothing;
                        ! [17: say ~[There] [are] no more room in [the receptacle].~ ( b )]
                        say__p=1;! [18: ~[There] [are] no more room in [the receptacle].~ ( b )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_185); new_line; .L_Say154; .L_SayX153;}
                    ! [19: stop the action]
                    rtrue;
                    }
                    }
                    }
                    }
                    } else if (debug_rules > 1) DB_Rule(R_121, 121, 'action');
                    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Dropping (B141_carry_out_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor dropping ( this is the standard dropping rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor dropping ( this is the standard dropping rule ):
[ R_122 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_122, 122);
    ! [2: now the noun is in the holder of the actor]
    MoveObject(noun,(HolderOf(actor)));
    } else if (debug_rules > 1) DB_Rule(R_122, 122, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Dropping (B142_report_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor dropping ( this is the standard report dropping rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor dropping ( this is the standard report dropping rule ):
[ R_123 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_123, 123);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~Dropped.~ ( a )]
            say__p=1;! [5: ~Dropped.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_186); new_line; .L_Say155; .L_SayX154;} else {
            ! [6: say ~[The actor] [put] down [the noun].~ ( b )]
            say__p=1;! [7: ~[The actor] [put] down [the noun].~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_187); new_line; .L_Say156; .L_SayX155;}
            }
            } else if (debug_rules > 1) DB_Rule(R_123, 123, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Putting it on (B143_check_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Check an actor putting something on ( this is the convert put to drop where possible rule ):
!   === equally specific with ===
! Rule 2/6 ! Check an actor putting something on ( this is the can't put what's not held rule ):
!   === equally specific with ===
! Rule 3/6 ! Check an actor putting something on ( this is the can't put something on itself rule ):
!   === equally specific with ===
! Rule 4/6 ! Check an actor putting something on ( this is the can't put onto what's not a supporter rule ):
!   === equally specific with ===
! Rule 5/6 ! Check an actor putting something on ( this is the can't put clothes being worn rule ):
!   === equally specific with ===
! Rule 6/6 ! Check an actor putting something on ( this is the can't put if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor putting something on ( this is the convert put to drop where possible rule ):
[ R_124 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_124, 124);
    ! [2: if the second noun is down or the actor is on the second noun]
    if ((((second == I60_down))) || (((second == SupporterOf(actor)))))
    {! [3: convert to the dropping action on the noun]
        return GVS_Convert(##Drop,noun,0);
        }
        } else if (debug_rules > 1) DB_Rule(R_124, 124, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor putting something on ( this is the can't put what's not held rule ):
[ R_125 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_125, 125);
    ! [2: if the actor is carrying the noun]
    if (((actor == CarrierOf(noun))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [5: continue the action]
        rfalse;
        }
    ! [6: carry out the implicitly taking activity with the noun]
    CarryOutActivity(V25_implicitly_taking, noun);
    ! [7: if the actor is carrying the noun]
    if (((actor == CarrierOf(noun))))
    {! [8: continue the action]
        rfalse;
        }
    ! [9: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_125, 125, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor putting something on ( this is the can't put something on itself rule ):
[ R_126 
    tmp_0 ! Let/loop value, e.g., 'noun-CPC': object
    tmp_1 ! Let/loop value, e.g., 'second-CPC': object
    tmp_2 ! Let/loop value, e.g., 'transfer ceiling': object
    ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_126, 126);
    ! [2: let the noun-cpc be the component parts core of the noun]

    		tmp_0 = CoreOf(noun);
    ! [3: let the second-cpc be the component parts core of the second noun]

    		tmp_1 = CoreOf(second);
    ! [4: let the transfer ceiling be the common ancestor of the noun-cpc with the second-cpc]

    		tmp_2 = (CommonAncestor(tmp_0, tmp_1));
    ! [5: if the transfer ceiling is the noun-cpc]
    if (((tmp_2 == tmp_0)))
    {! [6: if the actor is the player]
        if (((actor == player)))
        {! [7: say ~[We] [can't put] something on top of itself.~ ( a )]
            say__p=1;! [8: ~[We] [can't put] something on top of itself.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_188); new_line; .L_Say157; .L_SayX156;}
        ! [9: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_126, 126, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor putting something on ( this is the can't put onto what's not a supporter rule ):
[ R_127 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_127, 127);
    ! [2: if the second noun is not a supporter]
    if (((~~((second ofclass K6_supporter)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~Putting things on [the second noun] [would achieve] nothing.~ ( a )]
            say__p=1;! [5: ~Putting things on [the second noun] [would achieve] nothing.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_189); new_line; .L_Say158; .L_SayX157;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_127, 127, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor putting something on ( this is the can't put clothes being worn rule ):
[ R_128 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_128, 128);
    ! [2: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~(first taking [regarding the noun][them] off)[command clarification break]~ ( a )]
            say__p=1;! [5: ~(first taking [regarding the noun][them] off)[command clarification break]~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_190); .L_Say159; .L_SayX158;}
        ! [6: silently try the actor trying taking off the noun]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        ClearParagraphing(1);
        TryAction(0, actor, ##Disrobe, noun, 0);
        DivideParagraphPoint();
        @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

        ! [7: if the actor is wearing the noun]
        if (((actor == WearerOf(noun))))
        {! [8: stop the action]
            rtrue;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_128, 128, 'action');
            rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor putting something on ( this is the can't put if this exceeds carrying capacity rule ):
[ R_129 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_129, 129);
    ! [2: if the second noun provides the property carrying capacity]
    if (((WhetherProvides(second, false, capacity))))
    {! [3: if the number of things on the second noun is at least the carrying capacity of the second noun]
        if ((((Prop_46()) >= GProperty(OBJECT_TY, second,capacity))))
        {! [4: if the actor is the player]
            if (((actor == player)))
            {! [5: say ~[There] [are] no more room on [the second noun].~ ( a )]
                say__p=1;! [6: ~[There] [are] no more room on [the second noun].~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_191); new_line; .L_Say160; .L_SayX159;}
            ! [7: stop the action]
            rtrue;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_129, 129, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Putting it on (B144_carry_out_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor putting something on ( this is the standard putting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor putting something on ( this is the standard putting rule ):
[ R_130 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_130, 130);
    ! [2: now the noun is on the second noun]
    MoveObject(noun,second);
    } else if (debug_rules > 1) DB_Rule(R_130, 130, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Putting it on (B145_report_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor putting something on ( this is the concise report putting rule ):
!   === equally specific with ===
! Rule 2/2 ! Report an actor putting something on ( this is the standard report putting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor putting something on ( this is the concise report putting rule ):
[ R_131 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_131, 131);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: if the actor is the player and the i6 parser is running multiple actions]
        if ((((actor == player))) && (((multiflag==1))))
        {! [4: say ~Done.~ ( a )]
            say__p=1;! [5: ~Done.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_192); new_line; .L_Say161; .L_SayX160;! [6: stop the action]
            rtrue;
            }
            }
    ! [7: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_131, 131, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor putting something on ( this is the standard report putting rule ):
[ R_132 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_132, 132);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: say ~[The actor] [put] [the noun] on [the second noun].~ ( a )]
        say__p=1;! [4: ~[The actor] [put] [the noun] on [the second noun].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_193); new_line; .L_Say162; .L_SayX161;}
        } else if (debug_rules > 1) DB_Rule(R_132, 132, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Inserting it into (B146_check_inserting_it_into)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Check an actor inserting something into ( this is the convert insert to drop where possible rule ):
!   === equally specific with ===
! Rule 2/7 ! Check an actor inserting something into ( this is the can't insert what's not held rule ):
!   === equally specific with ===
! Rule 3/7 ! Check an actor inserting something into ( this is the can't insert something into itself rule ):
!   === equally specific with ===
! Rule 4/7 ! Check an actor inserting something into ( this is the can't insert into closed containers rule ):
!   === equally specific with ===
! Rule 5/7 ! Check an actor inserting something into ( this is the can't insert into what's not a container rule ):
!   === equally specific with ===
! Rule 6/7 ! Check an actor inserting something into ( this is the can't insert clothes being worn rule ):
!   === equally specific with ===
! Rule 7/7 ! Check an actor inserting something into ( this is the can't insert if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the convert insert to drop where possible rule ):
[ R_133 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_133, 133);
    ! [2: if the second noun is down or the actor is in the second noun]
    if ((((second == I60_down))) || (((second == ContainerOf(actor)))))
    {! [3: convert to the dropping action on the noun]
        return GVS_Convert(##Drop,noun,0);
        }
        } else if (debug_rules > 1) DB_Rule(R_133, 133, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the can't insert what's not held rule ):
[ R_134 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_134, 134);
    ! [2: if the actor is carrying the noun]
    if (((actor == CarrierOf(noun))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [5: continue the action]
        rfalse;
        }
    ! [6: carry out the implicitly taking activity with the noun]
    CarryOutActivity(V25_implicitly_taking, noun);
    ! [7: if the actor is carrying the noun]
    if (((actor == CarrierOf(noun))))
    {! [8: continue the action]
        rfalse;
        }
    ! [9: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_134, 134, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the can't insert something into itself rule ):
[ R_135 
    tmp_0 ! Let/loop value, e.g., 'noun-CPC': object
    tmp_1 ! Let/loop value, e.g., 'second-CPC': object
    tmp_2 ! Let/loop value, e.g., 'transfer ceiling': object
    ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_135, 135);
    ! [2: let the noun-cpc be the component parts core of the noun]

    		tmp_0 = CoreOf(noun);
    ! [3: let the second-cpc be the component parts core of the second noun]

    		tmp_1 = CoreOf(second);
    ! [4: let the transfer ceiling be the common ancestor of the noun-cpc with the second-cpc]

    		tmp_2 = (CommonAncestor(tmp_0, tmp_1));
    ! [5: if the transfer ceiling is the noun-cpc]
    if (((tmp_2 == tmp_0)))
    {! [6: if the actor is the player]
        if (((actor == player)))
        {! [7: say ~[We] [can't put] something inside itself.~ ( a )]
            say__p=1;! [8: ~[We] [can't put] something inside itself.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_194); new_line; .L_Say163; .L_SayX162;}
        ! [9: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_135, 135, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the can't insert into closed containers rule ):
[ R_136 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_136, 136);
    ! [2: if the second noun is a closed container]
    if (((second ofclass K5_container) && ((Adj_102_t1_v10(second)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The second noun] [are] closed.~ ( a )]
            say__p=1;! [5: ~[The second noun] [are] closed.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_195); new_line; .L_Say164; .L_SayX163;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_136, 136, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the can't insert into what's not a container rule ):
[ R_137 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_137, 137);
    ! [2: if the second noun is not a container]
    if (((~~((second ofclass K5_container)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the second noun][Those] [can't contain] things.~ ( a )]
            say__p=1;! [5: ~[regarding the second noun][Those] [can't contain] things.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_196); new_line; .L_Say165; .L_SayX164;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_137, 137, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the can't insert clothes being worn rule ):
[ R_138 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_138, 138);
    ! [2: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~(first taking [regarding the noun][them] off)[command clarification break]~ ( a )]
            say__p=1;! [5: ~(first taking [regarding the noun][them] off)[command clarification break]~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_197); .L_Say166; .L_SayX165;}
        ! [6: silently try the actor trying taking off the noun]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        ClearParagraphing(1);
        TryAction(0, actor, ##Disrobe, noun, 0);
        DivideParagraphPoint();
        @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

        ! [7: if the actor is wearing the noun]
        if (((actor == WearerOf(noun))))
        {! [8: stop the action]
            rtrue;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_138, 138, 'action');
            rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor inserting something into ( this is the can't insert if this exceeds carrying capacity rule ):
[ R_139 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_139, 139);
    ! [2: if the second noun provides the property carrying capacity]
    if (((WhetherProvides(second, false, capacity))))
    {! [3: if the number of things in the second noun is at least the carrying capacity of the second noun]
        if ((((Prop_47()) >= GProperty(OBJECT_TY, second,capacity))))
        {! [4: if the actor is the player]
            if (((actor == player)))
            {! [5: now the prior named object is nothing]
                prior_named_noun = nothing;
                ! [6: say ~[There] [are] no more room in [the second noun].~ ( a )]
                say__p=1;! [7: ~[There] [are] no more room in [the second noun].~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_198); new_line; .L_Say167; .L_SayX166;}
            ! [8: stop the action]
            rtrue;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_139, 139, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Inserting it into (B147_carry_out_inserting_it_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor inserting something into ( this is the standard inserting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor inserting something into ( this is the standard inserting rule ):
[ R_140 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_140, 140);
    ! [2: now the noun is in the second noun]
    MoveObject(noun,second);
    } else if (debug_rules > 1) DB_Rule(R_140, 140, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Inserting it into (B148_report_inserting_it_int)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor inserting something into ( this is the concise report inserting rule ):
!   === equally specific with ===
! Rule 2/2 ! Report an actor inserting something into ( this is the standard report inserting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor inserting something into ( this is the concise report inserting rule ):
[ R_141 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_141, 141);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: if the actor is the player and the i6 parser is running multiple actions]
        if ((((actor == player))) && (((multiflag==1))))
        {! [4: say ~Done.~ ( a )]
            say__p=1;! [5: ~Done.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_199); new_line; .L_Say168; .L_SayX167;! [6: stop the action]
            rtrue;
            }
            }
    ! [7: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_141, 141, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor inserting something into ( this is the standard report inserting rule ):
[ R_142 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_142, 142);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: say ~[The actor] [put] [the noun] into [the second noun].~ ( a )]
        say__p=1;! [4: ~[The actor] [put] [the noun] into [the second noun].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_200); new_line; .L_Say169; .L_SayX168;}
        } else if (debug_rules > 1) DB_Rule(R_142, 142, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Eating (B149_check_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor eating ( this is the can't eat unless edible rule ):
!   === equally specific with ===
! Rule 2/4 ! Check an actor eating ( this is the can't eat clothing without removing it first rule ):
!   === equally specific with ===
! Rule 3/4 ! Check an actor eating ( this is the can't eat other people's food rule ):
!   === equally specific with ===
! Rule 4/4 ! Check an actor eating ( this is the can't eat portable food without carrying it rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor eating ( this is the can't eat unless edible rule ):
[ R_143 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_143, 143);
    ! [2: if the noun is not a thing or the noun is not edible]
    if ((((~~((noun ofclass K2_thing))))) || (((~~(((Adj_84_t1_v10(noun))))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They're] plainly inedible.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They're] plainly inedible.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_201); new_line; .L_Say170; .L_SayX169;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_143, 143, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor eating ( this is the can't eat clothing without removing it first rule ):
[ R_144 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_144, 144);
    ! [2: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~(first taking [the noun] off)[command clarification break]~ ( a )]
            say__p=1;! [5: ~(first taking [the noun] off)[command clarification break]~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_202); .L_Say171; .L_SayX170;}
        ! [6: try the actor trying taking off the noun]
        TryAction(0, actor, ##Disrobe, noun, 0);
        ! [7: if the actor is wearing the noun]
        if (((actor == WearerOf(noun))))
        {! [8: stop the action]
            rtrue;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_144, 144, 'action');
            rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor eating ( this is the can't eat other people's food rule ):
[ R_145 
    tmp_0 ! Let/loop value, e.g., 'owner': person
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_145, 145);
    ! [2: if the noun is enclosed by a person ( called the owner ) who is not the actor]
    if ((((Prop_48() && (tmp_0=deferred_calling_list-->0, true)) || (tmp_0 = 0,false))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The owner] [might not appreciate] that.~ ( a )]
            say__p=1;! [5: ~[The owner] [might not appreciate] that.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_203); new_line; .L_Say172; .L_SayX171;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_145, 145, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor eating ( this is the can't eat portable food without carrying it rule ):
[ R_146 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_146, 146);
    ! [2: if the noun is portable and the actor is not carrying the noun]
    if (((((Adj_87_t1_v10(noun))))) && (((~~((actor == CarrierOf(noun)))))))
    {! [3: carry out the implicitly taking activity with the noun]
        CarryOutActivity(V25_implicitly_taking, noun);
        ! [4: if the actor is not carrying the noun]
        if (((~~((actor == CarrierOf(noun))))))
        {! [5: stop the action]
            rtrue;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_146, 146, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Eating (B150_carry_out_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor eating ( this is the standard eating rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor eating ( this is the standard eating rule ):
[ R_147 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_147, 147);
    ! [2: now the noun is nowhere]
    RemoveFromPlay(noun);;
    } else if (debug_rules > 1) DB_Rule(R_147, 147, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Eating (B151_report_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor eating ( this is the standard report eating rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor eating ( this is the standard report eating rule ):
[ R_148 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_148, 148);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [eat] [the noun]. Not bad.~ ( a )]
            say__p=1;! [5: ~[We] [eat] [the noun]. Not bad.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_204); new_line; .L_Say173; .L_SayX172;} else {
            ! [6: say ~[The actor] [eat] [the noun].~ ( b )]
            say__p=1;! [7: ~[The actor] [eat] [the noun].~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_205); new_line; .L_Say174; .L_SayX173;}
            }
            } else if (debug_rules > 1) DB_Rule(R_148, 148, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Going (B152_check_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/11 ! Check going northwest from the strip mall parking lot south when the player does not know break-in-to-laundromat:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 2/11 ! Check going northwest from the strip mall parking lot south when the player knows break-in-to-laundromat:
!   >>> I - Number of aspects constrained >>>
! Rule 3/11 ! Check going down from Featureless Hyperplane:
!   >>> I - Number of aspects constrained >>>
! Rule 4/11 ! Check going a hyperspatial direction:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 5/11 ! Check an actor going when actor is talking on a phone ( called P ) and P is wired:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 6/11 ! Check an actor going when the actor is on a supporter ( called the chaise ) ( this is the stand up before going rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 7/11 ! Check an actor going ( this is the can't travel in what's not a vehicle rule ):
!   === equally specific with ===
! Rule 8/11 ! Check an actor going ( this is the can't go through undescribed doors rule ):
!   === equally specific with ===
! Rule 9/11 ! Check an actor going ( this is the can't go through closed doors rule ):
!   === equally specific with ===
! Rule 10/11 ! Check an actor going ( this is the determine map connection rule ):
!   === equally specific with ===
! Rule 11/11 ! Check an actor going ( this is the can't go that way rule ):
! ----------------------------------------------------------------------------------------------------
! From "Swamp Park" by Philip Riley
! No specific request
! Check going northwest from the strip mall parking lot south when the player does not know break-in-to-laundromat:
[ R_1395 ;
    if ((( (actor==player) && ((noun == I53_northwest) && (true)) && (((MStack-->MstVON(20007,0)) == I294_strip_mall_parking_lot_) && ((MStack-->MstVON(20007,0)) ofclass K1_room)) && ((MStack-->MstVON(20007,1)) ~= nothing) && (self=actor,true) && (((~~(((RGuard_T_2(player,I170_break_in_to_laundromat)))))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1395, 1395);
    ! [2: say ~A sign on the laundromat door says 'Closed for renovations'.~]
    say__p=1;! [3: ~A sign on the laundromat door says 'Closed for renovations'.~]
    ParaContent(); print "A sign on the laundromat door says ~Closed for renovations~."; new_line; .L_Say175; .L_SayX174;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1395, 1395, 'action');
    rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! Check going northwest from the strip mall parking lot south when the player knows break-in-to-laundromat:
[ R_1396 ;
    if ((( (actor==player) && ((noun == I53_northwest) && (true)) && (((MStack-->MstVON(20007,0)) == I294_strip_mall_parking_lot_) && ((MStack-->MstVON(20007,0)) ofclass K1_room)) && ((MStack-->MstVON(20007,1)) ~= nothing) && (self=actor,true) && ((((RGuard_T_2(player,I170_break_in_to_laundromat)))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1396, 1396);
    ! [2: say ~Predictably, the laundromat door is locked.~]
    say__p=1;! [3: ~Predictably, the laundromat door is locked.~]
    ParaContent(); print "Predictably, the laundromat door is locked."; new_line; .L_Say176; .L_SayX175;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1396, 1396, 'action');
    rfalse;
];
! From "Hyperspace" by Philip Riley
! No specific request
! Check going down from Featureless Hyperplane:
[ R_1259 ;
    if ((( (actor==player) && ((noun == I60_down) && (true)) && (((MStack-->MstVON(20007,0)) == I244_featureless_hyperplane) && ((MStack-->MstVON(20007,0)) ofclass K1_room)) && ((MStack-->MstVON(20007,1)) ~= nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1259, 1259);
    ! [2: if hyperplane coords is not staircase coords]
    if (((~~(( BlkValueCompare((Global_Vars-->45), BC_3023) == 0)))))
    {! [3: say ~[text of the can't go that way rule response (A)][line break]~]
        say__p=1;! [4: text of the can't go that way rule response ( a )]
        ParaContent(); (PHR_380_r40 (R_114_RESP_A));! [5: line break]
        ParaContent(); new_line; .L_Say177; .L_SayX176;rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_1259, 1259, 'action');
        rfalse;
];
! From "Hyperspace" by Philip Riley
! No specific request
! Check going a hyperspatial direction:
[ R_1241 ;
    if ((( (actor==player) && ((noun ofclass K3_direction) && ((Adj_159_t1_v10(noun))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1241, 1241);
    ! [2: if player is not in hyperspace and player is not wearing the astral lenses]
    if ((((~~((TestRegionalContainment(player,I232_hyperspace)))))) && (((~~((player == WearerOf(I426_astral_lenses)))))))
    {! [3: say ~[text of can't go that way rule response (A)][line break]~]
        say__p=1;! [4: text of can't go that way rule response ( a )]
        ParaContent(); (PHR_380_r40 (R_114_RESP_A));! [5: line break]
        ParaContent(); new_line; .L_Say178; .L_SayX177;rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_1241, 1241, 'action');
        rfalse;
];
! From "Phones" by Philip Riley
! No specific request
! Check an actor going when actor is talking on a phone ( called P ) and P is wired:
[ R_1003 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_25();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_25 
    tmp_0 ! Let/loop value, e.g., 'P': phone
    ;
    if ((((act_requester==nothing) && (self=actor,true) && (((((RGuard_f1_3(actor)) ofclass K20_phone) && (tmp_0=((RGuard_f1_3(actor))), true))) && ((((Adj_138_t1_v10(tmp_0))))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1003, 1003);
    ! [2: print to actor that ~You'll have to hang up first.~]
    (PHR_963_r41 (actor,BlkValueCopy(I7SFRAME, TX_L_483)));
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1003, 1003, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor going when the actor is on a supporter ( called the chaise ) ( this is the stand up before going rule ):
[ R_150 
    tmp_0 ! Let/loop value, e.g., 'chaise': supporter
    ;
    if ((((act_requester==nothing) && (self=actor,true) && (((SupporterOf(actor) ofclass K6_supporter) && (tmp_0=(SupporterOf(actor)), true)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_150, 150);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~(first getting off [the chaise])[command clarification break]~ ( a )]
        say__p=1;! [4: ~(first getting off [the chaise])[command clarification break]~ ( a )]
        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_206); .L_Say179; .L_SayX178;}
    ! [5: silently try the actor exiting]
    @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
    ClearParagraphing(1);
    TryAction(0, actor, ##Exit, 0, 0);
    DivideParagraphPoint();
    @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

    } else if (debug_rules > 1) DB_Rule(R_150, 150, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor going ( this is the can't travel in what's not a vehicle rule ):
[ R_151 
    tmp_0 ! Let/loop value, e.g., 'nonvehicle': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_151, 151);
    ! [2: let nonvehicle be the holder of the actor]

    		tmp_0 = (HolderOf(actor));
    ! [3: if nonvehicle is the room gone from]
    if (((tmp_0 == (MStack-->MstVO(20007,0)))))
    {! [4: continue the action]
        rfalse;
        }
    ! [5: if nonvehicle is the vehicle gone by]
    if (((tmp_0 == (MStack-->MstVO(20007,3)))))
    {! [6: continue the action]
        rfalse;
        }
    ! [7: if the actor is the player]
    if (((actor == player)))
    {! [8: if nonvehicle is a supporter]
        if (((tmp_0 ofclass K6_supporter)))
        {! [9: say ~[We] [would have] to get off [the nonvehicle] first.~ ( a )]
            say__p=1;! [10: ~[We] [would have] to get off [the nonvehicle] first.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_207); new_line; .L_Say180; .L_SayX179;} else {
            ! [11: say ~[We] [would have] to get out of [the nonvehicle] first.~ ( b )]
            say__p=1;! [12: ~[We] [would have] to get out of [the nonvehicle] first.~ ( b )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_208); new_line; .L_Say181; .L_SayX180;}
            }
    ! [13: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_151, 151, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor going ( this is the can't go through undescribed doors rule ):
[ R_152 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_152, 152);
    ! [2: if the door gone through is not nothing and the door gone through is undescribed]
    if ((((~~(((MStack-->MstVO(20007,2)) == nothing))))) && ((((Adj_93_t1_v10((MStack-->MstVO(20007,2))))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [can't go] that way.~ ( a )]
            say__p=1;! [5: ~[We] [can't go] that way.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_209); new_line; .L_Say182; .L_SayX181;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_152, 152, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor going ( this is the can't go through closed doors rule ):
[ R_153 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_153, 153);
    ! [2: if the door gone through is not nothing and the door gone through is closed]
    if ((((~~(((MStack-->MstVO(20007,2)) == nothing))))) && ((((Adj_102_t1_v10((MStack-->MstVO(20007,2))))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~(first opening [the door gone through])[command clarification break]~ ( a )]
            say__p=1;! [5: ~(first opening [the door gone through])[command clarification break]~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_210); .L_Say183; .L_SayX182;}
        ! [6: silently try the actor opening the door gone through]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        ClearParagraphing(1);
        TryAction(0, actor, ##Open, (MStack-->MstVO(20007,2)), 0);
        DivideParagraphPoint();
        @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

        ! [7: if the door gone through is open]
        if ((((Adj_101_t1_v10((MStack-->MstVO(20007,2)))))))
        {! [8: continue the action]
            rfalse;
            }
        ! [9: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_153, 153, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor going ( this is the determine map connection rule ):
[ R_154 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_26();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_26 
    tmp_0 ! Let/loop value, e.g., 'target': object
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_154, 154);
    ! [2: let the target be nothing]

    		tmp_0 = nothing;
    ! [3: if the noun is a direction]
    if (((noun ofclass K3_direction)))
    {! [4: let direction d be the noun]

        		tmp_1 = noun;
        ! [5: let the target be the room-or-door direction d from the room gone from]
        tmp_0 = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par0 ofclass K3_direction) && (formal_par0 ofclass K3_direction))))) && ((
                        formal_rv = RoomOrDoorFrom(formal_par1,formal_par0)) | 1)
                        )|| (ArgumentTypeFailed(2330, 1))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = (MStack-->MstVO(20007,0))) +
                    (formal_par0 = tmp_1)
                    ))
            )

        ! Resolution complete
        ;
        } else {
        ! [6: if the noun is a door]
        if (((noun ofclass K4_door)))
        {! [7: let the target be the noun]
            tmp_0 = noun;
            }
            }
    ! [8: if the target is a door]
    if (((tmp_0 ofclass K4_door)))
    {! [9: now the target is the other side of the target from the room gone from]
        tmp_0 = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par0 ofclass K4_door) && (formal_par0 ofclass K4_door))))) && ((
                        formal_rv = OtherSideOfDoor(formal_par0,formal_par1)) | 1)
                        )|| (ArgumentTypeFailed(2334, 1))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = (MStack-->MstVO(20007,0))) +
                    (formal_par0 = tmp_0)
                    ))
            )

        ! Resolution complete
        ;
        }
    ! [10: now the room gone to is the target]
    (MStack-->MstVO(20007,1)) = tmp_0;
    } else if (debug_rules > 1) DB_Rule(R_154, 154, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor going ( this is the can't go that way rule ):
[ R_155 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_155, 155);
    ! [2: if the room gone to is nothing]
    if ((((MStack-->MstVO(20007,1)) == nothing)))
    {! [3: if the door gone through is nothing]
        if ((((MStack-->MstVO(20007,2)) == nothing)))
        {! [4: if the actor is the player]
            if (((actor == player)))
            {! [5: say ~[We] [can't go] that way.~ ( a )]
                say__p=1;! [6: ~[We] [can't go] that way.~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_211); new_line; .L_Say184; .L_SayX183;}
            ! [7: stop the action]
            rtrue;
            }
        ! [8: if the actor is the player]
        if (((actor == player)))
        {! [9: say ~[We] [can't], since [the door gone through] [lead] nowhere.~ ( b )]
            say__p=1;! [10: ~[We] [can't], since [the door gone through] [lead] nowhere.~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_212); new_line; .L_Say185; .L_SayX184;}
        ! [11: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_155, 155, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Going (B153_carry_out_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! This is the say goodbye when moving rule:
! --- now the mid-placed rules ---
! Rule 2/5 ! Carry out going a direction ( called D ) from Featureless Hyperplane:
!   >>> I - Number of aspects constrained >>>
! Rule 3/5 ! Carry out an actor going ( this is the move player and vehicle rule ):
!   === equally specific with ===
! Rule 4/5 ! Carry out an actor going ( this is the move floating objects rule ):
!   === equally specific with ===
! Rule 5/5 ! Carry out an actor going ( this is the check light in new location rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversation Framework" by Eric Eve
! No specific request
! This is the say goodbye when moving rule:
[ R_838 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_838, 838);
    ! [2: if the current interlocutor is a person enclosed by the location]
    if ((((Global_Vars-->11) ofclass K8_person) && (IndirectlyContains(real_location,(Global_Vars-->11)))))
    {! [3: now the farewell type is implicit]
        (Global_Vars-->13) = I129_implicit;
        ! [4: try saying goodbye to the current interlocutor]
        TryAction(0, player, ##A77_saying_goodbye_to, (Global_Vars-->11), 0);
        }
        } else if (debug_rules > 1) DB_Rule(R_838, 838, 'actor');
        rfalse;
];
! From "Hyperspace" by Philip Riley
! No specific request
! Carry out going a direction ( called D ) from Featureless Hyperplane:
[ R_1250 
    tmp_0 ! Let/loop value, e.g., 'D': direction
    ;
    if ((( (actor==player) && (tmp_0 = noun, (((noun ofclass K3_direction) && (tmp_0=(noun), true)))) && (((MStack-->MstVON(20007,0)) == I244_featureless_hyperplane) && ((MStack-->MstVON(20007,0)) ofclass K1_room)) && ((MStack-->MstVON(20007,1)) ~= nothing)) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1250, 1250);
    ! [2: if d is north]
    if (((tmp_0 == I51_north)))
    {! [3: increment entry 1 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),1,LIST_OF_TY_GetItem((Global_Vars-->45),1) + 1);;
        }
    ! [4: if d is northeast]
    if (((tmp_0 == I52_northeast)))
    {! [5: increment entry 1 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),1,LIST_OF_TY_GetItem((Global_Vars-->45),1) + 1);;
        ! [6: decrement entry 2 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),2,LIST_OF_TY_GetItem((Global_Vars-->45),2) - 1);;
        }
    ! [7: if d is east]
    if (((tmp_0 == I57_east)))
    {! [8: decrement entry 2 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),2,LIST_OF_TY_GetItem((Global_Vars-->45),2) - 1);;
        }
    ! [9: if d is southeast]
    if (((tmp_0 == I55_southeast)))
    {! [10: decrement entry 1 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),1,LIST_OF_TY_GetItem((Global_Vars-->45),1) - 1);;
        ! [11: decrement entry 2 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),2,LIST_OF_TY_GetItem((Global_Vars-->45),2) - 1);;
        }
    ! [12: if d is south]
    if (((tmp_0 == I54_south)))
    {! [13: decrement entry 1 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),1,LIST_OF_TY_GetItem((Global_Vars-->45),1) - 1);;
        }
    ! [14: if d is southwest]
    if (((tmp_0 == I56_southwest)))
    {! [15: decrement entry 1 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),1,LIST_OF_TY_GetItem((Global_Vars-->45),1) - 1);;
        ! [16: increment entry 2 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),2,LIST_OF_TY_GetItem((Global_Vars-->45),2) + 1);;
        }
    ! [17: if d is west]
    if (((tmp_0 == I58_west)))
    {! [18: increment entry 2 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),2,LIST_OF_TY_GetItem((Global_Vars-->45),2) + 1);;
        }
    ! [19: if d is northwest]
    if (((tmp_0 == I53_northwest)))
    {! [20: increment entry 1 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),1,LIST_OF_TY_GetItem((Global_Vars-->45),1) + 1);;
        ! [21: increment entry 2 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),2,LIST_OF_TY_GetItem((Global_Vars-->45),2) + 1);;
        }
    ! [22: if d is back]
    if (((tmp_0 == I233_back)))
    {! [23: decrement entry 3 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),3,LIST_OF_TY_GetItem((Global_Vars-->45),3) - 1);;
        }
    ! [24: if d is forth]
    if (((tmp_0 == I234_forth)))
    {! [25: increment entry 3 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),3,LIST_OF_TY_GetItem((Global_Vars-->45),3) + 1);;
        }
    ! [26: if d is backnorth]
    if (((tmp_0 == I239_backnorth)))
    {! [27: increment entry 1 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),1,LIST_OF_TY_GetItem((Global_Vars-->45),1) + 1);;
        ! [28: decrement entry 3 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),3,LIST_OF_TY_GetItem((Global_Vars-->45),3) - 1);;
        }
    ! [29: if d is backeast]
    if (((tmp_0 == I240_backeast)))
    {! [30: decrement entry 2 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),2,LIST_OF_TY_GetItem((Global_Vars-->45),2) - 1);;
        ! [31: decrement entry 3 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),3,LIST_OF_TY_GetItem((Global_Vars-->45),3) - 1);;
        }
    ! [32: if d is backsouth]
    if (((tmp_0 == I241_backsouth)))
    {! [33: decrement entry 1 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),1,LIST_OF_TY_GetItem((Global_Vars-->45),1) - 1);;
        ! [34: decrement entry 3 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),3,LIST_OF_TY_GetItem((Global_Vars-->45),3) - 1);;
        }
    ! [35: if d is backwest]
    if (((tmp_0 == I242_backwest)))
    {! [36: increment entry 2 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),2,LIST_OF_TY_GetItem((Global_Vars-->45),2) + 1);;
        ! [37: decrement entry 3 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),3,LIST_OF_TY_GetItem((Global_Vars-->45),3) - 1);;
        }
    ! [38: if d is forthnorth]
    if (((tmp_0 == I235_forthnorth)))
    {! [39: increment entry 1 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),1,LIST_OF_TY_GetItem((Global_Vars-->45),1) + 1);;
        ! [40: increment entry 3 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),3,LIST_OF_TY_GetItem((Global_Vars-->45),3) + 1);;
        }
    ! [41: if d is fortheast]
    if (((tmp_0 == I236_fortheast)))
    {! [42: decrement entry 2 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),2,LIST_OF_TY_GetItem((Global_Vars-->45),2) - 1);;
        ! [43: increment entry 3 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),3,LIST_OF_TY_GetItem((Global_Vars-->45),3) + 1);;
        }
    ! [44: if d is forthsouth]
    if (((tmp_0 == I237_forthsouth)))
    {! [45: decrement entry 1 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),1,LIST_OF_TY_GetItem((Global_Vars-->45),1) - 1);;
        ! [46: increment entry 3 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),3,LIST_OF_TY_GetItem((Global_Vars-->45),3) + 1);;
        }
    ! [47: if d is forthwest]
    if (((tmp_0 == I238_forthwest)))
    {! [48: increment entry 2 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),2,LIST_OF_TY_GetItem((Global_Vars-->45),2) + 1);;
        ! [49: increment entry 3 of hyperplane coords]
        WriteLIST_OF_TY_GetItem((Global_Vars-->45),3,LIST_OF_TY_GetItem((Global_Vars-->45),3) + 1);;
        }
    ! [50: if hyperplane coords is coordinates of pillar]
    if ((( BlkValueCompare((Global_Vars-->45), BC_3024) == 0)))
    {! [51: if the player does not carry the mystic compass]
        if (((~~((player == CarrierOf(I243_mystic_compass))))))
        {! [52: move the mystic compass to featureless hyperplane]
            MoveObject(I243_mystic_compass, I244_featureless_hyperplane, 0, false);
            }
        ! [53: now the printed name of featureless hyperplane is ~ethereal pillar~]
        BlkValueCopy(GProperty(10, I244_featureless_hyperplane,short_name), TX_L_484);
        ! [54: now the preposition of featureless hyperplane is ~next to~]
        BlkValueCopy(GProperty(10, I244_featureless_hyperplane,p21_preposition), TX_L_485);
        ! [55: move ethereal pillar to featureless hyperplane]
        MoveObject(I246_ethereal_pillar, I244_featureless_hyperplane, 0, false);
        } else {
        ! [56: if hyperplane coords is staircase coords]
        if ((( BlkValueCompare((Global_Vars-->45), BC_3025) == 0)))
        {! [57: if the player does not carry the mystic compass]
            if (((~~((player == CarrierOf(I243_mystic_compass))))))
            {! [58: remove the mystic compass from play]
                RemoveFromPlay(I243_mystic_compass);
                }
            ! [59: now the printed name of featureless hyperplane is ~descending stair~]
            BlkValueCopy(GProperty(10, I244_featureless_hyperplane,short_name), TX_L_486);
            ! [60: now the preposition of featureless hyperplane is ~at the top of~]
            BlkValueCopy(GProperty(10, I244_featureless_hyperplane,p21_preposition), TX_L_487);
            ! [61: move descending stair to featureless hyperplane]
            MoveObject(I245_descending_stair, I244_featureless_hyperplane, 0, false);
            } else {
            ! [62: if the player does not carry the mystic compass]
            if (((~~((player == CarrierOf(I243_mystic_compass))))))
            {! [63: remove the mystic compass from play]
                RemoveFromPlay(I243_mystic_compass);
                }
            ! [64: now the printed name of featureless hyperplane is ~featureless hyperplane~]
            BlkValueCopy(GProperty(10, I244_featureless_hyperplane,short_name), TX_L_125);
            ! [65: now the preposition of featureless hyperplane is ~on~]
            BlkValueCopy(GProperty(10, I244_featureless_hyperplane,p21_preposition), TX_L_126);
            ! [66: now the ethereal pillar is nowhere]
            RemoveFromPlay(I246_ethereal_pillar);;
            ! [67: now descending stair is nowhere]
            RemoveFromPlay(I245_descending_stair);;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_1250, 1250, 'action');
            rfalse;
];
! From the Standard Rules
! No specific request
! Carry out an actor going ( this is the move player and vehicle rule ):
[ R_156 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_156, 156);
    ! [2: if the vehicle gone by is nothing]
    if ((((MStack-->MstVO(20007,3)) == nothing)))
    {! [3: surreptitiously move the actor to the room gone to during going]
        MoveDuringGoing(actor, (MStack-->MstVO(20007,1)));
        } else {
        ! [4: surreptitiously move the vehicle gone by to the room gone to during going]
        MoveDuringGoing((MStack-->MstVO(20007,3)), (MStack-->MstVO(20007,1)));
        }
    ! [5: if the location is not the location of the player]
    if (((~~((real_location == LocationOf(player))))))
    {! [6: now the location is the location of the player]
        real_location = LocationOf(player);
        }
        } else if (debug_rules > 1) DB_Rule(R_156, 156, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out an actor going ( this is the move floating objects rule ):
[ R_157 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_157, 157);
    ! [2: if the actor is the player or the player is within the vehicle gone by or the player is within the thing gone with]
    if ((((actor == player))) || (((((MStack-->MstVO(20007,3)) == ContainerOf(player)))) || ((((MStack-->MstVO(20007,4)) == ContainerOf(player))))))
    {! [3: update backdrop positions]
        MoveFloatingObjects();
        }
        } else if (debug_rules > 1) DB_Rule(R_157, 157, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out an actor going ( this is the check light in new location rule ):
[ R_158 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_158, 158);
    ! [2: if the actor is the player or the player is within the vehicle gone by or the player is within the thing gone with]
    if ((((actor == player))) || (((((MStack-->MstVO(20007,3)) == ContainerOf(player)))) || ((((MStack-->MstVO(20007,4)) == ContainerOf(player))))))
    {! [3: surreptitiously reckon darkness]
        SilentlyConsiderLight();
        }
        } else if (debug_rules > 1) DB_Rule(R_158, 158, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Going (B154_report_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor going ( this is the describe room gone into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor going ( this is the describe room gone into rule ):
[ R_159 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_27();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_27 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_159, 159);
    ! [2: if the player is the actor]
    if (((player == actor)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: produce a room description with going spacing conventions]
            LookAfterGoing();
            }
            } else {
        ! [5: if the noun is a direction]
        if (((noun ofclass K3_direction)))
        {! [6: if the location is the room gone from or the player is within the vehicle gone by or the player is within the thing gone with]
            if ((((real_location == (MStack-->MstVO(20007,0))))) || (((((MStack-->MstVO(20007,3)) == ContainerOf(player)))) || ((((MStack-->MstVO(20007,4)) == ContainerOf(player))))))
            {! [7: if the room gone from is the room gone to]
                if ((((MStack-->MstVO(20007,0)) == (MStack-->MstVO(20007,1)))))
                {! [8: continue the action]
                    rfalse;
                    } else {
                    ! [9: if the noun is up]
                    if (((noun == I59_up)))
                    {! [10: say ~[The actor] [go] up~ ( a )]
                        say__p=1;! [11: ~[The actor] [go] up~ ( a )]
                        ParaContent(); print (TEXT_TY_Say) (TX_R_213); .L_Say186; .L_SayX185;} else {
                        ! [12: if the noun is down]
                        if (((noun == I60_down)))
                        {! [13: say ~[The actor] [go] down~ ( b )]
                            say__p=1;! [14: ~[The actor] [go] down~ ( b )]
                            ParaContent(); print (TEXT_TY_Say) (TX_R_214); .L_Say187; .L_SayX186;} else {
                            ! [15: say ~[The actor] [go] [noun]~ ( c )]
                            say__p=1;! [16: ~[The actor] [go] [noun]~ ( c )]
                            ParaContent(); print (TEXT_TY_Say) (TX_R_215); .L_Say188; .L_SayX187;}
                            }
                            }
                            } else {
                ! [17: let the back way be the opposite of the noun]

                		tmp_0 = GProperty(OBJECT_TY, noun,p10_opposite);
                ! [18: if the location is the room gone to]
                if (((real_location == (MStack-->MstVO(20007,1)))))
                {! [19: let the room back the other way be the room back way from the location]

                    		tmp_1 = 
                    ! Resolution of run-time phrase ambiguity (deciding a value):
                        (
                            ! This value evaluates third (i.e., last)
                            formal_rv
                        +
                            0*(
                                ! The following condition evaluates second
                                ((
                                    ((((((formal_par1 ofclass K1_room) && (formal_par1 ofclass K1_room))))) && ((
                                    formal_rv = MapConnection(formal_par1,formal_par0)) | 1)
                                    )|| (ArgumentTypeFailed(2385, 1))

                                ))
                            +
                                ! The following assignments evaluate first
                                ((formal_par1 = real_location) +
                                (formal_par0 = tmp_0)
                                ))
                        )

                    ! Resolution complete
                    ;
                    ! [20: let the room normally this way be the room noun from the room gone from]

                    		tmp_2 = 
                    ! Resolution of run-time phrase ambiguity (deciding a value):
                        (
                            ! This value evaluates third (i.e., last)
                            formal_rv
                        +
                            0*(
                                ! The following condition evaluates second
                                ((
                                    ((((((formal_par0 ofclass K3_direction) && (formal_par0 ofclass K3_direction))))) && ((
                                    formal_rv = MapConnection(formal_par1,formal_par0)) | 1)
                                    )|| (ArgumentTypeFailed(2387, 1))

                                ))
                            +
                                ! The following assignments evaluate first
                                ((formal_par1 = (MStack-->MstVO(20007,0))) +
                                (formal_par0 = noun)
                                ))
                        )

                    ! Resolution complete
                    ;
                    ! [21: if the room back the other way is the room gone from or the room back the other way is the room normally this way]
                    if ((((tmp_1 == (MStack-->MstVO(20007,0))))) || (((tmp_1 == tmp_2))))
                    {! [22: if the back way is up]
                        if (((tmp_0 == I59_up)))
                        {! [23: say ~[The actor] [arrive] from above~ ( d )]
                            say__p=1;! [24: ~[The actor] [arrive] from above~ ( d )]
                            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_216); .L_Say189; .L_SayX188;} else {
                            ! [25: if the back way is down]
                            if (((tmp_0 == I60_down)))
                            {! [26: say ~[The actor] [arrive] from below~ ( e )]
                                say__p=1;! [27: ~[The actor] [arrive] from below~ ( e )]
                                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_217); .L_Say190; .L_SayX189;} else {
                                ! [28: say ~[The actor] [arrive] from [the back way]~ ( f )]
                                say__p=1;! [29: ~[The actor] [arrive] from [the back way]~ ( f )]
                                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_218); .L_Say191; .L_SayX190;}
                                }
                                } else {
                        ! [30: say ~[The actor] [arrive]~ ( g )]
                        say__p=1;! [31: ~[The actor] [arrive]~ ( g )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_219); .L_Say192; .L_SayX191;}
                        } else {
                    ! [32: if the back way is up]
                    if (((tmp_0 == I59_up)))
                    {! [33: say ~[The actor] [arrive] at [the room gone to] from above~ ( h )]
                        say__p=1;! [34: ~[The actor] [arrive] at [the room gone to] from above~ ( h )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_220); .L_Say193; .L_SayX192;} else {
                        ! [35: if the back way is down]
                        if (((tmp_0 == I60_down)))
                        {! [36: say ~[The actor] [arrive] at [the room gone to] from below~ ( i )]
                            say__p=1;! [37: ~[The actor] [arrive] at [the room gone to] from below~ ( i )]
                            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_221); .L_Say194; .L_SayX193;} else {
                            ! [38: say ~[The actor] [arrive] at [the room gone to] from [the back way]~ ( j )]
                            say__p=1;! [39: ~[The actor] [arrive] at [the room gone to] from [the back way]~ ( j )]
                            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_222); .L_Say195; .L_SayX194;}
                            }
                            }
                            }
                            } else {
            ! [40: if the location is the room gone from]
            if (((real_location == (MStack-->MstVO(20007,0)))))
            {! [41: say ~[The actor] [go] through [the noun]~ ( k )]
                say__p=1;! [42: ~[The actor] [go] through [the noun]~ ( k )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_223); .L_Say196; .L_SayX195;} else {
                ! [43: say ~[The actor] [arrive] from [the noun]~ ( l )]
                say__p=1;! [44: ~[The actor] [arrive] from [the noun]~ ( l )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_224); .L_Say197; .L_SayX196;}
                }
        ! [45: if the vehicle gone by is not nothing]
        if (((~~(((MStack-->MstVO(20007,3)) == nothing)))))
        {! [46: say ~ ~]
            say__p=1;! [47: ~ ~]
            ParaContent(); print " "; .L_Say198; .L_SayX197;! [48: if the vehicle gone by is a supporter]
            if ((((MStack-->MstVO(20007,3)) ofclass K6_supporter)))
            {! [49: say ~on [the vehicle gone by]~ ( m )]
                say__p=1;! [50: ~on [the vehicle gone by]~ ( m )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_225); .L_Say199; .L_SayX198;} else {
                ! [51: say ~in [the vehicle gone by]~ ( n )]
                say__p=1;! [52: ~in [the vehicle gone by]~ ( n )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_226); .L_Say200; .L_SayX199;}
                }
        ! [53: if the thing gone with is not nothing]
        if (((~~(((MStack-->MstVO(20007,4)) == nothing)))))
        {! [54: if the player is within the thing gone with]
            if ((((MStack-->MstVO(20007,4)) == ContainerOf(player))))
            {! [55: say ~, pushing [the thing gone with] in front, and [us] along too~ ( o )]
                say__p=1;! [56: ~, pushing [the thing gone with] in front, and [us] along too~ ( o )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_227); .L_Say201; .L_SayX200;} else {
                ! [57: if the player is within the vehicle gone by]
                if ((((MStack-->MstVO(20007,3)) == ContainerOf(player))))
                {! [58: say ~, pushing [the thing gone with] in front~ ( p )]
                    say__p=1;! [59: ~, pushing [the thing gone with] in front~ ( p )]
                    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_228); .L_Say202; .L_SayX201;} else {
                    ! [60: if the location is the room gone from]
                    if (((real_location == (MStack-->MstVO(20007,0)))))
                    {! [61: say ~, pushing [the thing gone with] away~ ( q )]
                        say__p=1;! [62: ~, pushing [the thing gone with] away~ ( q )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_229); .L_Say203; .L_SayX202;} else {
                        ! [63: say ~, pushing [the thing gone with] in~ ( r )]
                        say__p=1;! [64: ~, pushing [the thing gone with] in~ ( r )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_230); .L_Say204; .L_SayX203;}
                        }
                        }
                        }
        ! [65: if the player is within the vehicle gone by and the player is not within the thing gone with]
        if (((((MStack-->MstVO(20007,3)) == ContainerOf(player)))) && (((~~(((MStack-->MstVO(20007,4)) == ContainerOf(player)))))))
        {! [66: say ~, taking [us] along~ ( s )]
            say__p=1;! [67: ~, taking [us] along~ ( s )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TX_R_231); .L_Say205; .L_SayX204;! [68: say ~.~]
            say__p=1;! [69: ~.~]
            ParaContent(); print "."; new_line; .L_Say206; .L_SayX205;! [70: try looking]
            TryAction(0, player, ##Look, 0, 0);
            ! [71: continue the action]
            rfalse;
            }
        ! [72: say ~.~]
        say__p=1;! [73: ~.~]
        ParaContent(); print "."; new_line; .L_Say207; .L_SayX206;}
        } else if (debug_rules > 1) DB_Rule(R_159, 159, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Entering (B155_check_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/8 ! Check an actor entering ( this is the convert enter door into go rule ):
!   === equally specific with ===
! Rule 2/8 ! Check an actor entering ( this is the convert enter compass direction into go rule ):
!   === equally specific with ===
! Rule 3/8 ! Check an actor entering ( this is the can't enter what's already entered rule ):
!   === equally specific with ===
! Rule 4/8 ! Check an actor entering ( this is the can't enter what's not enterable rule ):
!   === equally specific with ===
! Rule 5/8 ! Check an actor entering ( this is the can't enter closed containers rule ):
!   === equally specific with ===
! Rule 6/8 ! Check an actor entering ( this is the can't enter if this exceeds carrying capacity rule ):
!   === equally specific with ===
! Rule 7/8 ! Check an actor entering ( this is the can't enter something carried rule ):
!   === equally specific with ===
! Rule 8/8 ! Check an actor entering ( this is the implicitly pass through other barriers rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the convert enter door into go rule ):
[ R_161 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_161, 161);
    ! [2: if the noun is a door]
    if (((noun ofclass K4_door)))
    {! [3: convert to the going action on the noun]
        return GVS_Convert(##Go,noun,0);
        }
        } else if (debug_rules > 1) DB_Rule(R_161, 161, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the convert enter compass direction into go rule ):
[ R_162 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_162, 162);
    ! [2: if the noun is a direction]
    if (((noun ofclass K3_direction)))
    {! [3: convert to the going action on the noun]
        return GVS_Convert(##Go,noun,0);
        }
        } else if (debug_rules > 1) DB_Rule(R_162, 162, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the can't enter what's already entered rule ):
[ R_163 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_163, 163);
    ! [2: if the actor is the noun]
    if (((actor == noun)))
    {! [3: make no decision]
        rfalse;
        }
    ! [4: let the local ceiling be the common ancestor of the actor with the noun]

    		tmp_0 = (CommonAncestor(actor, noun));
    ! [5: if the local ceiling is the noun]
    if (((tmp_0 == noun)))
    {! [6: if the player is the actor]
        if (((player == actor)))
        {! [7: if the noun is a supporter]
            if (((noun ofclass K6_supporter)))
            {! [8: say ~But [we]['re] already on [the noun].~ ( a )]
                say__p=1;! [9: ~But [we]['re] already on [the noun].~ ( a )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_232); new_line; .L_Say208; .L_SayX207;} else {
                ! [10: say ~But [we]['re] already in [the noun].~ ( b )]
                say__p=1;! [11: ~But [we]['re] already in [the noun].~ ( b )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_233); new_line; .L_Say209; .L_SayX208;}
                }
        ! [12: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_163, 163, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the can't enter what's not enterable rule ):
[ R_164 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_164, 164);
    ! [2: if the noun is not enterable]
    if (((~~(((Adj_98_t1_v10(noun)))))))
    {! [3: if the player is the actor]
        if (((player == actor)))
        {! [4: if the player's command includes ~stand~]
            if (((matched_text=SnippetIncludes(Consult_Grammar_204,players_command))))
            {! [5: say ~[regarding the noun][They're] not something [we] [can] stand on.~ ( a )]
                say__p=1;! [6: ~[regarding the noun][They're] not something [we] [can] stand on.~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_234); new_line; .L_Say210; .L_SayX209;} else {
                ! [7: if the player's command includes ~sit~]
                if (((matched_text=SnippetIncludes(Consult_Grammar_205,players_command))))
                {! [8: say ~[regarding the noun][They're] not something [we] [can] sit down on.~ ( b )]
                    say__p=1;! [9: ~[regarding the noun][They're] not something [we] [can] sit down on.~ ( b )]
                    ParaContent(); print (TEXT_TY_Say) (TX_R_235); new_line; .L_Say211; .L_SayX210;} else {
                    ! [10: if the player's command includes ~lie~]
                    if (((matched_text=SnippetIncludes(Consult_Grammar_206,players_command))))
                    {! [11: say ~[regarding the noun][They're] not something [we] [can] lie down on.~ ( c )]
                        say__p=1;! [12: ~[regarding the noun][They're] not something [we] [can] lie down on.~ ( c )]
                        ParaContent(); print (TEXT_TY_Say) (TX_R_236); new_line; .L_Say212; .L_SayX211;} else {
                        ! [13: say ~[regarding the noun][They're] not something [we] [can] enter.~ ( d )]
                        say__p=1;! [14: ~[regarding the noun][They're] not something [we] [can] enter.~ ( d )]
                        ParaContent(); print (TEXT_TY_Say) (TX_R_237); new_line; .L_Say213; .L_SayX212;}
                        }
                        }
                        }
        ! [15: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_164, 164, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the can't enter closed containers rule ):
[ R_165 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_165, 165);
    ! [2: if the noun is a closed container]
    if (((noun ofclass K5_container) && ((Adj_102_t1_v10(noun)))))
    {! [3: if the player is the actor]
        if (((player == actor)))
        {! [4: say ~[We] [can't get] into the closed [noun].~ ( a )]
            say__p=1;! [5: ~[We] [can't get] into the closed [noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_238); new_line; .L_Say214; .L_SayX213;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_165, 165, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the can't enter if this exceeds carrying capacity rule ):
[ R_166 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_166, 166);
    ! [2: if the noun provides the property carrying capacity]
    if (((WhetherProvides(noun, false, capacity))))
    {! [3: if the noun is a supporter]
        if (((noun ofclass K6_supporter)))
        {! [4: if the number of things on the noun is at least the carrying capacity of the noun]
            if ((((Prop_49()) >= GProperty(OBJECT_TY, noun,capacity))))
            {! [5: if the actor is the player]
                if (((actor == player)))
                {! [6: now the prior named object is nothing]
                    prior_named_noun = nothing;
                    ! [7: say ~[There] [are] no more room on [the noun].~ ( a )]
                    say__p=1;! [8: ~[There] [are] no more room on [the noun].~ ( a )]
                    ParaContent(); print (TEXT_TY_Say) (TX_R_239); new_line; .L_Say215; .L_SayX214;}
                ! [9: stop the action]
                rtrue;
                }
                } else {
            ! [10: if the noun is a container]
            if (((noun ofclass K5_container)))
            {! [11: if the number of things in the noun is at least the carrying capacity of the noun]
                if ((((Prop_50()) >= GProperty(OBJECT_TY, noun,capacity))))
                {! [12: if the actor is the player]
                    if (((actor == player)))
                    {! [13: now the prior named object is nothing]
                        prior_named_noun = nothing;
                        ! [14: say ~[There] [are] no more room in [the noun].~ ( b )]
                        say__p=1;! [15: ~[There] [are] no more room in [the noun].~ ( b )]
                        ParaContent(); print (TEXT_TY_Say) (TX_R_240); new_line; .L_Say216; .L_SayX215;}
                    ! [16: stop the action]
                    rtrue;
                    }
                    }
                    }
                    }
                    } else if (debug_rules > 1) DB_Rule(R_166, 166, 'action');
                    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the can't enter something carried rule ):
[ R_167 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_167, 167);
    ! [2: let the local ceiling be the common ancestor of the actor with the noun]

    		tmp_0 = (CommonAncestor(actor, noun));
    ! [3: if the local ceiling is the actor]
    if (((tmp_0 == actor)))
    {! [4: if the player is the actor]
        if (((player == actor)))
        {! [5: say ~[We] [can] only get into something free-standing.~ ( a )]
            say__p=1;! [6: ~[We] [can] only get into something free-standing.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_241); new_line; .L_Say217; .L_SayX216;}
        ! [7: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_167, 167, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor entering ( this is the implicitly pass through other barriers rule ):
[ R_168 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'target': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_168, 168);
    ! [2: if the holder of the actor is the holder of the noun]
    if ((((HolderOf(actor)) == (HolderOf(noun)))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: let the local ceiling be the common ancestor of the actor with the noun]

    		tmp_0 = (CommonAncestor(actor, noun));
    ! [5: while the holder of the actor is not the local ceiling]
    while (((~~(((HolderOf(actor)) == tmp_0)))))
    {! [6: let the current home be the holder of the actor]

        		tmp_1 = (HolderOf(actor));
        ! [7: if the player is the actor]
        if (((player == actor)))
        {! [8: if the current home is a supporter or the current home is an animal]
            if ((((tmp_1 ofclass K6_supporter))) || (((tmp_1 ofclass K13_animal))))
            {! [9: say ~(getting off [the current home])[command clarification break]~ ( a )]
                say__p=1;! [10: ~(getting off [the current home])[command clarification break]~ ( a )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_242); .L_Say218; .L_SayX217;} else {
                ! [11: say ~(getting out of [the current home])[command clarification break]~ ( b )]
                say__p=1;! [12: ~(getting out of [the current home])[command clarification break]~ ( b )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_243); .L_Say219; .L_SayX218;}
                }
        ! [13: silently try the actor trying exiting]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        ClearParagraphing(1);
        TryAction(0, actor, ##Exit, 0, 0);
        DivideParagraphPoint();
        @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

        ! [14: if the holder of the actor is the current home]
        if ((((HolderOf(actor)) == tmp_1)))
        {! [15: stop the action]
            rtrue;
            }
            }
    ! [16: if the holder of the actor is the noun]
    if ((((HolderOf(actor)) == noun)))
    {! [17: stop the action]
        rtrue;
        }
    ! [18: if the holder of the actor is the holder of the noun]
    if ((((HolderOf(actor)) == (HolderOf(noun)))))
    {! [19: continue the action]
        rfalse;
        }
    ! [20: let the target be the holder of the noun]

    		tmp_1 = (HolderOf(noun));
    ! [21: if the noun is part of the target]
    if (((tmp_1 == (noun.component_parent))))
    {! [22: let the target be the holder of the target]
        tmp_1 = (HolderOf(tmp_1));
        }
    ! [23: while the target is a thing]
    while (((tmp_1 ofclass K2_thing)))
    {! [24: if the holder of the target is the local ceiling]
        if ((((HolderOf(tmp_1)) == tmp_0)))
        {! [25: if the player is the actor]
            if (((player == actor)))
            {! [26: if the target is a supporter]
                if (((tmp_1 ofclass K6_supporter)))
                {! [27: say ~(getting onto [the target])[command clarification break]~ ( c )]
                    say__p=1;! [28: ~(getting onto [the target])[command clarification break]~ ( c )]
                    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_244); .L_Say220; .L_SayX219;} else {
                    ! [29: if the target is a container]
                    if (((tmp_1 ofclass K5_container)))
                    {! [30: say ~(getting into [the target])[command clarification break]~ ( d )]
                        say__p=1;! [31: ~(getting into [the target])[command clarification break]~ ( d )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_245); .L_Say221; .L_SayX220;} else {
                        ! [32: say ~(entering [the target])[command clarification break]~ ( e )]
                        say__p=1;! [33: ~(entering [the target])[command clarification break]~ ( e )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_246); .L_Say222; .L_SayX221;}
                        }
                        }
            ! [34: silently try the actor trying entering the target]
            @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Enter, tmp_1, 0);
            DivideParagraphPoint();
            @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

            ! [35: if the holder of the actor is not the target]
            if (((~~(((HolderOf(actor)) == tmp_1)))))
            {! [36: stop the action]
                rtrue;
                }
            ! [37: convert to the entering action on the noun]
            return GVS_Convert(##Enter,noun,0);
            ! [38: continue the action]
            rfalse;
            }
        ! [39: let the target be the holder of the target]
        tmp_1 = (HolderOf(tmp_1));
        }
        } else if (debug_rules > 1) DB_Rule(R_168, 168, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Entering (B156_carry_out_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor entering ( this is the standard entering rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor entering ( this is the standard entering rule ):
[ R_169 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_169, 169);
    ! [2: surreptitiously move the actor to the noun]
    move actor to noun;
    } else if (debug_rules > 1) DB_Rule(R_169, 169, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Entering (B157_report_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor entering ( this is the standard report entering rule ):
!   === equally specific with ===
! Rule 2/2 ! Report an actor entering ( this is the describe contents entered into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor entering ( this is the standard report entering rule ):
[ R_170 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_170, 170);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: if the noun is a supporter]
            if (((noun ofclass K6_supporter)))
            {! [5: say ~[We] [get] onto [the noun].~ ( a )]
                say__p=1;! [6: ~[We] [get] onto [the noun].~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_247); new_line; .L_Say223; .L_SayX222;} else {
                ! [7: say ~[We] [get] into [the noun].~ ( b )]
                say__p=1;! [8: ~[We] [get] into [the noun].~ ( b )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_248); new_line; .L_Say224; .L_SayX223;}
                }
                } else {
        ! [9: if the noun is a container]
        if (((noun ofclass K5_container)))
        {! [10: say ~[The actor] [get] into [the noun].~ ( c )]
            say__p=1;! [11: ~[The actor] [get] into [the noun].~ ( c )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_249); new_line; .L_Say225; .L_SayX224;} else {
            ! [12: say ~[The actor] [get] onto [the noun].~ ( d )]
            say__p=1;! [13: ~[The actor] [get] onto [the noun].~ ( d )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_250); new_line; .L_Say226; .L_SayX225;}
            }
    ! [14: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_170, 170, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor entering ( this is the describe contents entered into rule ):
[ R_171 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_171, 171);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: describe locale for the noun]
        (PHR_79_r42 (noun));
        }
        } else if (debug_rules > 1) DB_Rule(R_171, 171, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Exiting (B158_check_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor exiting ( this is the convert exit into go out rule ):
!   === equally specific with ===
! Rule 2/5 ! Check an actor exiting ( this is the can't exit when not inside anything rule ):
!   === equally specific with ===
! Rule 3/5 ! Check an actor exiting ( this is the can't exit closed containers rule ):
!   === equally specific with ===
! Rule 4/5 ! Check an actor exiting ( this is the convert exit into get off rule ):
!   === equally specific with ===
! Rule 5/5 ! Check an actor exiting ( this is the new can't exit when not inside anything rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor exiting ( this is the convert exit into go out rule ):
[ R_173 
    tmp_0 ! Let/loop value, e.g., 'local room': room
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_173, 173);
    ! [2: let the local room be the location of the actor]

    		tmp_0 = LocationOf(actor);
    ! [3: if the container exited from is the local room]
    if ((((MStack-->MstVO(20009,0)) == tmp_0)))
    {! [4: if the room-or-door outside from the local room is not nothing]
        if (((~~((RoomOrDoorFrom(tmp_0,out_obj) == nothing)))))
        {! [5: convert to the going action on the outside]
            return GVS_Convert(##Go,out_obj,0);
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_173, 173, 'action');
            rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor exiting ( this is the can't exit when not inside anything rule ):
[ R_174 
    tmp_0 ! Let/loop value, e.g., 'local room': room
    ;
    if ((((1 == 1)))) rfalse;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_174, 174);
    ! [2: let the local room be the location of the actor]

    		tmp_0 = LocationOf(actor);
    ! [3: if the container exited from is the local room]
    if ((((MStack-->MstVO(20009,0)) == tmp_0)))
    {! [4: if the player is the actor]
        if (((player == actor)))
        {! [5: say ~But [we] [aren't] in anything at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
            say__p=1;! [6: ~But [we] [aren't] in anything at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_251); new_line; .L_Say227; .L_SayX226;}
        ! [7: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_174, 174, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor exiting ( this is the can't exit closed containers rule ):
[ R_175 
    tmp_0 ! Let/loop value, e.g., 'cage': container
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_175, 175);
    ! [2: if the actor is in a closed container ( called the cage )]
    if (((ContainerOf(actor) ofclass K5_container) && ((Adj_102_t1_v10(ContainerOf(actor)))) && (tmp_0=(ContainerOf(actor)), true)))
    {! [3: if the player is the actor]
        if (((player == actor)))
        {! [4: say ~You can't get out of the closed [cage].~ ( a )]
            say__p=1;! [5: ~You can't get out of the closed [cage].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_252); new_line; .L_Say228; .L_SayX227;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_175, 175, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor exiting ( this is the convert exit into get off rule ):
[ R_176 
    tmp_0 ! Let/loop value, e.g., 'platform': supporter
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_176, 176);
    ! [2: if the actor is on a supporter ( called the platform )]
    if (((SupporterOf(actor) ofclass K6_supporter) && (tmp_0=(SupporterOf(actor)), true)))
    {! [3: convert to the getting off action on the platform]
        return GVS_Convert(##GetOff,tmp_0,0);
        }
        } else if (debug_rules > 1) DB_Rule(R_176, 176, 'action');
        rfalse;
];
! From "Can't Go That Way" by Philip Riley
! No specific request
! Check an actor exiting ( this is the new can't exit when not inside anything rule ):
[ R_1107 
    tmp_0 ! Let/loop value, e.g., 'local room': room
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1107, 1107);
    ! [2: let the local room be the location of the actor]

    		tmp_0 = LocationOf(actor);
    ! [3: if the container exited from is the local room]
    if ((((MStack-->MstVO(20009,0)) == tmp_0)))
    {! [4: if the player is the actor]
        if (((player == actor)))
        {! [5: say ~[excuse for local room to outside][line break]~ ( a )]
            say__p=1;! [6: ~[excuse for local room to outside][line break]~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_253); .L_Say229; .L_SayX228;}
        ! [7: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_1107, 1107, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Exiting (B159_carry_out_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor exiting ( this is the standard exiting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor exiting ( this is the standard exiting rule ):
[ R_177 
    tmp_0 ! Let/loop value, e.g., 'former exterior': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_177, 177);
    ! [2: let the former exterior be the not-counting-parts holder of the container exited from]

    		tmp_0 = (CoreOfParentOfCoreOf((MStack-->MstVO(20009,0))));
    ! [3: surreptitiously move the actor to the former exterior]
    move actor to tmp_0;
    } else if (debug_rules > 1) DB_Rule(R_177, 177, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Exiting (B160_report_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor exiting ( this is the standard report exiting rule ):
!   === equally specific with ===
! Rule 2/2 ! Report an actor exiting ( this is the describe room emerged into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor exiting ( this is the standard report exiting rule ):
[ R_178 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_178, 178);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: if the container exited from is a supporter]
            if ((((MStack-->MstVO(20009,0)) ofclass K6_supporter)))
            {! [5: say ~[We] [get] off [the container exited from].~ ( a )]
                say__p=1;! [6: ~[We] [get] off [the container exited from].~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_254); new_line; .L_Say230; .L_SayX229;} else {
                ! [7: say ~[We] [get] out of [the container exited from].~ ( b )]
                say__p=1;! [8: ~[We] [get] out of [the container exited from].~ ( b )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_255); new_line; .L_Say231; .L_SayX230;}
                } else {
            ! [9: say ~[The actor] [get] out of [the container exited from].~ ( c )]
            say__p=1;! [10: ~[The actor] [get] out of [the container exited from].~ ( c )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_256); new_line; .L_Say232; .L_SayX231;}
            }
    ! [11: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_178, 178, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor exiting ( this is the describe room emerged into rule ):
[ R_179 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_179, 179);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: surreptitiously reckon darkness]
        SilentlyConsiderLight();
        ! [4: produce a room description with going spacing conventions]
        LookAfterGoing();
        }
        } else if (debug_rules > 1) DB_Rule(R_179, 179, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Getting off (B161_check_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor getting off ( this is the can't get off things rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor getting off ( this is the can't get off things rule ):
[ R_180 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_180, 180);
    ! [2: if the actor is on the noun]
    if (((noun == SupporterOf(actor))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is carried by the noun]
    if (((noun == CarrierOf(actor))))
    {! [5: continue the action]
        rfalse;
        }
    ! [6: if the actor is the player]
    if (((actor == player)))
    {! [7: say ~But [we] [aren't] on [the noun] at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
        say__p=1;! [8: ~But [we] [aren't] on [the noun] at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_257); new_line; .L_Say233; .L_SayX232;}
    ! [9: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_180, 180, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Getting off (B162_carry_out_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor getting off ( this is the standard getting off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor getting off ( this is the standard getting off rule ):
[ R_181 
    tmp_0 ! Let/loop value, e.g., 'former exterior': object
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_181, 181);
    ! [2: let the former exterior be the not-counting-parts holder of the noun]

    		tmp_0 = (CoreOfParentOfCoreOf(noun));
    ! [3: surreptitiously move the actor to the former exterior]
    move actor to tmp_0;
    } else if (debug_rules > 1) DB_Rule(R_181, 181, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Getting off (B163_report_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor getting off ( this is the standard report getting off rule ):
!   === equally specific with ===
! Rule 2/2 ! Report an actor getting off ( this is the describe room stood up into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor getting off ( this is the standard report getting off rule ):
[ R_182 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_182, 182);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: say ~[The actor] [get] off [the noun].~ ( a )]
        say__p=1;! [4: ~[The actor] [get] off [the noun].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_258); new_line; .L_Say234; .L_SayX233;}
    ! [5: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_182, 182, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor getting off ( this is the describe room stood up into rule ):
[ R_183 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_183, 183);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: produce a room description with going spacing conventions]
        LookAfterGoing();
        }
        } else if (debug_rules > 1) DB_Rule(R_183, 183, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Looking (B165_carry_out_looking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Carry out looking ( this is the declare everything unmentioned rule ):
!   === equally specific with ===
! Rule 2/7 ! Carry out looking ( this is the new room description heading rule ):
!   === equally specific with ===
! Rule 3/7 ! Carry out looking ( this is the room description body text rule ):
!   === equally specific with ===
! Rule 4/7 ! this is the room description astral passages rule:
!   === equally specific with ===
! Rule 5/7 ! Carry out looking ( this is the room description paragraphs about objects rule ):
!   === equally specific with ===
! Rule 6/7 ! Carry out looking ( this is the check new arrival rule ):
!   === equally specific with ===
! Rule 7/7 ! Carry out looking ( this is the mark items as seen when looking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out looking ( this is the declare everything unmentioned rule ):
[ R_185 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_185, 185);
    ! [2: repeat with item running through things]
    for (tmp_0=Prop_51(0), tmp_1=Prop_51(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_51(tmp_1))
    {! [3: now the item is not mentioned]
        (Adj_96_t3_v10(tmp_0));
        }
        } else if (debug_rules > 1) DB_Rule(R_185, 185, 'actor');
        rfalse;
];
! From "Third Person Narration" by Philip Riley
! No specific request
! Carry out looking ( this is the new room description heading rule ):
[ R_1042 
    tmp_0 ! Let/loop value, e.g., 'intermediate level': object
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((real_location == I411_isolation_booth)))) rfalse;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1042, 1042);
    ! [2: say ~Agent [Player] is ~]
    say__p=1;! [3: ~Agent ~]
    ParaContent(); print "Agent ";! [4: player]
    ParaContent(); PrintShortName(player);! [5: ~ is ~]
    ParaContent(); print " is "; .L_Say235; .L_SayX234;! [6: say bold type]
    say__p=1;! [7: bold type]
    ParaContent(); (PHR_352_r2 ()); .L_Say236; .L_SayX235;! [8: if the visibility level count is 0]
    if ((((MStack-->MstVO(20011,2)) == 0)))
    {! [9: begin the printing the name of a dark room activity]
        BeginActivity(V9_printing_the_name_of_a_da);
        ! [10: if handling the printing the name of a dark room activity]
        if (((~~(ForActivity(V9_printing_the_name_of_a_da)))))
        {! [11: say ~in the dark~ ( a )]
            say__p=1;! [12: ~in the dark~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_259); .L_Say237; .L_SayX236;}
        ! [13: end the printing the name of a dark room activity]
        EndActivity(V9_printing_the_name_of_a_da);
        } else {
        ! [14: if the visibility ceiling is the location]
        if ((((MStack-->MstVO(20011,3)) == real_location)))
        {! [15: say ~[roman type][the preposition of the location][bold type] [if the visibility ceiling is always-indefinite][a visibility ceiling][otherwise][the visibility ceiling][end if]~]
            say__p=1;! [16: roman type]
            ParaContent(); (PHR_354_r3 ());! [17: the preposition of the location]
            ParaContent(); @push self; print (TEXT_TY_Say) GProperty(OBJECT_TY, self=real_location,p21_preposition);@pull self; ! [18: bold type]
            ParaContent(); (PHR_352_r2 ());! [19: ~ ~]
            ParaContent(); print " ";! [20: if the visibility ceiling is always-indefinite]

            	if (~~(((((Adj_143_t1_v10((MStack-->MstVO(20011,3))))))))) jump L_Say238;! [21: a visibility ceiling]
            ParaContent(); print (a) (MStack-->MstVO(20011,3));! [22: otherwise]

            	jump L_SayX237; .L_Say238;! [23: the visibility ceiling]
            ParaContent(); print (the) (MStack-->MstVO(20011,3));! [24: end if]

            	.L_Say239; .L_SayX237; .L_Say240; .L_SayX238;} else {
            ! [25: say ~in [the visibility ceiling]~]
            say__p=1;! [26: ~in ~]
            ParaContent(); print "in ";! [27: the visibility ceiling]
            ParaContent(); print (the) (MStack-->MstVO(20011,3)); .L_Say241; .L_SayX239;}
            }
    ! [28: say roman type]
    say__p=1;! [29: roman type]
    ParaContent(); (PHR_354_r3 ()); .L_Say242; .L_SayX240;! [30: say ~. [run paragraph on]~]
    say__p=1;! [31: ~. ~]
    ParaContent(); print ". ";! [32: run paragraph on]
    ParaContent(); RunParagraphOn(); .L_Say243; .L_SayX241;! [33: let intermediate level be the visibility-holder of the actor]

    		tmp_0 = VisibilityParent(actor);
    ! [34: if visibility level count > 1]
    if ((((MStack-->MstVO(20011,2)) > 1)))
    {! [35: say ~[We] [are]~]
        say__p=1;! [36: we]
        ParaContent(); (PHR_764_r7 ());! [37: ~ ~]
        ParaContent(); print " ";! [38: are]
        ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say244; .L_SayX242;! [39: repeat with intermediate level count running from 2 to the visibility level count]
        for (tmp_1=2: tmp_1<=(MStack-->MstVO(20011,2)): tmp_1++)
        {! [40: if the intermediate level is a supporter or the intermediate level is an animal]
            if ((((tmp_0 ofclass K6_supporter))) || (((tmp_0 ofclass K13_animal))))
            {! [41: say ~ on [the intermediate level]~ ( b )]
                say__p=1;! [42: ~ on [the intermediate level]~ ( b )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_260); .L_Say245; .L_SayX243;} else {
                ! [43: say ~ in [the intermediate level]~ ( c )]
                say__p=1;! [44: ~ in [the intermediate level]~ ( c )]
                ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_261); .L_Say246; .L_SayX244;}
            ! [45: let the intermediate level be the visibility-holder of the intermediate level]
            tmp_0 = VisibilityParent(tmp_0);
            }
        ! [46: say ~. [run paragraph on]~]
        say__p=1;! [47: ~. ~]
        ParaContent(); print ". ";! [48: run paragraph on]
        ParaContent(); RunParagraphOn(); .L_Say247; .L_SayX245;}
    ! [49: if the description of the location is ~~]
    if ((( BlkValueCompare(GProperty(OBJECT_TY, real_location,description), EMPTY_TEXT_VALUE) == 0)))
    {! [50: say paragraph break]
        say__p=1;! [51: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say248; .L_SayX246;}
        } else if (debug_rules > 1) DB_Rule(R_1042, 1042, 'actor');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out looking ( this is the room description body text rule ):
[ R_187 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_187, 187);
    ! [2: if the visibility level count is 0]
    if ((((MStack-->MstVO(20011,2)) == 0)))
    {! [3: if set to abbreviated room descriptions]
        if (((lookmode == 3)))
        {! [4: continue the action]
            rfalse;
            }
        ! [5: if set to sometimes abbreviated room descriptions and abbreviated form allowed is true and darkness witnessed is true]
        if ((((lookmode == 1))) && ((((((MStack-->MstVO(20011,1)) && true) == (1 && true)))) && (((((Global_Vars-->0) && true) == (1 && true))))))
        {! [6: continue the action]
            rfalse;
            }
        ! [7: begin the printing the description of a dark room activity]
        BeginActivity(V10_printing_the_description);
        ! [8: if handling the printing the description of a dark room activity]
        if (((~~(ForActivity(V10_printing_the_description)))))
        {! [9: now the prior named object is nothing]
            prior_named_noun = nothing;
            ! [10: say ~[It] [are] pitch dark, and [we] [can't see] a thing.~ ( a )]
            say__p=1;! [11: ~[It] [are] pitch dark, and [we] [can't see] a thing.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_262); new_line; .L_Say249; .L_SayX247;}
        ! [12: end the printing the description of a dark room activity]
        EndActivity(V10_printing_the_description);
        } else {
        ! [13: if the visibility ceiling is the location]
        if ((((MStack-->MstVO(20011,3)) == real_location)))
        {! [14: if set to abbreviated room descriptions]
            if (((lookmode == 3)))
            {! [15: continue the action]
                rfalse;
                }
            ! [16: if set to sometimes abbreviated room descriptions and abbreviated form allowed is true and the location is visited]
            if ((((lookmode == 1))) && ((((((MStack-->MstVO(20011,1)) && true) == (1 && true)))) && ((((Adj_80_t1_v10(real_location)))))))
            {! [17: continue the action]
                rfalse;
                }
            ! [18: print the location's description]
            PrintOrRun(location, description);
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_187, 187, 'actor');
            rfalse;
];
! From "Hyperspace" by Philip Riley
! No specific request
! this is the room description astral passages rule:
[ R_1243 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(5);
    BlkValueCreateOnStack(3, TEXT_TY);
    BlkValueCreateOnStack(1, TEXT_TY);
    BlkValueCreateOnStack(0, KD2_list_of_texts);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_28();
    @pull formal_par1;
    @pull formal_par0;
    BlkValueFreeOnStack(3);
    BlkValueFreeOnStack(1);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_28 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1243, 1243);
    ! [2: if the player wears the astral lenses and the location is not in hyperspace]
    if ((((player == WearerOf(I426_astral_lenses)))) && (((~~((TestRegionalContainment(real_location,I232_hyperspace)))))))
    {! [3: let directions be a list of texts]
        tmp_0 = I7SFRAME; 
        		
        ! [4: repeat with d running through hyperspatial directions]
        for (tmp_1=Prop_52(0), tmp_2=Prop_52(tmp_1): tmp_1: tmp_1=tmp_2, tmp_2=Prop_52(tmp_2))
        {! [5: if the room d from the location is somewhere]
            if (((LocationOf(
            ! Resolution of run-time phrase ambiguity (deciding a value):
                (
                    ! This value evaluates third (i.e., last)
                    formal_rv
                +
                    0*(
                        ! The following condition evaluates second
                        ((
                            ((((((formal_par1 ofclass K1_room) && (formal_par1 ofclass K1_room))))) && ((
                            formal_rv = MapConnection(formal_par1,formal_par0)) | 1)
                            )|| (ArgumentTypeFailed(80, 27))

                        ))
                    +
                        ! The following assignments evaluate first
                        ((formal_par1 = real_location) +
                        (formal_par0 = tmp_1)
                        ))
                )

            ! Resolution complete
            ) ofclass K1_room)))
            {! [6: add ~'[D]'~ to directions]
                LIST_OF_TY_InsertItem(tmp_0, BlkValueCopy((I7SFRAME+WORDSIZE), ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*3),TX_S_365))), 0, 0, 0);
                }
                }
        ! [7: if directions is not empty]
        if (((~~(((Adj_17_t1_v34(tmp_0)))))))
        {! [8: if encountered astral passages is false]
            if (((((Global_Vars-->48) && true) == (0 && true))))
            {! [9: now encountered astral passages is true]
                (Global_Vars-->48) = 1;
                ! [10: let c be number of entries of directions]

                		tmp_1 = LIST_OF_TY_GetLength(tmp_0);
                ! [11: say ~[if C is 1]A s[otherwise]S[end if]trange sparkly white [regarding C]passage[if C > 1]s[end if] [branch] off in [if C is 1]an impossible direction[otherwise]impossible directions[end if] from here.^^[Player's surname] [have] discovered [if C is 1]a hyperspatial tunnel[otherwise]hyperspatial tunnels[end if]! [regarding C][They] [lead] in the hyperspatial [regarding C]direction[if C > 1]s[end if] of [directions].~]
                say__p=1;! [12: if c is 1]

                	if (~~((((tmp_1 == 1))))) jump L_Say250;! [13: ~A s~]
                ParaContent(); print "A s";! [14: otherwise]

                	jump L_SayX248; .L_Say250;! [15: ~S~]
                ParaContent(); print "S";! [16: end if]

                	.L_Say251; .L_SayX248;! [17: ~trange sparkly white ~]
                ParaContent(); print "trange sparkly white ";! [18: regarding c]
                ParaContent(); RegardingNumber(tmp_1);! [19: ~passage~]
                ParaContent(); print "passage";! [20: if c > 1]

                	if (~~((((tmp_1 > 1))))) jump L_Say252;! [21: ~s~]
                ParaContent(); print "s";! [22: end if]

                	.L_Say252; .L_SayX249;! [23: ~ ~]
                ParaContent(); print " ";! [24: branch]
                ConjugateVerb_98(CV_POS, PNToVP(), story_tense); say__p=1; ! [25: ~ off in ~]
                ParaContent(); print " off in ";! [26: if c is 1]

                	if (~~((((tmp_1 == 1))))) jump L_Say253;! [27: ~an impossible direction~]
                ParaContent(); print "an impossible direction";! [28: otherwise]

                	jump L_SayX250; .L_Say253;! [29: ~impossible directions~]
                ParaContent(); print "impossible directions";! [30: end if]

                	.L_Say254; .L_SayX250;! [31: ~ from here.^^~]
                ParaContent(); print " from here.^^";! [32: player's surname]
                ParaContent(); print (TEXT_TY_Say) (Global_Vars-->20);! [33: ~ ~]
                ParaContent(); print " ";! [34: have]
                ConjugateVerb_2(CV_POS, PNToVP(), story_tense); say__p=1; ! [35: ~ discovered ~]
                ParaContent(); print " discovered ";! [36: if c is 1]

                	if (~~((((tmp_1 == 1))))) jump L_Say255;! [37: ~a hyperspatial tunnel~]
                ParaContent(); print "a hyperspatial tunnel";! [38: otherwise]

                	jump L_SayX251; .L_Say255;! [39: ~hyperspatial tunnels~]
                ParaContent(); print "hyperspatial tunnels";! [40: end if]

                	.L_Say256; .L_SayX251;! [41: ~! ~]
                ParaContent(); print "! ";! [42: regarding c]
                ParaContent(); RegardingNumber(tmp_1);! [43: they]
                ParaContent(); (PHR_776_r43 ());! [44: ~ ~]
                ParaContent(); print " ";! [45: lead]
                ConjugateVerb_39(CV_POS, PNToVP(), story_tense); say__p=1; ! [46: ~ in the hyperspatial ~]
                ParaContent(); print " in the hyperspatial ";! [47: regarding c]
                ParaContent(); RegardingNumber(tmp_1);! [48: ~direction~]
                ParaContent(); print "direction";! [49: if c > 1]

                	if (~~((((tmp_1 > 1))))) jump L_Say257;! [50: ~s~]
                ParaContent(); print "s";! [51: end if]

                	.L_Say257; .L_SayX252;! [52: ~ of ~]
                ParaContent(); print " of ";! [53: directions]
                ParaContent(); LIST_OF_TY_Say(tmp_0);! [54: ~.~]
                ParaContent(); print "."; new_line; .L_Say258; .L_SayX253;! [55: say ~For help regarding hyperspace, enter [bold type]HELP HYPERSPACE[roman type].~]
                say__p=1;! [56: ~For help regarding hyperspace, enter ~]
                ParaContent(); print "For help regarding hyperspace, enter ";! [57: bold type]
                ParaContent(); (PHR_352_r2 ());! [58: ~HELP HYPERSPACE~]
                ParaContent(); print "HELP HYPERSPACE";! [59: roman type]
                ParaContent(); (PHR_354_r3 ());! [60: ~.~]
                ParaContent(); print "."; new_line; .L_Say259; .L_SayX254;} else {
                ! [61: let c be number of entries of directions]

                		tmp_1 = LIST_OF_TY_GetLength(tmp_0);
                ! [62: say ~[if C is 1]A hyperspatial tunnel[otherwise]Hyperspatial tunnels[end if] [regarding C][lead] in the [regarding C]direction[if C > 1]s[end if] of [directions].~]
                say__p=1;! [63: if c is 1]

                	if (~~((((tmp_1 == 1))))) jump L_Say260;! [64: ~A hyperspatial tunnel~]
                ParaContent(); print "A hyperspatial tunnel";! [65: otherwise]

                	jump L_SayX255; .L_Say260;! [66: ~Hyperspatial tunnels~]
                ParaContent(); print "Hyperspatial tunnels";! [67: end if]

                	.L_Say261; .L_SayX255;! [68: ~ ~]
                ParaContent(); print " ";! [69: regarding c]
                ParaContent(); RegardingNumber(tmp_1);! [70: lead]
                ConjugateVerb_39(CV_POS, PNToVP(), story_tense); say__p=1; ! [71: ~ in the ~]
                ParaContent(); print " in the ";! [72: regarding c]
                ParaContent(); RegardingNumber(tmp_1);! [73: ~direction~]
                ParaContent(); print "direction";! [74: if c > 1]

                	if (~~((((tmp_1 > 1))))) jump L_Say262;! [75: ~s~]
                ParaContent(); print "s";! [76: end if]

                	.L_Say262; .L_SayX256;! [77: ~ of ~]
                ParaContent(); print " of ";! [78: directions]
                ParaContent(); LIST_OF_TY_Say(tmp_0);! [79: ~.~]
                ParaContent(); print "."; new_line; .L_Say263; .L_SayX257;}
                }
                }
                } else if (debug_rules > 1) DB_Rule(R_1243, 1243, 'actor');
                rfalse;
];
! From the Standard Rules
! No specific request
! Carry out looking ( this is the room description paragraphs about objects rule ):
[ R_188 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_188, 188);
    ! [2: if the visibility level count is greater than 0]
    if ((((MStack-->MstVO(20011,2)) > 0)))
    {! [3: let the intermediate position be the actor]

        		tmp_0 = actor;
        ! [4: let the ip count be the visibility level count]

        		tmp_1 = (MStack-->MstVO(20011,2));
        ! [5: while the ip count is greater than 0]
        while (((tmp_1 > 0)))
        {! [6: now the intermediate position is marked for listing]
            (Adj_94_t2_v10(tmp_0));
            ! [7: let the intermediate position be the visibility-holder of the intermediate position]
            tmp_0 = VisibilityParent(tmp_0);
            ! [8: decrease the ip count by 1]
            tmp_1 = tmp_1 - 1;;
            }
        ! [9: let the top-down ip count be the visibility level count]

        		tmp_2 = (MStack-->MstVO(20011,2));
        ! [10: while the top-down ip count is greater than 0]
        while (((tmp_2 > 0)))
        {! [11: let the intermediate position be the actor]
            tmp_0 = actor;
            ! [12: let the ip count be 0]
            tmp_1 = 0;
            ! [13: while the ip count is less than the top-down ip count]
            while (((tmp_1 < tmp_2)))
            {! [14: let the intermediate position be the visibility-holder of the intermediate position]
                tmp_0 = VisibilityParent(tmp_0);
                ! [15: increase the ip count by 1]
                tmp_1 = tmp_1 + 1;;
                }
            ! [16: describe locale for the intermediate position]
            (PHR_79_r42 (tmp_0));
            ! [17: decrease the top-down ip count by 1]
            tmp_2 = tmp_2 - 1;;
            }
            }
    ! [18: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_188, 188, 'actor');
    rfalse;
];
! From the Standard Rules
! No specific request
! Carry out looking ( this is the check new arrival rule ):
[ R_189 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_189, 189);
    ! [2: if in darkness]
    if (((location==thedark)))
    {! [3: now the darkness witnessed is true]
        (Global_Vars-->0) = 1;
        } else {
        ! [4: if the location is a room]
        if (((real_location ofclass K1_room)))
        {! [5: now the location is visited]
            (Adj_80_t2_v10(real_location));
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_189, 189, 'actor');
            rfalse;
];
! From "Epistemology" by Eric Eve
! No specific request
! Carry out looking ( this is the mark items as seen when looking rule ):
[ R_797 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_797, 797);
    ! [2: unless in darkness]
    if (~~(((location==thedark))))
    {! [3: now every backdrop in the location is seen]
        Prop_53();
        ! [4: repeat with item running through things that are enclosed by the location]
        for (tmp_0=Prop_54(0), tmp_1=Prop_54(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_54(tmp_1))
        {! [5: if the item is not enclosed by an opaque closed container]
            if ((((~~Prop_55(tmp_0)))))
            {! [6: now the item is familiar]
                (Adj_118_t2_v10(tmp_0));
                ! [7: now the item is seen]
                (Adj_116_t2_v10(tmp_0));
                }
                }
                }
                } else if (debug_rules > 1) DB_Rule(R_797, 797, 'actor');
                rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Looking (B166_report_looking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor looking ( this is the other people looking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor looking ( this is the other people looking rule ):
[ R_190 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_190, 190);
    ! [2: if the actor is not the player]
    if (((~~((actor == player)))))
    {! [3: say ~[The actor] [look] around.~ ( a )]
        say__p=1;! [4: ~[The actor] [look] around.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_263); new_line; .L_Say264; .L_SayX258;}
        } else if (debug_rules > 1) DB_Rule(R_190, 190, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Examining (B167_check_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check examining down ( this is the standard looking down rule ):
!   === equally specific with ===
! Rule 2/2 ! Check examining up ( this is the standard looking up rule ):
! ----------------------------------------------------------------------------------------------------
! From "Floors" by Philip Riley
! No specific request
! Check examining down ( this is the standard looking down rule ):
[ R_1086 ;
    if ((( (actor==player) && ((noun == I60_down) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1086, 1086);
    ! [2: try examining the floor]
    TryAction(0, player, ##Examine, I193_floor, 0);
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1086, 1086, 'action');
    rfalse;
];
! From "Ceilings" by Philip Riley
! No specific request
! Check examining up ( this is the standard looking up rule ):
[ R_1103 ;
    if ((( (actor==player) && ((noun == I59_up) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1103, 1103);
    ! [2: try examining the ceiling]
    TryAction(0, player, ##Examine, I194_ceiling, 0);
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1103, 1103, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Examining (B168_carry_out_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/8 ! Carry out examining something visible ( this is the mark items as seen on examining rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/8 ! Carry out examining ( this is the standard examining rule ):
!   === equally specific with ===
! Rule 3/8 ! Carry out examining ( this is the examine directions rule ):
!   === equally specific with ===
! Rule 4/8 ! Carry out examining ( this is the examine containers rule ):
!   === equally specific with ===
! Rule 5/8 ! Carry out examining ( this is the examine supporters rule ):
!   === equally specific with ===
! Rule 6/8 ! Carry out examining ( this is the examine devices rule ):
!   === equally specific with ===
! Rule 7/8 ! Carry out examining ( this is the examine undescribed things rule ):
!   === equally specific with ===
! Rule 8/8 ! Carry out examining ( this is the examine two-sided doors rule ):
! ----------------------------------------------------------------------------------------------------
! From "Epistemology" by Eric Eve
! No specific request
! Carry out examining something visible ( this is the mark items as seen on examining rule ):
[ R_799 ;
    if ((( (actor==player) && ((noun ofclass K2_thing) && ((Adj_3_t1_v10(noun))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_799, 799);
    ! [2: now the noun is familiar]
    (Adj_118_t2_v10(noun));
    ! [3: now the noun is seen]
    (Adj_116_t2_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_799, 799, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Carry out examining ( this is the standard examining rule ):
[ R_191 ;
    if ((((noun ofclass K30_two_sided_door)))) rfalse;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_191, 191);
    ! [2: if the noun provides the property description and the description of the noun is not ~~]
    if ((((WhetherProvides(noun, false, description)))) && (((~~(( BlkValueCompare(GProperty(OBJECT_TY, noun,description), EMPTY_TEXT_VALUE) == 0))))))
    {! [3: say ~[description of the noun][line break]~]
        say__p=1;! [4: description of the noun]
        ParaContent(); @push self; print (TEXT_TY_Say) GProperty(OBJECT_TY, self=noun,description);@pull self; ! [5: line break]
        ParaContent(); new_line; .L_Say265; .L_SayX259;! [6: now examine text printed is true]
        (MStack-->MstVO(20012,0)) = 1;
        }
        } else if (debug_rules > 1) DB_Rule(R_191, 191, 'actor');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out examining ( this is the examine directions rule ):
[ R_192 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_192, 192);
    ! [2: if the noun is a direction]
    if (((noun ofclass K3_direction)))
    {! [3: say ~[We] [see] nothing unexpected in that direction.~ ( a )]
        say__p=1;! [4: ~[We] [see] nothing unexpected in that direction.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_264); new_line; .L_Say266; .L_SayX260;! [5: now examine text printed is true]
        (MStack-->MstVO(20012,0)) = 1;
        }
        } else if (debug_rules > 1) DB_Rule(R_192, 192, 'actor');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out examining ( this is the examine containers rule ):
[ R_193 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_193, 193);
    ! [2: if the noun is a container]
    if (((noun ofclass K5_container)))
    {! [3: if the noun is open or the noun is transparent]
        if (((((Adj_101_t1_v10(noun))))) || ((((Adj_100_t1_v10(noun))))))
        {! [4: if something described which is not scenery is in the noun and something which is not the player is in the noun]
            if (((((Prop_56())))) && ((((Prop_57())))))
            {! [5: say ~In [the noun] ~ ( a )]
                say__p=1;! [6: ~In [the noun] ~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_265); .L_Say267; .L_SayX261;! [7: list the contents of the noun , as a sentence , tersely , not listing concealed items , prefacing with is/are]
                WriteListFrom(child(noun), 3144);
                ! [8: say ~.~]
                say__p=1;! [9: ~.~]
                ParaContent(); print "."; new_line; .L_Say268; .L_SayX262;! [10: now examine text printed is true]
                (MStack-->MstVO(20012,0)) = 1;
                } else {
                ! [11: if examine text printed is false]
                if (((((MStack-->MstVO(20012,0)) && true) == (0 && true))))
                {! [12: if the player is in the noun]
                    if (((noun == ContainerOf(player))))
                    {! [13: make no decision]
                        rfalse;
                        }
                    ! [14: say ~[The noun] [are] empty.~ ( b )]
                    say__p=1;! [15: ~[The noun] [are] empty.~ ( b )]
                    ParaContent(); print (TEXT_TY_Say) (TX_R_266); new_line; .L_Say269; .L_SayX263;! [16: now examine text printed is true]
                    (MStack-->MstVO(20012,0)) = 1;
                    }
                    }
                    }
                    }
                    } else if (debug_rules > 1) DB_Rule(R_193, 193, 'actor');
                    rfalse;
];
! From the Standard Rules
! No specific request
! Carry out examining ( this is the examine supporters rule ):
[ R_194 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_194, 194);
    ! [2: if the noun is a supporter]
    if (((noun ofclass K6_supporter)))
    {! [3: if something described which is not scenery is on the noun and something which is not the player is on the noun]
        if (((((Prop_58())))) && ((((Prop_59())))))
        {! [4: say ~On [the noun] ~ ( a )]
            say__p=1;! [5: ~On [the noun] ~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_267); .L_Say270; .L_SayX264;! [6: list the contents of the noun , as a sentence , tersely , not listing concealed items , prefacing with is/are , including contents , giving brief inventory information]
            WriteListFrom(child(noun), 3288);
            ! [7: say ~.~]
            say__p=1;! [8: ~.~]
            ParaContent(); print "."; new_line; .L_Say271; .L_SayX265;! [9: now examine text printed is true]
            (MStack-->MstVO(20012,0)) = 1;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_194, 194, 'actor');
            rfalse;
];
! From the Standard Rules
! No specific request
! Carry out examining ( this is the examine devices rule ):
[ R_195 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_195, 195);
    ! [2: if the noun is a device]
    if (((noun ofclass K14_device)))
    {! [3: say ~[The noun] [are] [if story tense is present tense]currently [end if]switched [if the noun is switched on]on[otherwise]off[end if].~ ( a )]
        say__p=1;! [4: ~[The noun] [are] [if story tense is present tense]currently [end if]switched [if the noun is switched on]on[otherwise]off[end if].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_268); new_line; .L_Say272; .L_SayX266;! [5: now examine text printed is true]
        (MStack-->MstVO(20012,0)) = 1;
        }
        } else if (debug_rules > 1) DB_Rule(R_195, 195, 'actor');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out examining ( this is the examine undescribed things rule ):
[ R_196 ;
    if ((((noun ofclass K30_two_sided_door)))) rfalse;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_196, 196);
    ! [2: if examine text printed is false]
    if (((((MStack-->MstVO(20012,0)) && true) == (0 && true))))
    {! [3: say ~[We] [see] nothing special about [the noun].~ ( a )]
        say__p=1;! [4: ~[We] [see] nothing special about [the noun].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_269); new_line; .L_Say273; .L_SayX267;}
        } else if (debug_rules > 1) DB_Rule(R_196, 196, 'actor');
        rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Carry out examining ( this is the examine two-sided doors rule ):
[ R_1352 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    I7RBLK = KERNEL_29();
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_29 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1352, 1352);
    ! [2: if the noun is a two-sided door]
    if (((noun ofclass K30_two_sided_door)))
    {! [3: if the location is the frontside of the noun]
        if (((real_location == GProperty(OBJECT_TY, noun,p30_frontside))))
        {! [4: if the front description of the noun is not ~~]
            if (((~~(( BlkValueCompare(GProperty(OBJECT_TY, noun,p33_front_description), EMPTY_TEXT_VALUE) == 0)))))
            {! [5: say ~[front description of the noun][line break]~]
                say__p=1;! [6: front description of the noun]
                ParaContent(); @push self; print (TEXT_TY_Say) GProperty(OBJECT_TY, self=noun,p33_front_description);@pull self; ! [7: line break]
                ParaContent(); new_line; .L_Say274; .L_SayX268;! [8: now examine text printed is true]
                (MStack-->MstVO(20012,0)) = 1;
                ! [9: continue the action]
                rfalse;
                }
                }
        ! [10: if the location is the backside of the noun]
        if (((real_location == 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par0 ofclass K4_door) && (formal_par0 ofclass K4_door))))) && ((
                        formal_rv = (PHR_1345_r44 (formal_par0))) | 1)
                        )|| (ArgumentTypeFailed(80, 47))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par0 = noun)
                    ))
            )

        ! Resolution complete
        )))
        {! [11: if the back description of the noun is not ~~]
            if (((~~(( BlkValueCompare(GProperty(OBJECT_TY, noun,p34_back_description), EMPTY_TEXT_VALUE) == 0)))))
            {! [12: say ~[back description of the noun][line break]~]
                say__p=1;! [13: back description of the noun]
                ParaContent(); @push self; print (TEXT_TY_Say) GProperty(OBJECT_TY, self=noun,p34_back_description);@pull self; ! [14: line break]
                ParaContent(); new_line; .L_Say275; .L_SayX269;! [15: now examine text printed is true]
                (MStack-->MstVO(20012,0)) = 1;
                ! [16: continue the action]
                rfalse;
                }
                }
        ! [17: say ~[text of the examine undescribed things rule response (A)][line break]~]
        say__p=1;! [18: text of the examine undescribed things rule response ( a )]
        ParaContent(); (PHR_380_r40 (R_154_RESP_A));! [19: line break]
        ParaContent(); new_line; .L_Say276; .L_SayX270;}
        } else if (debug_rules > 1) DB_Rule(R_1352, 1352, 'actor');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Examining (B169_report_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor examining ( this is the report other people examining rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor examining ( this is the report other people examining rule ):
[ R_197 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_197, 197);
    ! [2: if the actor is not the player]
    if (((~~((actor == player)))))
    {! [3: say ~[The actor] [look] closely at [the noun].~ ( a )]
        say__p=1;! [4: ~[The actor] [look] closely at [the noun].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_270); new_line; .L_Say277; .L_SayX271;}
        } else if (debug_rules > 1) DB_Rule(R_197, 197, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Looking under (B171_carry_out_looking_under)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor looking under ( this is the standard looking under rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor looking under ( this is the standard looking under rule ):
[ R_198 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_198, 198);
    ! [2: if the player is the actor]
    if (((player == actor)))
    {! [3: say ~[We] [find] nothing of interest.~ ( a )]
        say__p=1;! [4: ~[We] [find] nothing of interest.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_271); new_line; .L_Say278; .L_SayX272;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_198, 198, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Looking under (B172_report_looking_under)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor looking under ( this is the report other people looking under rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor looking under ( this is the report other people looking under rule ):
[ R_199 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_199, 199);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: if the actor is not the player]
        if (((~~((actor == player)))))
        {! [4: say ~[The actor] [look] under [the noun].~ ( a )]
            say__p=1;! [5: ~[The actor] [look] under [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_272); new_line; .L_Say279; .L_SayX273;}
            }
            } else if (debug_rules > 1) DB_Rule(R_199, 199, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Searching (B173_check_searching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor searching ( this is the can't search unless container or supporter rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor searching ( this is the can't search closed opaque containers rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor searching ( this is the can't search unless container or supporter rule ):
[ R_200 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_200, 200);
    ! [2: if the noun is not a container and the noun is not a supporter]
    if ((((~~((noun ofclass K5_container))))) && (((~~((noun ofclass K6_supporter))))))
    {! [3: if the player is the actor]
        if (((player == actor)))
        {! [4: say ~[We] [find] nothing of interest.~ ( a )]
            say__p=1;! [5: ~[We] [find] nothing of interest.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_273); new_line; .L_Say280; .L_SayX274;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_200, 200, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor searching ( this is the can't search closed opaque containers rule ):
[ R_201 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_201, 201);
    ! [2: if the noun is a closed opaque container]
    if (((noun ofclass K5_container) && ((Adj_102_t1_v10(noun))) && ((Adj_99_t1_v10(noun)))))
    {! [3: if the player is the actor]
        if (((player == actor)))
        {! [4: say ~[We] [can't see] inside, since [the noun] [are] closed.~ ( a )]
            say__p=1;! [5: ~[We] [can't see] inside, since [the noun] [are] closed.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_274); new_line; .L_Say281; .L_SayX275;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_201, 201, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Searching (B175_report_searching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report searching a container ( this is the standard search containers rule ):
!   === equally specific with ===
! Rule 2/3 ! Report searching a supporter ( this is the standard search supporters rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 3/3 ! Report an actor searching ( this is the report other people searching rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report searching a container ( this is the standard search containers rule ):
[ R_202 ;
    if ((( (actor==player) && ((noun ofclass K5_container))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_202, 202);
    ! [2: if the noun contains a described thing which is not scenery]
    if ((((Prop_60()))))
    {! [3: say ~In [the noun] ~ ( a )]
        say__p=1;! [4: ~In [the noun] ~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_275); .L_Say282; .L_SayX276;! [5: list the contents of the noun , as a sentence , tersely , not listing concealed items , prefacing with is/are]
        WriteListFrom(child(noun), 3144);
        ! [6: say ~.~]
        say__p=1;! [7: ~.~]
        ParaContent(); print "."; new_line; .L_Say283; .L_SayX277;} else {
        ! [8: say ~[The noun] [are] empty.~ ( b )]
        say__p=1;! [9: ~[The noun] [are] empty.~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_276); new_line; .L_Say284; .L_SayX278;}
        } else if (debug_rules > 1) DB_Rule(R_202, 202, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Report searching a supporter ( this is the standard search supporters rule ):
[ R_203 ;
    if ((( (actor==player) && ((noun ofclass K6_supporter))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_203, 203);
    ! [2: if the noun supports a described thing which is not scenery]
    if ((((Prop_61()))))
    {! [3: say ~On [the noun] ~ ( a )]
        say__p=1;! [4: ~On [the noun] ~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_277); .L_Say285; .L_SayX279;! [5: list the contents of the noun , as a sentence , tersely , not listing concealed items , prefacing with is/are]
        WriteListFrom(child(noun), 3144);
        ! [6: say ~.~]
        say__p=1;! [7: ~.~]
        ParaContent(); print "."; new_line; .L_Say286; .L_SayX280;} else {
        ! [8: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [9: say ~[There] [are] nothing on [the noun].~ ( b )]
        say__p=1;! [10: ~[There] [are] nothing on [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_278); new_line; .L_Say287; .L_SayX281;}
        } else if (debug_rules > 1) DB_Rule(R_203, 203, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor searching ( this is the report other people searching rule ):
[ R_204 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_204, 204);
    ! [2: if the actor is not the player]
    if (((~~((actor == player)))))
    {! [3: say ~[The actor] [search] [the noun].~ ( a )]
        say__p=1;! [4: ~[The actor] [search] [the noun].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_279); new_line; .L_Say288; .L_SayX282;}
        } else if (debug_rules > 1) DB_Rule(R_204, 204, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Consulting it about (B178_report_consulting_it_ab)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor consulting something about ( this is the block consulting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor consulting something about ( this is the block consulting rule ):
[ R_205 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_205, 205);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~[We] [discover] nothing of interest in [the noun].~ ( a )]
        say__p=1;! [4: ~[We] [discover] nothing of interest in [the noun].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_280); new_line; .L_Say289; .L_SayX283;} else {
        ! [5: say ~[The actor] [look] at [the noun].~ ( b )]
        say__p=1;! [6: ~[The actor] [look] at [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_281); new_line; .L_Say290; .L_SayX284;}
        } else if (debug_rules > 1) DB_Rule(R_205, 205, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Locking it with (B179_check_locking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Check an actor locking a two-sided door with ( this is the can't lock a two-sided door without a lock rule ):
!   === equally specific with ===
! Rule 2/6 ! Check an actor locking a two-sided door with ( this is the can't lock a two-sided door that's already locked rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 3/6 ! Check an actor locking something with ( this is the can't lock without a lock rule ):
!   === equally specific with ===
! Rule 4/6 ! Check an actor locking something with ( this is the can't lock what's already locked rule ):
!   === equally specific with ===
! Rule 5/6 ! Check an actor locking something with ( this is the can't lock what's open rule ):
!   === equally specific with ===
! Rule 6/6 ! Check an actor locking something with ( this is the can't lock without the correct key rule ):
! ----------------------------------------------------------------------------------------------------
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Check an actor locking a two-sided door with ( this is the can't lock a two-sided door without a lock rule ):
[ R_1353 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    I7RBLK = KERNEL_30();
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_30 ;
    if ((((act_requester==nothing) && ((noun ofclass K30_two_sided_door))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1353, 1353);
    ! [2: if the location of the actor is the frontside of the noun and ( the noun is front-locks-the-back or the noun is front-locks-the-front )]
    if ((((LocationOf(actor) == GProperty(OBJECT_TY, noun,p30_frontside)))) && (((((Adj_166_t1_v10(noun))))) || ((((Adj_167_t1_v10(noun)))))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the location of the actor is the backside of the noun and ( the noun is back-locks-the-back or the noun is back-locks-the-front )]
    if ((((LocationOf(actor) == 
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K4_door) && (formal_par0 ofclass K4_door))))) && ((
                    formal_rv = (PHR_1345_r44 (formal_par0))) | 1)
                    )|| (ArgumentTypeFailed(95, 47))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par0 = noun)
                ))
        )

    ! Resolution complete
    ))) && (((((Adj_168_t1_v10(noun))))) || ((((Adj_169_t1_v10(noun)))))))
    {! [5: continue the action]
        rfalse;
        }
    ! [6: if the actor is the player]
    if (((actor == player)))
    {! [7: say ~[regarding the noun][Those] [don't] seem to be something [we] [can] lock.~ ( a )]
        say__p=1;! [8: ~[regarding the noun][Those] [don't] seem to be something [we] [can] lock.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_282); new_line; .L_Say291; .L_SayX285;}
    ! [9: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1353, 1353, 'action');
    rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Check an actor locking a two-sided door with ( this is the can't lock a two-sided door that's already locked rule ):
[ R_1354 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_31();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_31 ;
    if ((((act_requester==nothing) && ((noun ofclass K30_two_sided_door))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1354, 1354);
    ! [2: say ~A: [the noun]; [the actor].~]
    say__p=1;! [3: ~A: ~]
    ParaContent(); print "A: ";! [4: the noun]
    ParaContent(); print (the) noun;! [5: ~; ~]
    ParaContent(); print "; ";! [6: the actor]
    ParaContent(); print (the) actor;! [7: ~.~]
    ParaContent(); print "."; new_line; .L_Say292; .L_SayX286;! [8: if the noun is locked for actor]
    if (
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K30_two_sided_door) && (formal_par0 ofclass K30_two_sided_door))))) && ((
                    formal_rv = ((PHR_1347_r45 (formal_par0,formal_par1)))) | 1)
                    )|| (ArgumentTypeFailed(104, 47))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par1 = actor) +
                (formal_par0 = noun)
                ))
        )

    ! Resolution complete
    )
    {! [9: say ~B.~]
        say__p=1;! [10: ~B.~]
        ParaContent(); print "B."; new_line; .L_Say293; .L_SayX287;! [11: if the actor is the player]
        if (((actor == player)))
        {! [12: say ~C.~]
            say__p=1;! [13: ~C.~]
            ParaContent(); print "C."; new_line; .L_Say294; .L_SayX288;! [14: say ~[regarding the noun][They're] locked at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
            say__p=1;! [15: ~[regarding the noun][They're] locked at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_283); new_line; .L_Say295; .L_SayX289;}
        ! [16: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_1354, 1354, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor locking something with ( this is the can't lock without a lock rule ):
[ R_206 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_206, 206);
    ! [2: if the noun provides the property lockable and the noun is lockable]
    if ((((WhetherProvides(noun, true, lockable)))) && ((((Adj_105_t1_v10(noun))))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is the player]
    if (((actor == player)))
    {! [5: say ~[regarding the noun][Those] [don't] seem to be something [we] [can] lock.~ ( a )]
        say__p=1;! [6: ~[regarding the noun][Those] [don't] seem to be something [we] [can] lock.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_284); new_line; .L_Say296; .L_SayX290;}
    ! [7: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_206, 206, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor locking something with ( this is the can't lock what's already locked rule ):
[ R_207 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_207, 207);
    ! [2: if the noun is locked]
    if ((((Adj_106_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They're] locked at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They're] locked at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_285); new_line; .L_Say297; .L_SayX291;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_207, 207, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor locking something with ( this is the can't lock what's open rule ):
[ R_208 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_208, 208);
    ! [2: if the noun is open]
    if ((((Adj_101_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~First [we] [would have] to close [the noun].~ ( a )]
            say__p=1;! [5: ~First [we] [would have] to close [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_286); new_line; .L_Say298; .L_SayX292;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_208, 208, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor locking something with ( this is the can't lock without the correct key rule ):
[ R_209 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_209, 209);
    ! [2: if the holder of the second noun is not the actor or the noun does not provide the property matching key or the matching key of the noun is not the second noun]
    if ((((~~(((HolderOf(second)) == actor))))) || ((((~~((WhetherProvides(noun, false, with_key)))))) || (((~~((GProperty(OBJECT_TY, noun,with_key) == second)))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the second noun][Those] [don't] seem to fit the lock.~ ( a )]
            say__p=1;! [5: ~[regarding the second noun][Those] [don't] seem to fit the lock.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_287); new_line; .L_Say299; .L_SayX293;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_209, 209, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Locking it with (B180_carry_out_locking_it_wi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out an actor locking a two-sided door with ( this is the standard two-sided door locking rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 2/2 ! Carry out an actor locking something with ( this is the standard locking rule ):
! ----------------------------------------------------------------------------------------------------
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Carry out an actor locking a two-sided door with ( this is the standard two-sided door locking rule ):
[ R_1355 ;
    if ((((act_requester==nothing) && ((noun ofclass K30_two_sided_door))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1355, 1355);
    ! [2: if location of the actor is the frontside of the noun]
    if (((LocationOf(actor) == GProperty(OBJECT_TY, noun,p30_frontside))))
    {! [3: if noun is front-locks-the-front]
        if ((((Adj_167_t1_v10(noun)))))
        {! [4: now the noun is front-locked]
            (Adj_160_t2_v10(noun));
            }
        ! [5: if noun is front-locks-the-back]
        if ((((Adj_166_t1_v10(noun)))))
        {! [6: now the noun is back-locked]
            (Adj_161_t2_v10(noun));
            }
            } else {
        ! [7: if noun is back-locks-the-front]
        if ((((Adj_169_t1_v10(noun)))))
        {! [8: now the noun is front-locked]
            (Adj_160_t2_v10(noun));
            }
        ! [9: if noun is back-locks-the-back]
        if ((((Adj_168_t1_v10(noun)))))
        {! [10: now the noun is back-locked]
            (Adj_161_t2_v10(noun));
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_1355, 1355, 'action');
            rfalse;
];
! From the Standard Rules
! No specific request
! Carry out an actor locking something with ( this is the standard locking rule ):
[ R_210 ;
    if ((((noun ofclass K30_two_sided_door)))) rfalse;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_210, 210);
    ! [2: now the noun is locked]
    (Adj_106_t2_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_210, 210, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Locking it with (B181_report_locking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor locking something with ( this is the standard report locking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor locking something with ( this is the standard report locking rule ):
[ R_211 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_211, 211);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [lock] [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [lock] [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_288); new_line; .L_Say300; .L_SayX294;}
            } else {
        ! [6: if the actor is visible]
        if ((((Adj_3_t1_v10(actor)))))
        {! [7: say ~[The actor] [lock] [the noun].~ ( b )]
            say__p=1;! [8: ~[The actor] [lock] [the noun].~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_289); new_line; .L_Say301; .L_SayX295;}
            }
            } else if (debug_rules > 1) DB_Rule(R_211, 211, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Unlocking it with (B182_check_unlocking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Check an actor unlocking a swipe door with something swipable ( this is the can't unlock without the correct card key rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 2/6 ! Check an actor unlocking a two-sided door with ( this is the can't unlock a two-sided door without a lock rule ):
!   === equally specific with ===
! Rule 3/6 ! Check an actor unlocking a two-sided door with ( this is the can't unlock a two-sided door that's already unlocked rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 4/6 ! Check an actor unlocking something with ( this is the can't unlock without a lock rule ):
!   === equally specific with ===
! Rule 5/6 ! Check an actor unlocking something with ( this is the can't unlock what's already unlocked rule ):
!   === equally specific with ===
! Rule 6/6 ! Check an actor unlocking something with ( this is the can't unlock without the correct key rule ):
! ----------------------------------------------------------------------------------------------------
! From "Door Varieties" by Philip Riley
! No specific request
! Check an actor unlocking a swipe door with something swipable ( this is the can't unlock without the correct card key rule ):
[ R_1389 ;
    if ((((act_requester==nothing) && ((noun ofclass K35_swipe_door)) && ((second ofclass K2_thing) && ((Adj_176_t1_v10(second))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1389, 1389);
    ! [2: if the holder of the second noun is not the actor or the noun does not provide the property matching key or the matching key of the noun is not the second noun]
    if ((((~~(((HolderOf(second)) == actor))))) || ((((~~((WhetherProvides(noun, false, with_key)))))) || (((~~((GProperty(OBJECT_TY, noun,with_key) == second)))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the second noun][Those] [don't] seem to be the right card.~ ( a )]
            say__p=1;! [5: ~[regarding the second noun][Those] [don't] seem to be the right card.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_290); new_line; .L_Say302; .L_SayX296;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_1389, 1389, 'action');
        rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Check an actor unlocking a two-sided door with ( this is the can't unlock a two-sided door without a lock rule ):
[ R_1361 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    @push formal_par0;
    I7RBLK = KERNEL_32();
    @pull formal_par0;
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_32 ;
    if ((((act_requester==nothing) && ((noun ofclass K30_two_sided_door))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1361, 1361);
    ! [2: if the location of the actor is the frontside of the noun and ( the noun is front-locks-the-back or the noun is front-locks-the-front )]
    if ((((LocationOf(actor) == GProperty(OBJECT_TY, noun,p30_frontside)))) && (((((Adj_166_t1_v10(noun))))) || ((((Adj_167_t1_v10(noun)))))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the location of the actor is the backside of the noun and ( the noun is back-locks-the-back or the noun is back-locks-the-front )]
    if ((((LocationOf(actor) == 
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K4_door) && (formal_par0 ofclass K4_door))))) && ((
                    formal_rv = (PHR_1345_r44 (formal_par0))) | 1)
                    )|| (ArgumentTypeFailed(155, 47))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par0 = noun)
                ))
        )

    ! Resolution complete
    ))) && (((((Adj_168_t1_v10(noun))))) || ((((Adj_169_t1_v10(noun)))))))
    {! [5: continue the action]
        rfalse;
        }
    ! [6: if the actor is the player]
    if (((actor == player)))
    {! [7: say ~[can't unlock without a lock description for the noun][line break]~]
        say__p=1;! [8: can't unlock without a lock description for the noun]
        ParaContent(); print (TEXT_TY_Say) 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par0 ofclass K30_two_sided_door) && (formal_par0 ofclass K30_two_sided_door))))) && ((
                        formal_rv = (PHR_1357_r46 (I7SFRAME,formal_par0))) | 1)
                        )|| (ArgumentTypeFailed(1))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par0 = noun)
                    ))
            )

        ! Resolution complete
        ;! [9: line break]
        ParaContent(); new_line; .L_Say303; .L_SayX297;}
    ! [10: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1361, 1361, 'action');
    rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Check an actor unlocking a two-sided door with ( this is the can't unlock a two-sided door that's already unlocked rule ):
[ R_1363 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_33();
    @pull formal_par1;
    @pull formal_par0;
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_33 ;
    if ((((act_requester==nothing) && ((noun ofclass K30_two_sided_door))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1363, 1363);
    ! [2: unless the noun is locked for actor]
    if (~~(
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K30_two_sided_door) && (formal_par0 ofclass K30_two_sided_door))))) && ((
                    formal_rv = ((PHR_1347_r45 (formal_par0,formal_par1)))) | 1)
                    )|| (ArgumentTypeFailed(174, 47))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par1 = actor) +
                (formal_par0 = noun)
                ))
        )

    ! Resolution complete
    ))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[can't unlock already unlocked description for the noun][line break]~]
            say__p=1;! [5: can't unlock already unlocked description for the noun]
            ParaContent(); print (TEXT_TY_Say) 
            ! Resolution of run-time phrase ambiguity (deciding a value):
                (
                    ! This value evaluates third (i.e., last)
                    formal_rv
                +
                    0*(
                        ! The following condition evaluates second
                        ((
                            ((((((formal_par0 ofclass K30_two_sided_door) && (formal_par0 ofclass K30_two_sided_door))))) && ((
                            formal_rv = (PHR_1359_r47 (I7SFRAME,formal_par0))) | 1)
                            )|| (ArgumentTypeFailed(1))

                        ))
                    +
                        ! The following assignments evaluate first
                        ((formal_par0 = noun)
                        ))
                )

            ! Resolution complete
            ;! [6: line break]
            ParaContent(); new_line; .L_Say304; .L_SayX298;}
        ! [7: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_1363, 1363, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor unlocking something with ( this is the can't unlock without a lock rule ):
[ R_212 ;
    if ((((noun ofclass K30_two_sided_door)))) rfalse;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_212, 212);
    ! [2: if the noun provides the property lockable and the noun is lockable]
    if ((((WhetherProvides(noun, true, lockable)))) && ((((Adj_105_t1_v10(noun))))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is the player]
    if (((actor == player)))
    {! [5: say ~[regarding the noun][Those] [don't] seem to be something [we] [can] unlock.~ ( a )]
        say__p=1;! [6: ~[regarding the noun][Those] [don't] seem to be something [we] [can] unlock.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_291); new_line; .L_Say305; .L_SayX299;}
    ! [7: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_212, 212, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor unlocking something with ( this is the can't unlock what's already unlocked rule ):
[ R_213 ;
    if ((((noun ofclass K30_two_sided_door)))) rfalse;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_213, 213);
    ! [2: if the noun is not locked]
    if (((~~(((Adj_106_t1_v10(noun)))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They're] unlocked at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They're] unlocked at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_292); new_line; .L_Say306; .L_SayX300;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_213, 213, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor unlocking something with ( this is the can't unlock without the correct key rule ):
[ R_214 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_214, 214);
    ! [2: if the holder of the second noun is not the actor or the noun does not provide the property matching key or the matching key of the noun is not the second noun]
    if ((((~~(((HolderOf(second)) == actor))))) || ((((~~((WhetherProvides(noun, false, with_key)))))) || (((~~((GProperty(OBJECT_TY, noun,with_key) == second)))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the second noun][Those] [don't] seem to fit the lock.~ ( a )]
            say__p=1;! [5: ~[regarding the second noun][Those] [don't] seem to fit the lock.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_293); new_line; .L_Say307; .L_SayX301;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_214, 214, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Unlocking it with (B183_carry_out_unlocking_it_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Carry out an actor unlocking a time-locked two-sided door with ( this is the start lock countdown rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 2/3 ! Carry out an actor unlocking a two-sided door with ( this is the standard two-sided door unlocking rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 3/3 ! Carry out an actor unlocking something with ( this is the standard unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Carry out an actor unlocking a time-locked two-sided door with ( this is the start lock countdown rule ):
[ R_1360 ;
    if ((((act_requester==nothing) && ((noun ofclass K30_two_sided_door) && ((Adj_175_t1_v10(noun))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1360, 1360);
    ! [2: now the lock countdown of the noun is the time lock delay of the noun]
    WriteGProperty(OBJECT_TY, noun,p36_lock_countdown,GProperty(OBJECT_TY, noun,p32_time_lock_delay));
    } else if (debug_rules > 1) DB_Rule(R_1360, 1360, 'action');
    rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Carry out an actor unlocking a two-sided door with ( this is the standard two-sided door unlocking rule ):
[ R_1362 ;
    if ((((act_requester==nothing) && ((noun ofclass K30_two_sided_door))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1362, 1362);
    ! [2: if location of the actor is the frontside of the noun]
    if (((LocationOf(actor) == GProperty(OBJECT_TY, noun,p30_frontside))))
    {! [3: if noun is front-locks-the-front]
        if ((((Adj_167_t1_v10(noun)))))
        {! [4: now the noun is not front-locked]
            (Adj_160_t3_v10(noun));
            }
        ! [5: if noun is front-locks-the-back]
        if ((((Adj_166_t1_v10(noun)))))
        {! [6: now the noun is not back-locked]
            (Adj_161_t3_v10(noun));
            }
            } else {
        ! [7: if noun is back-locks-the-front]
        if ((((Adj_169_t1_v10(noun)))))
        {! [8: now the noun is not front-locked]
            (Adj_160_t3_v10(noun));
            }
        ! [9: if noun is back-locks-the-back]
        if ((((Adj_168_t1_v10(noun)))))
        {! [10: now the noun is not back-locked]
            (Adj_161_t3_v10(noun));
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_1362, 1362, 'action');
            rfalse;
];
! From the Standard Rules
! No specific request
! Carry out an actor unlocking something with ( this is the standard unlocking rule ):
[ R_215 ;
    if ((((noun ofclass K30_two_sided_door)))) rfalse;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_215, 215);
    ! [2: now the noun is not locked]
    (Adj_106_t3_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_215, 215, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Unlocking it with (B184_report_unlocking_it_wit)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor unlocking something with ( this is the standard report unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor unlocking something with ( this is the standard report unlocking rule ):
[ R_216 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_216, 216);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [unlock] [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [unlock] [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_294); new_line; .L_Say308; .L_SayX302;}
            } else {
        ! [6: if the actor is visible]
        if ((((Adj_3_t1_v10(actor)))))
        {! [7: say ~[The actor] [unlock] [the noun].~ ( b )]
            say__p=1;! [8: ~[The actor] [unlock] [the noun].~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_295); new_line; .L_Say309; .L_SayX303;}
            }
            } else if (debug_rules > 1) DB_Rule(R_216, 216, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Switching on (B185_check_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor switching on ( this is the can't switch on unless switchable rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor switching on ( this is the can't switch on what's already on rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor switching on ( this is the can't switch on unless switchable rule ):
[ R_217 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_217, 217);
    ! [2: if the noun provides the property switched on]
    if (((WhetherProvides(noun, true, on))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is the player]
    if (((actor == player)))
    {! [5: say ~[regarding the noun][They] [aren't] something [we] [can] switch.~ ( a )]
        say__p=1;! [6: ~[regarding the noun][They] [aren't] something [we] [can] switch.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_296); new_line; .L_Say310; .L_SayX304;}
    ! [7: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_217, 217, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor switching on ( this is the can't switch on what's already on rule ):
[ R_218 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_218, 218);
    ! [2: if the noun is switched on]
    if ((((Adj_112_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They're] already on.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They're] already on.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_297); new_line; .L_Say311; .L_SayX305;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_218, 218, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Switching on (B186_carry_out_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor switching on ( this is the standard switching on rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor switching on ( this is the standard switching on rule ):
[ R_219 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_219, 219);
    ! [2: now the noun is switched on]
    (Adj_112_t2_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_219, 219, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Switching on (B187_report_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor switching on ( this is the standard report switching on rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor switching on ( this is the standard report switching on rule ):
[ R_220 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_220, 220);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: say ~[The actor] [switch] [the noun] on.~ ( a )]
        say__p=1;! [4: ~[The actor] [switch] [the noun] on.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_298); new_line; .L_Say312; .L_SayX306;}
        } else if (debug_rules > 1) DB_Rule(R_220, 220, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Switching off (B188_check_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor switching off ( this is the can't switch off unless switchable rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor switching off ( this is the can't switch off what's already off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor switching off ( this is the can't switch off unless switchable rule ):
[ R_221 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_221, 221);
    ! [2: if the noun provides the property switched on]
    if (((WhetherProvides(noun, true, on))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is the player]
    if (((actor == player)))
    {! [5: say ~[regarding the noun][They] [aren't] something [we] [can] switch.~ ( a )]
        say__p=1;! [6: ~[regarding the noun][They] [aren't] something [we] [can] switch.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_299); new_line; .L_Say313; .L_SayX307;}
    ! [7: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_221, 221, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor switching off ( this is the can't switch off what's already off rule ):
[ R_222 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_222, 222);
    ! [2: if the noun is switched off]
    if ((((Adj_113_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They're] already off.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They're] already off.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_300); new_line; .L_Say314; .L_SayX308;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_222, 222, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Switching off (B189_carry_out_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor switching off ( this is the standard switching off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Carry out an actor switching off ( this is the standard switching off rule ):
[ R_223 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_223, 223);
    ! [2: now the noun is switched off]
    (Adj_113_t2_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_223, 223, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Switching off (B190_report_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor switching off ( this is the standard report switching off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor switching off ( this is the standard report switching off rule ):
[ R_224 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_224, 224);
    ! [2: if the action is not silent]
    if (((keep_silent == false)))
    {! [3: say ~[The actor] [switch] [the noun] off.~ ( a )]
        say__p=1;! [4: ~[The actor] [switch] [the noun] off.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_301); new_line; .L_Say315; .L_SayX309;}
        } else if (debug_rules > 1) DB_Rule(R_224, 224, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Opening (B191_check_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Check opening Biff's desk's drawer when biff's desk's drawer is locked and the blue flipphone is in biff's desk's drawer and the blue flipphone is ringing for the first time:
!   >>> I - Number of aspects constrained >>>
! Rule 2/6 ! Check an actor opening a two-sided door ( this is the can't open a two-sided door unless openable rule ):
!   === equally specific with ===
! Rule 3/6 ! Check an actor opening a two-sided door ( this is the can't open a two-sided door that's locked rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 4/6 ! Check an actor opening ( this is the can't open unless openable rule ):
!   === equally specific with ===
! Rule 5/6 ! Check an actor opening ( this is the can't open what's locked rule ):
!   === equally specific with ===
! Rule 6/6 ! Check an actor opening ( this is the can't open what's already open rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check opening Biff's desk's drawer when biff's desk's drawer is locked and the blue flipphone is in biff's desk's drawer and the blue flipphone is ringing for the first time:
[ R_1486 ;
    if ((PAPR_2() && (((TimesActionHasHappened-->2) == 1) && (ActionCurrentlyHappeningFlag->2)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1486, 1486);
    ! [2: now the player knows desk-locked]
    (RGuard_MT_2(player,I164_desk_locked));
    ! [3: say ~[We] [try] to open the desk to answer the phone, but it seems to be locked. [We] [sigh]. 'Margaret must have the key.'[paragraph break]~]
    say__p=1;! [4: we]
    ParaContent(); (PHR_764_r7 ());! [5: ~ ~]
    ParaContent(); print " ";! [6: try]
    ConjugateVerb_116(CV_POS, PNToVP(), story_tense); say__p=1; ! [7: ~ to open the desk to answer the phone, but it seems to be locked. ~]
    ParaContent(); print " to open the desk to answer the phone, but it seems to be locked. ";! [8: we]
    ParaContent(); (PHR_764_r7 ());! [9: ~ ~]
    ParaContent(); print " ";! [10: sigh]
    ConjugateVerb_105(CV_POS, PNToVP(), story_tense); say__p=1; ! [11: ~. 'Margaret must have the key.'~]
    ParaContent(); print ". ~Margaret must have the key.~";! [12: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say316; .L_SayX310;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1486, 1486, 'action');
    rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Check an actor opening a two-sided door ( this is the can't open a two-sided door unless openable rule ):
[ R_1365 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_34();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_34 ;
    if ((((act_requester==nothing) && ((noun ofclass K30_two_sided_door))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1365, 1365);
    ! [2: if the noun is front-openable and the closest side of the noun to the actor is front]
    if (((((Adj_162_t1_v10(noun))))) && (((
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K4_door) && (formal_par0 ofclass K4_door))))) && ((
                    formal_rv = (PHR_1348_r48 (formal_par0,formal_par1))) | 1)
                    )|| (ArgumentTypeFailed(193, 47))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par1 = actor) +
                (formal_par0 = noun)
                ))
        )

    ! Resolution complete
     == I286_front))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the noun is back-openable and the closest side of the noun to the actor is xback]
    if (((((Adj_163_t1_v10(noun))))) && (((
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K4_door) && (formal_par0 ofclass K4_door))))) && ((
                    formal_rv = (PHR_1348_r48 (formal_par0,formal_par1))) | 1)
                    )|| (ArgumentTypeFailed(195, 47))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par1 = actor) +
                (formal_par0 = noun)
                ))
        )

    ! Resolution complete
     == I287_xback))))
    {! [5: continue the action]
        rfalse;
        }
    ! [6: if the actor is the player]
    if (((actor == player)))
    {! [7: say ~[regarding the noun][They] [aren't] something [we] [can] open.~ ( a )]
        say__p=1;! [8: ~[regarding the noun][They] [aren't] something [we] [can] open.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_302); new_line; .L_Say317; .L_SayX311;}
    ! [9: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1365, 1365, 'action');
    rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Check an actor opening a two-sided door ( this is the can't open a two-sided door that's locked rule ):
[ R_1366 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_35();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_35 ;
    if ((((act_requester==nothing) && ((noun ofclass K30_two_sided_door))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1366, 1366);
    ! [2: if the noun is locked for actor]
    if (
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K30_two_sided_door) && (formal_par0 ofclass K30_two_sided_door))))) && ((
                    formal_rv = ((PHR_1347_r45 (formal_par0,formal_par1)))) | 1)
                    )|| (ArgumentTypeFailed(202, 47))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par1 = actor) +
                (formal_par0 = noun)
                ))
        )

    ! Resolution complete
    )
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They] [seem] to be locked.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They] [seem] to be locked.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_303); new_line; .L_Say318; .L_SayX312;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_1366, 1366, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor opening ( this is the can't open unless openable rule ):
[ R_225 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_225, 225);
    ! [2: if the noun provides the property openable and the noun is openable]
    if ((((WhetherProvides(noun, true, openable)))) && ((((Adj_103_t1_v10(noun))))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is the player]
    if (((actor == player)))
    {! [5: say ~[regarding the noun][They] [aren't] something [we] [can] open.~ ( a )]
        say__p=1;! [6: ~[regarding the noun][They] [aren't] something [we] [can] open.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_304); new_line; .L_Say319; .L_SayX313;}
    ! [7: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_225, 225, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor opening ( this is the can't open what's locked rule ):
[ R_226 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_226, 226);
    ! [2: if the noun provides the property lockable and the noun is locked]
    if ((((WhetherProvides(noun, true, lockable)))) && ((((Adj_106_t1_v10(noun))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They] [seem] to be locked.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They] [seem] to be locked.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_305); new_line; .L_Say320; .L_SayX314;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_226, 226, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor opening ( this is the can't open what's already open rule ):
[ R_227 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_227, 227);
    ! [2: if the noun is open]
    if ((((Adj_101_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They're] already open.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They're] already open.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_306); new_line; .L_Say321; .L_SayX315;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_227, 227, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Opening (B192_carry_out_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Carry out an actor opening an auto-closable two-sided door ( this is the start close countdown rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/3 ! Carry out an actor opening ( this is the standard opening rule ):
!   <<< I - Number of aspects constrained <<<
! Rule 3/3 ! Carry out opening a container ( this is the mark items as seen on opening a container rule ):
! ----------------------------------------------------------------------------------------------------
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Carry out an actor opening an auto-closable two-sided door ( this is the start close countdown rule ):
[ R_1364 ;
    if ((((act_requester==nothing) && ((noun ofclass K30_two_sided_door) && ((Adj_174_t1_v10(noun))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1364, 1364);
    ! [2: now the close countdown of the noun is the close delay of the noun]
    WriteGProperty(OBJECT_TY, noun,p37_close_countdown,GProperty(OBJECT_TY, noun,p31_close_delay));
    } else if (debug_rules > 1) DB_Rule(R_1364, 1364, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Carry out an actor opening ( this is the standard opening rule ):
[ R_228 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_228, 228);
    ! [2: now the noun is open]
    (Adj_101_t2_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_228, 228, 'action');
    rfalse;
];
! From "Epistemology" by Eric Eve
! No specific request
! Carry out opening a container ( this is the mark items as seen on opening a container rule ):
[ R_798 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((( (actor==player) && ((noun ofclass K5_container))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_798, 798);
    ! [2: repeat with item running through things that are enclosed by the noun]
    for (tmp_0=Prop_62(0), tmp_1=Prop_62(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_62(tmp_1))
    {! [3: if the item is unseen and the item is visible]
        if (((((Adj_117_t1_v10(tmp_0))))) && ((((Adj_3_t1_v10(tmp_0))))))
        {! [4: now the item is familiar]
            (Adj_118_t2_v10(tmp_0));
            ! [5: now the item is seen]
            (Adj_116_t2_v10(tmp_0));
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_798, 798, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Opening (B193_report_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor opening ( this is the reveal any newly visible interior rule ):
!   === equally specific with ===
! Rule 2/2 ! Report an actor opening ( this is the standard report opening rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor opening ( this is the reveal any newly visible interior rule ):
[ R_229 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_229, 229);
    ! [2: if the actor is the player and the noun is an opaque container and the first thing held by the noun is not nothing and the noun does not enclose the actor]
    if ((((actor == player))) && ((((noun ofclass K5_container) && ((Adj_99_t1_v10(noun))))) && ((((~~(((child(noun)) == nothing))))) && (((~~((IndirectlyContains(noun,actor)))))))))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: if the actor is the player]
            if (((actor == player)))
            {! [5: say ~[We] [open] [the noun], revealing ~ ( a )]
                say__p=1;! [6: ~[We] [open] [the noun], revealing ~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_307); .L_Say322; .L_SayX316;! [7: list the contents of the noun , as a sentence , tersely , not listing concealed items]
                WriteListFrom(child(noun), 2120);
                ! [8: say ~.~]
                say__p=1;! [9: ~.~]
                ParaContent(); print "."; new_line; .L_Say323; .L_SayX317;}
                }
        ! [10: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_229, 229, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor opening ( this is the standard report opening rule ):
[ R_230 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_230, 230);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [open] [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [open] [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_308); new_line; .L_Say324; .L_SayX318;}
            } else {
        ! [6: if the player can see the actor]
        if (((TestVisibility(player,actor))))
        {! [7: say ~[The actor] [open] [the noun].~ ( b )]
            say__p=1;! [8: ~[The actor] [open] [the noun].~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_309); new_line; .L_Say325; .L_SayX319;} else {
            ! [9: say ~[The noun] [open].~ ( c )]
            say__p=1;! [10: ~[The noun] [open].~ ( c )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_310); new_line; .L_Say326; .L_SayX320;}
            }
            } else if (debug_rules > 1) DB_Rule(R_230, 230, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Closing (B194_check_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor closing a two-sided door ( this is the can't close a two-sided door unless openable rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/3 ! Check an actor closing ( this is the can't close unless openable rule ):
!   === equally specific with ===
! Rule 3/3 ! Check an actor closing ( this is the can't close what's already closed rule ):
! ----------------------------------------------------------------------------------------------------
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Check an actor closing a two-sided door ( this is the can't close a two-sided door unless openable rule ):
[ R_1367 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_36();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_36 ;
    if ((((act_requester==nothing) && ((noun ofclass K30_two_sided_door))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1367, 1367);
    ! [2: if the noun is front-closable and the closest side of the noun to the actor is front]
    if (((((Adj_164_t1_v10(noun))))) && (((
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K4_door) && (formal_par0 ofclass K4_door))))) && ((
                    formal_rv = (PHR_1348_r48 (formal_par0,formal_par1))) | 1)
                    )|| (ArgumentTypeFailed(210, 47))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par1 = actor) +
                (formal_par0 = noun)
                ))
        )

    ! Resolution complete
     == I286_front))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the noun is back-closable and the closest side of the noun to the actor is xback]
    if (((((Adj_165_t1_v10(noun))))) && (((
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K4_door) && (formal_par0 ofclass K4_door))))) && ((
                    formal_rv = (PHR_1348_r48 (formal_par0,formal_par1))) | 1)
                    )|| (ArgumentTypeFailed(212, 47))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par1 = actor) +
                (formal_par0 = noun)
                ))
        )

    ! Resolution complete
     == I287_xback))))
    {! [5: continue the action]
        rfalse;
        }
    ! [6: if the actor is the player]
    if (((actor == player)))
    {! [7: say ~[regarding the noun][They] [aren't] something [we] [can] close.~ ( a )]
        say__p=1;! [8: ~[regarding the noun][They] [aren't] something [we] [can] close.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_311); new_line; .L_Say327; .L_SayX321;}
    ! [9: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1367, 1367, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor closing ( this is the can't close unless openable rule ):
[ R_231 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_231, 231);
    ! [2: if the noun provides the property openable and the noun is openable]
    if ((((WhetherProvides(noun, true, openable)))) && ((((Adj_103_t1_v10(noun))))))
    {! [3: continue the action]
        rfalse;
        }
    ! [4: if the actor is the player]
    if (((actor == player)))
    {! [5: say ~[regarding the noun][They] [aren't] something [we] [can] close.~ ( a )]
        say__p=1;! [6: ~[regarding the noun][They] [aren't] something [we] [can] close.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_312); new_line; .L_Say328; .L_SayX322;}
    ! [7: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_231, 231, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor closing ( this is the can't close what's already closed rule ):
[ R_232 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_232, 232);
    ! [2: if the noun is closed]
    if ((((Adj_102_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They're] already closed.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They're] already closed.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_313); new_line; .L_Say329; .L_SayX323;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_232, 232, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Closing (B195_carry_out_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out an actor closing a two-sided door ( this is the lock auto-locking two-sided doors rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Carry out an actor closing ( this is the standard closing rule ):
! ----------------------------------------------------------------------------------------------------
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Carry out an actor closing a two-sided door ( this is the lock auto-locking two-sided doors rule ):
[ R_1368 ;
    if ((((act_requester==nothing) && ((noun ofclass K30_two_sided_door))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1368, 1368);
    ! [2: if the noun is autolock-the-front]
    if ((((Adj_173_t1_v10(noun)))))
    {! [3: now the noun is front-locked]
        (Adj_160_t2_v10(noun));
        }
    ! [4: if the noun is autolock-the-back]
    if ((((Adj_172_t1_v10(noun)))))
    {! [5: now the noun is back-locked]
        (Adj_161_t2_v10(noun));
        }
        } else if (debug_rules > 1) DB_Rule(R_1368, 1368, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Carry out an actor closing ( this is the standard closing rule ):
[ R_233 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_233, 233);
    ! [2: now the noun is closed]
    (Adj_102_t2_v10(noun));
    } else if (debug_rules > 1) DB_Rule(R_233, 233, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Closing (B196_report_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor closing ( this is the standard report closing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor closing ( this is the standard report closing rule ):
[ R_234 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_234, 234);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [close] [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [close] [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_314); new_line; .L_Say330; .L_SayX324;}
            } else {
        ! [6: if the player can see the actor]
        if (((TestVisibility(player,actor))))
        {! [7: say ~[The actor] [close] [the noun].~ ( b )]
            say__p=1;! [8: ~[The actor] [close] [the noun].~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_315); new_line; .L_Say331; .L_SayX325;} else {
            ! [9: say ~[The noun] [close].~ ( c )]
            say__p=1;! [10: ~[The noun] [close].~ ( c )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_316); new_line; .L_Say332; .L_SayX326;}
            }
            } else if (debug_rules > 1) DB_Rule(R_234, 234, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Wearing (B197_check_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor wearing ( this is the can't wear what's not clothing rule ):
!   === equally specific with ===
! Rule 2/3 ! Check an actor wearing ( this is the can't wear what's not held rule ):
!   === equally specific with ===
! Rule 3/3 ! Check an actor wearing ( this is the can't wear what's already worn rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor wearing ( this is the can't wear what's not clothing rule ):
[ R_235 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_235, 235);
    ! [2: if the noun is not a thing or the noun is not wearable]
    if ((((~~((noun ofclass K2_thing))))) || (((~~(((Adj_89_t1_v10(noun))))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [can't wear] [regarding the noun][those]!~ ( a )]
            say__p=1;! [5: ~[We] [can't wear] [regarding the noun][those]!~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_317); new_line; .L_Say333; .L_SayX327;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_235, 235, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor wearing ( this is the can't wear what's not held rule ):
[ R_236 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_236, 236);
    ! [2: if the holder of the noun is not the actor]
    if (((~~(((HolderOf(noun)) == actor)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [aren't] holding [regarding the noun][those]!~ ( a )]
            say__p=1;! [5: ~[We] [aren't] holding [regarding the noun][those]!~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_318); new_line; .L_Say334; .L_SayX328;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_236, 236, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor wearing ( this is the can't wear what's already worn rule ):
[ R_237 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_237, 237);
    ! [2: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We]['re] already wearing [regarding the noun][those]!~ ( a )]
            say__p=1;! [5: ~[We]['re] already wearing [regarding the noun][those]!~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_319); new_line; .L_Say335; .L_SayX329;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_237, 237, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Wearing (B198_carry_out_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out wearing the astral lenses:
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Carry out an actor wearing ( this is the standard wearing rule ):
! ----------------------------------------------------------------------------------------------------
! From "Hyperspace" by Philip Riley
! No specific request
! Carry out wearing the astral lenses:
[ R_1244 ;
    if ((( (actor==player) && ((noun == I426_astral_lenses) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1244, 1244);
    ! [2: now the hyperlight is lit]
    (Adj_82_t2_v10(I218_hyperlight));
    } else if (debug_rules > 1) DB_Rule(R_1244, 1244, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Carry out an actor wearing ( this is the standard wearing rule ):
[ R_238 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_238, 238);
    ! [2: now the actor wears the noun]
    WearObject(noun,actor);
    } else if (debug_rules > 1) DB_Rule(R_238, 238, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Wearing (B199_report_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor wearing ( this is the standard report wearing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor wearing ( this is the standard report wearing rule ):
[ R_239 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_239, 239);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [put] on [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [put] on [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_320); new_line; .L_Say336; .L_SayX330;}
            } else {
        ! [6: say ~[The actor] [put] on [the noun].~ ( b )]
        say__p=1;! [7: ~[The actor] [put] on [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_321); new_line; .L_Say337; .L_SayX331;}
        } else if (debug_rules > 1) DB_Rule(R_239, 239, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Taking off (B200_check_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor taking off ( this is the can't take off what's not worn rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor taking off ( this is the can't exceed carrying capacity when taking off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor taking off ( this is the can't take off what's not worn rule ):
[ R_241 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_241, 241);
    ! [2: if the actor is not wearing the noun]
    if (((~~((actor == WearerOf(noun))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [aren't] wearing [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [aren't] wearing [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_322); new_line; .L_Say338; .L_SayX332;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_241, 241, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor taking off ( this is the can't exceed carrying capacity when taking off rule ):
[ R_242 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_242, 242);
    ! [2: if the number of things carried by the actor is at least the carrying capacity of the actor]
    if ((((Prop_63()) >= GProperty(10, actor,capacity))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We]['re] carrying too many things already.~ ( a )]
            say__p=1;! [5: ~[We]['re] carrying too many things already.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_323); new_line; .L_Say339; .L_SayX333;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_242, 242, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking off (B201_carry_out_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out taking off the astral lenses:
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Carry out an actor taking off ( this is the standard taking off rule ):
! ----------------------------------------------------------------------------------------------------
! From "Hyperspace" by Philip Riley
! No specific request
! Carry out taking off the astral lenses:
[ R_1245 ;
    if ((( (actor==player) && ((noun == I426_astral_lenses) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1245, 1245);
    ! [2: now the hyperlight is unlit]
    (Adj_83_t2_v10(I218_hyperlight));
    } else if (debug_rules > 1) DB_Rule(R_1245, 1245, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Carry out an actor taking off ( this is the standard taking off rule ):
[ R_243 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_243, 243);
    ! [2: now the actor carries the noun]
    MoveObject(noun,actor);
    } else if (debug_rules > 1) DB_Rule(R_243, 243, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking off (B202_report_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking off ( this is the standard report taking off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor taking off ( this is the standard report taking off rule ):
[ R_244 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_244, 244);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [take] off [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [take] off [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_324); new_line; .L_Say340; .L_SayX334;}
            } else {
        ! [6: say ~[The actor] [take] off [the noun].~ ( b )]
        say__p=1;! [7: ~[The actor] [take] off [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_325); new_line; .L_Say341; .L_SayX335;}
        } else if (debug_rules > 1) DB_Rule(R_244, 244, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Giving it to (B203_check_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor giving something to ( this is the can't give what you haven't got rule ):
!   === equally specific with ===
! Rule 2/5 ! Check an actor giving something to ( this is the can't give to yourself rule ):
!   === equally specific with ===
! Rule 3/5 ! Check an actor giving something to ( this is the can't give to a non-person rule ):
!   === equally specific with ===
! Rule 4/5 ! Check an actor giving something to ( this is the can't give clothes being worn rule ):
!   === equally specific with ===
! Rule 5/5 ! Check an actor giving something to ( this is the can't exceed carrying capacity when giving rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor giving something to ( this is the can't give what you haven't got rule ):
[ R_245 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_245, 245);
    ! [2: if the actor is not the holder of the noun]
    if (((~~((actor == (HolderOf(noun)))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [aren't] holding [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [aren't] holding [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_326); new_line; .L_Say342; .L_SayX336;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_245, 245, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor giving something to ( this is the can't give to yourself rule ):
[ R_246 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_246, 246);
    ! [2: if the actor is the second noun]
    if (((actor == second)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [can't give] [the noun] to [ourselves].~ ( a )]
            say__p=1;! [5: ~[We] [can't give] [the noun] to [ourselves].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_327); new_line; .L_Say343; .L_SayX337;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_246, 246, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor giving something to ( this is the can't give to a non-person rule ):
[ R_247 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_247, 247);
    ! [2: if the second noun is not a person]
    if (((~~((second ofclass K8_person)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The second noun] [aren't] able to receive things.~ ( a )]
            say__p=1;! [5: ~[The second noun] [aren't] able to receive things.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_328); new_line; .L_Say344; .L_SayX338;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_247, 247, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor giving something to ( this is the can't give clothes being worn rule ):
[ R_248 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_248, 248);
    ! [2: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [3: say ~(first taking [the noun] off)[command clarification break]~ ( a )]
        say__p=1;! [4: ~(first taking [the noun] off)[command clarification break]~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_329); .L_Say345; .L_SayX339;! [5: silently try the actor trying taking off the noun]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        ClearParagraphing(1);
        TryAction(0, actor, ##Disrobe, noun, 0);
        DivideParagraphPoint();
        @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

        ! [6: if the actor is wearing the noun]
        if (((actor == WearerOf(noun))))
        {! [7: stop the action]
            rtrue;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_248, 248, 'action');
            rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor giving something to ( this is the can't exceed carrying capacity when giving rule ):
[ R_250 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_250, 250);
    ! [2: if the number of things carried by the second noun is at least the carrying capacity of the second noun]
    if ((((Prop_64()) >= GProperty(OBJECT_TY, second,capacity))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The second noun] [are] carrying too many things already.~ ( a )]
            say__p=1;! [5: ~[The second noun] [are] carrying too many things already.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_330); new_line; .L_Say346; .L_SayX340;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_250, 250, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Giving it to (B205_report_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! This is the standard response rule:
! --- now the mid-placed rules ---
! Rule 2/2 ! Report giving something to someone ( this is the default giving rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversation Responses" by Eric Eve
! No specific request
! This is the standard response rule:
[ R_869 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_869, 869);
    ! [2: abide by the response rules for the current interlocutor]
    if (FollowRulebook(365, (Global_Vars-->11), true)) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_869, 869, 'actor');
    rfalse;
];
! From "Conversational Defaults" by Eric Eve
! No specific request
! Report giving something to someone ( this is the default giving rule ):
[ R_882 ;
    if ((( (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_882, 882);
    ! [2: abide by the default give response rules for the second noun]
    if (FollowRulebook(375, second, true)) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_882, 882, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Showing it to (B206_check_showing_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor showing something to ( this is the can't show what you haven't got rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor showing something to ( this is the convert show to yourself to examine rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor showing something to ( this is the can't show what you haven't got rule ):
[ R_253 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_253, 253);
    ! [2: if the actor is not the holder of the noun]
    if (((~~((actor == (HolderOf(noun)))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [aren't] holding [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [aren't] holding [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_331); new_line; .L_Say347; .L_SayX341;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_253, 253, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor showing something to ( this is the convert show to yourself to examine rule ):
[ R_254 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_254, 254);
    ! [2: if the actor is the second noun]
    if (((actor == second)))
    {! [3: convert to the examining action on the noun]
        return GVS_Convert(##Examine,noun,0);
        }
        } else if (debug_rules > 1) DB_Rule(R_254, 254, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Showing it to (B208_report_showing_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! This is the standard response rule:
! --- now the mid-placed rules ---
! Rule 2/2 ! Report showing something to someone ( this is the default showing rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversational Defaults" by Eric Eve
! No specific request
! Report showing something to someone ( this is the default showing rule ):
[ R_883 ;
    if ((( (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_883, 883);
    ! [2: abide by the default show response rules for the second noun]
    if (FollowRulebook(376, second, true)) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_883, 883, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waking (B209_check_waking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waking ( this is the block waking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor waking ( this is the block waking rule ):
[ R_256 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_256, 256);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [4: say ~That [seem] unnecessary.~ ( a )]
        say__p=1;! [5: ~That [seem] unnecessary.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_332); new_line; .L_Say348; .L_SayX342;}
    ! [6: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_256, 256, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Throwing it at (B212_check_throwing_it_at)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor throwing something at ( this is the implicitly remove thrown clothing rule ):
!   === equally specific with ===
! Rule 2/3 ! Check an actor throwing something at ( this is the futile to throw things at inanimate objects rule ):
!   === equally specific with ===
! Rule 3/3 ! Check an actor throwing something at ( this is the block throwing at rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor throwing something at ( this is the implicitly remove thrown clothing rule ):
[ R_257 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_257, 257);
    ! [2: if the actor is wearing the noun]
    if (((actor == WearerOf(noun))))
    {! [3: say ~(first taking [the noun] off)[command clarification break]~ ( a )]
        say__p=1;! [4: ~(first taking [the noun] off)[command clarification break]~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_333); .L_Say349; .L_SayX343;! [5: silently try the actor trying taking off the noun]
        @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
        ClearParagraphing(1);
        TryAction(0, actor, ##Disrobe, noun, 0);
        DivideParagraphPoint();
        @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

        ! [6: if the actor is wearing the noun]
        if (((actor == WearerOf(noun))))
        {! [7: stop the action]
            rtrue;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_257, 257, 'action');
            rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor throwing something at ( this is the futile to throw things at inanimate objects rule ):
[ R_258 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_258, 258);
    ! [2: if the second noun is not a person]
    if (((~~((second ofclass K8_person)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~Futile.~ ( a )]
            say__p=1;! [5: ~Futile.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_334); new_line; .L_Say350; .L_SayX344;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_258, 258, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor throwing something at ( this is the block throwing at rule ):
[ R_259 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_259, 259);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~[We] [lack] the nerve when it [if story tense is the past tense]came[otherwise]comes[end if] to the crucial moment.~ ( a )]
        say__p=1;! [4: ~[We] [lack] the nerve when it [if story tense is the past tense]came[otherwise]comes[end if] to the crucial moment.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_335); new_line; .L_Say351; .L_SayX345;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_259, 259, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Attacking (B215_check_attacking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Check attacking the walls when the location is not walled ( this is the block attacking no walls rule ):
!   === equally specific with ===
! Rule 2/6 ! Check attacking the ceiling when the location is not ceilinged ( this is the block attacking no ceiling rule ):
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 3/6 ! Check attacking the walls when the location is walled ( this is the block attacking the walls rule ):
!   === equally specific with ===
! Rule 4/6 ! Check attacking the Ceiling when the location is ceilinged ( this is the block attacking the Ceiling rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 5/6 ! Check attacking the Floor ( this is the block attacking the Floor rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 6/6 ! Check an actor attacking ( this is the block attacking rule ):
! ----------------------------------------------------------------------------------------------------
! From "Walls" by Philip Riley
! No specific request
! Check attacking the walls when the location is not walled ( this is the block attacking no walls rule ):
[ R_1070 ;
    if ((( (actor==player) && ((noun == I192_walls) && (true)) && (self=actor,true) && (((~~(((Adj_51_t1_v10(real_location)))))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1070, 1070);
    ! [2: say ~There are no walls.~ ( a )]
    say__p=1;! [3: ~There are no walls.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_336); new_line; .L_Say352; .L_SayX346;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1070, 1070, 'action');
    rfalse;
];
! From "Ceilings" by Philip Riley
! No specific request
! Check attacking the ceiling when the location is not ceilinged ( this is the block attacking no ceiling rule ):
[ R_1099 ;
    if ((( (actor==player) && ((noun == I194_ceiling) && (true)) && (self=actor,true) && (((~~(((Adj_55_t1_v10(real_location)))))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1099, 1099);
    ! [2: say ~There is no ceiling.~ ( a )]
    say__p=1;! [3: ~There is no ceiling.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_337); new_line; .L_Say353; .L_SayX347;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1099, 1099, 'action');
    rfalse;
];
! From "Walls" by Philip Riley
! No specific request
! Check attacking the walls when the location is walled ( this is the block attacking the walls rule ):
[ R_1069 ;
    if ((( (actor==player) && ((noun == I192_walls) && (true)) && (self=actor,true) && ((((Adj_51_t1_v10(real_location)))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1069, 1069);
    ! [2: say ~[We] would just embarrass [ourselves].~ ( a )]
    say__p=1;! [3: ~[We] would just embarrass [ourselves].~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_338); new_line; .L_Say354; .L_SayX348;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1069, 1069, 'action');
    rfalse;
];
! From "Ceilings" by Philip Riley
! No specific request
! Check attacking the Ceiling when the location is ceilinged ( this is the block attacking the Ceiling rule ):
[ R_1098 ;
    if ((( (actor==player) && ((noun == I194_ceiling) && (true)) && (self=actor,true) && ((((Adj_55_t1_v10(real_location)))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1098, 1098);
    ! [2: say ~[We] would just embarrass [ourselves].~ ( a )]
    say__p=1;! [3: ~[We] would just embarrass [ourselves].~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_339); new_line; .L_Say355; .L_SayX349;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1098, 1098, 'action');
    rfalse;
];
! From "Floors" by Philip Riley
! No specific request
! Check attacking the Floor ( this is the block attacking the Floor rule ):
[ R_1083 ;
    if ((( (actor==player) && ((noun == I193_floor) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1083, 1083);
    ! [2: say ~[We] would just look like a nutcase.~ ( a )]
    say__p=1;! [3: ~[We] would just look like a nutcase.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_340); new_line; .L_Say356; .L_SayX350;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1083, 1083, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor attacking ( this is the block attacking rule ):
[ R_260 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_260, 260);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [4: say ~Violence [aren't] the answer to this one.~ ( a )]
        say__p=1;! [5: ~Violence [aren't] the answer to this one.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_341); new_line; .L_Say357; .L_SayX351;}
    ! [6: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_260, 260, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Kissing (B218_check_kissing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor kissing ( this is the kissing yourself rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor kissing ( this is the block kissing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor kissing ( this is the kissing yourself rule ):
[ R_261 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_261, 261);
    ! [2: if the noun is the actor]
    if (((noun == actor)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [don't] get much from that.~ ( a )]
            say__p=1;! [5: ~[We] [don't] get much from that.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_342); new_line; .L_Say358; .L_SayX352;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_261, 261, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor kissing ( this is the block kissing rule ):
[ R_262 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_262, 262);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~[The noun] [might not] like that.~ ( a )]
        say__p=1;! [4: ~[The noun] [might not] like that.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_343); new_line; .L_Say359; .L_SayX353;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_262, 262, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Answering it that (B223_report_answering_it_tha)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! This is the standard response rule:
! --- now the mid-placed rules ---
! Rule 2/2 ! Report answering someone that something ( this is the default answering rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversational Defaults" by Eric Eve
! No specific request
! Report answering someone that something ( this is the default answering rule ):
[ R_881 ;
    if ((( (actor==player) && ((noun ofclass K8_person)) && (true)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_881, 881);
    ! [2: abide by the default answer response rules for the noun]
    if (FollowRulebook(373, noun, true)) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_881, 881, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Telling it about (B224_check_telling_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! check telling someone about something:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 2/2 ! Check an actor telling something about ( this is the telling yourself rule ):
! ----------------------------------------------------------------------------------------------------
! From "Simple Conversation" by Philip Riley
! No specific request
! check telling someone about something:
[ R_1214 ;
    if ((( (actor==player) && ((noun ofclass K8_person)) && (true)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1214, 1214);
    ! [2: say ~[text of the block informing rule response (A)][line break]~]
    say__p=1;! [3: text of the block informing rule response ( a )]
    ParaContent(); (PHR_380_r40 (R_264_RESP_A));! [4: line break]
    ParaContent(); new_line; .L_Say360; .L_SayX354;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1214, 1214, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor telling something about ( this is the telling yourself rule ):
[ R_264 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_264, 264);
    ! [2: if the actor is the noun]
    if (((actor == noun)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [talk] to [ourselves] a while.~ ( a )]
            say__p=1;! [5: ~[We] [talk] to [ourselves] a while.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_344); new_line; .L_Say361; .L_SayX355;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_264, 264, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Telling it about (B226_report_telling_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! This is the standard response rule:
! --- now the mid-placed rules ---
! Rule 2/2 ! Report telling someone about something ( this is the default telling rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversational Defaults" by Eric Eve
! No specific request
! Report telling someone about something ( this is the default telling rule ):
[ R_879 ;
    if ((( (actor==player) && ((noun ofclass K8_person)) && (true)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_879, 879);
    ! [2: abide by the default tell response rules for the noun]
    if (FollowRulebook(372, noun, true)) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_879, 879, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Asking it about (B227_check_asking_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! check asking someone about something:
! ----------------------------------------------------------------------------------------------------
! From "Simple Conversation" by Philip Riley
! No specific request
! check asking someone about something:
[ R_1213 ;
    if ((( (actor==player) && ((noun ofclass K8_person)) && (true)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1213, 1213);
    ! [2: say ~[text of the block quizzing rule response (A)][line break]~]
    say__p=1;! [3: text of the block quizzing rule response ( a )]
    ParaContent(); (PHR_380_r40 (R_265_RESP_A));! [4: line break]
    ParaContent(); new_line; .L_Say362; .L_SayX356;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1213, 1213, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Asking it about (B229_report_asking_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! This is the standard response rule:
! --- now the mid-placed rules ---
! Rule 2/2 ! Report asking someone about something ( this is the default asking rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversational Defaults" by Eric Eve
! No specific request
! Report asking someone about something ( this is the default asking rule ):
[ R_877 ;
    if ((( (actor==player) && ((noun ofclass K8_person)) && (true)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_877, 877);
    ! [2: abide by the default ask response rules for the noun]
    if (FollowRulebook(370, noun, true)) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_877, 877, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Asking it for (B230_check_asking_it_for)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor asking something for ( this is the asking yourself for something rule ):
!   === equally specific with ===
! Rule 2/2 ! Check an actor asking something for ( this is the translate asking for to giving rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor asking something for ( this is the asking yourself for something rule ):
[ R_267 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_267, 267);
    ! [2: if the actor is the noun and the actor is the player]
    if ((((actor == noun))) && (((actor == player))))
    {! [3: try taking inventory]
        TryAction(0, player, ##Inv, 0, 0);
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_267, 267, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor asking something for ( this is the translate asking for to giving rule ):
[ R_268 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_268, 268);
    ! [2: convert to request of the noun to perform giving it to action with the second noun and the actor]
    return ConvertToRequest(noun, ##Give, second, actor);
    } else if (debug_rules > 1) DB_Rule(R_268, 268, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Waiting (B235_report_waiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor waiting ( this is the standard report waiting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor waiting ( this is the standard report waiting rule ):
[ R_269 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_269, 269);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: now the prior named object is nothing]
            prior_named_noun = nothing;
            ! [5: say ~Time [pass].~ ( a )]
            say__p=1;! [6: ~Time [pass].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_345); new_line; .L_Say363; .L_SayX357;}
            } else {
        ! [7: say ~[The actor] [wait].~ ( b )]
        say__p=1;! [8: ~[The actor] [wait].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_346); new_line; .L_Say364; .L_SayX358;}
        } else if (debug_rules > 1) DB_Rule(R_269, 269, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Touching (B238_report_touching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report an actor touching ( this is the report touching yourself rule ):
!   === equally specific with ===
! Rule 2/3 ! Report an actor touching ( this is the report touching other people rule ):
!   === equally specific with ===
! Rule 3/3 ! Report an actor touching ( this is the report touching things rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor touching ( this is the report touching yourself rule ):
[ R_270 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_270, 270);
    ! [2: if the noun is the actor]
    if (((noun == actor)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: if the action is not silent]
            if (((keep_silent == false)))
            {! [5: say ~[We] [achieve] nothing by this.~ ( a )]
                say__p=1;! [6: ~[We] [achieve] nothing by this.~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_347); new_line; .L_Say365; .L_SayX359;}
                } else {
            ! [7: say ~[The actor] [touch] [themselves].~ ( b )]
            say__p=1;! [8: ~[The actor] [touch] [themselves].~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_348); new_line; .L_Say366; .L_SayX360;}
        ! [9: stop the action]
        rtrue;
        }
    ! [10: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_270, 270, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor touching ( this is the report touching other people rule ):
[ R_271 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_271, 271);
    ! [2: if the noun is a person]
    if (((noun ofclass K8_person)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: if the action is not silent]
            if (((keep_silent == false)))
            {! [5: say ~[The noun] [might not like] that.~ ( a )]
                say__p=1;! [6: ~[The noun] [might not like] that.~ ( a )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_349); new_line; .L_Say367; .L_SayX361;}
                } else {
            ! [7: if the noun is the player]
            if (((noun == player)))
            {! [8: say ~[The actor] [touch] [us].~ ( b )]
                say__p=1;! [9: ~[The actor] [touch] [us].~ ( b )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_350); new_line; .L_Say368; .L_SayX362;} else {
                ! [10: say ~[The actor] [touch] [the noun].~ ( c )]
                say__p=1;! [11: ~[The actor] [touch] [the noun].~ ( c )]
                ParaContent(); print (TEXT_TY_Say) (TX_R_351); new_line; .L_Say369; .L_SayX363;}
                }
        ! [12: stop the action]
        rtrue;
        }
    ! [13: continue the action]
    rfalse;
    } else if (debug_rules > 1) DB_Rule(R_271, 271, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor touching ( this is the report touching things rule ):
[ R_272 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_272, 272);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [feel] nothing unexpected.~ ( a )]
            say__p=1;! [5: ~[We] [feel] nothing unexpected.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_352); new_line; .L_Say370; .L_SayX364;}
            } else {
        ! [6: say ~[The actor] [touch] [the noun].~ ( b )]
        say__p=1;! [7: ~[The actor] [touch] [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_353); new_line; .L_Say371; .L_SayX365;}
        } else if (debug_rules > 1) DB_Rule(R_272, 272, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waving (B239_check_waving)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waving ( this is the can't wave what's not held rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor waving ( this is the can't wave what's not held rule ):
[ R_273 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_273, 273);
    ! [2: if the actor is not the holder of the noun]
    if (((~~((actor == (HolderOf(noun)))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~But [we] [aren't] holding [regarding the noun][those].~ ( a )]
            say__p=1;! [5: ~But [we] [aren't] holding [regarding the noun][those].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_354); new_line; .L_Say372; .L_SayX366;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_273, 273, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Waving (B241_report_waving)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor waving ( this is the report waving things rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor waving ( this is the report waving things rule ):
[ R_274 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_274, 274);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [wave] [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [wave] [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_355); new_line; .L_Say373; .L_SayX367;}
            } else {
        ! [6: say ~[The actor] [wave] [the noun].~ ( b )]
        say__p=1;! [7: ~[The actor] [wave] [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_356); new_line; .L_Say374; .L_SayX368;}
        } else if (debug_rules > 1) DB_Rule(R_274, 274, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pulling (B242_check_pulling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor pulling ( this is the can't pull what's fixed in place rule ):
!   === equally specific with ===
! Rule 2/3 ! Check an actor pulling ( this is the can't pull scenery rule ):
!   === equally specific with ===
! Rule 3/3 ! Check an actor pulling ( this is the can't pull people rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor pulling ( this is the can't pull what's fixed in place rule ):
[ R_275 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_275, 275);
    ! [2: if the noun is fixed in place]
    if ((((Adj_86_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They] [are] fixed in place.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They] [are] fixed in place.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_357); new_line; .L_Say375; .L_SayX369;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_275, 275, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pulling ( this is the can't pull scenery rule ):
[ R_276 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_276, 276);
    ! [2: if the noun is scenery]
    if ((((Adj_88_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [are] unable to.~ ( a )]
            say__p=1;! [5: ~[We] [are] unable to.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_358); new_line; .L_Say376; .L_SayX370;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_276, 276, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pulling ( this is the can't pull people rule ):
[ R_277 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_277, 277);
    ! [2: if the noun is a person]
    if (((noun ofclass K8_person)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The noun] [might not like] that.~ ( a )]
            say__p=1;! [5: ~[The noun] [might not like] that.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_359); new_line; .L_Say377; .L_SayX371;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_277, 277, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Pulling (B244_report_pulling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor pulling ( this is the report pulling rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor pulling ( this is the report pulling rule ):
[ R_278 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_278, 278);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: now the prior named object is nothing]
            prior_named_noun = nothing;
            ! [5: say ~Nothing obvious [happen].~ ( a )]
            say__p=1;! [6: ~Nothing obvious [happen].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_360); new_line; .L_Say378; .L_SayX372;}
            } else {
        ! [7: say ~[The actor] [pull] [the noun].~ ( b )]
        say__p=1;! [8: ~[The actor] [pull] [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_361); new_line; .L_Say379; .L_SayX373;}
        } else if (debug_rules > 1) DB_Rule(R_278, 278, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pushing (B245_check_pushing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check pushing car 1:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 2/4 ! Check an actor pushing something ( this is the can't push what's fixed in place rule ):
!   === equally specific with ===
! Rule 3/4 ! Check an actor pushing something ( this is the can't push scenery rule ):
!   === equally specific with ===
! Rule 4/4 ! Check an actor pushing something ( this is the can't push people rule ):
! ----------------------------------------------------------------------------------------------------
! From "Swamp Park" by Philip Riley
! No specific request
! Check pushing car 1:
[ R_1392 ;
    if ((( (actor==player) && ((noun == I299_car_1) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1392, 1392);
    ! [2: say ~[We] could probably push the car if [we] put it in neutral and released the parking brake, but why would [we]?~]
    say__p=1;! [3: we]
    ParaContent(); (PHR_764_r7 ());! [4: ~ could probably push the car if ~]
    ParaContent(); print " could probably push the car if ";! [5: we]
    ParaContent(); (PHR_757_r16 ());! [6: ~ put it in neutral and released the parking brake, but why would ~]
    ParaContent(); print " put it in neutral and released the parking brake, but why would ";! [7: we]
    ParaContent(); (PHR_757_r16 ());! [8: ~?~]
    ParaContent(); print "?"; new_line; .L_Say380; .L_SayX374;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1392, 1392, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something ( this is the can't push what's fixed in place rule ):
[ R_279 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_279, 279);
    ! [2: if the noun is fixed in place]
    if ((((Adj_86_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They] [are] fixed in place.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They] [are] fixed in place.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_362); new_line; .L_Say381; .L_SayX375;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_279, 279, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something ( this is the can't push scenery rule ):
[ R_280 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_280, 280);
    ! [2: if the noun is scenery]
    if ((((Adj_88_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [are] unable to.~ ( a )]
            say__p=1;! [5: ~[We] [are] unable to.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_363); new_line; .L_Say382; .L_SayX376;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_280, 280, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something ( this is the can't push people rule ):
[ R_281 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_281, 281);
    ! [2: if the noun is a person]
    if (((noun ofclass K8_person)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The noun] [might not like] that.~ ( a )]
            say__p=1;! [5: ~[The noun] [might not like] that.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_364); new_line; .L_Say383; .L_SayX377;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_281, 281, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Pushing (B247_report_pushing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor pushing something ( this is the report pushing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor pushing something ( this is the report pushing rule ):
[ R_282 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_282, 282);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: now the prior named object is nothing]
            prior_named_noun = nothing;
            ! [5: say ~Nothing obvious [happen].~ ( a )]
            say__p=1;! [6: ~Nothing obvious [happen].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_365); new_line; .L_Say384; .L_SayX378;}
            } else {
        ! [7: say ~[The actor] [push] [the noun].~ ( b )]
        say__p=1;! [8: ~[The actor] [push] [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_366); new_line; .L_Say385; .L_SayX379;}
        } else if (debug_rules > 1) DB_Rule(R_282, 282, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Turning (B248_check_turning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check turning car 1:
!   >>> I - Number of aspects constrained >>>
! Rule 2/4 ! Check an actor turning ( this is the can't turn what's fixed in place rule ):
!   === equally specific with ===
! Rule 3/4 ! Check an actor turning ( this is the can't turn scenery rule ):
!   === equally specific with ===
! Rule 4/4 ! Check an actor turning ( this is the can't turn people rule ):
! ----------------------------------------------------------------------------------------------------
! From "Swamp Park" by Philip Riley
! No specific request
! Check turning car 1:
[ R_1393 ;
    if ((( (actor==player) && ((noun == I299_car_1) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1393, 1393);
    ! [2: say ~It's not clear what you mean for [us] to do.~]
    say__p=1;! [3: ~It's not clear what you mean for ~]
    ParaContent(); print "It's not clear what you mean for ";! [4: us]
    ParaContent(); (PHR_760_r49 ());! [5: ~ to do.~]
    ParaContent(); print " to do."; new_line; .L_Say386; .L_SayX380;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1393, 1393, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor turning ( this is the can't turn what's fixed in place rule ):
[ R_283 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_283, 283);
    ! [2: if the noun is fixed in place]
    if ((((Adj_86_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They] [are] fixed in place.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They] [are] fixed in place.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_367); new_line; .L_Say387; .L_SayX381;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_283, 283, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor turning ( this is the can't turn scenery rule ):
[ R_284 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_284, 284);
    ! [2: if the noun is scenery]
    if ((((Adj_88_t1_v10(noun)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[We] [are] unable to.~ ( a )]
            say__p=1;! [5: ~[We] [are] unable to.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_368); new_line; .L_Say388; .L_SayX382;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_284, 284, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor turning ( this is the can't turn people rule ):
[ R_285 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_285, 285);
    ! [2: if the noun is a person]
    if (((noun ofclass K8_person)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The noun] [might not like] that.~ ( a )]
            say__p=1;! [5: ~[The noun] [might not like] that.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_369); new_line; .L_Say389; .L_SayX383;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_285, 285, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Turning (B250_report_turning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor turning ( this is the report turning rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor turning ( this is the report turning rule ):
[ R_286 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_286, 286);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: now the prior named object is nothing]
            prior_named_noun = nothing;
            ! [5: say ~Nothing obvious [happen].~ ( a )]
            say__p=1;! [6: ~Nothing obvious [happen].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_370); new_line; .L_Say390; .L_SayX384;}
            } else {
        ! [7: say ~[The actor] [turn] [the noun].~ ( b )]
        say__p=1;! [8: ~[The actor] [turn] [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_371); new_line; .L_Say391; .L_SayX385;}
        } else if (debug_rules > 1) DB_Rule(R_286, 286, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pushing it to (B251_check_pushing_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Check an actor pushing something to ( this is the can't push unpushable things rule ):
!   === equally specific with ===
! Rule 2/6 ! Check an actor pushing something to ( this is the can't push to non-directions rule ):
!   === equally specific with ===
! Rule 3/6 ! Check an actor pushing something to ( this is the can't push vertically rule ):
!   === equally specific with ===
! Rule 4/6 ! Check an actor pushing something to ( this is the can't push from within rule ):
!   === equally specific with ===
! Rule 5/6 ! Check an actor pushing something to ( this is the standard pushing in directions rule ):
!   === equally specific with ===
! Rule 6/6 ! Check an actor pushing something to ( this is the block pushing in directions rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor pushing something to ( this is the can't push unpushable things rule ):
[ R_287 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_287, 287);
    ! [2: if the noun is not pushable between rooms]
    if (((~~(((Adj_90_t1_v10(noun)))))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The noun] [cannot] be pushed from place to place.~ ( a )]
            say__p=1;! [5: ~[The noun] [cannot] be pushed from place to place.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_372); new_line; .L_Say392; .L_SayX386;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_287, 287, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something to ( this is the can't push to non-directions rule ):
[ R_288 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_288, 288);
    ! [2: if the second noun is not a direction]
    if (((~~((second ofclass K3_direction)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[regarding the noun][They] [aren't] a direction.~ ( a )]
            say__p=1;! [5: ~[regarding the noun][They] [aren't] a direction.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_373); new_line; .L_Say393; .L_SayX387;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_288, 288, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something to ( this is the can't push vertically rule ):
[ R_289 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_289, 289);
    ! [2: if the second noun is up or the second noun is down]
    if ((((second == I59_up))) || (((second == I60_down))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The noun] [cannot] be pushed up or down.~ ( a )]
            say__p=1;! [5: ~[The noun] [cannot] be pushed up or down.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_374); new_line; .L_Say394; .L_SayX388;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_289, 289, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something to ( this is the can't push from within rule ):
[ R_290 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_290, 290);
    ! [2: if the noun encloses the actor]
    if (((IndirectlyContains(noun,actor))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The noun] [cannot] be pushed from here.~ ( a )]
            say__p=1;! [5: ~[The noun] [cannot] be pushed from here.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_375); new_line; .L_Say395; .L_SayX389;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_290, 290, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something to ( this is the standard pushing in directions rule ):
[ R_291 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_291, 291);
    ! [2: convert to special going-with-push action]
    return ConvertToGoingWithPush();
    } else if (debug_rules > 1) DB_Rule(R_291, 291, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor pushing something to ( this is the block pushing in directions rule ):
[ R_292 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_292, 292);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~[The noun] [cannot] be pushed from place to place.~ ( a )]
        say__p=1;! [4: ~[The noun] [cannot] be pushed from place to place.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_376); new_line; .L_Say396; .L_SayX390;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_292, 292, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Squeezing (B254_check_squeezing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor squeezing ( this is the innuendo about squeezing people rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor squeezing ( this is the innuendo about squeezing people rule ):
[ R_293 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_293, 293);
    ! [2: if the noun is a person]
    if (((noun ofclass K8_person)))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The noun] [might not like] that.~ ( a )]
            say__p=1;! [5: ~[The noun] [might not like] that.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_377); new_line; .L_Say397; .L_SayX391;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_293, 293, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Squeezing (B256_report_squeezing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor squeezing ( this is the report squeezing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor squeezing ( this is the report squeezing rule ):
[ R_294 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_294, 294);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [achieve] nothing by this.~ ( a )]
            say__p=1;! [5: ~[We] [achieve] nothing by this.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_378); new_line; .L_Say398; .L_SayX392;}
            } else {
        ! [6: say ~[The actor] [squeeze] [the noun].~ ( b )]
        say__p=1;! [7: ~[The actor] [squeeze] [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_379); new_line; .L_Say399; .L_SayX393;}
        } else if (debug_rules > 1) DB_Rule(R_294, 294, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Saying yes (B259_report_saying_yes)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! This is the standard response rule:
! --- now the mid-placed rules ---
! Rule 2/2 ! Report saying yes ( this is the default yes rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversational Defaults" by Eric Eve
! No specific request
! Report saying yes ( this is the default yes rule ):
[ R_886 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_886, 886);
    ! [2: abide by the default yes-no response rules for the current interlocutor]
    if (FollowRulebook(378, (Global_Vars-->11), true)) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_886, 886, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Saying no (B262_report_saying_no)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! This is the standard response rule:
! --- now the mid-placed rules ---
! Rule 2/2 ! Report saying no ( this is the default no rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversational Defaults" by Eric Eve
! No specific request
! Report saying no ( this is the default no rule ):
[ R_887 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_887, 887);
    ! [2: abide by the default yes-no response rules for the current interlocutor]
    if (FollowRulebook(378, (Global_Vars-->11), true)) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_887, 887, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Cutting (B263_check_cutting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Check cutting the walls when the location is not walled ( this is the block cutting no walls rule ):
!   === equally specific with ===
! Rule 2/6 ! Check cutting the Ceiling when the location is not ceilinged ( this is the block cutting no Ceiling rule ):
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 3/6 ! Check cutting the walls when the location is walled ( this is the block cutting the walls rule ):
!   === equally specific with ===
! Rule 4/6 ! Check cutting the Ceiling when the location is ceilinged ( this is the block cutting the Ceiling rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 5/6 ! Check cutting the Floor ( this is the block cutting the Floor rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 6/6 ! Check an actor cutting ( this is the block cutting rule ):
! ----------------------------------------------------------------------------------------------------
! From "Walls" by Philip Riley
! No specific request
! Check cutting the walls when the location is not walled ( this is the block cutting no walls rule ):
[ R_1072 ;
    if ((( (actor==player) && ((noun == I192_walls) && (true)) && (self=actor,true) && (((~~(((Adj_51_t1_v10(real_location)))))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1072, 1072);
    ! [2: say ~There are no walls.~ ( a )]
    say__p=1;! [3: ~There are no walls.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_380); new_line; .L_Say400; .L_SayX394;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1072, 1072, 'action');
    rfalse;
];
! From "Ceilings" by Philip Riley
! No specific request
! Check cutting the Ceiling when the location is not ceilinged ( this is the block cutting no Ceiling rule ):
[ R_1101 ;
    if ((( (actor==player) && ((noun == I194_ceiling) && (true)) && (self=actor,true) && (((~~(((Adj_55_t1_v10(real_location)))))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1101, 1101);
    ! [2: say ~There is no ceiling.~ ( a )]
    say__p=1;! [3: ~There is no ceiling.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_381); new_line; .L_Say401; .L_SayX395;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1101, 1101, 'action');
    rfalse;
];
! From "Walls" by Philip Riley
! No specific request
! Check cutting the walls when the location is walled ( this is the block cutting the walls rule ):
[ R_1071 ;
    if ((( (actor==player) && ((noun == I192_walls) && (true)) && (self=actor,true) && ((((Adj_51_t1_v10(real_location)))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1071, 1071);
    ! [2: say ~That's just daft.~ ( a )]
    say__p=1;! [3: ~That's just daft.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_382); new_line; .L_Say402; .L_SayX396;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1071, 1071, 'action');
    rfalse;
];
! From "Ceilings" by Philip Riley
! No specific request
! Check cutting the Ceiling when the location is ceilinged ( this is the block cutting the Ceiling rule ):
[ R_1100 ;
    if ((( (actor==player) && ((noun == I194_ceiling) && (true)) && (self=actor,true) && ((((Adj_55_t1_v10(real_location)))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1100, 1100);
    ! [2: say ~That's just daft.~ ( a )]
    say__p=1;! [3: ~That's just daft.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_383); new_line; .L_Say403; .L_SayX397;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1100, 1100, 'action');
    rfalse;
];
! From "Floors" by Philip Riley
! No specific request
! Check cutting the Floor ( this is the block cutting the Floor rule ):
[ R_1084 ;
    if ((( (actor==player) && ((noun == I193_floor) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1084, 1084);
    ! [2: say ~That isn't possible.~ ( a )]
    say__p=1;! [3: ~That isn't possible.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_384); new_line; .L_Say404; .L_SayX398;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1084, 1084, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor cutting ( this is the block cutting rule ):
[ R_297 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_297, 297);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~Cutting [regarding the noun][them] up [would achieve] little.~ ( a )]
        say__p=1;! [4: ~Cutting [regarding the noun][them] up [would achieve] little.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_385); new_line; .L_Say405; .L_SayX399;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_297, 297, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Saying sorry (B268_report_saying_sorry)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! This is the standard response rule:
! --- now the mid-placed rules ---
! Rule 2/2 ! Report saying sorry ( this is the default sorry rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversational Defaults" by Eric Eve
! No specific request
! Report saying sorry ( this is the default sorry rule ):
[ R_888 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_888, 888);
    ! [2: abide by the default response rules for the current interlocutor]
    if (FollowRulebook(379, (Global_Vars-->11), true)) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_888, 888, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Rubbing (B269_check_rubbing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check rubbing walls ( this is the standard check rubbing the walls rule ):
!   === equally specific with ===
! Rule 2/4 ! Check rubbing Floor ( this is the standard check rubbing the floor rule ):
!   === equally specific with ===
! Rule 3/4 ! Check rubbing Ceiling ( this is the standard check rubbing the ceiling rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 4/4 ! Check an actor rubbing ( this is the can't rub another person rule ):
! ----------------------------------------------------------------------------------------------------
! From "Walls" by Philip Riley
! No specific request
! Check rubbing walls ( this is the standard check rubbing the walls rule ):
[ R_1068 ;
    if ((( (actor==player) && ((noun == I192_walls) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1068, 1068);
    ! [2: unless the location is walled]
    if (~~((((Adj_51_t1_v10(real_location))))))
    {! [3: say ~There are no walls.~ ( b )]
        say__p=1;! [4: ~There are no walls.~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_386); new_line; .L_Say406; .L_SayX400;rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_1068, 1068, 'action');
        rfalse;
];
! From "Floors" by Philip Riley
! No specific request
! Check rubbing Floor ( this is the standard check rubbing the floor rule ):
[ R_1082 ;
    if ((( (actor==player) && ((noun == I193_floor) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1082, 1082);
    ! [2: unless the location is floored]
    if (~~((((Adj_53_t1_v10(real_location))))))
    {! [3: say ~There is no floor.~ ( b )]
        say__p=1;! [4: ~There is no floor.~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_387); new_line; .L_Say407; .L_SayX401;rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_1082, 1082, 'action');
        rfalse;
];
! From "Ceilings" by Philip Riley
! No specific request
! Check rubbing Ceiling ( this is the standard check rubbing the ceiling rule ):
[ R_1097 ;
    if ((( (actor==player) && ((noun == I194_ceiling) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1097, 1097);
    ! [2: if the location is ceilinged]
    if ((((Adj_55_t1_v10(real_location)))))
    {! [3: if the location is not low-ceilinged]
        if (((~~(((Adj_56_t1_v10(real_location)))))))
        {! [4: say ~[We] can't reach the ceiling.~ ( a )]
            say__p=1;! [5: ~[We] can't reach the ceiling.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_388); new_line; .L_Say408; .L_SayX402;rtrue;
            }
            } else {
        ! [7: say ~There is no ceiling.~ ( b )]
        say__p=1;! [8: ~There is no ceiling.~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_389); new_line; .L_Say409; .L_SayX403;rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_1097, 1097, 'action');
        rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor rubbing ( this is the can't rub another person rule ):
[ R_299 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_299, 299);
    ! [2: if the noun is a person who is not the actor]
    if (((noun ofclass K8_person) && (~~((noun == actor)))))
    {! [3: if the actor is the player]
        if (((actor == player)))
        {! [4: say ~[The noun] [might not like] that.~ ( a )]
            say__p=1;! [5: ~[The noun] [might not like] that.~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_390); new_line; .L_Say410; .L_SayX404;}
        ! [6: stop the action]
        rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_299, 299, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Rubbing (B271_report_rubbing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor rubbing ( this is the report rubbing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Report an actor rubbing ( this is the report rubbing rule ):
[ R_300 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_300, 300);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: if the action is not silent]
        if (((keep_silent == false)))
        {! [4: say ~[We] [rub] [the noun].~ ( a )]
            say__p=1;! [5: ~[We] [rub] [the noun].~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_391); new_line; .L_Say411; .L_SayX405;}
            } else {
        ! [6: say ~[The actor] [rub] [the noun].~ ( b )]
        say__p=1;! [7: ~[The actor] [rub] [the noun].~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_392); new_line; .L_Say412; .L_SayX406;}
        } else if (debug_rules > 1) DB_Rule(R_300, 300, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Buying (B272_check_buying)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor buying ( this is the block buying rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! No specific request
! Check an actor buying ( this is the block buying rule ):
[ R_301 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_301, 301);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [4: say ~Nothing [are] on sale.~ ( a )]
        say__p=1;! [5: ~Nothing [are] on sale.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_393); new_line; .L_Say413; .L_SayX407;}
    ! [6: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_301, 301, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Requesting epistemic status of (B322_report_requesting_epist)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report requesting epistemic status of ( this is the report epistemic status rule ):
! ----------------------------------------------------------------------------------------------------
! From "Epistemology" by Eric Eve
! No specific request
! Report requesting epistemic status of ( this is the report epistemic status rule ):
[ R_802 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_802, 802);
    ! [2: say ~[noun] - [if the noun is seen]seen[otherwise]unseen[end if] / [if the noun is familiar]familiar[otherwise]unfamiliar[end if] / [if the noun is known]known[otherwise]unknown[end if].~ ( a )]
    say__p=1;! [3: ~[noun] - [if the noun is seen]seen[otherwise]unseen[end if] / [if the noun is familiar]familiar[otherwise]unfamiliar[end if] / [if the noun is known]known[otherwise]unknown[end if].~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_394); new_line; .L_Say414; .L_SayX408;} else if (debug_rules > 1) DB_Rule(R_802, 802, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Requesting it for (B325_report_requesting_it_fo)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! This is the standard response rule:
! --- now the mid-placed rules ---
! Rule 2/2 ! Report requesting someone for something ( this is the default requesting rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversational Defaults" by Eric Eve
! No specific request
! Report requesting someone for something ( this is the default requesting rule ):
[ R_884 ;
    if ((( (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_884, 884);
    ! [2: abide by the default ask-for response rules for the noun]
    if (FollowRulebook(374, noun, true)) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_884, 884, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Imploring it for (B328_report_imploring_it_for)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! This is the standard response rule:
! --- now the mid-placed rules ---
! Rule 2/2 ! Report imploring someone for something ( this is the default imploring rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversational Defaults" by Eric Eve
! No specific request
! Report imploring someone for something ( this is the default imploring rule ):
[ R_885 ;
    if ((( (actor==player) && ((noun ofclass K8_person)) && (true)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_885, 885);
    ! [2: abide by the default ask-for response rules for the noun]
    if (FollowRulebook(374, noun, true)) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_885, 885, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Quizzing it about (B329_check_quizzing_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check quizzing someone about something unknown ( this is the block asking about something unknown rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversation Framework" by Eric Eve
! No specific request
! Check quizzing someone about something unknown ( this is the block asking about something unknown rule ):
[ R_846 ;
    if ((( (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing) && ((Adj_43_t1_v10(second))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_846, 846);
    ! [2: abide by the block asking rule]
    if (FollowRulebook(R_266)) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_846, 846, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Quizzing it about (B331_report_quizzing_it_abou)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! This is the standard response rule:
! --- now the mid-placed rules ---
! Rule 2/2 ! Report quizzing someone about something ( this is the default quizzing rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversational Defaults" by Eric Eve
! No specific request
! Report quizzing someone about something ( this is the default quizzing rule ):
[ R_878 ;
    if ((( (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_878, 878);
    ! [2: abide by the default ask response rules for the noun]
    if (FollowRulebook(370, noun, true)) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_878, 878, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Informing it about (B332_check_informing_it_abou)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check informing someone about something unknown ( this is the block telling about something unknown rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 2/2 ! check informing someone about something:
! ----------------------------------------------------------------------------------------------------
! From "Conversation Framework" by Eric Eve
! No specific request
! Check informing someone about something unknown ( this is the block telling about something unknown rule ):
[ R_847 ;
    if ((( (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing) && ((Adj_43_t1_v10(second))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_847, 847);
    ! [2: abide by the block telling rule]
    if (FollowRulebook(R_265)) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_847, 847, 'action');
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! check informing someone about something:
[ R_1212 ;
    if ((( (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1212, 1212);
    ! [2: say ~[text of the block informing rule response (A)][line break]~]
    say__p=1;! [3: text of the block informing rule response ( a )]
    ParaContent(); (PHR_380_r40 (R_264_RESP_A));! [4: line break]
    ParaContent(); new_line; .L_Say415; .L_SayX409;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1212, 1212, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Informing it about (B334_report_informing_it_abo)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! This is the standard response rule:
! --- now the mid-placed rules ---
! Rule 2/2 ! Report informing someone about something ( this is the default informing rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversational Defaults" by Eric Eve
! No specific request
! Report informing someone about something ( this is the default informing rule ):
[ R_880 ;
    if ((( (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_880, 880);
    ! [2: abide by the default tell response rules for the noun]
    if (FollowRulebook(372, noun, true)) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_880, 880, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying hello to (B353_check_saying_hello_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check saying hello to a person when the noun is the current interlocutor ( this is the can't greet current interlocutor rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Check saying hello to the player ( this is the can't greet yourself rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversation Framework" by Eric Eve
! No specific request
! Check saying hello to a person when the noun is the current interlocutor ( this is the can't greet current interlocutor rule ):
[ R_820 ;
    if ((( (actor==player) && ((noun ofclass K8_person)) && (self=actor,true) && (((noun == (Global_Vars-->11))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_820, 820);
    ! [2: if the noun is the player]
    if (((noun == player)))
    {! [3: say ~Talking to [ourselves] [regarding nothing][are] unrewarding.~ ( a )]
        say__p=1;! [4: ~Talking to [ourselves] [regarding nothing][are] unrewarding.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_395); new_line; .L_Say416; .L_SayX410;rtrue;
        }
    ! [6: say ~[We] [are] already talking to [the noun].~ ( b )]
    say__p=1;! [7: ~[We] [are] already talking to [the noun].~ ( b )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_396); new_line; .L_Say417; .L_SayX411;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_820, 820, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Check saying hello to the player ( this is the can't greet yourself rule ):
[ R_821 ;
    if ((( (actor==player) && ((noun == player) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_821, 821);
    ! [2: say ~Talking to [ourselves] [regarding nothing][are] likely to prove unrewarding.~ ( a )]
    say__p=1;! [3: ~Talking to [ourselves] [regarding nothing][are] likely to prove unrewarding.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_397); new_line; .L_Say418; .L_SayX412;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_821, 821, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Saying hello to (B354_carry_out_saying_hello_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out saying hello to a person ( this is the note current interlocutor when greeted rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversation Framework" by Eric Eve
! No specific request
! Carry out saying hello to a person ( this is the note current interlocutor when greeted rule ):
[ R_822 ;
    if ((( (actor==player) && ((noun ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_822, 822);
    ! [2: now the current interlocutor is the noun]
    (Global_Vars-->11) = noun;
    } else if (debug_rules > 1) DB_Rule(R_822, 822, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Saying hello to (B355_report_saying_hello_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! The first report rule for saying hello to someone ( this is the standard report greeting rule ):
! --- now the mid-placed rules ---
! Rule 2/4 ! Report player saying hello to someone ( called P ) when player is talking with P:
!   >>> III.3.3 - Action/What/Actor Performing Action >>>
! Rule 3/4 ! Report saying hello to someone when the greeting type is explicit ( this is the default greeting rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 4/4 ! Report saying hello to something that is not a person ( this is the can't greet inanimate objects rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversation Responses" by Eric Eve
! No specific request
! The first report rule for saying hello to someone ( this is the standard report greeting rule ):
[ R_871 ;
    if ((( (actor==player) && ((noun ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_871, 871);
    ! [2: if greeting type is implicit]
    if ((((Global_Vars-->12) == I129_implicit)))
    {! [3: abide by the implicit greeting response rules for the noun]
        if (FollowRulebook(368, noun, true)) rtrue;
        }
    ! [4: abide by the greeting response rules for the noun]
    if (FollowRulebook(366, noun, true)) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_871, 871, 'action');
    rfalse;
];
! From "Phones" by Philip Riley
! No specific request
! Report player saying hello to someone ( called P ) when player is talking with P:
[ R_1012 
    tmp_0 ! Let/loop value, e.g., 'P': person
    ;
    if ((( (actor==player) && (tmp_0 = noun, (((noun ofclass K8_person) && (tmp_0=(noun), true)))) && (self=actor,true) && ((((RGuard_T_4(player,tmp_0)))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1012, 1012);
    ! [2: say ~[We] [say] hello.~]
    say__p=1;! [3: we]
    ParaContent(); (PHR_764_r7 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: say]
    ConjugateVerb_53(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ hello.~]
    ParaContent(); print " hello."; new_line; .L_Say419; .L_SayX413;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1012, 1012, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Report saying hello to someone when the greeting type is explicit ( this is the default greeting rule ):
[ R_824 ;
    if ((( (actor==player) && ((noun ofclass K8_person)) && (self=actor,true) && ((((Global_Vars-->12) == I130_explicit)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_824, 824);
    ! [2: say ~[We] [say] hello to [the noun].~ ( a )]
    say__p=1;! [3: ~[We] [say] hello to [the noun].~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_398); new_line; .L_Say420; .L_SayX414;} else if (debug_rules > 1) DB_Rule(R_824, 824, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Report saying hello to something that is not a person ( this is the can't greet inanimate objects rule ):
[ R_823 ;
    if ((( (actor==player) && ((noun ofclass K2_thing) && (~~((noun ofclass K8_person))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_823, 823);
    ! [2: say ~[The noun] [do not] respond.~]
    say__p=1;! [3: the noun]
    ParaContent(); print (The) noun;! [4: ~ ~]
    ParaContent(); print " ";! [5: do not]
    ConjugateVerb_3(CV_NEG, PNToVP(), story_tense); say__p=1; ! [6: ~ respond.~]
    ParaContent(); print " respond."; new_line; .L_Say421; .L_SayX415;} else if (debug_rules > 1) DB_Rule(R_823, 823, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Hailing (B356_check_hailing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check hailing ( this is the check what's being hailed rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversation Framework" by Eric Eve
! No specific request
! Check hailing ( this is the check what's being hailed rule ):
[ R_826 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_826, 826);
    ! [2: if the current interlocutor is a visible person]
    if ((((Global_Vars-->11) ofclass K8_person) && ((Adj_3_t1_v10((Global_Vars-->11))))))
    {! [3: say ~[We] [are] already talking to [the current interlocutor].~ ( a )]
        say__p=1;! [4: ~[We] [are] already talking to [the current interlocutor].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_399); new_line; .L_Say422; .L_SayX416;rtrue;
        }
    ! [6: now the noun is a random visible person who is not the player]
    noun = (Prop_65());
    ! [7: if the noun is a person and the noun is not yourself and the noun is not the player]
    if ((((noun ofclass K8_person))) && ((((~~((noun == selfobj))))) && (((~~((noun == player)))))))
    {! [8: say ~(addressing [the noun])~ ( b )]
        say__p=1;! [9: ~(addressing [the noun])~ ( b )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_400); .L_Say423; .L_SayX417;} else {
        ! [10: say ~[There's] no one [here] but [us].~]
        say__p=1;! [11: there's]
        ParaContent(); (PHR_792_r50 ());! [12: ~ no one ~]
        ParaContent(); print " no one ";! [13: here]
        ParaContent(); (PHR_517_r51 ());! [14: ~ but ~]
        ParaContent(); print " but ";! [15: us]
        ParaContent(); (PHR_760_r49 ());! [16: ~.~]
        ParaContent(); print "."; new_line; .L_Say424; .L_SayX418;rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_826, 826, 'actor');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Hailing (B357_carry_out_hailing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out hailing ( this is the standard hailing rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversation Framework" by Eric Eve
! No specific request
! Carry out hailing ( this is the standard hailing rule ):
[ R_827 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_827, 827);
    ! [2: try saying hello to the noun]
    TryAction(0, player, ##A74_saying_hello_to, noun, 0);
    } else if (debug_rules > 1) DB_Rule(R_827, 827, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Leavetaking (B359_check_leavetaking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check leavetaking when the current interlocutor is not a visible person ( this is the don't allow saying goodbye to no-one rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversation Framework" by Eric Eve
! No specific request
! Check leavetaking when the current interlocutor is not a visible person ( this is the don't allow saying goodbye to no-one rule ):
[ R_833 ;
    if (actor == player) {
    if ((((((~~(((Global_Vars-->11) ofclass K8_person) && ((Adj_3_t1_v10((Global_Vars-->11))))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_833, 833);
    ! [2: say ~[We] [aren't] talking to anyone.~ ( a )]
    say__p=1;! [3: ~[We] [aren't] talking to anyone.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_401); new_line; .L_Say425; .L_SayX419;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_833, 833, 'context');
    } else if (debug_rules > 1) DB_Rule(R_833, 833, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Leavetaking (B360_carry_out_leavetaking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out someone trying leavetaking ( this is the convert npc leavetaking to player leavetaking rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Carry out leavetaking ( this is the standard leavetaking rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversation Framework" by Eric Eve
! No specific request
! Carry out someone trying leavetaking ( this is the convert npc leavetaking to player leavetaking rule ):
[ R_836 ;
    if ((( (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_836, 836);
    ! [2: try saying goodbye to the person asked]
    TryAction(0, player, ##A77_saying_goodbye_to, actor, 0);
    } else if (debug_rules > 1) DB_Rule(R_836, 836, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Carry out leavetaking ( this is the standard leavetaking rule ):
[ R_834 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_834, 834);
    ! [2: try saying goodbye to the current interlocutor]
    TryAction(0, player, ##A77_saying_goodbye_to, (Global_Vars-->11), 0);
    } else if (debug_rules > 1) DB_Rule(R_834, 834, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying goodbye to (B362_check_saying_goodbye_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check saying goodbye to something when the noun is not the current interlocutor ( this is the can't say goodbye to someone you're not talking to rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversation Framework" by Eric Eve
! No specific request
! Check saying goodbye to something when the noun is not the current interlocutor ( this is the can't say goodbye to someone you're not talking to rule ):
[ R_831 ;
    if ((( (actor==player) && ((noun ofclass K2_thing)) && (self=actor,true) && (((~~((noun == (Global_Vars-->11))))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_831, 831);
    ! [2: say ~[We] [aren't] talking to [the noun].~ ( a )]
    say__p=1;! [3: ~[We] [aren't] talking to [the noun].~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_402); new_line; .L_Say426; .L_SayX420;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_831, 831, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Saying goodbye to (B363_carry_out_saying_goodby)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out saying goodbye to something ( this is the reset interlocutor on saying goodbye rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversation Framework" by Eric Eve
! No specific request
! Carry out saying goodbye to something ( this is the reset interlocutor on saying goodbye rule ):
[ R_832 ;
    if ((( (actor==player) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_832, 832);
    ! [2: reset the interlocutor]
    (PHR_830_r1 ());
    } else if (debug_rules > 1) DB_Rule(R_832, 832, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Saying goodbye to (B364_report_saying_goodbye_t)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! The first report rule for saying goodbye to someone ( this is the standard report farewell rule ):
! --- now the mid-placed rules ---
! Rule 2/2 ! Report saying goodbye to someone when the farewell type is explicit ( this is the default saying goodbye rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversation Responses" by Eric Eve
! No specific request
! The first report rule for saying goodbye to someone ( this is the standard report farewell rule ):
[ R_870 ;
    if ((( (actor==player) && ((noun ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_870, 870);
    ! [2: if farewell type is implicit]
    if ((((Global_Vars-->13) == I129_implicit)))
    {! [3: abide by the implicit farewell response rules for the noun]
        if (FollowRulebook(369, noun, true)) rtrue;
        }
    ! [4: abide by the farewell response rules for the noun]
    if (FollowRulebook(367, noun, true)) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_870, 870, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Report saying goodbye to someone when the farewell type is explicit ( this is the default saying goodbye rule ):
[ R_837 ;
    if ((( (actor==player) && ((noun ofclass K8_person)) && (self=actor,true) && ((((Global_Vars-->13) == I130_explicit)))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_837, 837);
    ! [2: say ~[We] [say] goodbye to [the noun].~]
    say__p=1;! [3: we]
    ParaContent(); (PHR_764_r7 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: say]
    ConjugateVerb_53(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ goodbye to ~]
    ParaContent(); print " goodbye to ";! [7: the noun]
    ParaContent(); print (the) noun;! [8: ~.~]
    ParaContent(); print "."; new_line; .L_Say427; .L_SayX421;} else if (debug_rules > 1) DB_Rule(R_837, 837, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: response (B365_response)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Response of Klimp when asked about aliens:
!   === equally specific with ===
! Rule 2/5 ! Response of Klimp when asked about Moira:
!   === equally specific with ===
! Rule 3/5 ! Response of Klimp when asked about Margaret:
!   === equally specific with ===
! Rule 4/5 ! Response of Klimp when asked about the Bureau of Strange Happenings:
!   === equally specific with ===
! Rule 5/5 ! Response of Klimp when asked about Senator Savra:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Response of Klimp when asked about aliens:
[ R_1465 ;
    if (((((parameter_value == I419_chief_huffton_klimp) && (true))))) { ! Runs only when pattern matches
    if ((((((PHR_849_r52 (I417_aliens))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1465, 1465);
    ! [2: say ~Klimp assumes his lecturing pose. 'You know what I think, of course. They're here, they've been here for decades, maybe centuries, and they're a menace to the human race.'~]
    say__p=1;! [3: ~Klimp assumes his lecturing pose. 'You know what I think, of course. They're here, they've been here for decades, maybe centuries, and they're a menace to the human race.'~]
    ParaContent(); print "Klimp assumes his lecturing pose. ~You know what I think, of course. They're here, they've been here for decades, maybe centuries, and they're a menace to the human race.~"; new_line; .L_Say428; .L_SayX422;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1465, 1465, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1465, 1465, 'action');
    rfalse;
];
! No specific request
! Response of Klimp when asked about Moira:
[ R_1467 ;
    if (((((parameter_value == I419_chief_huffton_klimp) && (true))))) { ! Runs only when pattern matches
    if ((((((PHR_849_r52 (I427_moira_zin))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1467, 1467);
    ! [2: say ~Klimp nods. 'Superior agent. I'd be honored to be compared to her.'~]
    say__p=1;! [3: ~Klimp nods. 'Superior agent. I'd be honored to be compared to her.'~]
    ParaContent(); print "Klimp nods. ~Superior agent. I'd be honored to be compared to her.~"; new_line; .L_Say429; .L_SayX423;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1467, 1467, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1467, 1467, 'action');
    rfalse;
];
! No specific request
! Response of Klimp when asked about Margaret:
[ R_1468 ;
    if (((((parameter_value == I419_chief_huffton_klimp) && (true))))) { ! Runs only when pattern matches
    if ((((((PHR_849_r52 (I358_margaret_chao))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1468, 1468);
    ! [2: say ~He rolls his eyes. 'You take what you can get.'~]
    say__p=1;! [3: ~He rolls his eyes. 'You take what you can get.'~]
    ParaContent(); print "He rolls his eyes. ~You take what you can get.~"; new_line; .L_Say430; .L_SayX424;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1468, 1468, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1468, 1468, 'action');
    rfalse;
];
! No specific request
! Response of Klimp when asked about the Bureau of Strange Happenings:
[ R_1469 ;
    if (((((parameter_value == I419_chief_huffton_klimp) && (true))))) { ! Runs only when pattern matches
    if ((((((PHR_849_r52 (I418_bureau_of_strange_happe))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1469, 1469);
    ! [2: say ~'The Bureau will be the most important line of defense when the alien threat inevitably comes to fruition. Savra is a fool,' he says with a gleam in his eye.~]
    say__p=1;! [3: ~'The Bureau will be the most important line of defense when the alien threat inevitably comes to fruition. Savra is a fool,' he says with a gleam in his eye.~]
    ParaContent(); print "~The Bureau will be the most important line of defense when the alien threat inevitably comes to fruition. Savra is a fool,~ he says with a gleam in his eye."; new_line; .L_Say431; .L_SayX425;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1469, 1469, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1469, 1469, 'action');
    rfalse;
];
! No specific request
! Response of Klimp when asked about Senator Savra:
[ R_1470 ;
    if (((((parameter_value == I419_chief_huffton_klimp) && (true))))) { ! Runs only when pattern matches
    if ((((((PHR_849_r52 (I415_senator_savra))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1470, 1470);
    ! [2: say ~Klimp stops short of actually spitting. 'The lowest of the low.'~]
    say__p=1;! [3: ~Klimp stops short of actually spitting. 'The lowest of the low.'~]
    ParaContent(); print "Klimp stops short of actually spitting. ~The lowest of the low.~"; new_line; .L_Say432; .L_SayX426;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1470, 1470, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1470, 1470, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: greeting response (B366_greeting_response)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Greeting response for Dave:
!   === equally specific with ===
! Rule 2/2 ! Greeting response for Klimp:
! ----------------------------------------------------------------------------------------------------
! From "Swamp Park" by Philip Riley
! No specific request
! Greeting response for Dave:
[ R_1404 ;
    if (((((parameter_value == I320_dave) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1404, 1404);
    ! [2: say ~[Dave] grunts hello.~]
    say__p=1;! [3: dave]
    ParaContent(); PrintShortName(I320_dave);! [4: ~ grunts hello.~]
    ParaContent(); print " grunts hello."; new_line; .L_Say433; .L_SayX427;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1404, 1404, 'action');
    rfalse;
];
! No specific request
! Greeting response for Klimp:
[ R_1466 ;
    if (((((parameter_value == I419_chief_huffton_klimp) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1466, 1466);
    ! [2: say ~Good day.~]
    say__p=1;! [3: ~Good day.~]
    ParaContent(); print "Good day."; new_line; .L_Say434; .L_SayX428;! [4: continue the action]
    rfalse;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1466, 1466, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: default ask response (B370_default_ask_response)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Last default ask response rule for a thing ( called the responder ) ( this is the try default ask-tell response rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversational Defaults" by Eric Eve
! No specific request
! Last default ask response rule for a thing ( called the responder ) ( this is the try default ask-tell response rule ):
[ R_874 
    tmp_0 ! Let/loop value, e.g., 'responder': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_874, 874);
    ! [2: abide by the default ask-tell response rules for the responder]
    if (FollowRulebook(371, tmp_0, true)) rtrue;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_874, 874, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: default ask-tell response (B371_default_ask_tell_respon)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last default ask-tell response rule for a thing ( called the responder ) ( this is the try default response rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversational Defaults" by Eric Eve
! No specific request
! The last default ask-tell response rule for a thing ( called the responder ) ( this is the try default response rule ):
[ R_876 
    tmp_0 ! Let/loop value, e.g., 'responder': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_876, 876);
    ! [2: abide by the default response rules for the responder]
    if (FollowRulebook(379, tmp_0, true)) rtrue;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_876, 876, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: default tell response (B372_default_tell_response)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Last default ask response rule for a thing ( called the responder ) ( this is the try default ask-tell response rule ):
! ----------------------------------------------------------------------------------------------------
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: default answer response (B373_default_answer_response)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Last default answer response rule for a thing ( called the responder ) ( this is the try default tell response rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversational Defaults" by Eric Eve
! No specific request
! Last default answer response rule for a thing ( called the responder ) ( this is the try default tell response rule ):
[ R_873 
    tmp_0 ! Let/loop value, e.g., 'responder': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_873, 873);
    ! [2: abide by the default tell response rules for the responder]
    if (FollowRulebook(372, tmp_0, true)) rtrue;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_873, 873, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: default ask-for response (B374_default_ask_for_respons)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last default ask-tell response rule for a thing ( called the responder ) ( this is the try default response rule ):
! ----------------------------------------------------------------------------------------------------
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: default give response (B375_default_give_response)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last default give response rule for a thing ( called the responder ) ( this is the try default give-show response rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversational Defaults" by Eric Eve
! No specific request
! The last default give response rule for a thing ( called the responder ) ( this is the try default give-show response rule ):
[ R_875 
    tmp_0 ! Let/loop value, e.g., 'responder': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_875, 875);
    ! [2: abide by the default give-show response rules for the responder]
    if (FollowRulebook(377, tmp_0, true)) rtrue;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_875, 875, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: default show response (B376_default_show_response)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last default give response rule for a thing ( called the responder ) ( this is the try default give-show response rule ):
! ----------------------------------------------------------------------------------------------------
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: default give-show response (B377_default_give_show_respo)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last default ask-tell response rule for a thing ( called the responder ) ( this is the try default response rule ):
! ----------------------------------------------------------------------------------------------------
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: default yes-no response (B378_default_yes_no_response)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last default ask-tell response rule for a thing ( called the responder ) ( this is the try default response rule ):
! ----------------------------------------------------------------------------------------------------
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: default response (B379_default_response)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last default response rule ( this is the unresponsive rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversational Defaults" by Eric Eve
! No specific request
! The last default response rule ( this is the unresponsive rule ):
[ R_872 ;
    if (debug_rules) DB_Rule(R_872, 872);
    ! [2: say ~[The current interlocutor] [do not] respond.~ ( a )]
    say__p=1;! [3: ~[The current interlocutor] [do not] respond.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_403); new_line; .L_Say435; .L_SayX429;RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Pausing the game (B381_for_pausing_the_game)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! For pausing the game ( this is the standard pausing the game rule ):
! ----------------------------------------------------------------------------------------------------
! From "Basic Screen Effects" by Emily Short
! No specific request
! For pausing the game ( this is the standard pausing the game rule ):
[ R_895 ;
    if (debug_rules) DB_Rule(R_895, 895);
    ! [2: say ~[paragraph break]Please press SPACE to continue.~ ( a )]
    say__p=1;! [3: ~[paragraph break]Please press SPACE to continue.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_404); new_line; .L_Say436; .L_SayX430;! [4: wait for the space key]
    SPACEPause();
    ! [5: clear the screen]
    VM_ClearScreen(0);
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: escape detection (B383_escape_detection)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Escape detection for 98:
!   === equally specific with ===
! Rule 2/6 ! Escape detection for 105:
!   === equally specific with ===
! Rule 3/6 ! Escape detection for 114:
!   === equally specific with ===
! Rule 4/6 ! Escape detection for 102:
!   === equally specific with ===
! Rule 5/6 ! Escape detection for 118:
! --- now the last-placed rules ---
! Rule 6/6 ! Last escape detection for a number ( called N ):
! ----------------------------------------------------------------------------------------------------
! From "Formatting Capture" by Daniel Stelzer
! No specific request
! Escape detection for 98:
[ R_937 ;
    if (((((parameter_value == 98) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_937, 937);
    ! [2: say bold type]
    say__p=1;! [3: bold type]
    ParaContent(); (PHR_352_r2 ()); .L_Say437; .L_SayX431;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_937, 937, 'action');
    rfalse;
];
! From "Formatting Capture" by Daniel Stelzer
! No specific request
! Escape detection for 105:
[ R_938 ;
    if (((((parameter_value == 105) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_938, 938);
    ! [2: say italic type]
    say__p=1;! [3: italic type]
    ParaContent(); (PHR_353_r9 ()); .L_Say438; .L_SayX432;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_938, 938, 'action');
    rfalse;
];
! From "Formatting Capture" by Daniel Stelzer
! No specific request
! Escape detection for 114:
[ R_939 ;
    if (((((parameter_value == 114) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_939, 939);
    ! [2: say roman type]
    say__p=1;! [3: roman type]
    ParaContent(); (PHR_354_r3 ()); .L_Say439; .L_SayX433;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_939, 939, 'action');
    rfalse;
];
! From "Formatting Capture" by Daniel Stelzer
! No specific request
! Escape detection for 102:
[ R_940 ;
    if (((((parameter_value == 102) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_940, 940);
    ! [2: say fixed letter spacing]
    say__p=1;! [3: fixed letter spacing]
    ParaContent(); (PHR_355_r53 ()); .L_Say440; .L_SayX434;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_940, 940, 'action');
    rfalse;
];
! From "Formatting Capture" by Daniel Stelzer
! No specific request
! Escape detection for 118:
[ R_941 ;
    if (((((parameter_value == 118) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_941, 941);
    ! [2: say variable letter spacing]
    say__p=1;! [3: variable letter spacing]
    ParaContent(); (PHR_356_r54 ()); .L_Say441; .L_SayX435;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_941, 941, 'action');
    rfalse;
];
! From "Formatting Capture" by Daniel Stelzer
! No specific request
! Last escape detection for a number ( called N ):
[ R_942 
    tmp_0 ! Let/loop value, e.g., 'N': number
    ;
    if ((((tmp_0 = parameter_value, (((true) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_942, 942);
    ! [2: say ~<[N]>~]
    say__p=1;! [3: ~<~]
    ParaContent(); print "<";! [4: n]
    ParaContent(); print (say__n=tmp_0);! [5: ~>~]
    ParaContent(); print ">"; .L_Say442; .L_SayX436;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_942, 942, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check asking for identification (B387_check_asking_for_identi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check asking for identification when current interlocutor is nothing:
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Check asking for identification:
! ----------------------------------------------------------------------------------------------------
! From "Essentials" by Philip Riley
! No specific request
! Check asking for identification when current interlocutor is nothing:
[ R_967 ;
    if (actor == player) {
    if (((((((Global_Vars-->11) == nothing)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_967, 967);
    ! [2: say ~[text of the don't allow saying goodbye to no-one rule response (A)][paragraph break]~]
    say__p=1;! [3: text of the don't allow saying goodbye to no-one rule response ( a )]
    ParaContent(); (PHR_380_r40 (R_285_RESP_A));! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say443; .L_SayX437;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_967, 967, 'context');
    } else if (debug_rules > 1) DB_Rule(R_967, 967, 'actor');
    rfalse;
];
! From "Essentials" by Philip Riley
! No specific request
! Check asking for identification:
[ R_968 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_968, 968);
    ! [2: try quizzing current interlocutor about current interlocutor]
    TryAction(0, player, ##A66_quizzing_it_about, (Global_Vars-->11), (Global_Vars-->11));
    } else if (debug_rules > 1) DB_Rule(R_968, 968, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Questioning motives (B390_check_questioning_motiv)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check questioning motives when current interlocutor is nothing:
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Check questioning motives:
! ----------------------------------------------------------------------------------------------------
! From "Essentials" by Philip Riley
! No specific request
! Check questioning motives when current interlocutor is nothing:
[ R_969 ;
    if (actor == player) {
    if (((((((Global_Vars-->11) == nothing)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_969, 969);
    ! [2: say ~[text of the don't allow saying goodbye to no-one rule response (A)][paragraph break]~]
    say__p=1;! [3: text of the don't allow saying goodbye to no-one rule response ( a )]
    ParaContent(); (PHR_380_r40 (R_285_RESP_A));! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say444; .L_SayX438;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_969, 969, 'context');
    } else if (debug_rules > 1) DB_Rule(R_969, 969, 'actor');
    rfalse;
];
! From "Essentials" by Philip Riley
! No specific request
! Check questioning motives:
[ R_970 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_970, 970);
    ! [2: try quizzing current interlocutor about motives]
    TryAction(0, player, ##A66_quizzing_it_about, (Global_Vars-->11), I160_motives);
    } else if (debug_rules > 1) DB_Rule(R_970, 970, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check promising (B393_check_promising)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check promising when the current interlocutor is nothing:
! ----------------------------------------------------------------------------------------------------
! From "Essentials" by Philip Riley
! No specific request
! Check promising when the current interlocutor is nothing:
[ R_971 ;
    if (actor == player) {
    if (((((((Global_Vars-->11) == nothing)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_971, 971);
    ! [2: say ~[text of the don't allow saying goodbye to no-one rule response (A)][paragraph break]~]
    say__p=1;! [3: text of the don't allow saying goodbye to no-one rule response ( a )]
    ParaContent(); (PHR_380_r40 (R_285_RESP_A));! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say445; .L_SayX439;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_971, 971, 'context');
    } else if (debug_rules > 1) DB_Rule(R_971, 971, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Audibility of (B396_audibility_of)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Audibility of a thing ( called T ) when location is indoors:
!   === equally specific with ===
! Rule 2/2 ! Audibility of a thing ( called T ) when location is outdoors:
! ----------------------------------------------------------------------------------------------------
! From "Hearing" by Philip Riley
! No specific request
! Audibility of a thing ( called T ) when location is indoors:
[ R_978 
    tmp_0 ! Let/loop value, e.g., 'T': thing
    tmp_1 ! Let/loop value, e.g., 'N': number
    tmp_2 ! Let/loop value, e.g., 'ans': real number
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (((((((Adj_122_t1_v10(real_location)))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_978, 978);
    ! [2: if best route from the location to the location of t through rooms which are indoors , using doors is nothing]
    if (((MapRouteTo(real_location,LocationOf(tmp_0),Prop_66,1) == nothing)))
    {! [3: inaudible]
        RulebookSucceeds(22, RBNO_18); rtrue;

        }
    ! [4: let n be the number of moves from the location to the location of t through rooms which are indoors , using doors]

    		tmp_1 = MapRouteTo(real_location,LocationOf(tmp_0),Prop_67,1,true);
    ! [5: let ans be volume of t / n]

    		tmp_2 = (REAL_NUMBER_TY_Divide(GProperty(10, tmp_0,p17_volume), NUMBER_TY_to_REAL_NUMBER_TY(tmp_1)));
    ! [6: if ans >= 2]
    if (((REAL_NUMBER_TY_Compare(tmp_2, NUMBER_TY_to_REAL_NUMBER_TY(2)) >= 0)))
    {! [7: very loud]
        RulebookSucceeds(22, RBNO_13); rtrue;

        }
    ! [8: if ans >= 1]
    if (((REAL_NUMBER_TY_Compare(tmp_2, NUMBER_TY_to_REAL_NUMBER_TY(1)) >= 0)))
    {! [9: loud]
        RulebookSucceeds(22, RBNO_14); rtrue;

        }
    ! [10: if ans >= 0.5]
    if (((REAL_NUMBER_TY_Compare(tmp_2, 1056964608) >= 0)))
    {! [11: moderately loud]
        RulebookSucceeds(22, RBNO_15); rtrue;

        }
    ! [12: if ans >= 0.25]
    if (((REAL_NUMBER_TY_Compare(tmp_2, 1048576000) >= 0)))
    {! [13: faint]
        RulebookSucceeds(22, RBNO_16); rtrue;

        }
    ! [14: if ans >= 0.125]
    if (((REAL_NUMBER_TY_Compare(tmp_2, 1040187392) >= 0)))
    {! [15: very faint]
        RulebookSucceeds(22, RBNO_17); rtrue;

        }
    ! [16: inaudible]
    RulebookSucceeds(22, RBNO_18); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_978, 978, 'context');
    } else if (debug_rules > 1) DB_Rule(R_978, 978, 'action');
    rfalse;
];
! From "Hearing" by Philip Riley
! No specific request
! Audibility of a thing ( called T ) when location is outdoors:
[ R_979 
    tmp_0 ! Let/loop value, e.g., 'T': thing
    tmp_1 ! Let/loop value, e.g., 'N': number
    tmp_2 ! Let/loop value, e.g., 'ans': real number
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (((((((Adj_123_t1_v10(real_location)))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_979, 979);
    ! [2: if best route from the location to the location of t through rooms which are outdoors is nothing]
    if (((MapRouteTo(real_location,LocationOf(tmp_0),Prop_68,0) == nothing)))
    {! [3: inaudible]
        RulebookSucceeds(22, RBNO_18); rtrue;

        }
    ! [4: let n be the number of moves from the location to the location of t through rooms which are outdoors]

    		tmp_1 = MapRouteTo(real_location,LocationOf(tmp_0),Prop_69,0,true);
    ! [5: let ans be volume of t / ( 2 * n )]

    		tmp_2 = (REAL_NUMBER_TY_Divide(GProperty(10, tmp_0,p17_volume), NUMBER_TY_to_REAL_NUMBER_TY((2 * tmp_1))));
    ! [6: if ans >= 2]
    if (((REAL_NUMBER_TY_Compare(tmp_2, NUMBER_TY_to_REAL_NUMBER_TY(2)) >= 0)))
    {! [7: very loud]
        RulebookSucceeds(22, RBNO_13); rtrue;

        }
    ! [8: if ans >= 1]
    if (((REAL_NUMBER_TY_Compare(tmp_2, NUMBER_TY_to_REAL_NUMBER_TY(1)) >= 0)))
    {! [9: loud]
        RulebookSucceeds(22, RBNO_14); rtrue;

        }
    ! [10: if ans >= 0.5]
    if (((REAL_NUMBER_TY_Compare(tmp_2, 1056964608) >= 0)))
    {! [11: moderately loud]
        RulebookSucceeds(22, RBNO_15); rtrue;

        }
    ! [12: if ans >= 0.25]
    if (((REAL_NUMBER_TY_Compare(tmp_2, 1048576000) >= 0)))
    {! [13: faint]
        RulebookSucceeds(22, RBNO_16); rtrue;

        }
    ! [14: if ans >= 0.125]
    if (((REAL_NUMBER_TY_Compare(tmp_2, 1040187392) >= 0)))
    {! [15: very faint]
        RulebookSucceeds(22, RBNO_17); rtrue;

        }
    ! [16: inaudible]
    RulebookSucceeds(22, RBNO_18); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_979, 979, 'context');
    } else if (debug_rules > 1) DB_Rule(R_979, 979, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Noisiness of (B397_noisiness_of)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Noisiness of a phone ( called P ) ( this is the phone noisiness rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 2/2 ! Noisiness of a thing ( this is the default noisiness rule ):
! ----------------------------------------------------------------------------------------------------
! From "Phones" by Philip Riley
! No specific request
! Noisiness of a phone ( called P ) ( this is the phone noisiness rule ):
[ R_1000 
    tmp_0 ! Let/loop value, e.g., 'P': phone
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K20_phone) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1000, 1000);
    ! [2: if p is ringing]
    if ((((Adj_133_t1_v10(tmp_0)))))
    {! [3: noisy]
        RulebookSucceeds(22, RBNO_19); rtrue;

        }
    ! [4: quiet]
    RulebookSucceeds(22, RBNO_20); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1000, 1000, 'action');
    rfalse;
];
! From "Hearing" by Philip Riley
! No specific request
! Noisiness of a thing ( this is the default noisiness rule ):
[ R_980 ;
    if (((((parameter_value ofclass K2_thing))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_980, 980);
    ! [2: if thing is noisy]
    if ((((Prop_70()))))
    {! [3: noisy]
        RulebookSucceeds(22, RBNO_19); rtrue;

        }
    ! [4: rule fails]
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_980, 980, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for printing insistent sounds (B399_for_printing_insistent_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for printing insistent sounds:
! ----------------------------------------------------------------------------------------------------
! From "Hearing" by Philip Riley
! No specific request
! Rule for printing insistent sounds:
[ R_994 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (debug_rules) DB_Rule(R_994, 994);
    ! [2: repeat with t running through audible things which are insistent]
    for (tmp_0=Prop_71(0), tmp_1=Prop_71(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_71(tmp_1))
    {! [3: follow the noisiness of rules for t]
        FollowRulebook(397, tmp_0, true);
        ! [4: if rule succeeded]
        if (((RulebookSucceeded())))
        {! [5: if the outcome of the rulebook is the noisy outcome]
            if ((((ResultOfRule()) == RBNO_19)))
            {! [6: carry out the determining the subjective volume activity with t]
                CarryOutActivity(V37_determining_the_subjecti, tmp_0);
                ! [7: if the hearability of t is not inaudible]
                if (((~~((GProperty(10, tmp_0,p16_hearability) == I178_inaudible)))))
                {! [8: add t to audible sounds]
                    LIST_OF_TY_InsertItem((Global_Vars-->18), tmp_0, 0, 0, 0);
                    }
                ! [9: carry out the printing the sound description activity with t]
                CarryOutActivity(V38_printing_the_sound_descr, tmp_0);
                }
                }
                }
                RulebookSucceeds(); rtrue;
                rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for printing background sounds (B402_for_printing_background)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for printing background sounds:
! ----------------------------------------------------------------------------------------------------
! From "Hearing" by Philip Riley
! No specific request
! Rule for printing background sounds:
[ R_995 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (debug_rules) DB_Rule(R_995, 995);
    ! [2: repeat with t running through audible things which are background]
    for (tmp_0=Prop_72(0), tmp_1=Prop_72(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_72(tmp_1))
    {! [3: follow the noisiness of rules for t]
        FollowRulebook(397, tmp_0, true);
        ! [4: if rule succeeded]
        if (((RulebookSucceeded())))
        {! [5: if the outcome of the rulebook is the noisy outcome]
            if ((((ResultOfRule()) == RBNO_19)))
            {! [6: carry out the determining the subjective volume activity with t]
                CarryOutActivity(V37_determining_the_subjecti, tmp_0);
                ! [7: carry out the printing the sound description activity with t]
                CarryOutActivity(V38_printing_the_sound_descr, tmp_0);
                }
                }
                }
                RulebookSucceeds(); rtrue;
                rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after printing background sounds (B403_after_printing_backgrou)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! After printing background sounds when First Turn is true ( this is the make sure hearing works before the first turn rule ):
! ----------------------------------------------------------------------------------------------------
! From "Hearing" by Philip Riley
! No specific request
! After printing background sounds when First Turn is true ( this is the make sure hearing works before the first turn rule ):
[ R_983 ;
    if ((((((((Global_Vars-->19) && true) == (1 && true))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_983, 983);
    ! [2: carry out the printing insistent sounds activity]
    CarryOutActivity(V35_printing_insistent_sound);
    ! [3: now first turn is false]
    (Global_Vars-->19) = 0;
    } else if (debug_rules > 1) DB_Rule(R_983, 983, 'context');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Determining the subjective volume (B405_for_determining_the_sub)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for determining the subjective volume for something ( called T ):
! ----------------------------------------------------------------------------------------------------
! From "Hearing" by Philip Riley
! No specific request
! Rule for determining the subjective volume for something ( called T ):
[ R_984 
    tmp_0 ! Let/loop value, e.g., 'T': thing
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_984, 984);
    ! [2: follow the audibility of rules for t]
    FollowRulebook(396, tmp_0, true);
    ! [3: if rule succeeded]
    if (((RulebookSucceeded())))
    {! [4: let a be the outcome of the rulebook]

        		tmp_1 = (ResultOfRule());
        ! [5: if a is the very loud outcome]
        if (((tmp_1 == RBNO_13)))
        {! [6: now the hearability of t is very loud]
            WriteGProperty(10, tmp_0,p16_hearability,I173_very_loud);
            }
        ! [7: if a is the loud outcome]
        if (((tmp_1 == RBNO_14)))
        {! [8: now the hearability of t is loud]
            WriteGProperty(10, tmp_0,p16_hearability,I174_loud);
            }
        ! [9: if a is the moderately loud outcome]
        if (((tmp_1 == RBNO_15)))
        {! [10: now the hearability of t is moderately loud]
            WriteGProperty(10, tmp_0,p16_hearability,I175_moderately_loud);
            }
        ! [11: if a is the faint outcome]
        if (((tmp_1 == RBNO_16)))
        {! [12: now the hearability of t is faint]
            WriteGProperty(10, tmp_0,p16_hearability,I176_faint);
            }
        ! [13: if a is the very faint outcome]
        if (((tmp_1 == RBNO_17)))
        {! [14: now the hearability of t is very faint]
            WriteGProperty(10, tmp_0,p16_hearability,I177_very_faint);
            }
        ! [15: if a is the inaudible outcome]
        if (((tmp_1 == RBNO_18)))
        {! [16: now the hearability of t is inaudible]
            WriteGProperty(10, tmp_0,p16_hearability,I178_inaudible);
            }
            }
            RulebookSucceeds(); rtrue;
            } else if (debug_rules > 1) DB_Rule(R_984, 984, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the sound description (B408_for_printing_the_sound_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Rule for printing the sound description for something ( called noise ) when noise is visible:
!   === equally specific with ===
! Rule 2/5 ! Rule for printing the sound description for something ( called T ) when the player carries T:
!   === equally specific with ===
! Rule 3/5 ! Rule for printing the sound description for something ( called T ) when T is enclosed by the location:
!   === equally specific with ===
! Rule 4/5 ! Rule for printing the sound description for something ( called T ) when the number of moves from the location to the location of T , using doors is 1:
!   >>> I - Number of aspects constrained >>>
! Rule 5/5 ! Rule for printing the sound description for something ( called T ) ( this is the default sound description rule ):
! ----------------------------------------------------------------------------------------------------
! From "Hearing" by Philip Riley
! No specific request
! Rule for printing the sound description for something ( called noise ) when noise is visible:
[ R_985 
    tmp_0 ! Let/loop value, e.g., 'noise': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (((((((Adj_3_t1_v10(tmp_0)))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_985, 985);
    ! [2: add noise to audible sounds]
    LIST_OF_TY_InsertItem((Global_Vars-->18), tmp_0, 0, 0, 0);
    ! [3: say ~[The Noise] ~]
    say__p=1;! [4: the noise]
    ParaContent(); print (The) tmp_0;! [5: ~ ~]
    ParaContent(); print " "; .L_Say446; .L_SayX440;! [6: if the player encloses the noise]
    if (((IndirectlyContains(player,tmp_0))))
    {! [7: say ~you are carrying ~]
        say__p=1;! [8: ~you are carrying ~]
        ParaContent(); print "you are carrying "; .L_Say447; .L_SayX441;}
    ! [9: say ~is ~]
    say__p=1;! [10: ~is ~]
    ParaContent(); print "is "; .L_Say448; .L_SayX442;! [11: carry out the printing the sound action activity with noise]
    CarryOutActivity(V39_printing_the_sound_actio, tmp_0);
    ! [12: say ~.~]
    say__p=1;! [13: ~.~]
    ParaContent(); print "."; new_line; .L_Say449; .L_SayX443;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_985, 985, 'context');
    } else if (debug_rules > 1) DB_Rule(R_985, 985, 'action');
    rfalse;
];
! From "Hearing" by Philip Riley
! No specific request
! Rule for printing the sound description for something ( called T ) when the player carries T:
[ R_986 
    tmp_0 ! Let/loop value, e.g., 'T': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if ((((((player == CarrierOf(tmp_0))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_986, 986);
    ! [2: say ~[The T] is ~]
    say__p=1;! [3: the t]
    ParaContent(); print (The) tmp_0;! [4: ~ is ~]
    ParaContent(); print " is "; .L_Say450; .L_SayX444;! [5: carry out the printing the sound action activity with t]
    CarryOutActivity(V39_printing_the_sound_actio, tmp_0);
    ! [6: say ~.~]
    say__p=1;! [7: ~.~]
    ParaContent(); print "."; new_line; .L_Say451; .L_SayX445;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_986, 986, 'context');
    } else if (debug_rules > 1) DB_Rule(R_986, 986, 'action');
    rfalse;
];
! From "Hearing" by Philip Riley
! No specific request
! Rule for printing the sound description for something ( called T ) when T is enclosed by the location:
[ R_990 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    I7RBLK = KERNEL_37();
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_37 
    tmp_0 ! Let/loop value, e.g., 'T': thing
    tmp_1 ! Let/loop value, e.g., 'VT': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if ((((((IndirectlyContains(real_location,tmp_0))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_990, 990);
    ! [2: say ~[Generic description of T] is ~]
    say__p=1;! [3: generic description of t]
    ParaContent(); 
    ! Resolution of run-time phrase ambiguity (to phrase):
        formal_par0 = tmp_0;
        if (((((formal_par0 ofclass K8_person) && (formal_par0 ofclass K8_person))))) { (PHR_988_r55 (formal_par0)); }
        else if (((((formal_par0 ofclass K20_phone) && (formal_par0 ofclass K20_phone))))) { (PHR_999_r56 (formal_par0)); }
        else (PHR_987_r57 (formal_par0));
    ! Resolution complete
    ! [4: ~ is ~]
    ParaContent(); print " is "; .L_Say452; .L_SayX446;! [5: carry out the printing the sound action activity with t]
    CarryOutActivity(V39_printing_the_sound_actio, tmp_0);
    ! [6: if t is enclosed by a visible thing ( called vt )]
    if ((((Prop_73(tmp_0) && (tmp_1=deferred_calling_list-->0, true)) || (tmp_1 = 0,false))))
    {! [7: say ~ inside [the VT].~]
        say__p=1;! [8: ~ inside ~]
        ParaContent(); print " inside ";! [9: the vt]
        ParaContent(); print (the) tmp_1;! [10: ~.~]
        ParaContent(); print "."; new_line; .L_Say453; .L_SayX447;} else {
        ! [11: say ~ somewhere in the room.~]
        say__p=1;! [12: ~ somewhere in the room.~]
        ParaContent(); print " somewhere in the room."; new_line; .L_Say454; .L_SayX448;}
    ! [13: add t to audible sounds]
    LIST_OF_TY_InsertItem((Global_Vars-->18), tmp_0, 0, 0, 0);
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_990, 990, 'context');
    } else if (debug_rules > 1) DB_Rule(R_990, 990, 'action');
    rfalse;
];
! From "Hearing" by Philip Riley
! No specific request
! Rule for printing the sound description for something ( called T ) when the number of moves from the location to the location of T , using doors is 1:
[ R_991 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    I7RBLK = KERNEL_38();
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_38 
    tmp_0 ! Let/loop value, e.g., 'T': thing
    tmp_1 ! Let/loop value, e.g., 'X': object
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if ((((((MapRouteTo(real_location,LocationOf(tmp_0),0,1,true) == 1)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_991, 991);
    ! [2: say ~[Generic description of T] is ~]
    say__p=1;! [3: generic description of t]
    ParaContent(); 
    ! Resolution of run-time phrase ambiguity (to phrase):
        formal_par0 = tmp_0;
        if (((((formal_par0 ofclass K8_person) && (formal_par0 ofclass K8_person))))) { (PHR_988_r55 (formal_par0)); }
        else if (((((formal_par0 ofclass K20_phone) && (formal_par0 ofclass K20_phone))))) { (PHR_999_r56 (formal_par0)); }
        else (PHR_987_r57 (formal_par0));
    ! Resolution complete
    ! [4: ~ is ~]
    ParaContent(); print " is "; .L_Say455; .L_SayX449;! [5: carry out the printing the sound action activity with t]
    CarryOutActivity(V39_printing_the_sound_actio, tmp_0);
    ! [6: let x be the best route from location to location of t , using doors]

    		tmp_1 = MapRouteTo(real_location,LocationOf(tmp_0),0,1);
    ! [7: say ~ to the [X].~]
    say__p=1;! [8: ~ to the ~]
    ParaContent(); print " to the ";! [9: x]
    ParaContent(); PrintShortName(tmp_1);! [10: ~.~]
    ParaContent(); print "."; new_line; .L_Say456; .L_SayX450;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_991, 991, 'context');
    } else if (debug_rules > 1) DB_Rule(R_991, 991, 'action');
    rfalse;
];
! From "Hearing" by Philip Riley
! No specific request
! Rule for printing the sound description for something ( called T ) ( this is the default sound description rule ):
[ R_992 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    I7RBLK = KERNEL_39();
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_39 
    tmp_0 ! Let/loop value, e.g., 'T': thing
    tmp_1 ! Let/loop value, e.g., 'aud': rulebook outcome
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_992, 992);
    ! [2: follow the audibility of rules for t]
    FollowRulebook(396, tmp_0, true);
    ! [3: let aud be the outcome of the rulebook]

    		tmp_1 = (ResultOfRule());
    ! [4: if aud is the very loud outcome , or aud is the loud outcome]
    if ((((tmp_1 == RBNO_13))) || (((tmp_1 == RBNO_14))))
    {! [5: say ~[Generic description of T] is [sound of T] nearby.~]
        say__p=1;! [6: generic description of t]
        ParaContent(); 
        ! Resolution of run-time phrase ambiguity (to phrase):
            formal_par0 = tmp_0;
            if (((((formal_par0 ofclass K8_person) && (formal_par0 ofclass K8_person))))) { (PHR_988_r55 (formal_par0)); }
            else if (((((formal_par0 ofclass K20_phone) && (formal_par0 ofclass K20_phone))))) { (PHR_999_r56 (formal_par0)); }
            else (PHR_987_r57 (formal_par0));
        ! Resolution complete
        ! [7: ~ is ~]
        ParaContent(); print " is ";! [8: sound of t]
        ParaContent(); (PHR_989_r58 (tmp_0));! [9: ~ nearby.~]
        ParaContent(); print " nearby."; new_line; .L_Say457; .L_SayX451;! [10: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
    ! [11: if aud is the moderately loud outcome]
    if (((tmp_1 == RBNO_15)))
    {! [12: say ~[Generic description of T] is [sound of T] not too far away.~]
        say__p=1;! [13: generic description of t]
        ParaContent(); 
        ! Resolution of run-time phrase ambiguity (to phrase):
            formal_par0 = tmp_0;
            if (((((formal_par0 ofclass K8_person) && (formal_par0 ofclass K8_person))))) { (PHR_988_r55 (formal_par0)); }
            else if (((((formal_par0 ofclass K20_phone) && (formal_par0 ofclass K20_phone))))) { (PHR_999_r56 (formal_par0)); }
            else (PHR_987_r57 (formal_par0));
        ! Resolution complete
        ! [14: ~ is ~]
        ParaContent(); print " is ";! [15: sound of t]
        ParaContent(); (PHR_989_r58 (tmp_0));! [16: ~ not too far away.~]
        ParaContent(); print " not too far away."; new_line; .L_Say458; .L_SayX452;! [17: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
    ! [18: if aud is the faint outcome]
    if (((tmp_1 == RBNO_16)))
    {! [19: say ~[Generic description of T] is [sound of T] faintly nearby.~]
        say__p=1;! [20: generic description of t]
        ParaContent(); 
        ! Resolution of run-time phrase ambiguity (to phrase):
            formal_par0 = tmp_0;
            if (((((formal_par0 ofclass K8_person) && (formal_par0 ofclass K8_person))))) { (PHR_988_r55 (formal_par0)); }
            else if (((((formal_par0 ofclass K20_phone) && (formal_par0 ofclass K20_phone))))) { (PHR_999_r56 (formal_par0)); }
            else (PHR_987_r57 (formal_par0));
        ! Resolution complete
        ! [21: ~ is ~]
        ParaContent(); print " is ";! [22: sound of t]
        ParaContent(); (PHR_989_r58 (tmp_0));! [23: ~ faintly nearby.~]
        ParaContent(); print " faintly nearby."; new_line; .L_Say459; .L_SayX453;! [24: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
    ! [25: if aud is the very faint outcome]
    if (((tmp_1 == RBNO_17)))
    {! [26: say ~[Generic description of T] is [sound of T] somewhere far off.~]
        say__p=1;! [27: generic description of t]
        ParaContent(); 
        ! Resolution of run-time phrase ambiguity (to phrase):
            formal_par0 = tmp_0;
            if (((((formal_par0 ofclass K8_person) && (formal_par0 ofclass K8_person))))) { (PHR_988_r55 (formal_par0)); }
            else if (((((formal_par0 ofclass K20_phone) && (formal_par0 ofclass K20_phone))))) { (PHR_999_r56 (formal_par0)); }
            else (PHR_987_r57 (formal_par0));
        ! Resolution complete
        ! [28: ~ is ~]
        ParaContent(); print " is ";! [29: sound of t]
        ParaContent(); (PHR_989_r58 (tmp_0));! [30: ~ somewhere far off.~]
        ParaContent(); print " somewhere far off."; new_line; .L_Say460; .L_SayX454;! [31: rule succeeds]
        RulebookSucceeds(); rtrue;
        }
    ! [32: rule fails]
    RulebookFails(); rtrue;
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_992, 992, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the sound action (B411_for_printing_the_sound_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Rule for printing the sound action for a phone:
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 2/2 ! Rule for printing the sound action for something:
! ----------------------------------------------------------------------------------------------------
! From "Phones" by Philip Riley
! No specific request
! Rule for printing the sound action for a phone:
[ R_998 ;
    if (((((parameter_value ofclass K20_phone))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_998, 998);
    ! [2: say ~ringing~]
    say__p=1;! [3: ~ringing~]
    ParaContent(); print "ringing"; .L_Say461; .L_SayX455;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_998, 998, 'action');
    rfalse;
];
! From "Hearing" by Philip Riley
! No specific request
! Rule for printing the sound action for something:
[ R_993 ;
    if (((((parameter_value ofclass K2_thing))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_993, 993);
    ! [2: say ~making noise~]
    say__p=1;! [3: ~making noise~]
    ParaContent(); print "making noise"; .L_Say462; .L_SayX456;RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_993, 993, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Calling it on (B413_check_calling_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check calling someone on the green smartphone:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 2/3 ! Check an actor calling a phone ( called the callee phone ) on a phone ( called the caller phone ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 3/3 ! Check an actor calling someone ( called the callee ) on something ( called the caller phone ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check calling someone on the green smartphone:
[ R_1483 ;
    if ((( (actor==player) && ((noun ofclass K8_person)) && ((second == I445_green_smartphone) && (true))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1483, 1483);
    ! [2: say ~[The green smartphone] is out of batteries.~]
    say__p=1;! [3: the green smartphone]
    ParaContent(); print (The) I445_green_smartphone;! [4: ~ is out of batteries.~]
    ParaContent(); print " is out of batteries."; new_line; .L_Say463; .L_SayX457;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1483, 1483, 'action');
    rfalse;
];
! From "Phones" by Philip Riley
! No specific request
! Check an actor calling a phone ( called the callee phone ) on a phone ( called the caller phone ):
[ R_1006 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(18);
    BlkValueCreateOnStack(16, TEXT_TY);
    BlkValueCreateOnStack(14, TEXT_TY);
    BlkValueCreateOnStack(12, TEXT_TY);
    BlkValueCreateOnStack(10, TEXT_TY);
    BlkValueCreateOnStack(8, TEXT_TY);
    BlkValueCreateOnStack(6, TEXT_TY);
    BlkValueCreateOnStack(4, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_40();
    BlkValueFreeOnStack(16);
    BlkValueFreeOnStack(14);
    BlkValueFreeOnStack(12);
    BlkValueFreeOnStack(10);
    BlkValueFreeOnStack(8);
    BlkValueFreeOnStack(6);
    BlkValueFreeOnStack(4);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_40 
    tmp_0 ! Let/loop value, e.g., 'callee phone': phone
    tmp_1 ! Let/loop value, e.g., 'caller phone': phone
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((act_requester==nothing) && (tmp_0 = noun, (((noun ofclass K20_phone) && (tmp_0=(noun), true)))) && (tmp_1 = second, (((second ofclass K20_phone) && (tmp_1=(second), true))))) || (tmp_1 = 0,tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1006, 1006);
    ! [2: if the location of the actor is not nowhere]
    if (((LocationOf(LocationOf(actor)) ofclass K1_room)))
    {! [3: if reception of the location of the actor is false]
        if ((((GProperty(10, LocationOf(actor),p18_reception) && true) == (0 && true))))
        {! [4: print to actor that ~You have no reception here.~]
            (PHR_963_r41 (actor,BlkValueCopy(I7SFRAME, TX_L_488)));
            rtrue;
            }
        ! [6: if actor does not carry the caller phone and the caller phone is mobile]
        if ((((~~((actor == CarrierOf(tmp_1)))))) && ((((Adj_137_t1_v10(tmp_1))))))
        {! [7: if the actor is the player]
            if (((actor == player)))
            {! [8: say ~(first taking [the caller phone])~]
                say__p=1;! [9: ~(first taking ~]
                ParaContent(); print "(first taking ";! [10: the caller phone]
                ParaContent(); print (the) tmp_1;! [11: ~)~]
                ParaContent(); print ")"; .L_Say464; .L_SayX458;}
            ! [12: silently try actor taking the caller phone]
            @push keep_silent; keep_silent=1; @push say__p; @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Take, tmp_1, 0);
            DivideParagraphPoint();
            @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;

            ! [13: if the rule failed]
            if (((RulebookFailed())))
            {! [14: stop the action]
                rtrue;
                }
                }
        ! [15: let pn be a random phone number which reaches callee phone]

        		tmp_2 = (Prop_74(tmp_0));
        ! [16: if actor does not know pn]
        if (((~~(((RGuard_T_2(actor,tmp_2)))))))
        {! [17: print to actor that ~[We] [don't] know that phone number.~]
            (PHR_963_r41 (actor,BlkValueCopy((I7SFRAME+WORDSIZE*2), ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*4),TX_S_508)))));
            rtrue;
            }
        ! [19: if the callee phone is the caller phone]
        if (((tmp_0 == tmp_1)))
        {! [20: print to actor that ~[We] [can't] call the phone [we're] calling from!~]
            (PHR_963_r41 (actor,BlkValueCopy((I7SFRAME+WORDSIZE*6), ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*8),TX_S_509)))));
            rtrue;
            }
        ! [22: if the caller phone is not idle]
        if (((~~(((Adj_134_t1_v10(tmp_1)))))))
        {! [23: print to actor that ~[The caller phone] is busy.~]
            (PHR_963_r41 (actor,BlkValueCopy((I7SFRAME+WORDSIZE*10), ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*12),TX_S_510)))));
            rtrue;
            }
        ! [25: if the callee phone is not idle]
        if (((~~(((Adj_134_t1_v10(tmp_0)))))))
        {! [26: print to actor that ~[The callee phone] is busy.~]
            (PHR_963_r41 (actor,BlkValueCopy((I7SFRAME+WORDSIZE*14), ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*16),TX_S_511)))));
            rtrue;
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_1006, 1006, 'action');
            rfalse;
];
! From "Phones" by Philip Riley
! No specific request
! Check an actor calling someone ( called the callee ) on something ( called the caller phone ):
[ R_1009 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(4);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_41();
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_41 
    tmp_0 ! Let/loop value, e.g., 'callee': person
    tmp_1 ! Let/loop value, e.g., 'caller phone': thing
    tmp_2 ! Let/loop value, e.g., 'Ph': object
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    tmp_4 ! Let/loop value (deallocated by end of phrase)
    tmp_5 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((act_requester==nothing) && (tmp_0 = noun, (((noun ofclass K8_person) && (tmp_0=(noun), true)))) && (tmp_1 = second, (((second ofclass K2_thing) && (tmp_1=(second), true))))) || (tmp_1 = 0,tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1009, 1009);
    ! [2: let ph be nothing]

    		tmp_2 = nothing;
    ! [3: repeat with p running through the phones owned by the callee]
    for (tmp_3=Prop_75(tmp_0,0), tmp_4=Prop_75(tmp_0,tmp_3): tmp_3: tmp_3=tmp_4, tmp_4=Prop_75(tmp_0,tmp_4))
    {! [4: let pn be a random phone number which reaches p]

        		tmp_5 = (Prop_76(tmp_3));
        ! [5: if actor knows pn]
        if ((((RGuard_T_2(actor,tmp_5)))))
        {! [6: now ph is p]
            tmp_2 = tmp_3;
            }
            }
    ! [7: if ph is nothing]
    if (((tmp_2 == nothing)))
    {! [8: if actor is player]
        if (((actor == player)))
        {! [9: say ~[We] [don't] know of any phones owned by [Callee].~]
            say__p=1;! [10: we]
            ParaContent(); (PHR_764_r7 ());! [11: ~ ~]
            ParaContent(); print " ";! [12: don't]
            ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ! [13: ~ know of any phones owned by ~]
            ParaContent(); print " know of any phones owned by ";! [14: callee]
            ParaContent(); PrintShortName(tmp_0);! [15: ~.~]
            ParaContent(); print "."; new_line; .L_Say465; .L_SayX459;rtrue;
            } else {
            ! [17: print to actor that ~[regarding actor][Actor] [don't] know of any phones owned by [Callee].~]
            (PHR_963_r41 (actor,BlkValueCopy(I7SFRAME, ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=tmp_4),(LocalParking-->5=tmp_5),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*2),TX_S_512)))));
            rtrue;
            }
            }
    ! [19: if actor is the player]
    if (((actor == player)))
    {! [20: say ~(calling [the Ph])[command clarification break]~]
        say__p=1;! [21: ~(calling ~]
        ParaContent(); print "(calling ";! [22: the ph]
        ParaContent(); print (the) tmp_2;! [23: ~)~]
        ParaContent(); print ")";! [24: command clarification break]
        ParaContent(); CommandClarificationBreak(); .L_Say466; .L_SayX460;}
    ! [25: try actor calling ph on caller phone]
    TryAction(0, actor, ##A82_calling_it_on, tmp_2, tmp_1);
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1009, 1009, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Calling it on (B414_carry_out_calling_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor calling a phone ( called the callee phone ) on a phone ( called the caller phone ):
! ----------------------------------------------------------------------------------------------------
! From "Phones" by Philip Riley
! No specific request
! Carry out an actor calling a phone ( called the callee phone ) on a phone ( called the caller phone ):
[ R_1007 
    tmp_0 ! Let/loop value, e.g., 'callee phone': phone
    tmp_1 ! Let/loop value, e.g., 'caller phone': phone
    tmp_2 ! Let/loop value, e.g., 'callee': thing
    ;
    if ((((act_requester==nothing) && (tmp_0 = noun, (((noun ofclass K20_phone) && (tmp_0=(noun), true)))) && (tmp_1 = second, (((second ofclass K20_phone) && (tmp_1=(second), true))))) || (tmp_1 = 0,tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1007, 1007);
    ! [2: now the actor is calling the callee phone]
    (RGuard_MT_5(actor,tmp_0));
    ! [3: now the actor is talking on the caller phone]
    (RGuard_MT_3(actor,tmp_1));
    ! [4: let the callee be a random person who owns the callee phone]

    		tmp_2 = (Prop_77(tmp_0));
    ! [5: now the callee phone is ringing]
    (Adj_133_t2_v10(tmp_0));
    ! [6: now the caller phone is in use]
    (Adj_135_t2_v10(tmp_1));
    } else if (debug_rules > 1) DB_Rule(R_1007, 1007, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Calling it on (B415_report_calling_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor calling a phone ( called the callee phone ) on a phone ( called the caller phone ):
! ----------------------------------------------------------------------------------------------------
! From "Phones" by Philip Riley
! No specific request
! Report an actor calling a phone ( called the callee phone ) on a phone ( called the caller phone ):
[ R_1008 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(4);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_42();
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_42 
    tmp_0 ! Let/loop value, e.g., 'callee phone': phone
    tmp_1 ! Let/loop value, e.g., 'caller phone': phone
    ;
    if ((((act_requester==nothing) && (tmp_0 = noun, (((noun ofclass K20_phone) && (tmp_0=(noun), true)))) && (tmp_1 = second, (((second ofclass K20_phone) && (tmp_1=(second), true))))) || (tmp_1 = 0,tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1008, 1008);
    ! [2: if the actor is not the player]
    if (((~~((actor == player)))))
    {! [3: print near the actor that ~[Actor] calls someone on [caller phone].~]
        (PHR_964_r59 (actor,BlkValueCopy(I7SFRAME, ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*2),TX_S_513)))));
        }
        } else if (debug_rules > 1) DB_Rule(R_1008, 1008, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Cold-calling it on (B416_check_cold_calling_it_o)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check Cold-calling something on something:
! ----------------------------------------------------------------------------------------------------
! From "Phones" by Philip Riley
! No specific request
! Check Cold-calling something on something:
[ R_1004 ;
    if ((( (actor==player) && ((parsed_number ofclass K2_thing)) && ((second ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1004, 1004);
    ! [2: say ~You don't know the number for [topic understood].~]
    say__p=1;! [3: ~You don't know the number for ~]
    ParaContent(); print "You don't know the number for ";! [4: topic understood]
    ParaContent(); PrintSnippet(parsed_number);! [5: ~.~]
    ParaContent(); print "."; new_line; .L_Say467; .L_SayX461;} else if (debug_rules > 1) DB_Rule(R_1004, 1004, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Answering (B419_check_answering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor answering a phone ( called the phone ) ( this is the check actor answering phone rule ):
! ----------------------------------------------------------------------------------------------------
! From "Phones" by Philip Riley
! No specific request
! Check an actor answering a phone ( called the phone ) ( this is the check actor answering phone rule ):
[ R_1010 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(4);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_43();
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_43 
    tmp_0 ! Let/loop value, e.g., 'phone': phone
    tmp_1 ! Let/loop value, e.g., 'caller': thing
    ;
    if ((((act_requester==nothing) && (tmp_0 = noun, (((noun ofclass K20_phone) && (tmp_0=(noun), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1010, 1010);
    ! [2: if the phone is idle]
    if ((((Adj_134_t1_v10(tmp_0)))))
    {! [3: print to the actor that ~[The noun] isn't ringing.~ ( a )]
        (PHR_963_r41 (actor,BlkValueCopy(I7SFRAME, ((LocalParking-->0=tmp_0),TX_R_405))));
        rtrue;
        } else {
        ! [5: if the phone is in use]
        if ((((Adj_135_t1_v10(tmp_0)))))
        {! [6: print to the actor that ~You're already talking on [the noun].~ ( b )]
            (PHR_963_r41 (actor,BlkValueCopy((I7SFRAME+WORDSIZE*2), ((LocalParking-->0=tmp_0),TX_R_406))));
            rtrue;
            }
            }
    ! [8: let caller be a random person who is calling the phone]

    		tmp_1 = (Prop_78(tmp_0));
    ! [9: if the actor is the player and the caller is the player]
    if ((((actor == player))) && (((tmp_1 == player))))
    {! [10: say ~Oh I get it. You think you're clever, calling yourself. Well I won't put up with that kind of shenanigans.~ ( c )]
        say__p=1;! [11: ~Oh I get it. You think you're clever, calling yourself. Well I won't put up with that kind of shenanigans.~ ( c )]
        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_407); new_line; .L_Say468; .L_SayX462;rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_1010, 1010, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Answering (B420_carry_out_answering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor answering a phone ( called the phone ):
! ----------------------------------------------------------------------------------------------------
! From "Phones" by Philip Riley
! No specific request
! Carry out an actor answering a phone ( called the phone ):
[ R_1011 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(8);
    BlkValueCreateOnStack(6, TEXT_TY);
    BlkValueCreateOnStack(4, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_44();
    BlkValueFreeOnStack(6);
    BlkValueFreeOnStack(4);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_44 
    tmp_0 ! Let/loop value, e.g., 'phone': phone
    tmp_1 ! Let/loop value, e.g., 'caller': thing
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((act_requester==nothing) && (tmp_0 = noun, (((noun ofclass K20_phone) && (tmp_0=(noun), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1011, 1011);
    ! [2: now the phone is in use]
    (Adj_135_t2_v10(tmp_0));
    ! [3: now the actor is talking on the phone]
    (RGuard_MT_3(actor,tmp_0));
    ! [4: let caller be a random person who is calling the phone]

    		tmp_1 = (Prop_79(tmp_0));
    ! [5: now actor is talking with caller]
    (RGuard_MT_4(actor,tmp_1));
    ! [6: try actor picking up the phone]
    TryAction(0, actor, ##A85_picking_up, tmp_0, 0);
    ! [7: try actor saying hello to caller]
    TryAction(0, actor, ##A74_saying_hello_to, tmp_1, 0);
    ! [8: try caller saying hello to actor]
    TryAction(0, tmp_1, ##A74_saying_hello_to, actor, 0);
    ! [9: if the actor is the player]
    if (((actor == player)))
    {! [10: now the command prompt is ~(on the phone with [Caller]) >~]
        BlkValueCopy((Global_Vars-->1), ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TEXT_TY_ExpandIfPerishable(I7SFRAME,TX_S_517)));
        }
    ! [11: if the caller is the player]
    if (((tmp_1 == player)))
    {! [12: let a be ~[Actor]~]
        tmp_2 = (I7SFRAME+WORDSIZE*2); 
        		BlkValueCopy(tmp_2, ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*4),TX_S_518)));
        ! [13: now the command prompt is ~(on the phone with [a]) >~]
        BlkValueCopy((Global_Vars-->1), ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*6),TX_S_519)));
        }
        } else if (debug_rules > 1) DB_Rule(R_1011, 1011, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report PIcking up (B424_report_picking_up)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor picking up a phone ( called the phone ) ( this is the report picking up the phone rule ):
! ----------------------------------------------------------------------------------------------------
! From "Phones" by Philip Riley
! No specific request
! Report an actor picking up a phone ( called the phone ) ( this is the report picking up the phone rule ):
[ R_1016 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_45();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_45 
    tmp_0 ! Let/loop value, e.g., 'phone': phone
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((act_requester==nothing) && (tmp_0 = noun, (((noun ofclass K20_phone) && (tmp_0=(noun), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1016, 1016);
    ! [2: if the actor is not the player and the actor is colocated with the player]
    if ((((~~((actor == player))))) && (((PHR_957_r60 (actor,player)))))
    {! [3: say ~[Actor] answers [the phone].~ ( a )]
        say__p=1;! [4: ~[Actor] answers [the phone].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),TX_R_408); new_line; .L_Say469; .L_SayX463;}
    ! [5: if the actor is the player]
    if (((actor == player)))
    {! [6: let caller be a random person who is calling the phone]

        		tmp_1 = (Prop_80(tmp_0));
        ! [7: print to the player that ~You answer [the phone].~ ( b )]
        (PHR_963_r41 (player,BlkValueCopy(I7SFRAME, ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_409))));
        }
        } else if (debug_rules > 1) DB_Rule(R_1016, 1016, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Ending a call (B425_check_ending_a_call)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check ending a call when the player is not phoning:
!   >>> III - When/while requirement >>>
! Rule 2/2 ! Check an actor ending a call when the the actor is not phoning and the actor is not the player:
! ----------------------------------------------------------------------------------------------------
! From "Phones" by Philip Riley
! No specific request
! Check ending a call when the player is not phoning:
[ R_1019 ;
    if (actor == player) {
    if ((((((~~(((Adj_49_t1_v10(player)))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1019, 1019);
    ! [2: say ~You aren't on the phone.~]
    say__p=1;! [3: ~You aren't on the phone.~]
    ParaContent(); print "You aren't on the phone."; new_line; .L_Say470; .L_SayX464;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1019, 1019, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1019, 1019, 'actor');
    rfalse;
];
! From "Phones" by Philip Riley
! No specific request
! Check an actor ending a call when the the actor is not phoning and the actor is not the player:
[ R_1020 ;
    if ((((act_requester==nothing) && (self=actor,true) && ((((~~(((Adj_49_t1_v10(actor))))))) && (((~~((actor == player))))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1020, 1020);
    ! [2: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1020, 1020, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Ending a call (B426_carry_out_ending_a_call)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out an actor ending a call when the actor is talking with nobody:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 2/2 ! Carry out an actor ending a call when the actor is talking with someone ( called the callee ):
! ----------------------------------------------------------------------------------------------------
! From "Phones" by Philip Riley
! No specific request
! Carry out an actor ending a call when the actor is talking with nobody:
[ R_1022 
    tmp_0 ! Let/loop value, e.g., 'P': thing
    ;
    if ((((act_requester==nothing) && (self=actor,true) && ((((Prop_81()))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1022, 1022);
    ! [2: if the actor is calling something ( called p )]
    if ((((RGuard_f1_5(actor)) ofclass K20_phone) && (tmp_0=((RGuard_f1_5(actor))), true)))
    {! [3: now p is idle]
        (Adj_134_t2_v10(tmp_0));
        }
    ! [4: if the actor is talking on something ( called p )]
    if ((((RGuard_f1_3(actor)) ofclass K20_phone) && (tmp_0=((RGuard_f1_3(actor))), true)))
    {! [5: now p is idle]
        (Adj_134_t2_v10(tmp_0));
        ! [6: try the actor hanging up p]
        TryAction(0, actor, ##A87_hanging_up, tmp_0, 0);
        }
        } else if (debug_rules > 1) DB_Rule(R_1022, 1022, 'action');
        rfalse;
];
! From "Phones" by Philip Riley
! No specific request
! Carry out an actor ending a call when the actor is talking with someone ( called the callee ):
[ R_1021 
    tmp_0 ! Let/loop value, e.g., 'callee': person
    tmp_1 ! Let/loop value, e.g., 'P': thing
    ;
    if ((((act_requester==nothing) && (self=actor,true) && ((((Prop_82() && (tmp_0=deferred_calling_list-->0, true)) || (tmp_0 = 0,false))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1021, 1021);
    ! [2: try the actor signing off with the callee]
    TryAction(0, actor, ##A88_signing_off_with, tmp_0, 0);
    ! [3: try the callee signing off with the actor]
    TryAction(0, tmp_0, ##A88_signing_off_with, actor, 0);
    ! [4: if the actor is talking on something ( called p )]
    if ((((RGuard_f1_3(actor)) ofclass K20_phone) && (tmp_1=((RGuard_f1_3(actor))), true)))
    {! [5: try the actor hanging up p]
        TryAction(0, actor, ##A87_hanging_up, tmp_1, 0);
        }
    ! [6: if the callee is talking on something ( called p )]
    if ((((RGuard_f1_3(tmp_0)) ofclass K20_phone) && (tmp_1=((RGuard_f1_3(tmp_0))), true)))
    {! [7: try the callee hanging up p]
        TryAction(0, tmp_0, ##A87_hanging_up, tmp_1, 0);
        }
        } else if (debug_rules > 1) DB_Rule(R_1021, 1021, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Hanging up (B429_carry_out_hanging_up)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out an actor hanging up something ( called P ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 2/2 ! Carry out player hanging up:
! ----------------------------------------------------------------------------------------------------
! From "Phones" by Philip Riley
! No specific request
! Carry out an actor hanging up something ( called P ):
[ R_1023 
    tmp_0 ! Let/loop value, e.g., 'P': thing
    ;
    if ((((act_requester==nothing) && (tmp_0 = noun, (((noun ofclass K2_thing) && (tmp_0=(noun), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1023, 1023);
    ! [2: now p is idle]
    (Adj_134_t2_v10(tmp_0));
    ! [3: now the actor is not talking with anybody]
    Prop_83();
    ! [4: now the actor is not calling anything]
    Prop_84();
    ! [5: now the actor is not talking on anything]
    Prop_85();
    ! [6: now the current interlocutor is nothing]
    (Global_Vars-->11) = nothing;
    } else if (debug_rules > 1) DB_Rule(R_1023, 1023, 'action');
    rfalse;
];
! From "Phones" by Philip Riley
! No specific request
! Carry out player hanging up:
[ R_1028 ;
    if ((( (actor==player)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1028, 1028);
    ! [2: now the command prompt is ~>~]
    BlkValueCopy((Global_Vars-->1), TX_L_452);
    } else if (debug_rules > 1) DB_Rule(R_1028, 1028, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Hanging up (B430_report_hanging_up)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor hanging up:
! ----------------------------------------------------------------------------------------------------
! From "Phones" by Philip Riley
! No specific request
! Report an actor hanging up:
[ R_1025 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(4);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_46();
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_46 
    tmp_0 ! Let/loop value, e.g., 'P': person
    ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1025, 1025);
    ! [2: if actor is talking with someone ( called p )]
    if ((((Prop_86() && (tmp_0=deferred_calling_list-->0, true)) || (tmp_0 = 0,false))))
    {! [3: if p is the player and p is talking on something]
        if ((((tmp_0 == player))) && ((((RGuard_f1_3(tmp_0)) ofclass K20_phone))))
        {! [4: say ~[regarding actor][if actor is player][We][otherwise][Actor][end if] [hang] up the phone.~]
            say__p=1;! [5: regarding actor]
            ParaContent(); RegardingSingleObject(actor);! [6: if actor is player]

            	if (~~((((actor == player))))) jump L_Say471;! [7: we]
            ParaContent(); (PHR_764_r7 ());! [8: otherwise]

            	jump L_SayX465; .L_Say471;! [9: actor]
            ParaContent(); PrintShortName(actor);! [10: end if]

            	.L_Say472; .L_SayX465;! [11: ~ ~]
            ParaContent(); print " ";! [12: hang]
            ConjugateVerb_88(CV_POS, PNToVP(), story_tense); say__p=1; ! [13: ~ up the phone.~]
            ParaContent(); print " up the phone."; new_line; .L_Say473; .L_SayX466;}
            } else {
        ! [14: print near actor that ~[regarding actor][if actor is player][We][otherwise][Actor][end if] [hang] up the phone.[line break]~]
        (PHR_964_r59 (actor,BlkValueCopy(I7SFRAME, ((LocalParking-->0=tmp_0),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*2),TX_S_522)))));
        }
        } else if (debug_rules > 1) DB_Rule(R_1025, 1025, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Signing off with (B433_report_signing_off_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor signing off with a person ( called callee ):
! ----------------------------------------------------------------------------------------------------
! From "Phones" by Philip Riley
! No specific request
! Report an actor signing off with a person ( called callee ):
[ R_1024 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(4);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_47();
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_47 
    tmp_0 ! Let/loop value, e.g., 'callee': person
    ;
    if ((((act_requester==nothing) && (tmp_0 = noun, (((noun ofclass K8_person) && (tmp_0=(noun), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1024, 1024);
    ! [2: print to callee that ~[regarding actor][if actor is player][We][otherwise][Actor][end if] [say] goodbye to [if callee is player][us][otherwise][Callee][end if].~ as actor]
    (PHR_965_r61 (tmp_0,BlkValueCopy(I7SFRAME, ((LocalParking-->0=tmp_0),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*2),TX_S_523))),actor));
    } else if (debug_rules > 1) DB_Rule(R_1024, 1024, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Buying it with (B434_check_buying_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check buying something ( called the product ) with something ( called damoney ):
! ----------------------------------------------------------------------------------------------------
! From "Commerce" by Philip Riley
! No specific request
! Check buying something ( called the product ) with something ( called damoney ):
[ R_1033 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(1, KD8_list_of_people);
    BlkValueCreateOnStack(0, KD8_list_of_people);
    I7RBLK = KERNEL_48();
    BlkValueFreeOnStack(1);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_48 
    tmp_0 ! Let/loop value, e.g., 'product': thing
    tmp_1 ! Let/loop value, e.g., 'damoney': thing
    tmp_2 ! Let/loop value, e.g., 'P': list of people
    tmp_3 ! Let/loop value, e.g., 'seller': thing
    ;
    if ((( (actor==player) && (tmp_0 = noun, (((noun ofclass K2_thing) && (tmp_0=(noun), true)))) && (tmp_1 = second, (((second ofclass K2_thing) && (tmp_1=(second), true))))) || (tmp_1 = 0,tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1033, 1033);
    ! [2: if the player owns the product]
    if (((player == (RGuard_f0_7(tmp_0)))))
    {! [3: say ~You already own that.~]
        say__p=1;! [4: ~You already own that.~]
        ParaContent(); print "You already own that."; new_line; .L_Say474; .L_SayX467;rtrue;
        }
    ! [6: let p be the list of visible people who own the product]
    tmp_2 = I7SFRAME; 
    		BlkValueCopy(tmp_2, (Prop_87(tmp_0,(I7SFRAME+WORDSIZE),10)));
    ! [7: if p is empty]
    if ((((Adj_17_t1_v34(tmp_2)))))
    {! [8: say ~No one owns that.~]
        say__p=1;! [9: ~No one owns that.~]
        ParaContent(); print "No one owns that."; new_line; .L_Say475; .L_SayX468;rtrue;
        }
    ! [11: let seller be entry 1 of p]

    		tmp_3 = LIST_OF_TY_GetItem(tmp_2,1);
    ! [12: if seller is not willing to sell the product]
    if (((~~((tmp_3 == (RGuard_f0_8(tmp_0)))))))
    {! [13: say ~[The seller] doesn[']t want to sell [the product].~]
        say__p=1;! [14: the seller]
        ParaContent(); print (The) tmp_3;! [15: ~ doesn~]
        ParaContent(); print " doesn";! [16: ']
        ParaContent(); print "'";! [17: ~t want to sell ~]
        ParaContent(); print "t want to sell ";! [18: the product]
        ParaContent(); print (the) tmp_0;! [19: ~.~]
        ParaContent(); print "."; new_line; .L_Say476; .L_SayX469;rtrue;
        }
    ! [21: if damoney is mc-disabled]
    if ((((Adj_142_t1_v10(tmp_1)))))
    {! [22: say ~[The seller] runs [the damoney], but it's declined. You might want to call the bank.~]
        say__p=1;! [23: the seller]
        ParaContent(); print (The) tmp_3;! [24: ~ runs ~]
        ParaContent(); print " runs ";! [25: the damoney]
        ParaContent(); print (the) tmp_1;! [26: ~, but it's declined. You might want to call the bank.~]
        ParaContent(); print ", but it's declined. You might want to call the bank."; new_line; .L_Say477; .L_SayX470;rtrue;
        }
    ! [28: if the balance of damoney is less than the price of the product]
    if (((GProperty(10, tmp_1,p19_balance) < GProperty(10, tmp_0,p20_price))))
    {! [29: say ~You don't have enough money to buy [the product]. You need [the price of the product], but you only have [the balance of damoney].~]
        say__p=1;! [30: ~You don't have enough money to buy ~]
        ParaContent(); print "You don't have enough money to buy ";! [31: the product]
        ParaContent(); print (the) tmp_0;! [32: ~. You need ~]
        ParaContent(); print ". You need ";! [33: the price of the product]
        ParaContent(); @push self; E80(GProperty(10, self=tmp_0,p20_price));@pull self; ! [34: ~, but you only have ~]
        ParaContent(); print ", but you only have ";! [35: the balance of damoney]
        ParaContent(); @push self; E80(GProperty(10, self=tmp_1,p19_balance));@pull self; ! [36: ~.~]
        ParaContent(); print "."; new_line; .L_Say478; .L_SayX471;rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_1033, 1033, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Buying it with (B435_carry_out_buying_it_wit)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out buying something ( called the product ) with something ( called damoney ):
! ----------------------------------------------------------------------------------------------------
! From "Commerce" by Philip Riley
! No specific request
! Carry out buying something ( called the product ) with something ( called damoney ):
[ R_1034 
    tmp_0 ! Let/loop value, e.g., 'product': thing
    tmp_1 ! Let/loop value, e.g., 'damoney': thing
    ;
    if ((( (actor==player) && (tmp_0 = noun, (((noun ofclass K2_thing) && (tmp_0=(noun), true)))) && (tmp_1 = second, (((second ofclass K2_thing) && (tmp_1=(second), true))))) || (tmp_1 = 0,tmp_0 = 0,false))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1034, 1034);
    ! [2: say ~You pay [the price of the product] and [the product] [are] yours.~]
    say__p=1;! [3: ~You pay ~]
    ParaContent(); print "You pay ";! [4: the price of the product]
    ParaContent(); @push self; E80(GProperty(10, self=tmp_0,p20_price));@pull self; ! [5: ~ and ~]
    ParaContent(); print " and ";! [6: the product]
    ParaContent(); print (the) tmp_0;! [7: ~ ~]
    ParaContent(); print " ";! [8: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [9: ~ yours.~]
    ParaContent(); print " yours."; new_line; .L_Say479; .L_SayX472;! [10: now the player owns the product]
    (RGuard_MT_7(player,tmp_0));
    ! [11: now the balance of damoney is the balance of damoney minus the price of the product]
    WriteGProperty(10, tmp_1,p19_balance,(GProperty(10, tmp_1,p19_balance) - GProperty(10, tmp_0,p20_price)));
    ! [12: now the player has the product]
    MoveObject(tmp_0,player);
    } else if (debug_rules > 1) DB_Rule(R_1034, 1034, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Pricing it (B438_carry_out_pricing_it)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out pricing:
! ----------------------------------------------------------------------------------------------------
! From "Commerce" by Philip Riley
! No specific request
! Carry out pricing:
[ R_1035 ;
    if ((( (actor==player)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1035, 1035);
    ! [2: if the vendor of the noun is not nothing and the owner of the noun is the vendor of the noun]
    if ((((~~((GProperty(OBJECT_TY, noun,p126_vendor) == nothing))))) && (((GProperty(OBJECT_TY, noun,p125_owner) == GProperty(OBJECT_TY, noun,p126_vendor)))))
    {! [3: say ~The price of [the noun] is [the price of the noun].~]
        say__p=1;! [4: ~The price of ~]
        ParaContent(); print "The price of ";! [5: the noun]
        ParaContent(); print (the) noun;! [6: ~ is ~]
        ParaContent(); print " is ";! [7: the price of the noun]
        ParaContent(); @push self; E80(GProperty(OBJECT_TY, self=noun,p20_price));@pull self; ! [8: ~.~]
        ParaContent(); print "."; new_line; .L_Say480; .L_SayX473;} else {
        ! [9: say ~[The noun] isn't for sale.~]
        say__p=1;! [10: the noun]
        ParaContent(); print (The) noun;! [11: ~ isn't for sale.~]
        ParaContent(); print " isn't for sale."; new_line; .L_Say481; .L_SayX474;}
        } else if (debug_rules > 1) DB_Rule(R_1035, 1035, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Accounting (B441_carry_out_accounting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out accounting:
! ----------------------------------------------------------------------------------------------------
! From "Commerce" by Philip Riley
! No specific request
! Carry out accounting:
[ R_1036 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(1, KD10_list_of_money_cards);
    BlkValueCreateOnStack(0, KD10_list_of_money_cards);
    I7RBLK = KERNEL_49();
    BlkValueFreeOnStack(1);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_49 
    tmp_0 ! Let/loop value, e.g., 'cards': list of money cards
    tmp_1 ! Let/loop value, e.g., 'B': amount of money
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    tmp_4 ! Let/loop value: number
    ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1036, 1036);
    ! [2: let cards be the list of held money cards]
    tmp_0 = I7SFRAME; 
    		BlkValueCopy(tmp_0, (Prop_88((I7SFRAME+WORDSIZE),10)));
    ! [3: let b be $0]

    		tmp_1 = 0;
    ! [4: repeat with card running through cards]
    for (tmp_4=tmp_0, tmp_3=1, tmp_2=LIST_OF_TY_GetItem(tmp_4, tmp_3, true): tmp_3<=LIST_OF_TY_GetLength(tmp_4): tmp_3++, tmp_2=LIST_OF_TY_GetItem(tmp_4, tmp_3, true))
    {! [5: now b is b plus the balance of card]
        tmp_1 = (tmp_1 + GProperty(10, tmp_2,p19_balance));
        }
    ! [6: say ~You have [B].~]
    say__p=1;! [7: ~You have ~]
    ParaContent(); print "You have ";! [8: b]
    ParaContent(); E80(tmp_1);! [9: ~.~]
    ParaContent(); print "."; new_line; .L_Say482; .L_SayX475;} else if (debug_rules > 1) DB_Rule(R_1036, 1036, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Attributing it (B444_carry_out_attributing_i)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out Attributing:
! ----------------------------------------------------------------------------------------------------
! From "Commerce" by Philip Riley
! No specific request
! Carry out Attributing:
[ R_1038 ;
    if ((( (actor==player)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1038, 1038);
    ! [2: if the owner of the noun is nothing]
    if (((GProperty(OBJECT_TY, noun,p125_owner) == nothing)))
    {! [3: say ~No one owns [the noun].~]
        say__p=1;! [4: ~No one owns ~]
        ParaContent(); print "No one owns ";! [5: the noun]
        ParaContent(); print (the) noun;! [6: ~.~]
        ParaContent(); print "."; new_line; .L_Say483; .L_SayX476;} else {
        ! [7: say ~[The owner of the noun] owns [the noun].~]
        say__p=1;! [8: the owner of the noun]
        ParaContent(); @push self; print (The) GProperty(OBJECT_TY, self=noun,p125_owner);@pull self; ! [9: ~ owns ~]
        ParaContent(); print " owns ";! [10: the noun]
        ParaContent(); print (the) noun;! [11: ~.~]
        ParaContent(); print "."; new_line; .L_Say484; .L_SayX477;}
        } else if (debug_rules > 1) DB_Rule(R_1038, 1038, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Acting as (B447_for_acting_as)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for acting as someone ( called P ):
! ----------------------------------------------------------------------------------------------------
! From "Real People" by Philip Riley
! No specific request
! Rule for acting as someone ( called P ):
[ R_1046 
    tmp_0 ! Let/loop value, e.g., 'P': person
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K8_person) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1046, 1046);
    ! [2: abide by the interruption rules for p]
    if (FollowRulebook(449, tmp_0, true)) rtrue;
    ! [3: carry out the behaving as activity with p]
    CarryOutActivity(V41_behaving_as, tmp_0);
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1046, 1046, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for behaving as (B452_for_behaving_as)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Rule for behaving as Margaret when the current behavior of Margaret is throw out boxes:
!   === equally specific with ===
! Rule 2/4 ! Rule for behaving as margaret when the the current behavior of margaret is locking-back-door:
!   === equally specific with ===
! Rule 3/4 ! Rule for behaving as margaret when the the current behavior of margaret is waiting-for-player:
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 4/4 ! Rule for behaving as a person ( called P ) when the the current behavior of P is walking-to:
! ----------------------------------------------------------------------------------------------------
! From "Margaret" by Philip Riley
! No specific request
! Rule for behaving as Margaret when the current behavior of Margaret is throw out boxes:
[ R_1431 ;
    if (((((parameter_value == I358_margaret_chao) && (parameter_value ofclass K8_person))))) { ! Runs only when pattern matches
    if (((((((PHR_1053_r62 (I358_margaret_chao)) == I368_throw_out_boxes)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1431, 1431);
    ! [2: if margaret is in back lot]
    if (((I325_back_lot == ContainerOf(I358_margaret_chao))))
    {! [3: if margaret carries margaret-flattened-boxes]
        if (((I358_margaret_chao == CarrierOf(I468_margaret_flattened_boxe))))
        {! [4: try margaret inserting margaret-flattened-boxes into dumpster]
            TryAction(0, I358_margaret_chao, ##Insert, I468_margaret_flattened_boxe, I448_dumpster);
            } else {
            ! [5: try margaret going east]
            TryAction(0, I358_margaret_chao, ##Go, I57_east, 0);
            }
            } else {
        ! [6: if margaret is in biff's office]
        if (((I429_biff_s_office == ContainerOf(I358_margaret_chao))))
        {! [7: if margaret carries margaret-flattened-boxes]
            if (((I358_margaret_chao == CarrierOf(I468_margaret_flattened_boxe))))
            {! [8: if bosh back door is locked]
                if ((((Adj_106_t1_v10(I367_bosh_back_door)))))
                {! [9: try margaret unlocking the bosh back door with the white key]
                    TryAction(0, I358_margaret_chao, ##Unlock, I367_bosh_back_door, I446_white_key);
                    } else {
                    ! [10: try margaret going west]
                    TryAction(0, I358_margaret_chao, ##Go, I58_west, 0);
                    }
                    } else {
                ! [11: if the bosh back door is closed and the bosh back door is locked]
                if (((((Adj_102_t1_v10(I367_bosh_back_door))))) && ((((Adj_106_t1_v10(I367_bosh_back_door))))))
                {! [12: try margaret going north]
                    TryAction(0, I358_margaret_chao, ##Go, I51_north, 0);
                    } else {
                    ! [13: if the bosh back door is open]
                    if ((((Adj_101_t1_v10(I367_bosh_back_door)))))
                    {! [14: try margaret closing the bosh back door]
                        TryAction(0, I358_margaret_chao, ##Close, I367_bosh_back_door, 0);
                        }
                    ! [15: if the door is unlocked]
                    if ((((Prop_89()))))
                    {! [16: try margaret locking the bosh back door with the white key]
                        TryAction(0, I358_margaret_chao, ##Lock, I367_bosh_back_door, I446_white_key);
                        }
                        }
                        }
                        } else {
            ! [17: if margaret is in the office hallway]
            if (((I452_bosh_office_hallway == ContainerOf(I358_margaret_chao))))
            {! [18: if margaret carries margaret-flattened-boxes]
                if (((I358_margaret_chao == CarrierOf(I468_margaret_flattened_boxe))))
                {! [19: try margaret going south]
                    TryAction(0, I358_margaret_chao, ##Go, I54_south, 0);
                    } else {
                    ! [20: try margaret going east]
                    TryAction(0, I358_margaret_chao, ##Go, I57_east, 0);
                    }
                    } else {
                ! [21: if margaret is in the front office]
                if (((I295_the_front_office == ContainerOf(I358_margaret_chao))))
                {! [22: if margaret carries margaret-flattened-boxes]
                    if (((I358_margaret_chao == CarrierOf(I468_margaret_flattened_boxe))))
                    {! [23: try margaret going west]
                        TryAction(0, I358_margaret_chao, ##Go, I58_west, 0);
                        } else {
                        ! [24: remove behavior from margaret]
                        (PHR_1051_r63 (I358_margaret_chao));
                        }
                        }
                        }
                        }
                        }
                        RulebookSucceeds(); rtrue;
                        } else if (debug_rules > 1) DB_Rule(R_1431, 1431, 'context');
                        } else if (debug_rules > 1) DB_Rule(R_1431, 1431, 'action');
                        rfalse;
];
! No specific request
! Rule for behaving as margaret when the the current behavior of margaret is locking-back-door:
[ R_1492 ;
    if (((((parameter_value == I358_margaret_chao) && (parameter_value ofclass K8_person))))) { ! Runs only when pattern matches
    if (((((((PHR_1053_r62 (I358_margaret_chao)) == I449_locking_back_door)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1492, 1492);
    ! [2: if bosh back door is open]
    if ((((Adj_101_t1_v10(I367_bosh_back_door)))))
    {! [3: try margaret closing bosh back door]
        TryAction(0, I358_margaret_chao, ##Close, I367_bosh_back_door, 0);
        }
    ! [4: if bosh back door is unlocked]
    if ((((Adj_107_t1_v10(I367_bosh_back_door)))))
    {! [5: try margaret locking bosh back door with the white key]
        TryAction(0, I358_margaret_chao, ##Lock, I367_bosh_back_door, I446_white_key);
        }
    ! [6: remove behavior from margaret]
    (PHR_1051_r63 (I358_margaret_chao));
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1492, 1492, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1492, 1492, 'action');
    rfalse;
];
! No specific request
! Rule for behaving as margaret when the the current behavior of margaret is waiting-for-player:
[ R_1493 ;
    if (((((parameter_value == I358_margaret_chao) && (parameter_value ofclass K8_person))))) { ! Runs only when pattern matches
    if (((((((PHR_1053_r62 (I358_margaret_chao)) == I450_waiting_for_player)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1493, 1493);
    ! [2: if the location is not the back lot]
    if (((~~((real_location == I325_back_lot)))))
    {! [3: remove behavior from margaret]
        (PHR_1051_r63 (I358_margaret_chao));
        }
        RulebookSucceeds(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1493, 1493, 'context');
        } else if (debug_rules > 1) DB_Rule(R_1493, 1493, 'action');
        rfalse;
];
! From "Real People" by Philip Riley
! No specific request
! Rule for behaving as a person ( called P ) when the the current behavior of P is walking-to:
[ R_1054 
    tmp_0 ! Let/loop value, e.g., 'P': person
    tmp_1 ! Let/loop value, e.g., 'D': object
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K8_person) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (((((((PHR_1053_r62 (tmp_0)) == I191_walking_to)))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1054, 1054);
    ! [2: let d be the best route from the location of p to the target location of p , using doors]

    		tmp_1 = MapRouteTo(LocationOf(tmp_0),GProperty(10, tmp_0,p23_target_location),0,1);
    ! [3: try p going d]
    TryAction(0, tmp_0, ##Go, tmp_1, 0);
    ! [4: if p is in the target location of p]
    if (((GProperty(10, tmp_0,p23_target_location) == ContainerOf(tmp_0))))
    {! [5: clear behavior of p]
        (PHR_1049_r64 (tmp_0));
        }
        RulebookSucceeds(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1054, 1054, 'context');
        } else if (debug_rules > 1) DB_Rule(R_1054, 1054, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: wall description (B457_wall_description)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Wall description of a room ( called R ) ( this is the standard wall description rule ):
! ----------------------------------------------------------------------------------------------------
! From "Walls" by Philip Riley
! No specific request
! Wall description of a room ( called R ) ( this is the standard wall description rule ):
[ R_1062 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(6);
    BlkValueCreateOnStack(4, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_50();
    BlkValueFreeOnStack(4);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_50 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K1_room) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1062, 1062);
    ! [2: if r is wall-defined]
    if ((((Adj_50_t1_v10(tmp_0)))))
    {! [3: choose row with a locale of r in the table of walls]
        ct_0 = T5_walls; ct_1 = TableRowCorr(ct_0, 123, tmp_0);
        ! [4: if there is a wall description entry]
        if (((ExistsTableLookUpEntry(ct_0,125,ct_1))))
        {! [5: rule succeeds with result wall description entry]
            RulebookSucceeds(TEXT_TY,BlkValueCopy(I7SFRAME, TableLookUpEntry(ct_0,125,ct_1))); rtrue;
            }
            }
    ! [6: if r is walled]
    if ((((Adj_51_t1_v10(tmp_0)))))
    {! [7: rule succeeds with result ~[We] [see] nothing special about the walls.~ ( a )]
        RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*2), ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),TX_R_410))); rtrue;
        }
    ! [8: rule succeeds with result ~There are no walls to see.~ ( b )]
    RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*4), ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),TX_R_411))); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1062, 1062, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: wall touch description (B458_wall_touch_description)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Wall touch description of a room ( called R ) ( this is the standard wall touch description rule ):
! ----------------------------------------------------------------------------------------------------
! From "Walls" by Philip Riley
! No specific request
! Wall touch description of a room ( called R ) ( this is the standard wall touch description rule ):
[ R_1065 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(6);
    BlkValueCreateOnStack(4, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_51();
    BlkValueFreeOnStack(4);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_51 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K1_room) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1065, 1065);
    ! [2: if r is wall-defined]
    if ((((Adj_50_t1_v10(tmp_0)))))
    {! [3: choose row with a locale of r in the table of walls]
        ct_0 = T5_walls; ct_1 = TableRowCorr(ct_0, 123, tmp_0);
        ! [4: if there is a touch description entry]
        if (((ExistsTableLookUpEntry(ct_0,126,ct_1))))
        {! [5: rule succeeds with result touch description entry]
            RulebookSucceeds(TEXT_TY,BlkValueCopy(I7SFRAME, TableLookUpEntry(ct_0,126,ct_1))); rtrue;
            }
            }
    ! [6: if the location is walled]
    if ((((Adj_51_t1_v10(real_location)))))
    {! [7: rule succeeds with result ~[We] [feel] nothing special about the walls.~ ( a )]
        RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*2), ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),TX_R_412))); rtrue;
        }
    ! [8: rule succeeds with result ~There are no walls to feel.~ ( b )]
    RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*4), ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),TX_R_413))); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1065, 1065, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: floor description (B459_floor_description)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Floor description of a room ( called R ) ( this is the standard floor description rule ):
! ----------------------------------------------------------------------------------------------------
! From "Floors" by Philip Riley
! No specific request
! Floor description of a room ( called R ) ( this is the standard floor description rule ):
[ R_1076 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(6);
    BlkValueCreateOnStack(4, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_52();
    BlkValueFreeOnStack(4);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_52 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K1_room) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1076, 1076);
    ! [2: if r is floor-defined]
    if ((((Adj_52_t1_v10(tmp_0)))))
    {! [3: choose row with a locale of r in the table of floors]
        ct_0 = T6_floors; ct_1 = TableRowCorr(ct_0, 123, tmp_0);
        ! [4: if there is a floor description entry]
        if (((ExistsTableLookUpEntry(ct_0,128,ct_1))))
        {! [5: rule succeeds with result floor description entry]
            RulebookSucceeds(TEXT_TY,BlkValueCopy(I7SFRAME, TableLookUpEntry(ct_0,128,ct_1))); rtrue;
            }
            }
    ! [6: if r is floored]
    if ((((Adj_53_t1_v10(tmp_0)))))
    {! [7: rule succeeds with result ~[We] [see] nothing special about the [if the location is indoors]floor[otherwise]ground[end if].~ ( a )]
        RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*2), ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),TX_R_414))); rtrue;
        }
    ! [8: rule succeeds with result ~There is no floor to see.~ ( b )]
    RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*4), ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),TX_R_415))); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1076, 1076, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: floor touch description (B460_floor_touch_description)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Floor touch description of a room ( called R ) ( this is the standard floor touch description rule ):
! ----------------------------------------------------------------------------------------------------
! From "Floors" by Philip Riley
! No specific request
! Floor touch description of a room ( called R ) ( this is the standard floor touch description rule ):
[ R_1079 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(8);
    BlkValueCreateOnStack(6, TEXT_TY);
    BlkValueCreateOnStack(4, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_53();
    BlkValueFreeOnStack(6);
    BlkValueFreeOnStack(4);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_53 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K1_room) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1079, 1079);
    ! [2: if r is floor-defined]
    if ((((Adj_52_t1_v10(tmp_0)))))
    {! [3: choose row with a locale of r in the table of floors]
        ct_0 = T6_floors; ct_1 = TableRowCorr(ct_0, 123, tmp_0);
        ! [4: if there is a touch description entry]
        if (((ExistsTableLookUpEntry(ct_0,126,ct_1))))
        {! [5: rule succeeds with result touch description entry]
            RulebookSucceeds(TEXT_TY,BlkValueCopy(I7SFRAME, TableLookUpEntry(ct_0,126,ct_1))); rtrue;
            }
            }
    ! [6: if r is floored]
    if ((((Adj_53_t1_v10(tmp_0)))))
    {! [7: if the location is indoors]
        if ((((Adj_122_t1_v10(real_location)))))
        {! [8: rule succeeds with result ~[We] [feel] nothing special about the floor.~ ( a )]
            RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*2), ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),TX_R_416))); rtrue;
            } else {
            ! [9: rule succeeds with result ~[We] [feel] nothing special about the ground.~ ( b )]
            RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*4), ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),TX_R_417))); rtrue;
            }
            }
    ! [10: rule succeeds with result ~There is no floor to feel.~ ( c )]
    RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*6), ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),TX_R_418))); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1079, 1079, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: ceiling description (B461_ceiling_description)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Ceiling description of a room ( called R ) ( this is the standard ceiling description rule ):
! ----------------------------------------------------------------------------------------------------
! From "Ceilings" by Philip Riley
! No specific request
! Ceiling description of a room ( called R ) ( this is the standard ceiling description rule ):
[ R_1091 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(8);
    BlkValueCreateOnStack(6, TEXT_TY);
    BlkValueCreateOnStack(4, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_54();
    BlkValueFreeOnStack(6);
    BlkValueFreeOnStack(4);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_54 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K1_room) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1091, 1091);
    ! [2: if r is ceiling-defined]
    if ((((Adj_54_t1_v10(tmp_0)))))
    {! [3: choose row with a locale of r in the table of ceilings]
        ct_0 = T7_ceilings; ct_1 = TableRowCorr(ct_0, 123, tmp_0);
        ! [4: if there is a ceiling description entry]
        if (((ExistsTableLookUpEntry(ct_0,130,ct_1))))
        {! [5: rule succeeds with result ceiling description entry]
            RulebookSucceeds(TEXT_TY,BlkValueCopy(I7SFRAME, TableLookUpEntry(ct_0,130,ct_1))); rtrue;
            }
            }
    ! [6: if r is ceilinged]
    if ((((Adj_55_t1_v10(tmp_0)))))
    {! [7: rule succeeds with result ~[We] [see] nothing special about the ceiling.~ ( a )]
        RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*2), ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),TX_R_419))); rtrue;
        }
    ! [8: if location is outdoors]
    if ((((Adj_123_t1_v10(real_location)))))
    {! [9: rule succeeds with result ~There's nothing up there but sky.~ ( b )]
        RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*4), ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),TX_R_420))); rtrue;
        }
    ! [10: rule succeeds with result ~There is no ceiling to see.~ ( c )]
    RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*6), ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),TX_R_421))); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1091, 1091, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: ceiling touch description (B462_ceiling_touch_descripti)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Ceiling touch description of a room ( called R ) ( this is the standard ceiling touch description rule ):
! ----------------------------------------------------------------------------------------------------
! From "Ceilings" by Philip Riley
! No specific request
! Ceiling touch description of a room ( called R ) ( this is the standard ceiling touch description rule ):
[ R_1094 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(10);
    BlkValueCreateOnStack(8, TEXT_TY);
    BlkValueCreateOnStack(6, TEXT_TY);
    BlkValueCreateOnStack(4, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_55();
    BlkValueFreeOnStack(8);
    BlkValueFreeOnStack(6);
    BlkValueFreeOnStack(4);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_55 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K1_room) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1094, 1094);
    ! [2: if r is ceiling-defined]
    if ((((Adj_54_t1_v10(tmp_0)))))
    {! [3: choose row with a locale of r in the table of ceilings]
        ct_0 = T7_ceilings; ct_1 = TableRowCorr(ct_0, 123, tmp_0);
        ! [4: if there is a touch description entry]
        if (((ExistsTableLookUpEntry(ct_0,126,ct_1))))
        {! [5: rule succeeds with result touch description entry]
            RulebookSucceeds(TEXT_TY,BlkValueCopy(I7SFRAME, TableLookUpEntry(ct_0,126,ct_1))); rtrue;
            }
            }
    ! [6: if location is not low-ceilinged and the location is ceilinged]
    if ((((~~(((Adj_56_t1_v10(real_location))))))) && ((((Adj_55_t1_v10(real_location))))))
    {! [7: rule succeeds with result ~[We] [can't] reach the ceiling.~ ( a )]
        RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*2), ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),TX_R_422))); rtrue;
        }
    ! [8: if location is ceilinged]
    if ((((Adj_55_t1_v10(real_location)))))
    {! [9: rule succeeds with result ~[We] [feel] nothing special about the ceiling.~ ( b )]
        RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*4), ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),TX_R_423))); rtrue;
        }
    ! [10: if location is outdoors]
    if ((((Adj_123_t1_v10(real_location)))))
    {! [11: rule succeeds with result ~[We] [can't] touch the sky.~ ( c )]
        RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*6), ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),TX_R_424))); rtrue;
        }
    ! [12: rule succeeds with result ~There is no ceiling to feel.~ ( d )]
    RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*8), ((LocalParking-->0=tmp_0),(LocalParking-->1=ct_0),(LocalParking-->2=ct_1),TX_R_425))); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1094, 1094, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: excuse text (B463_excuse_text)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! excuse text for a direction ( called dir ) ( this is the standard excuse text rule ):
! ----------------------------------------------------------------------------------------------------
! From "Can't Go That Way" by Philip Riley
! No specific request
! excuse text for a direction ( called dir ) ( this is the standard excuse text rule ):
[ R_1104 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(20);
    BlkValueCreateOnStack(18, TEXT_TY);
    BlkValueCreateOnStack(16, TEXT_TY);
    BlkValueCreateOnStack(14, TEXT_TY);
    BlkValueCreateOnStack(12, TEXT_TY);
    BlkValueCreateOnStack(10, TEXT_TY);
    BlkValueCreateOnStack(8, TEXT_TY);
    BlkValueCreateOnStack(6, TEXT_TY);
    BlkValueCreateOnStack(4, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_56();
    BlkValueFreeOnStack(18);
    BlkValueFreeOnStack(16);
    BlkValueFreeOnStack(14);
    BlkValueFreeOnStack(12);
    BlkValueFreeOnStack(10);
    BlkValueFreeOnStack(8);
    BlkValueFreeOnStack(6);
    BlkValueFreeOnStack(4);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_56 
    tmp_0 ! Let/loop value, e.g., 'dir': direction
    tmp_1 ! Let/loop value, e.g., 'source': room
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K3_direction) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1104, 1104);
    ! [2: let source be the room you tried to leave]

    		tmp_1 = (Global_Vars-->21);
    ! [3: repeat through the table of excuses]
    @push ct_0; @push ct_1;
    		for (tmp_2=T8_excuses, tmp_3=1, ct_0=tmp_2, ct_1=tmp_3:
    			tmp_3<=TableRows(tmp_2):
    			tmp_3++, ct_0=tmp_2, ct_1=tmp_3)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [4: if there is a dirs entry]
        if (((ExistsTableLookUpEntry(ct_0,133,ct_1))))
        {! [5: if ( source room entry is source ) and ( dir is listed in dirs entry )]
            if ((((TableLookUpEntry(ct_0,132,ct_1) == tmp_1))) && (((LIST_OF_TY_FindItem(TableLookUpEntry(ct_0,133,ct_1), tmp_0)))))
            {! [6: rule succeeds with result excuse entry]
                RulebookSucceeds(TEXT_TY,BlkValueCopy(I7SFRAME, TableLookUpEntry(ct_0,134,ct_1))); rtrue;
                }
                }
                }
                @pull ct_1; @pull ct_0;! [7: if dir is up]
    if (((tmp_0 == I59_up)))
    {! [8: rule succeeds with result ~[We] [can] neither climb walls nor fly.~ ( a )]
        RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*2), ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=ct_0),(LocalParking-->3=ct_1),(LocalParking-->4=tmp_2),(LocalParking-->5=tmp_3),TX_R_426))); rtrue;
        }
    ! [9: if dir is down]
    if (((tmp_0 == I60_down)))
    {! [10: if source is floored]
        if ((((Adj_53_t1_v10(tmp_1)))))
        {! [11: rule succeeds with result ~[We] [can't] just dig downward.~ ( b ) in sentence case]
            RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*4), TEXT_TY_CharactersToCase((I7SFRAME+WORDSIZE*6), ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=ct_0),(LocalParking-->3=ct_1),(LocalParking-->4=tmp_2),(LocalParking-->5=tmp_3),TX_R_427), 3))); rtrue;
            } else {
            ! [12: rule succeeds with result ~[We] [can't] go that way.~ ( c )]
            RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*8), ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=ct_0),(LocalParking-->3=ct_1),(LocalParking-->4=tmp_2),(LocalParking-->5=tmp_3),TX_R_428))); rtrue;
            }
            }
    ! [13: if dir is inside]
    if (((tmp_0 == in_obj)))
    {! [14: rule succeeds with result ~What [regarding the player][do] [we] want to enter?~ ( d )]
        RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*10), ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=ct_0),(LocalParking-->3=ct_1),(LocalParking-->4=tmp_2),(LocalParking-->5=tmp_3),TX_R_429))); rtrue;
        }
    ! [15: if dir is outside]
    if (((tmp_0 == out_obj)))
    {! [16: rule succeeds with result ~[text of the can't exit when not inside anything rule response (A)]~]
        RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*12), ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=ct_0),(LocalParking-->3=ct_1),(LocalParking-->4=tmp_2),(LocalParking-->5=tmp_3),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*14),TX_S_544)))); rtrue;
        }
    ! [17: repeat through the table of excuses]
    @push ct_0; @push ct_1;
    		for (tmp_2=T8_excuses, tmp_3=1, ct_0=tmp_2, ct_1=tmp_3:
    			tmp_3<=TableRows(tmp_2):
    			tmp_3++, ct_0=tmp_2, ct_1=tmp_3)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [18: if there is no dirs entry]
        if (((ExistsTableLookUpEntry(ct_0,133,ct_1) == false)))
        {! [19: if source room entry is source]
            if (((TableLookUpEntry(ct_0,132,ct_1) == tmp_1)))
            {! [20: rule succeeds with result excuse entry]
                RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*16), TableLookUpEntry(ct_0,134,ct_1))); rtrue;
                }
                }
                }
                @pull ct_1; @pull ct_0;! [21: rule succeeds with result ~[We] [can't] go that way.~ ( e )]
    RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*18), ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=ct_0),(LocalParking-->3=ct_1),(LocalParking-->4=tmp_2),(LocalParking-->5=tmp_3),TX_R_430))); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1104, 1104, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: can't take that (B464_can_t_take_that)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! can't take that of a thing ( called T ) ( this is the standard can't take that rule ):
! ----------------------------------------------------------------------------------------------------
! From "Can't Take That" by Philip Riley
! No specific request
! can't take that of a thing ( called T ) ( this is the standard can't take that rule ):
[ R_1108 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(4);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_57();
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_57 
    tmp_0 ! Let/loop value, e.g., 'T': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1108, 1108);
    ! [2: if there is a message corresponding to a target of t in the table of frustrated taking]
    if (((ExistsTableLookUpCorr(T9_frustrated_taking,136,135,tmp_0))))
    {! [3: rule succeeds with result the message corresponding to a target of t in the table of frustrated taking]
        RulebookSucceeds(TEXT_TY,BlkValueCopy(I7SFRAME, TableLookUpCorr(T9_frustrated_taking,136,135,tmp_0))); rtrue;
        }
    ! [4: rule succeeds with result ~[We] [can't] take that.~ ( a )]
    RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*2), ((LocalParking-->0=tmp_0),TX_R_431))); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1108, 1108, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: can't move that (B465_can_t_move_that)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! can't move that of a thing ( called T ) ( this is the standard can't move that rule ):
! ----------------------------------------------------------------------------------------------------
! From "Can't Take That" by Philip Riley
! No specific request
! can't move that of a thing ( called T ) ( this is the standard can't move that rule ):
[ R_1110 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(4);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_58();
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_58 
    tmp_0 ! Let/loop value, e.g., 'T': thing
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K2_thing) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1110, 1110);
    ! [2: if there is a move message corresponding to a target of t in the table of frustrated taking]
    if (((ExistsTableLookUpCorr(T9_frustrated_taking,137,135,tmp_0))))
    {! [3: rule succeeds with result the move message corresponding to a target of t in the table of frustrated taking]
        RulebookSucceeds(TEXT_TY,BlkValueCopy(I7SFRAME, TableLookUpCorr(T9_frustrated_taking,137,135,tmp_0))); rtrue;
        }
    ! [4: rule succeeds with result ~[We] [can't] move that.~ ( a )]
    RulebookSucceeds(TEXT_TY,BlkValueCopy((I7SFRAME+WORDSIZE*2), ((LocalParking-->0=tmp_0),TX_R_432))); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1110, 1110, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for List arranging (B467_for_list_arranging)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for list arranging:
! ----------------------------------------------------------------------------------------------------
! From "Complex Listing" by Emily Short
! No specific request
! Rule for list arranging:
[ R_1129 ;
    if (debug_rules) DB_Rule(R_1129, 1129);
    ! [2: sort table of scored listing in assigned score order]
    TableSort(T10_scored_listing, 139, 1);
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Delimiting a list (B470_for_delimiting_a_list)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for delimiting a list ( this is the standard delimiting rule ):
! ----------------------------------------------------------------------------------------------------
! From "Complex Listing" by Emily Short
! No specific request
! Rule for delimiting a list ( this is the standard delimiting rule ):
[ R_1134 
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    if (debug_rules) DB_Rule(R_1134, 1134);
    ! [2: choose row with list style of current list style in the table of list style assignments]
    ct_0 = T11_list_style_assignments; ct_1 = TableRowCorr(ct_0, 140, (Global_Vars-->26));
    ! [3: if current listing index is 1]
    if ((((Global_Vars-->28) == 1)))
    {! [4: if current listing total > 2]
        if ((((Global_Vars-->27) > 2)))
        {! [5: say ~[second delimiter entry]~ ( a )]
            say__p=1;! [6: ~[second delimiter entry]~ ( a )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=ct_0),(LocalParking-->1=ct_1),TX_R_433); .L_Say485; .L_SayX478;} else {
            ! [7: say ~[alternate second delimiter entry]~ ( b )]
            say__p=1;! [8: ~[alternate second delimiter entry]~ ( b )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=ct_0),(LocalParking-->1=ct_1),TX_R_434); .L_Say486; .L_SayX479;}
            } else {
        ! [9: if current listing index > 0]
        if ((((Global_Vars-->28) > 0)))
        {! [10: say ~[first delimiter entry]~ ( c )]
            say__p=1;! [11: ~[first delimiter entry]~ ( c )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=ct_0),(LocalParking-->1=ct_1),TX_R_435); .L_Say487; .L_SayX480;}
            }
            RulebookSucceeds(); rtrue;
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: door appearance (B472_door_appearance)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! A door appearance rule ( this is the default door appearance rule ):
! ----------------------------------------------------------------------------------------------------
! From "Exit Lister" by Eric Eve
! No specific request
! A door appearance rule ( this is the default door appearance rule ):
[ R_1136 ;
    if (debug_rules) DB_Rule(R_1136, 1136);
    ! [2: rule succeeds with result true]
    RulebookSucceeds(TRUTH_STATE_TY,1); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: room appearance (B473_room_appearance)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! A room appearance rule for a room in hyperspace ( this is the hyperspace appearance rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! A room appearance rule ( this is the default room appearance rule ):
! ----------------------------------------------------------------------------------------------------
! From "Exit Lister" by Eric Eve
! No specific request
! A room appearance rule for a room in hyperspace ( this is the hyperspace appearance rule ):
[ R_1139 ;
    if (((((parameter_value ofclass K1_room) && (TestRegionalContainment(parameter_value,I232_hyperspace)))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1139, 1139);
    ! [2: if the location is in hyperspace]
    if (((TestRegionalContainment(real_location,I232_hyperspace))))
    {! [3: make no decision]
        rfalse;
        }
    ! [4: if the player is wearing the astral lenses]
    if (((player == WearerOf(I426_astral_lenses))))
    {! [5: make no decision]
        rfalse;
        }
    ! [6: rule succeeds with result false]
    RulebookSucceeds(TRUTH_STATE_TY,0); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1139, 1139, 'action');
    rfalse;
];
! From "Exit Lister" by Eric Eve
! No specific request
! A room appearance rule ( this is the default room appearance rule ):
[ R_1138 ;
    if (debug_rules) DB_Rule(R_1138, 1138);
    ! [2: rule succeeds with result true]
    RulebookSucceeds(TRUTH_STATE_TY,1); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out ExitStarting (B475_carry_out_exitstarting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out ExitStarting ( this is the standard Exit Starting rule ):
! ----------------------------------------------------------------------------------------------------
! From "Exit Lister" by Eric Eve
! No specific request
! Carry out ExitStarting ( this is the standard Exit Starting rule ):
[ R_1148 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1148, 1148);
    ! [2: now exit listing is enabled]
    (Global_Vars-->33) = I210_enabled;
    } else if (debug_rules > 1) DB_Rule(R_1148, 1148, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report ExitStarting (B476_report_exitstarting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report ExitStarting ( this is the report exit starting rule ):
! ----------------------------------------------------------------------------------------------------
! From "Exit Lister" by Eric Eve
! No specific request
! Report ExitStarting ( this is the report exit starting rule ):
[ R_1149 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1149, 1149);
    ! [2: say ~Exit listing is now on.~ ( a )]
    say__p=1;! [3: ~Exit listing is now on.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_436); new_line; .L_Say488; .L_SayX481;} else if (debug_rules > 1) DB_Rule(R_1149, 1149, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out ExitStopping (B478_carry_out_exitstopping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out ExitStopping ( this is the standard Exit Stopping rule ):
! ----------------------------------------------------------------------------------------------------
! From "Exit Lister" by Eric Eve
! No specific request
! Carry out ExitStopping ( this is the standard Exit Stopping rule ):
[ R_1146 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1146, 1146);
    ! [2: now exit listing is disabled]
    (Global_Vars-->33) = I211_disabled;
    } else if (debug_rules > 1) DB_Rule(R_1146, 1146, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report ExitStopping (B479_report_exitstopping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report ExitStopping ( this is the report exit stopping rule ):
! ----------------------------------------------------------------------------------------------------
! From "Exit Lister" by Eric Eve
! No specific request
! Report ExitStopping ( this is the report exit stopping rule ):
[ R_1147 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1147, 1147);
    ! [2: clear only the status line]
    VM_ClearScreen(1);
    ! [3: say ~Exit listing is now off.~ ( a )]
    say__p=1;! [4: ~Exit listing is now off.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_437); new_line; .L_Say489; .L_SayX482;} else if (debug_rules > 1) DB_Rule(R_1147, 1147, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out ExitListing (B481_carry_out_exitlisting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out ExitListing ( this is the standard carry out exit listing rule ):
! ----------------------------------------------------------------------------------------------------
! From "Exit Lister" by Eric Eve
! No specific request
! Carry out ExitListing ( this is the standard carry out exit listing rule ):
[ R_1150 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1150, 1150);
    ! [2: list the exits]
    (PHR_1151_r65 ());
    } else if (debug_rules > 1) DB_Rule(R_1150, 1150, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report ExitListing (B482_report_exitlisting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report ExitListing when listing explained is false ( this is the explain exit listing rule ):
! ----------------------------------------------------------------------------------------------------
! From "Exit Lister" by Eric Eve
! No specific request
! Report ExitListing when listing explained is false ( this is the explain exit listing rule ):
[ R_1158 ;
    if (actor == player) {
    if ((((((((Global_Vars-->36) && true) == (0 && true))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1158, 1158);
    ! [2: now listing explained is true]
    (Global_Vars-->36) = 1;
    ! [3: say ~(Use EXITS ON to enable the status line exit lister and EXITS OFF to turn it off.)~ ( a )]
    say__p=1;! [4: ~(Use EXITS ON to enable the status line exit lister and EXITS OFF to turn it off.)~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_438); new_line; .L_Say490; .L_SayX483;} else if (debug_rules > 1) DB_Rule(R_1158, 1158, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1158, 1158, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out exit colouring (B484_carry_out_exit_colourin)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out exit colouring ( this is the standard exit colouring rule ):
! ----------------------------------------------------------------------------------------------------
! From "Exit Lister" by Eric Eve
! No specific request
! Carry out exit colouring ( this is the standard exit colouring rule ):
[ R_1162 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1162, 1162);
    ! [2: now indicate-unvisited is the visiting-mark after indicate-unvisited]
    (Global_Vars-->34) = A_E88((Global_Vars-->34));
    } else if (debug_rules > 1) DB_Rule(R_1162, 1162, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out exit symboling (B487_carry_out_exit_symbolin)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out exit symboling ( this is the standard exit symboling rule ):
! ----------------------------------------------------------------------------------------------------
! From "Exit Lister" by Eric Eve
! No specific request
! Carry out exit symboling ( this is the standard exit symboling rule ):
[ R_1160 
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1160, 1160);
    ! [2: increase exit-symbol-num by 1]
    (Global_Vars-->38) = (Global_Vars-->38) + 1;;
    ! [3: if exit-symbol-num > the number of rows in the table of exit symbols]
    if ((((Global_Vars-->38) > TableRows(T14_exit_symbols))))
    {! [4: now exit-symbol-num is 1]
        (Global_Vars-->38) = 1;
        }
    ! [5: choose row exit-symbol-num in the table of exit symbols]
    ct_0 = T14_exit_symbols; ct_1 = (Global_Vars-->38);
    ! [6: now exit-marker is the exit-symbol entry]
    BlkValueCopy((Global_Vars-->39), TableLookUpEntry(ct_0,146,ct_1));
    } else if (debug_rules > 1) DB_Rule(R_1160, 1160, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report exit symboling (B488_report_exit_symboling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report exit symboling:
! ----------------------------------------------------------------------------------------------------
! From "Exit Lister" by Eric Eve
! No specific request
! Report exit symboling:
[ R_1161 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1161, 1161);
    ! [2: say ~Done.~]
    say__p=1;! [3: ~Done.~]
    ParaContent(); print "Done."; new_line; .L_Say491; .L_SayX484;} else if (debug_rules > 1) DB_Rule(R_1161, 1161, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the options paragraph (B490_for_printing_the_option)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! The first for printing the options paragraph rule:
! --- now the mid-placed rules ---
! Rule 2/4 ! For printing the options paragraph:
!   === equally specific with ===
! Rule 3/4 ! For printing the options paragraph:
! --- now the last-placed rules ---
! Rule 4/4 ! The last for printing the options paragraph rule:
! ----------------------------------------------------------------------------------------------------
! From "Options Paragraph" by Philip Riley
! No specific request
! The first for printing the options paragraph rule:
[ R_1167 ;
    if (debug_rules) DB_Rule(R_1167, 1167);
    ! [2: now options printed is false]
    (Global_Vars-->40) = 0;
    ! [3: now the last person referenced is nothing]
    (Global_Vars-->10) = nothing;
    rfalse;
];
! From "Choices" by Philip Riley
! No specific request
! For printing the options paragraph:
[ R_1178 ;
    if (debug_rules) DB_Rule(R_1178, 1178);
    ! [2: carry out the listing the available choices activity]
    CarryOutActivity(V46_listing_the_available_ch);
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! For printing the options paragraph:
[ R_1231 ;
    if (debug_rules) DB_Rule(R_1231, 1231);
    ! [2: carry out the listing the available quips activity]
    CarryOutActivity(V49_listing_the_available_qu);
    rfalse;
];
! From "Options Paragraph" by Philip Riley
! No specific request
! The last for printing the options paragraph rule:
[ R_1168 ;
    if (debug_rules) DB_Rule(R_1168, 1168);
    ! [2: if options printed is true]
    if (((((Global_Vars-->40) && true) == (1 && true))))
    {! [3: say paragraph break]
        say__p=1;! [4: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line; .L_Say492; .L_SayX485;}
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Choosing (B492_check_choosing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check choosing:
! ----------------------------------------------------------------------------------------------------
! From "Choices" by Philip Riley
! No specific request
! Check choosing:
[ R_1171 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(1);
    BlkValueCreateOnStack(0, KD11_list_of_objects);
    I7RBLK = KERNEL_59();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_59 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1171, 1171);
    ! [2: if the noun is not listed in total choices]
    if (((LIST_OF_TY_FindItem((PHR_1175_r66 (I7SFRAME)), noun) == false)))
    {! [3: say ~That is not a valid choice right now.~]
        say__p=1;! [4: ~That is not a valid choice right now.~]
        ParaContent(); print "That is not a valid choice right now."; new_line; .L_Say493; .L_SayX486;rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_1171, 1171, 'actor');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Listing the available choices (B496_for_listing_the_availab)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! For listing the available choices:
! ----------------------------------------------------------------------------------------------------
! From "Choices" by Philip Riley
! No specific request
! For listing the available choices:
[ R_1177 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(3);
    BlkValueCreateOnStack(2, KD11_list_of_objects);
    BlkValueCreateOnStack(1, KD11_list_of_objects);
    BlkValueCreateOnStack(0, KD11_list_of_objects);
    I7RBLK = KERNEL_60();
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(1);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_60 
    tmp_0 ! Let/loop value, e.g., 'something said': truth state
    tmp_1 ! Let/loop value, e.g., 'Q': list of objects
    ;
    if (debug_rules) DB_Rule(R_1177, 1177);
    ! [2: let something said be false]

    		tmp_0 = 0;
    ! [3: let q be the total choices]
    tmp_1 = I7SFRAME; 
    		BlkValueCopy(tmp_1, (PHR_1175_r66 ((I7SFRAME+WORDSIZE))));
    ! [4: prepare the list of q]
    (PHR_1228_r67 (BlkValueCopy((I7SFRAME+WORDSIZE*2), tmp_1)));
    ! [5: if q is non-empty]
    if ((((~~Adj_17_t1_v34(tmp_1)))))
    {! [6: say ~[italic type][We] [can] [the prepared list delimited in the disjunctive style].[roman type]~]
        say__p=1;! [7: italic type]
        ParaContent(); (PHR_353_r9 ());! [8: we]
        ParaContent(); (PHR_764_r7 ());! [9: ~ ~]
        ParaContent(); print " ";! [10: can]
        ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [11: ~ ~]
        ParaContent(); print " ";! [12: the prepared list delimited in the disjunctive style]
        ParaContent(); (PHR_1124_r68 (I201_disjunctive));! [13: ~.~]
        ParaContent(); print ".";! [14: roman type]
        ParaContent(); (PHR_354_r3 ()); .L_Say494; .L_SayX487;! [15: now something said is true]
        tmp_0 = 1;
        }
    ! [16: if something said is true]
    if ((((tmp_0 && true) == (1 && true))))
    {! [17: now options printed is true]
        (Global_Vars-->40) = 1;
        }
        RulebookSucceeds(); rtrue;
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Looking behind (B498_check_looking_behind)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check looking behind something when nothing is behind the noun and the behind description of the noun is ~~:
! ----------------------------------------------------------------------------------------------------
! From "Basics" by Philip Riley
! No specific request
! Check looking behind something when nothing is behind the noun and the behind description of the noun is ~~:
[ R_1183 ;
    if ((( (actor==player) && ((noun ofclass K2_thing)) && (self=actor,true) && (((((Prop_90())))) && ((( BlkValueCompare(GProperty(OBJECT_TY, noun,p25_behind_description), EMPTY_TEXT_VALUE) == 0))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1183, 1183);
    ! [2: if the noun is the player]
    if (((noun == player)))
    {! [3: say ~[We] [look], but there is nothing behind [us].~]
        say__p=1;! [4: we]
        ParaContent(); (PHR_764_r7 ());! [5: ~ ~]
        ParaContent(); print " ";! [6: look]
        ConjugateVerb_43(CV_POS, PNToVP(), story_tense); say__p=1; ! [7: ~, but there is nothing behind ~]
        ParaContent(); print ", but there is nothing behind ";! [8: us]
        ParaContent(); (PHR_760_r49 ());! [9: ~.~]
        ParaContent(); print "."; new_line; .L_Say495; .L_SayX488;rtrue;
        }
    ! [11: say ~[We] [look], but there is nothing behind [the noun].~]
    say__p=1;! [12: we]
    ParaContent(); (PHR_764_r7 ());! [13: ~ ~]
    ParaContent(); print " ";! [14: look]
    ConjugateVerb_43(CV_POS, PNToVP(), story_tense); say__p=1; ! [15: ~, but there is nothing behind ~]
    ParaContent(); print ", but there is nothing behind ";! [16: the noun]
    ParaContent(); print (the) noun;! [17: ~.~]
    ParaContent(); print "."; new_line; .L_Say496; .L_SayX489;rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1183, 1183, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Looking behind (B499_carry_out_looking_behin)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out looking behind something:
! ----------------------------------------------------------------------------------------------------
! From "Basics" by Philip Riley
! No specific request
! Carry out looking behind something:
[ R_1184 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((( (actor==player) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1184, 1184);
    ! [2: repeat with x running through the thing behind the noun]
    for (tmp_0=Prop_91(0), tmp_1=Prop_91(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_91(tmp_1))
    {! [3: if x is not scenery]
        if (((~~(((Adj_88_t1_v10(tmp_0)))))))
        {! [4: now x is not behind the noun]
            (RGuard_MF_10(tmp_0,noun));
            ! [5: now x is in the location]
            MoveObject(tmp_0,real_location);
            ! [6: add x to hidden]
            LIST_OF_TY_InsertItem((MStack-->MstVO(20099,0)), tmp_0, 0, 0, 0);
            }
            }
            } else if (debug_rules > 1) DB_Rule(R_1184, 1184, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Looking behind (B500_report_looking_behind)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report looking behind something when the behind description of the noun is not ~~:
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Report looking behind something:
! ----------------------------------------------------------------------------------------------------
! From "Basics" by Philip Riley
! No specific request
! Report looking behind something when the behind description of the noun is not ~~:
[ R_1185 ;
    if ((( (actor==player) && ((noun ofclass K2_thing)) && (self=actor,true) && (((~~(( BlkValueCompare(GProperty(OBJECT_TY, noun,p25_behind_description), EMPTY_TEXT_VALUE) == 0)))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1185, 1185);
    ! [2: say ~[behind description of the noun][line break]~]
    say__p=1;! [3: behind description of the noun]
    ParaContent(); @push self; print (TEXT_TY_Say) GProperty(OBJECT_TY, self=noun,p25_behind_description);@pull self; ! [4: line break]
    ParaContent(); new_line; .L_Say497; .L_SayX490;} else if (debug_rules > 1) DB_Rule(R_1185, 1185, 'action');
    rfalse;
];
! From "Basics" by Philip Riley
! No specific request
! Report looking behind something:
[ R_1186 ;
    if ((( (actor==player) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1186, 1186);
    ! [2: if hidden is not empty]
    if (((~~(((Adj_17_t1_v34((MStack-->MstVO(20099,0)))))))))
    {! [3: say ~[We] [find] [hidden with indefinite articles] and [regarding the player][pull] [regarding the number of entries in hidden][them] out.~]
        say__p=1;! [4: we]
        ParaContent(); (PHR_764_r7 ());! [5: ~ ~]
        ParaContent(); print " ";! [6: find]
        ConjugateVerb_31(CV_POS, PNToVP(), story_tense); say__p=1; ! [7: ~ ~]
        ParaContent(); print " ";! [8: hidden with indefinite articles]
        ParaContent(); LIST_OF_TY_Say((MStack-->MstVO(20099,0)), 3);! [9: ~ and ~]
        ParaContent(); print " and ";! [10: regarding the player]
        ParaContent(); RegardingSingleObject(player);! [11: pull]
        ConjugateVerb_49(CV_POS, PNToVP(), story_tense); say__p=1; ! [12: ~ ~]
        ParaContent(); print " ";! [13: regarding the number of entries in hidden]
        ParaContent(); RegardingNumber(LIST_OF_TY_GetLength((MStack-->MstVO(20099,0))));! [14: them]
        ParaContent(); (PHR_779_r69 ());! [15: ~ out.~]
        ParaContent(); print " out."; new_line; .L_Say498; .L_SayX491;}
        } else if (debug_rules > 1) DB_Rule(R_1186, 1186, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check printing memories (B501_check_printing_memories)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check printing memories:
! ----------------------------------------------------------------------------------------------------
! From "Memories" by Philip Riley
! No specific request
! Check printing memories:
[ R_1191 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1191, 1191);
    ! [2: if remembrances of the player is empty]
    if ((((Adj_17_t1_v34(GProperty(10, player,p26_remembrances))))))
    {! [3: say ~[We] [don't] have anything to remember yet.~]
        say__p=1;! [4: we]
        ParaContent(); (PHR_764_r7 ());! [5: ~ ~]
        ParaContent(); print " ";! [6: don't]
        ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ! [7: ~ have anything to remember yet.~]
        ParaContent(); print " have anything to remember yet."; new_line; .L_Say499; .L_SayX492;rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_1191, 1191, 'actor');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report printing memories (B503_report_printing_memorie)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report printing memories:
! ----------------------------------------------------------------------------------------------------
! From "Memories" by Philip Riley
! No specific request
! Report printing memories:
[ R_1192 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1192, 1192);
    ! [2: say ~[italic type][We] can remember [remembrances of the player].[roman type][line break]~]
    say__p=1;! [3: italic type]
    ParaContent(); (PHR_353_r9 ());! [4: we]
    ParaContent(); (PHR_764_r7 ());! [5: ~ can remember ~]
    ParaContent(); print " can remember ";! [6: remembrances of the player]
    ParaContent(); @push self; LIST_OF_TY_Say(GProperty(10, self=player,p26_remembrances));@pull self; ! [7: ~.~]
    ParaContent(); print ".";! [8: roman type]
    ParaContent(); (PHR_354_r3 ());! [9: line break]
    ParaContent(); new_line; .L_Say500; .L_SayX493;} else if (debug_rules > 1) DB_Rule(R_1192, 1192, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report remembering (B506_report_remembering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! report remembering a memory:
! ----------------------------------------------------------------------------------------------------
! From "Memories" by Philip Riley
! No specific request
! report remembering a memory:
[ R_1194 ;
    if ((( (actor==player) && ((noun ofclass K28_memory))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1194, 1194);
    ! [2: say ~[italic type][description of the noun][roman type][line break]~]
    say__p=1;! [3: italic type]
    ParaContent(); (PHR_353_r9 ());! [4: description of the noun]
    ParaContent(); @push self; print (TEXT_TY_Say) GProperty(OBJECT_TY, self=noun,description);@pull self; ! [5: roman type]
    ParaContent(); (PHR_354_r3 ());! [6: line break]
    ParaContent(); new_line; .L_Say501; .L_SayX494;} else if (debug_rules > 1) DB_Rule(R_1194, 1194, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Discussing it with (B507_check_discussing_it_wit)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check discussing something with someone:
! ----------------------------------------------------------------------------------------------------
! From "Simple Conversation" by Philip Riley
! No specific request
! Check discussing something with someone:
[ R_1202 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    I7RBLK = KERNEL_61();
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_61 ;
    if ((( (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1202, 1202);
    ! [2: if the current interlocutor is not the second noun]
    if (((~~(((Global_Vars-->11) == second)))))
    {! [3: implicitly greet the second noun]

        ! Resolution of run-time phrase ambiguity (to phrase):
            formal_par0 = second;
            if (((((formal_par0 ofclass K2_thing) && (formal_par0 ofclass K2_thing))))) { (PHR_819_r12 (formal_par0)); }
            else ArgumentTypeFailed(104, 26);

        ! Resolution complete

        }
    ! [4: try discussing the noun]
    TryAction(0, player, ##A103_discussing, noun, 0);
    } else if (debug_rules > 1) DB_Rule(R_1202, 1202, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Discussing (B510_check_discussing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check discussing something ( this is the block exhausted one-shot quips rule ):
!   === equally specific with ===
! Rule 2/2 ! Check discussing something:
! ----------------------------------------------------------------------------------------------------
! From "Simple Conversation" by Philip Riley
! No specific request
! Check discussing something ( this is the block exhausted one-shot quips rule ):
[ R_1203 ;
    if ((( (actor==player) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1203, 1203);
    ! [2: if the noun is exhausted and the noun is one-shot]
    if (((((Adj_147_t1_v10(noun))))) && ((((Adj_149_t1_v10(noun))))))
    {! [3: say ~That is not a topic of conversation at the moment.~]
        say__p=1;! [4: ~That is not a topic of conversation at the moment.~]
        ParaContent(); print "That is not a topic of conversation at the moment."; new_line; .L_Say502; .L_SayX495;rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_1203, 1203, 'action');
        rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! Check discussing something:
[ R_1204 ;
    if ((( (actor==player) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1204, 1204);
    ! [2: if the current interlocutor is nothing]
    if ((((Global_Vars-->11) == nothing)))
    {! [3: say ~[We] [aren't] talking to anyone right now.~]
        say__p=1;! [4: we]
        ParaContent(); (PHR_764_r7 ());! [5: ~ ~]
        ParaContent(); print " ";! [6: aren't]
        ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [7: ~ talking to anyone right now.~]
        ParaContent(); print " talking to anyone right now."; new_line; .L_Say503; .L_SayX496;rtrue;
        }
    ! [9: if the noun is not q-available]
    if (((~~(((Adj_64_t1_v10(noun)))))))
    {! [10: say ~That is not a topic of conversation at the moment.~]
        say__p=1;! [11: ~That is not a topic of conversation at the moment.~]
        ParaContent(); print "That is not a topic of conversation at the moment."; new_line; .L_Say504; .L_SayX497;rtrue;
        }
        } else if (debug_rules > 1) DB_Rule(R_1204, 1204, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Discussing (B511_carry_out_discussing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out discussing something:
! ----------------------------------------------------------------------------------------------------
! From "Simple Conversation" by Philip Riley
! No specific request
! Carry out discussing something:
[ R_1205 ;
    if ((( (actor==player) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1205, 1205);
    ! [2: now the latest quip is the noun]
    (Global_Vars-->44) = noun; if (~~((Global_Vars-->44) ofclass K29_quip)) RunTimeProblem(RTP_WRONGASSIGNEDKIND, (Global_Vars-->44), "now the latest quip is the noun", "quip");;
    ! [3: if the latest quip is one-shot]
    if ((((Adj_149_t1_v10((Global_Vars-->44))))))
    {! [4: now the latest quip is exhausted]
        (Adj_147_t2_v10((Global_Vars-->44)));
        }
    ! [5: if the latest quip is listed in the queue of the current interlocutor]
    if (((LIST_OF_TY_FindItem(GProperty(OBJECT_TY, (Global_Vars-->11),p29_queue), (Global_Vars-->44)))))
    {! [6: remove the latest quip from the queue of the current interlocutor]
        LIST_OF_TY_RemoveValue(GProperty(OBJECT_TY, (Global_Vars-->11),p29_queue), (Global_Vars-->44), 0);
        }
    ! [7: say ~[comment of the noun][paragraph break][reply of the noun][paragraph break]~]
    say__p=1;! [8: comment of the noun]
    ParaContent(); @push self; print (TEXT_TY_Say) GProperty(OBJECT_TY, self=noun,p27_comment);@pull self; ! [9: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [10: reply of the noun]
    ParaContent(); @push self; print (TEXT_TY_Say) GProperty(OBJECT_TY, self=noun,p28_reply);@pull self; ! [11: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say505; .L_SayX498;} else if (debug_rules > 1) DB_Rule(R_1205, 1205, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Queueing quips following (B514_for_queueing_quips_foll)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! For queueing quips following a quip ( called Q ):
! ----------------------------------------------------------------------------------------------------
! From "Simple Conversation" by Philip Riley
! No specific request
! For queueing quips following a quip ( called Q ):
[ R_1207 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(1, KD1_list_of_quips);
    BlkValueCreateOnStack(0, KD1_list_of_quips);
    I7RBLK = KERNEL_62();
    BlkValueFreeOnStack(1);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_62 
    tmp_0 ! Let/loop value, e.g., 'Q': quip
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K29_quip) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1207, 1207);
    ! [2: if the current interlocutor is a person]
    if ((((Global_Vars-->11) ofclass K8_person)))
    {! [3: let new quips be a list of quips]
        tmp_1 = I7SFRAME; 
        		
        ! [4: add the list of quips that follow q to new quips]
        LIST_OF_TY_AppendList(tmp_1, (Prop_92(tmp_0,(I7SFRAME+WORDSIZE),10)), 0, 0, 0);
        ! [5: if q is repeatable]
        if ((((Adj_150_t1_v10(tmp_0)))))
        {! [6: add q to new quips]
            LIST_OF_TY_InsertItem(tmp_1, tmp_0, 0, 0, 0);
            }
        ! [7: add new quips to the queue of the current interlocutor]
        LIST_OF_TY_AppendList(GProperty(OBJECT_TY, (Global_Vars-->11),p29_queue), tmp_1, 0, 0, 0);
        }
        RulebookSucceeds(); rtrue;
        } else if (debug_rules > 1) DB_Rule(R_1207, 1207, 'action');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Ruling out quips following (B517_for_ruling_out_quips_fo)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! For ruling out quips following a quip ( called Q ):
! ----------------------------------------------------------------------------------------------------
! From "Simple Conversation" by Philip Riley
! No specific request
! For ruling out quips following a quip ( called Q ):
[ R_1211 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(1, KD1_list_of_quips);
    BlkValueCreateOnStack(0, KD1_list_of_quips);
    I7RBLK = KERNEL_63();
    BlkValueFreeOnStack(1);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_63 
    tmp_0 ! Let/loop value, e.g., 'Q': quip
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    tmp_4 ! Let/loop value: number
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K29_quip) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1211, 1211);
    ! [2: if the current interlocutor is a person]
    if ((((Global_Vars-->11) ofclass K8_person)))
    {! [3: let dead quips be a list of quips]
        tmp_1 = I7SFRAME; 
        		
        ! [4: add the list of quips that are ruled out by q to dead quips]
        LIST_OF_TY_AppendList(tmp_1, (Prop_93(tmp_0,(I7SFRAME+WORDSIZE),10)), 0, 0, 0);
        ! [5: remove dead quips from the queue of the current interlocutor]
        LIST_OF_TY_Remove_List(GProperty(OBJECT_TY, (Global_Vars-->11),p29_queue), tmp_1, 0);
        ! [6: repeat with q2 running through dead quips]
        for (tmp_4=tmp_1, tmp_3=1, tmp_2=LIST_OF_TY_GetItem(tmp_4, tmp_3, true): tmp_3<=LIST_OF_TY_GetLength(tmp_4): tmp_3++, tmp_2=LIST_OF_TY_GetItem(tmp_4, tmp_3, true))
        {! [7: now q2 is exhausted]
            (Adj_147_t2_v10(tmp_2));
            }
            }
            RulebookSucceeds(); rtrue;
            } else if (debug_rules > 1) DB_Rule(R_1211, 1211, 'action');
            rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: availability (B519_availability)
! ----------------------------------------------------------------------------------------------------
! Rule 1/16 ! An availability rule for a quip ( called Q ) when Q is not universal and the current interlocutor is something and Q does not quip-supply the current interlocutor ( this is the can't talk to the wrong person rule ):
!   >>> III - When/while requirement >>>
! Rule 2/16 ! An availability rule for a quip ( called Q ) when the current interlocutor is something and Q is listed in the queue of the current interlocutor ( this is the queued quip rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 3/16 ! An availability rule for no-thumb-drive:
!   === equally specific with ===
! Rule 4/16 ! An availability rule for yes-thumb-drive:
!   === equally specific with ===
! Rule 5/16 ! An availability rule for hand over the thumb drive:
!   === equally specific with ===
! Rule 6/16 ! An availability rule for for-a-screwdriver-pawn:
!   === equally specific with ===
! Rule 7/16 ! An availability rule for for-a-screwdriver-clerk:
!   === equally specific with ===
! Rule 8/16 ! An availability rule for about the whereabouts of the desk key:
!   === equally specific with ===
! Rule 9/16 ! An availability rule for about the status of the computer:
!   === equally specific with ===
! Rule 10/16 ! An availability rule for for the wrench:
!   === equally specific with ===
! Rule 11/16 ! An availability rule for for-a-screwdriver:
!   === equally specific with ===
! Rule 12/16 ! An availability rule for to unlock the backdoor:
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 13/16 ! An availability rule for an exhausted quip ( this is the exhausted quip availability rule ):
!   === equally specific with ===
! Rule 14/16 ! An availability rule for a universal quip ( this is the universal availability rule ):
!   === equally specific with ===
! Rule 15/16 ! An availability rule for an always-available quip ( this is the always-available rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 16/16 ! An availability rule for a quip ( called Q ) ( this is the basic availability rule ):
! ----------------------------------------------------------------------------------------------------
! From "Simple Conversation" by Philip Riley
! No specific request
! An availability rule for a quip ( called Q ) when Q is not universal and the current interlocutor is something and Q does not quip-supply the current interlocutor ( this is the can't talk to the wrong person rule ):
[ R_1219 
    tmp_0 ! Let/loop value, e.g., 'Q': quip
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K29_quip) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (((((((~~(((Adj_157_t1_v10(tmp_0))))))) && (((((Global_Vars-->11) ofclass K2_thing))) && (((~~(((RGuard_T_11(tmp_0,(Global_Vars-->11))))))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1219, 1219);
    ! [2: never available]
    RulebookFails(22, RBNO_24); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1219, 1219, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1219, 1219, 'action');
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! An availability rule for a quip ( called Q ) when the current interlocutor is something and Q is listed in the queue of the current interlocutor ( this is the queued quip rule ):
[ R_1221 
    tmp_0 ! Let/loop value, e.g., 'Q': quip
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K29_quip) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if ((((((((Global_Vars-->11) ofclass K2_thing))) && (((LIST_OF_TY_FindItem(GProperty(OBJECT_TY, (Global_Vars-->11),p29_queue), tmp_0)))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1221, 1221);
    ! [2: always available]
    RulebookSucceeds(22, RBNO_21); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1221, 1221, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1221, 1221, 'action');
    rfalse;
];
! From "Hyperspace" by Philip Riley
! No specific request
! An availability rule for no-thumb-drive:
[ R_1260 ;
    if (((((parameter_value == I258_no_thumb_drive) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1260, 1260);
    ! [2: if the player does not carry the thumb drive]
    if (((~~((player == CarrierOf(I259_thumb_drive))))))
    {! [3: always available]
        RulebookSucceeds(22, RBNO_21); rtrue;

        }
        } else if (debug_rules > 1) DB_Rule(R_1260, 1260, 'action');
        rfalse;
];
! From "Hyperspace" by Philip Riley
! No specific request
! An availability rule for yes-thumb-drive:
[ R_1261 ;
    if (((((parameter_value == I260_yes_thumb_drive) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1261, 1261);
    ! [2: if the player carries the thumb drive]
    if (((player == CarrierOf(I259_thumb_drive))))
    {! [3: always available]
        RulebookSucceeds(22, RBNO_21); rtrue;

        }
        } else if (debug_rules > 1) DB_Rule(R_1261, 1261, 'action');
        rfalse;
];
! From "Hyperspace" by Philip Riley
! No specific request
! An availability rule for hand over the thumb drive:
[ R_1263 ;
    if (((((parameter_value == I261_hand_over_the_thumb_dri) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1263, 1263);
    ! [2: if the player carries the thumb drive]
    if (((player == CarrierOf(I259_thumb_drive))))
    {! [3: always available]
        RulebookSucceeds(22, RBNO_21); rtrue;

        }
        } else if (debug_rules > 1) DB_Rule(R_1263, 1263, 'action');
        rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! An availability rule for for-a-screwdriver-pawn:
[ R_1405 ;
    if (((((parameter_value == I321_for_a_screwdriver_pawn) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1405, 1405);
    ! [2: if the player knows vent-screws and the screwdriver is not seen]
    if (((((RGuard_T_2(player,I163_vent_screws))))) && (((~~(((Adj_116_t1_v10(I322_screwdriver))))))))
    {! [3: always available]
        RulebookSucceeds(22, RBNO_21); rtrue;

        }
        } else if (debug_rules > 1) DB_Rule(R_1405, 1405, 'action');
        rfalse;
];
! From "Swamp Park" by Philip Riley
! No specific request
! An availability rule for for-a-screwdriver-clerk:
[ R_1418 ;
    if (((((parameter_value == I354_for_a_screwdriver_clerk) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1418, 1418);
    ! [2: if the player knows vent-screws and the screwdriver is not seen]
    if (((((RGuard_T_2(player,I163_vent_screws))))) && (((~~(((Adj_116_t1_v10(I322_screwdriver))))))))
    {! [3: always available]
        RulebookSucceeds(22, RBNO_21); rtrue;

        }
        } else if (debug_rules > 1) DB_Rule(R_1418, 1418, 'action');
        rfalse;
];
! From "Margaret" by Philip Riley
! No specific request
! An availability rule for about the whereabouts of the desk key:
[ R_1424 ;
    if (((((parameter_value == I359_about_the_whereabouts_o) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1424, 1424);
    ! [2: if the player knows desk-locked and the player does not know key-is-lost]
    if (((((RGuard_T_2(player,I164_desk_locked))))) && (((~~(((RGuard_T_2(player,I167_key_is_lost))))))))
    {! [3: always available]
        RulebookSucceeds(22, RBNO_21); rtrue;

        }
        } else if (debug_rules > 1) DB_Rule(R_1424, 1424, 'action');
        rfalse;
];
! From "Margaret" by Philip Riley
! No specific request
! An availability rule for about the status of the computer:
[ R_1426 ;
    if (((((parameter_value == I361_about_the_status_of_the) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1426, 1426);
    ! [2: if biff's computer is seen]
    if ((((Adj_116_t1_v10(I362_biff_s_computer)))))
    {! [3: never available]
        RulebookFails(22, RBNO_24); rtrue;

        }
    ! [4: if biff's office is visited]
    if ((((Adj_80_t1_v10(I429_biff_s_office)))))
    {! [5: always available]
        RulebookSucceeds(22, RBNO_21); rtrue;

        }
        } else if (debug_rules > 1) DB_Rule(R_1426, 1426, 'action');
        rfalse;
];
! From "Margaret" by Philip Riley
! No specific request
! An availability rule for for the wrench:
[ R_1427 ;
    if (((((parameter_value == I363_for_the_wrench) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1427, 1427);
    ! [2: if the player knows key-is-lost and player knows hex-screws]
    if (((((RGuard_T_2(player,I167_key_is_lost))))) && ((((RGuard_T_2(player,I169_hex_screws))))))
    {! [3: always available]
        RulebookSucceeds(22, RBNO_21); rtrue;

        }
        } else if (debug_rules > 1) DB_Rule(R_1427, 1427, 'action');
        rfalse;
];
! From "Margaret" by Philip Riley
! No specific request
! An availability rule for for-a-screwdriver:
[ R_1428 ;
    if (((((parameter_value == I365_for_a_screwdriver) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1428, 1428);
    ! [2: if the player knows vent-screws and the screwdriver is not seen]
    if (((((RGuard_T_2(player,I163_vent_screws))))) && (((~~(((Adj_116_t1_v10(I322_screwdriver))))))))
    {! [3: always available]
        RulebookSucceeds(22, RBNO_21); rtrue;

        }
        } else if (debug_rules > 1) DB_Rule(R_1428, 1428, 'action');
        rfalse;
];
! From "Margaret" by Philip Riley
! No specific request
! An availability rule for to unlock the backdoor:
[ R_1429 ;
    if (((((parameter_value == I366_to_unlock_the_backdoor) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1429, 1429);
    ! [2: if the player knows back-door-is-locked]
    if ((((RGuard_T_2(player,I171_back_door_is_locked)))))
    {! [3: always available]
        RulebookSucceeds(22, RBNO_21); rtrue;

        }
        } else if (debug_rules > 1) DB_Rule(R_1429, 1429, 'action');
        rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! An availability rule for an exhausted quip ( this is the exhausted quip availability rule ):
[ R_1217 ;
    if (((((parameter_value ofclass K29_quip) && ((Adj_147_t1_v10(parameter_value))))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1217, 1217);
    ! [2: never available]
    RulebookFails(22, RBNO_24); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1217, 1217, 'action');
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! An availability rule for a universal quip ( this is the universal availability rule ):
[ R_1218 ;
    if (((((parameter_value ofclass K29_quip) && ((Adj_157_t1_v10(parameter_value))))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1218, 1218);
    ! [2: always available]
    RulebookSucceeds(22, RBNO_21); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1218, 1218, 'action');
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! An availability rule for an always-available quip ( this is the always-available rule ):
[ R_1220 ;
    if (((((parameter_value ofclass K29_quip) && ((Adj_158_t1_v10(parameter_value))))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1220, 1220);
    ! [2: always available]
    RulebookSucceeds(22, RBNO_21); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1220, 1220, 'action');
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! An availability rule for a quip ( called Q ) ( this is the basic availability rule ):
[ R_1222 
    tmp_0 ! Let/loop value, e.g., 'Q': quip
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K29_quip) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1222, 1222);
    ! [2: never available]
    RulebookFails(22, RBNO_24); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1222, 1222, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: plausibility (B520_plausibility)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! A plausibility rule for how-are-you:
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 2/4 ! A plausibility rule for an ignored quip ( called Q ) ( this is the ignoreability rule ):
!   === equally specific with ===
! Rule 3/4 ! A plausibility rule for a ubiquitous quip ( this is the ubiquity rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 4/4 ! A plausibility rule ( this is the basic plausibility rule ):
! ----------------------------------------------------------------------------------------------------
! From "Conversations General" by Philip Riley
! No specific request
! A plausibility rule for how-are-you:
[ R_1421 ;
    if (((((parameter_value == I355_how_are_you) && (true))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1421, 1421);
    ! [2: it is implausible]
    RulebookFails(22, RBNO_27); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1421, 1421, 'action');
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! A plausibility rule for an ignored quip ( called Q ) ( this is the ignoreability rule ):
[ R_1224 
    tmp_0 ! Let/loop value, e.g., 'Q': quip
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K29_quip) && ((Adj_155_t1_v10(parameter_value))) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1224, 1224);
    ! [2: it is implausible]
    RulebookFails(22, RBNO_27); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1224, 1224, 'action');
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! A plausibility rule for a ubiquitous quip ( this is the ubiquity rule ):
[ R_1225 ;
    if (((((parameter_value ofclass K29_quip) && ((Adj_154_t1_v10(parameter_value))))))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1225, 1225);
    ! [2: it is plausible]
    RulebookSucceeds(22, RBNO_25); rtrue;

    } else if (debug_rules > 1) DB_Rule(R_1225, 1225, 'action');
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! A plausibility rule ( this is the basic plausibility rule ):
[ R_1226 ;
    if (debug_rules) DB_Rule(R_1226, 1226);
    ! [2: it is plausible]
    RulebookSucceeds(22, RBNO_25); rtrue;

    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Listing the available quips (B522_for_listing_the_availab)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! For listing the available quips:
! ----------------------------------------------------------------------------------------------------
! From "Simple Conversation" by Philip Riley
! No specific request
! For listing the available quips:
[ R_1229 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(3);
    BlkValueCreateOnStack(2, KD1_list_of_quips);
    BlkValueCreateOnStack(1, KD1_list_of_quips);
    BlkValueCreateOnStack(0, KD1_list_of_quips);
    I7RBLK = KERNEL_64();
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(1);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_64 
    tmp_0 ! Let/loop value, e.g., 'X': list of quips
    ;
    if (debug_rules) DB_Rule(R_1229, 1229);
    ! [2: let x be the list of plausible q-available quips that are not exhausted]
    tmp_0 = I7SFRAME; 
    		BlkValueCopy(tmp_0, (Prop_94((I7SFRAME+WORDSIZE),10)));
    ! [3: prepare the list of x]
    (PHR_1228_r67 (BlkValueCopy((I7SFRAME+WORDSIZE*2), tmp_0)));
    ! [4: if x is non-empty]
    if ((((~~Adj_17_t1_v34(tmp_0)))))
    {! [5: say ~[italic type][We] [can] [the prepared list delimited in the disjunctive style].[roman type]~]
        say__p=1;! [6: italic type]
        ParaContent(); (PHR_353_r9 ());! [7: we]
        ParaContent(); (PHR_764_r7 ());! [8: ~ ~]
        ParaContent(); print " ";! [9: can]
        ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [10: ~ ~]
        ParaContent(); print " ";! [11: the prepared list delimited in the disjunctive style]
        ParaContent(); (PHR_1124_r68 (I201_disjunctive));! [12: ~.~]
        ParaContent(); print ".";! [13: roman type]
        ParaContent(); (PHR_354_r3 ()); .L_Say506; .L_SayX499;! [14: now options printed is true]
        (Global_Vars-->40) = 1;
        }
        RulebookSucceeds(); rtrue;
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report frumping (B526_report_frumping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! report frumping:
! ----------------------------------------------------------------------------------------------------
! From "Simple Conversation" by Philip Riley
! No specific request
! report frumping:
[ R_1234 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1234, 1234);
    ! [2: repeat with x running through visible things]
    for (tmp_0=Prop_95(0), tmp_1=Prop_95(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_95(tmp_1))
    {! [3: say ~?? [X].~]
        say__p=1;! [4: ~?? ~]
        ParaContent(); print "?? ";! [5: x]
        ParaContent(); PrintShortName(tmp_0);! [6: ~.~]
        ParaContent(); print "."; new_line; .L_Say507; .L_SayX500;}
        } else if (debug_rules > 1) DB_Rule(R_1234, 1234, 'actor');
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out helping about hyperspace (B528_carry_out_helping_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out helping about hyperspace:
! ----------------------------------------------------------------------------------------------------
! From "Hyperspace" by Philip Riley
! No specific request
! Carry out helping about hyperspace:
[ R_1266 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1266, 1266);
    ! [2: say ~Hyperspace is a four-dimensional plane of being overlaying our own three-dimensional plane. The familiar directions (north, south, up, northeast, etc.) work there, as do two new directions 'back' and 'forth', and their combinations with our compass directions: forthnorth, backeast, etc. These can be abbreviated just as compass directions can: b, f, fn, be, and so on.~]
    say__p=1;! [3: ~Hyperspace is a four-dimensional plane of being overlaying our own three-dimensional plane. The familiar directions (north, south, up, northeast, etc.) work there, as do two new directions 'back' and 'forth', and their combinations with our compass directions: forthnorth, backeast, etc. These can be abbreviated just as compass directions can: b, f, fn, be, and so on.~]
    ParaContent(); print "Hyperspace is a four-dimensional plane of being overlaying our own three-dimensional plane. The familiar directions (north, south, up, northeast, etc.) work there, as do two new directions ~back~ and ~forth~, and their combinations with our compass directions: forthnorth, backeast, etc. These can be abbreviated just as compass directions can: b, f, fn, be, and so on."; new_line; .L_Say508; .L_SayX501;} else if (debug_rules > 1) DB_Rule(R_1266, 1266, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: glulx redrawing (B531_glulx_redrawing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! A glulx redrawing rule ( this is the default redrawing behavior rule ):
! ----------------------------------------------------------------------------------------------------
! From "Image Strip" by Philip Riley
! No specific request
! A glulx redrawing rule ( this is the default redrawing behavior rule ):
[ R_1325 ;
    if (debug_rules) DB_Rule(R_1325, 1325);
    ! [2: if glulx graphics is supported]
    if ((( glk_gestalt(gestalt_Graphics, 0) )))
    {! [3: follow the current graphics drawing rule]
        FollowRulebook((Global_Vars-->70));
        }
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: glulx arranging (B532_glulx_arranging)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! A glulx arranging rule ( this is the default arranging behavior rule ):
! ----------------------------------------------------------------------------------------------------
! From "Image Strip" by Philip Riley
! No specific request
! A glulx arranging rule ( this is the default arranging behavior rule ):
[ R_1324 ;
    if (debug_rules) DB_Rule(R_1324, 1324);
    ! [2: if glulx graphics is supported]
    if ((( glk_gestalt(gestalt_Graphics, 0) )))
    {! [3: follow the current graphics drawing rule]
        FollowRulebook((Global_Vars-->70));
        }
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: glulx zeroing-reference (B538_glulx_zeroing_reference)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! A glulx zeroing-reference rule ( this is the default removing reference to picwin rule ):
!   === equally specific with ===
! Rule 2/2 ! A glulx zeroing-reference rule ( this is the default removing reference to hidewin rule ):
! ----------------------------------------------------------------------------------------------------
! From "Image Strip" by Philip Riley
! No specific request
! A glulx zeroing-reference rule ( this is the default removing reference to picwin rule ):
[ R_1316 ;
    if (debug_rules) DB_Rule(R_1316, 1316);
    ! [2: zero picwin]
    gg_picwin = 0;
    rfalse;
];
! From "Image Strip" by Philip Riley
! No specific request
! A glulx zeroing-reference rule ( this is the default removing reference to hidewin rule ):
[ R_1320 ;
    if (debug_rules) DB_Rule(R_1320, 1320);
    ! [2: zero hidewin]
    gg_hidewin = 0;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: glulx resetting-windows (B539_glulx_resetting_windows)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! A glulx resetting-windows rule ( this is the default choosing picwin rule ):
!   === equally specific with ===
! Rule 2/2 ! A glulx resetting-windows rule ( this is the default choosing hidewin rule ):
! ----------------------------------------------------------------------------------------------------
! From "Image Strip" by Philip Riley
! No specific request
! A glulx resetting-windows rule ( this is the default choosing picwin rule ):
[ R_1318 ;
    if (debug_rules) DB_Rule(R_1318, 1318);
    ! [2: identify glulx rocks]
    RockSwitchingSGW();
    rfalse;
];
! From "Image Strip" by Philip Riley
! No specific request
! A glulx resetting-windows rule ( this is the default choosing hidewin rule ):
[ R_1322 ;
    if (debug_rules) DB_Rule(R_1322, 1322);
    ! [2: identify glulx rocks]
    RockSwitchingSGW();
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: glulx object-updating (B542_glulx_object_updating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! A glulx object-updating rule ( this is the automatic redrawing window rule ):
! ----------------------------------------------------------------------------------------------------
! From "Image Strip" by Philip Riley
! No specific request
! A glulx object-updating rule ( this is the automatic redrawing window rule ):
[ R_1326 ;
    if (debug_rules) DB_Rule(R_1326, 1326);
    ! [2: if glulx graphics is supported]
    if ((( glk_gestalt(gestalt_Graphics, 0) )))
    {! [3: follow the current graphics drawing rule]
        FollowRulebook((Global_Vars-->70));
        }
        rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: glulx input handling (B543_glulx_input_handling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/9 ! First glulx input handling rule for an arrange-event while arranging now in GEP is false ( this is the debounce arrange event rule ):
! --- now the last-placed rules ---
! Rule 2/9 ! Last glulx input handling rule for a timer-event when the direct event handling option is not active ( this is the redirect to GEP timed activity rule ):
!   === equally specific with ===
! Rule 3/9 ! Last glulx input handling rule for a char-event when the direct event handling option is not active ( this is the redirect to GEP character input rule ):
!   === equally specific with ===
! Rule 4/9 ! Last glulx input handling rule for a line-event when the direct event handling option is not active ( this is the redirect to GEP line input rule ):
!   === equally specific with ===
! Rule 5/9 ! Last glulx input handling rule for a mouse-event when the direct event handling option is not active ( this is the redirect to GEP mouse input rule ):
!   === equally specific with ===
! Rule 6/9 ! Last glulx input handling rule for an arrange-event when the direct event handling option is not active ( this is the redirect to GEP arranging rule ):
!   === equally specific with ===
! Rule 7/9 ! Last glulx input handling rule for a redraw-event when the direct event handling option is not active ( this is the redirect to GEP redrawing rule ):
!   === equally specific with ===
! Rule 8/9 ! Last glulx input handling rule for a sound-notify-event when the direct event handling option is not active ( this is the redirect to GEP sound notification rule ):
!   === equally specific with ===
! Rule 9/9 ! Last glulx input handling rule for a hyperlink-event when the direct event handling option is not active ( this is the redirect to GEP hyperlink rule ):
! ----------------------------------------------------------------------------------------------------
! From "Glulx Entry Points" by Emily Short
! No specific request
! First glulx input handling rule for an arrange-event while arranging now in GEP is false ( this is the debounce arrange event rule ):
[ R_1302 
    tmp_0 ! Let/loop value, e.g., 'i': number
    tmp_1 ! Let/loop value, e.g., 'final return value': number
    tmp_2 ! Let/loop value, e.g., 'arrange again': truth state
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    ;
    if (((((parameter_value == I270_arrange_event) && (true))))) { ! Runs only when pattern matches
    if ((((((((Global_Vars-->55) && true) == (0 && true))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1302, 1302);
    ! [2: let i be 0]

    		tmp_0 = 0;
    ! [3: let final return value be a number]

    		tmp_1 = 0; 
    ! [4: let arrange again be true]

    		tmp_2 = 1;
    ! [5: while 1 is 1]
    while (((1 == 1)))
    {! [6: poll for events in gep]
        glk_select_poll( gg_event ); for ( tmp_0 = 0 : tmp_0 < 3 : tmp_0++) { evGlobal-->tmp_0 = gg_event-->tmp_0; }
        ! [7: if the current event number in gep is 0]
        if (((evGlobal-->0 == 0)))
        {! [8: break]
            jump loop_break_0;
            } else {
            ! [9: if the current glk event is an arrange-event]
            if (((evGlobal-->0 == I270_arrange_event)))
            {! [10: next]
                continue;
                } else {
                ! [11: let temp event type be the current glk event]

                		tmp_3 = evGlobal-->0;
                ! [12: set the current glk event in gep to an arrange-event]
                evGlobal-->0 = I270_arrange_event;
                ! [13: now final return value is the glulx input handling rules for an arrange event]
                tmp_1 = (PHR_1303_r70 ());
                ! [14: set the current glk event in gep to temp event type]
                evGlobal-->0 = tmp_3;
                ! [15: now arrange again is false]
                tmp_2 = 0;
                ! [16: now final return value is the value returned by glk event handling]
                tmp_1 = (PHR_1291_r0 ());
                ! [17: break]
                jump loop_break_0;
                }
                }
                }
                .loop_break_0;! [18: if arrange again is true]
    if ((((tmp_2 && true) == (1 && true))))
    {! [19: now final return value is the glulx input handling rules for an arrange event]
        tmp_1 = (PHR_1303_r70 ());
        }
    ! [20: if final return value is input replacement]
    if (((tmp_1 == 2)))
    {! [21: replace player input]
        RulebookSucceeds(22, RBNO_28); rtrue;

        }
    ! [22: if final return value is input continuation]
    if (((tmp_1 == 1)))
    {! [23: require input to continue]
        RulebookSucceeds(22, RBNO_29); rtrue;

        }
    ! [24: rule fails]
    RulebookFails(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1302, 1302, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1302, 1302, 'action');
    rfalse;
];
! From "Glulx Entry Points" by Emily Short
! No specific request
! Last glulx input handling rule for a timer-event when the direct event handling option is not active ( this is the redirect to GEP timed activity rule ):
[ R_1294 ;
    if (((((parameter_value == I266_timer_event) && (true))))) { ! Runs only when pattern matches
    if ((((((~~(((Adj_25_t1_v16(30)))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1294, 1294);
    ! [2: abide by the glulx timed activity rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(530))) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1294, 1294, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1294, 1294, 'action');
    rfalse;
];
! From "Glulx Entry Points" by Emily Short
! No specific request
! Last glulx input handling rule for a char-event when the direct event handling option is not active ( this is the redirect to GEP character input rule ):
[ R_1295 ;
    if (((((parameter_value == I267_char_event) && (true))))) { ! Runs only when pattern matches
    if ((((((~~(((Adj_25_t1_v16(30)))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1295, 1295);
    ! [2: abide by the glulx character input rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(535))) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1295, 1295, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1295, 1295, 'action');
    rfalse;
];
! From "Glulx Entry Points" by Emily Short
! No specific request
! Last glulx input handling rule for a line-event when the direct event handling option is not active ( this is the redirect to GEP line input rule ):
[ R_1296 ;
    if (((((parameter_value == I268_line_event) && (true))))) { ! Runs only when pattern matches
    if ((((((~~(((Adj_25_t1_v16(30)))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1296, 1296);
    ! [2: follow the glulx line input rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(536));
    ! [3: if the rule succeeded]
    if (((RulebookSucceeded())))
    {! [4: replace player input]
        RulebookSucceeds(22, RBNO_28); rtrue;

        }
        } else if (debug_rules > 1) DB_Rule(R_1296, 1296, 'context');
        } else if (debug_rules > 1) DB_Rule(R_1296, 1296, 'action');
        rfalse;
];
! From "Glulx Entry Points" by Emily Short
! No specific request
! Last glulx input handling rule for a mouse-event when the direct event handling option is not active ( this is the redirect to GEP mouse input rule ):
[ R_1297 ;
    if (((((parameter_value == I269_mouse_event) && (true))))) { ! Runs only when pattern matches
    if ((((((~~(((Adj_25_t1_v16(30)))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1297, 1297);
    ! [2: abide by the glulx mouse input rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(534))) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1297, 1297, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1297, 1297, 'action');
    rfalse;
];
! From "Glulx Entry Points" by Emily Short
! No specific request
! Last glulx input handling rule for an arrange-event when the direct event handling option is not active ( this is the redirect to GEP arranging rule ):
[ R_1298 ;
    if (((((parameter_value == I270_arrange_event) && (true))))) { ! Runs only when pattern matches
    if ((((((~~(((Adj_25_t1_v16(30)))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1298, 1298);
    ! [2: abide by the glulx arranging rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(532))) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1298, 1298, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1298, 1298, 'action');
    rfalse;
];
! From "Glulx Entry Points" by Emily Short
! No specific request
! Last glulx input handling rule for a redraw-event when the direct event handling option is not active ( this is the redirect to GEP redrawing rule ):
[ R_1299 ;
    if (((((parameter_value == I271_redraw_event) && (true))))) { ! Runs only when pattern matches
    if ((((((~~(((Adj_25_t1_v16(30)))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1299, 1299);
    ! [2: abide by the glulx redrawing rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(531))) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1299, 1299, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1299, 1299, 'action');
    rfalse;
];
! From "Glulx Entry Points" by Emily Short
! No specific request
! Last glulx input handling rule for a sound-notify-event when the direct event handling option is not active ( this is the redirect to GEP sound notification rule ):
[ R_1300 ;
    if (((((parameter_value == I272_sound_notify_event) && (true))))) { ! Runs only when pattern matches
    if ((((((~~(((Adj_25_t1_v16(30)))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1300, 1300);
    ! [2: abide by the glulx sound notification rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(533))) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1300, 1300, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1300, 1300, 'action');
    rfalse;
];
! From "Glulx Entry Points" by Emily Short
! No specific request
! Last glulx input handling rule for a hyperlink-event when the direct event handling option is not active ( this is the redirect to GEP hyperlink rule ):
[ R_1301 ;
    if (((((parameter_value == I273_hyperlink_event) && (true))))) { ! Runs only when pattern matches
    if ((((((~~(((Adj_25_t1_v16(30)))))))))) { ! Runs only while condition holds
    if (debug_rules) DB_Rule(R_1301, 1301);
    ! [2: abide by the glulx hyperlink rules]
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(537))) rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1301, 1301, 'context');
    } else if (debug_rules > 1) DB_Rule(R_1301, 1301, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: command-counting (B544_command_counting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! A command-counting rule ( this is the ordinary checking for content rule ):
! ----------------------------------------------------------------------------------------------------
! From "Glulx Entry Points" by Emily Short
! No specific request
! A command-counting rule ( this is the ordinary checking for content rule ):
[ R_1307 ;
    if (debug_rules) DB_Rule(R_1307, 1307);
    ! [2: if the number of characters in the glulx replacement command is 0]
    if (((TEXT_TY_BlobAccess((Global_Vars-->53), CHR_BLOB) == 0)))
    {! [3: rule fails]
        RulebookFails(); rtrue;
        }
    ! [4: rule succeeds]
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: input-cancelling (B545_input_cancelling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! An input-cancelling rule ( this is the cancelling input in the main window rule ):
! ----------------------------------------------------------------------------------------------------
! From "Glulx Entry Points" by Emily Short
! No specific request
! An input-cancelling rule ( this is the cancelling input in the main window rule ):
[ R_1308 ;
    if (debug_rules) DB_Rule(R_1308, 1308);
    ! [2: cancel line input in the main window]
    glk_cancel_line_event(gg_mainwin, GLK_NULL);
    ! [3: cancel character input in the main window]
    glk_cancel_char_event(gg_mainwin);
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: command-showing (B546_command_showing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! A command-showing rule ( this is the print text to the input prompt rule ):
! ----------------------------------------------------------------------------------------------------
! From "Glulx Entry Points" by Emily Short
! No specific request
! A command-showing rule ( this is the print text to the input prompt rule ):
[ R_1311 ;
    if (debug_rules) DB_Rule(R_1311, 1311);
    ! [2: say input-style-for-glulx]
    say__p=1;! [3: input-style-for-glulx]
    ParaContent(); glk_set_style(style_Input); .L_Say509; .L_SayX502;! [4: say glulx replacement command]
    say__p=1;! [5: glulx replacement command]
    ParaContent(); print (TEXT_TY_Say) (Global_Vars-->53); .L_Say510; .L_SayX503;! [6: say roman type]
    say__p=1;! [7: roman type]
    ParaContent(); (PHR_354_r3 ()); .L_Say511; .L_SayX504;rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: command-pasting (B547_command_pasting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! A command-pasting rule ( this is the glue replacement command into parse buffer rule ):
! ----------------------------------------------------------------------------------------------------
! From "Glulx Entry Points" by Emily Short
! No specific request
! A command-pasting rule ( this is the glue replacement command into parse buffer rule ):
[ R_1313 ;
    if (debug_rules) DB_Rule(R_1313, 1313);
    ! [2: change the text of the player's command to the glulx replacement command]
    SetPlayersCommand((Global_Vars-->53));
    ! [3: rule succeeds]
    RulebookSucceeds(); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: glulx picture selection (B548_glulx_picture_selection)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! The first glulx picture selection rule ( this is the bosh picture selection rule ):
! --- now the mid-placed rules ---
! Rule 2/2 ! A glulx picture selection rule ( this is the default picture selection rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! The first glulx picture selection rule ( this is the bosh picture selection rule ):
[ R_1508 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    tmp_3 ! Let/loop value: number
    ;
    if (debug_rules) DB_Rule(R_1508, 1508);
    ! [2: remove characters from characters]
    LIST_OF_TY_Remove_List((Global_Vars-->81), (Global_Vars-->81), 0);
    ! [3: if the current play mode is picking character]
    if ((((Global_Vars-->75) == I410_picking_character)))
    {! [4: add figure gaunt to characters]
        LIST_OF_TY_InsertItem((Global_Vars-->81), I502_figure_gaunt, 0, 0, 0);
        ! [5: add figure goldberg to characters]
        LIST_OF_TY_InsertItem((Global_Vars-->81), I501_figure_goldberg, 0, 0, 0);
        ! [6: add figure faraji to characters]
        LIST_OF_TY_InsertItem((Global_Vars-->81), I503_figure_faraji, 0, 0, 0);
        } else {
        ! [7: if the player is yourself]
        if (((player == selfobj)))
        {! [8: rule succeeds with result 0]
            RulebookSucceeds(NUMBER_TY,0); rtrue;
            }
        ! [9: let pol be picture of the location]

        		tmp_0 = (PHR_1507_r71 ());
        ! [10: if pol is not figure null]
        if (((~~((tmp_0 == I500_figure_null)))))
        {! [11: add pol to characters]
            LIST_OF_TY_InsertItem((Global_Vars-->81), tmp_0, 0, 0, 0);
            }
        ! [12: add the portrait of the player to characters]
        LIST_OF_TY_InsertItem((Global_Vars-->81), GProperty(10, player,p49_portrait), 0, 0, 0);
        ! [13: if current play mode is _normal]
        if ((((Global_Vars-->75) == I409__normal)))
        {! [14: if the current interlocutor is something]
            if ((((Global_Vars-->11) ofclass K2_thing)))
            {! [15: add the portrait of the current interlocutor to characters]
                LIST_OF_TY_InsertItem((Global_Vars-->81), GProperty(OBJECT_TY, (Global_Vars-->11),p49_portrait), 0, 0, 0);
                }
            ! [16: repeat with c running through the people in the location]
            for (tmp_1=Prop_96(0), tmp_2=Prop_96(tmp_1): tmp_1: tmp_1=tmp_2, tmp_2=Prop_96(tmp_2))
            {! [17: if c is not the player and c is not the current interlocutor]
                if ((((~~((tmp_1 == player))))) && (((~~((tmp_1 == (Global_Vars-->11)))))))
                {! [18: add the portrait of c to characters]
                    LIST_OF_TY_InsertItem((Global_Vars-->81), GProperty(10, tmp_1,p49_portrait), 0, 0, 0);
                    }
                    }
            ! [19: repeat with c running through people talking with the player]
            for (tmp_1=Prop_97(0), tmp_2=Prop_97(tmp_1): tmp_1: tmp_1=tmp_2, tmp_2=Prop_97(tmp_2))
            {! [20: if the portrait of c is not listed in characters]
                if (((LIST_OF_TY_FindItem((Global_Vars-->81), GProperty(10, tmp_1,p49_portrait)) == false)))
                {! [21: add the portrait of c to characters]
                    LIST_OF_TY_InsertItem((Global_Vars-->81), GProperty(10, tmp_1,p49_portrait), 0, 0, 0);
                    }
                    }
            ! [22: repeat with t running through audible sounds]
            for (tmp_3=(Global_Vars-->18), tmp_2=1, tmp_1=LIST_OF_TY_GetItem(tmp_3, tmp_2, true): tmp_2<=LIST_OF_TY_GetLength(tmp_3): tmp_2++, tmp_1=LIST_OF_TY_GetItem(tmp_3, tmp_2, true))
            {! [23: if the portrait of t is not figure null]
                if (((~~((GProperty(10, tmp_1,p49_portrait) == I500_figure_null)))))
                {! [24: add the portrait of t to characters]
                    LIST_OF_TY_InsertItem((Global_Vars-->81), GProperty(10, tmp_1,p49_portrait), 0, 0, 0);
                    }
                    }
            ! [25: if could see hypertunnels and the player wears the astral lenses]
            if ((((PHR_1242_r72 ()))) && (((player == WearerOf(I426_astral_lenses)))))
            {! [26: add figure white tunnel to characters]
                LIST_OF_TY_InsertItem((Global_Vars-->81), I519_figure_white_tunnel, 0, 0, 0);
                }
                }
                }
    ! [27: if the number of entries of characters > 0]
    if (((LIST_OF_TY_GetLength((Global_Vars-->81)) > 0)))
    {! [28: now the internally selected picture 1 is entry 1 of characters]
        (Global_Vars-->61) = LIST_OF_TY_GetItem((Global_Vars-->81),1);
        }
    ! [29: if the number of entries of characters > 1]
    if (((LIST_OF_TY_GetLength((Global_Vars-->81)) > 1)))
    {! [30: now the internally selected picture 2 is entry 2 of characters]
        (Global_Vars-->62) = LIST_OF_TY_GetItem((Global_Vars-->81),2);
        }
    ! [31: if the number of entries of characters > 2]
    if (((LIST_OF_TY_GetLength((Global_Vars-->81)) > 2)))
    {! [32: now the internally selected picture 3 is entry 3 of characters]
        (Global_Vars-->63) = LIST_OF_TY_GetItem((Global_Vars-->81),3);
        }
    ! [33: if the number of entries of characters > 3]
    if (((LIST_OF_TY_GetLength((Global_Vars-->81)) > 3)))
    {! [34: now the internally selected picture 4 is entry 4 of characters]
        (Global_Vars-->64) = LIST_OF_TY_GetItem((Global_Vars-->81),4);
        }
    ! [35: if the number of entries of characters > 4]
    if (((LIST_OF_TY_GetLength((Global_Vars-->81)) > 4)))
    {! [36: now the internally selected picture 5 is entry 5 of characters]
        (Global_Vars-->65) = LIST_OF_TY_GetItem((Global_Vars-->81),5);
        }
    ! [37: rule succeeds with result the number of entries of characters]
    RulebookSucceeds(NUMBER_TY,LIST_OF_TY_GetLength((Global_Vars-->81))); rtrue;
    rfalse;
];
! From "Image Strip" by Philip Riley
! No specific request
! A glulx picture selection rule ( this is the default picture selection rule ):
[ R_1333 ;
    if (debug_rules) DB_Rule(R_1333, 1333);
    ! [2: now the internally selected picture 1 is the currently shown picture 1]
    (Global_Vars-->61) = (Global_Vars-->56);
    ! [3: now the internally selected picture 2 is the currently shown picture 2]
    (Global_Vars-->62) = (Global_Vars-->57);
    ! [4: now the internally selected picture 3 is the currently shown picture 3]
    (Global_Vars-->63) = (Global_Vars-->58);
    ! [5: rule succeeds with result 3]
    RulebookSucceeds(NUMBER_TY,3); rtrue;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: window resizing (B549_window_resizing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! A window resizing rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! A window resizing rule:
[ R_1512 ;
    if (debug_rules) DB_Rule(R_1512, 1512);
    ! [2: do nothing]
    ;
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: can't unlock without a lock description (B550_can_t_unlock_without_a_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Can't unlock without a lock description of a two-sided door ( called TSD ) ( this is the standard can't unlock without a lock description rule ):
! ----------------------------------------------------------------------------------------------------
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Can't unlock without a lock description of a two-sided door ( called TSD ) ( this is the standard can't unlock without a lock description rule ):
[ R_1356 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_65();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_65 
    tmp_0 ! Let/loop value, e.g., 'TSD': two-sided door
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K30_two_sided_door) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1356, 1356);
    ! [2: rule succeeds with result ~[regarding TSD][Those] [don't] seem to be something [we] [can] unlock.~ ( a )]
    RulebookSucceeds(TEXT_TY,BlkValueCopy(I7SFRAME, ((LocalParking-->0=tmp_0),TX_R_439))); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1356, 1356, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: can't unlock already unlocked description (B551_can_t_unlock_already_un)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Can't unlock already unlocked description of a two-sided door ( called TSD ) ( this is the standard can't unlock already unlocked description rule ):
! ----------------------------------------------------------------------------------------------------
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Can't unlock already unlocked description of a two-sided door ( called TSD ) ( this is the standard can't unlock already unlocked description rule ):
[ R_1358 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_66();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_66 
    tmp_0 ! Let/loop value, e.g., 'TSD': two-sided door
    ;
    if ((((tmp_0 = parameter_value, (((parameter_value ofclass K30_two_sided_door) && (tmp_0=(parameter_value), true))))) || (tmp_0 = 0,false))) { ! Runs only when pattern matches
    if (debug_rules) DB_Rule(R_1358, 1358);
    ! [2: rule succeeds with result ~[regarding the noun][They're] unlocked at the [if story tense is present tense]moment[otherwise]time[end if].~ ( a )]
    RulebookSucceeds(TEXT_TY,BlkValueCopy(I7SFRAME, ((LocalParking-->0=tmp_0),TX_R_440))); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1358, 1358, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Swiping it through (B552_check_swiping_it_throug)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check swiping something swipable through a swipe lock:
!   === equally specific with ===
! Rule 2/2 ! Check swiping something swipable through a swipe door:
! ----------------------------------------------------------------------------------------------------
! From "Door Varieties" by Philip Riley
! No specific request
! Check swiping something swipable through a swipe lock:
[ R_1387 
    tmp_0 ! Let/loop value, e.g., 'door': thing
    ;
    if ((( (actor==player) && ((noun ofclass K2_thing) && ((Adj_176_t1_v10(noun)))) && ((second ofclass K34_swipe_lock))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1387, 1387);
    ! [2: if something ( called the door ) incorporates the second noun]
    if ((((second.component_parent) ofclass K2_thing) && (tmp_0=((second.component_parent)), true)))
    {! [3: try unlocking the door with the noun]
        TryAction(0, player, ##Unlock, tmp_0, noun);
        }
        } else if (debug_rules > 1) DB_Rule(R_1387, 1387, 'action');
        rfalse;
];
! From "Door Varieties" by Philip Riley
! No specific request
! Check swiping something swipable through a swipe door:
[ R_1388 ;
    if ((( (actor==player) && ((noun ofclass K2_thing) && ((Adj_176_t1_v10(noun)))) && ((second ofclass K35_swipe_door))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1388, 1388);
    ! [2: try unlocking the second noun with the noun]
    TryAction(0, player, ##Unlock, second, noun);
    } else if (debug_rules > 1) DB_Rule(R_1388, 1388, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check moving it with (B555_check_moving_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check moving something with:
! ----------------------------------------------------------------------------------------------------
! From "Swamp Park" by Philip Riley
! No specific request
! Check moving something with:
[ R_1409 ;
    if ((( (actor==player) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1409, 1409);
    ! [2: say ~That isn't very helpful.~]
    say__p=1;! [3: ~That isn't very helpful.~]
    ParaContent(); print "That isn't very helpful."; new_line; .L_Say512; .L_SayX505;} else if (debug_rules > 1) DB_Rule(R_1409, 1409, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check howdeedoing (B558_check_howdeedoing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check howdeedoing:
! ----------------------------------------------------------------------------------------------------
! From "Conversations General" by Philip Riley
! No specific request
! Check howdeedoing:
[ R_1422 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1422, 1422);
    ! [2: try discussing how-are-you]
    TryAction(0, player, ##A103_discussing, I355_how_are_you, 0);
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1422, 1422, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check howdeedoing-someone (B561_check_howdeedoing_someo)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check howdeedoing-someone someone:
! ----------------------------------------------------------------------------------------------------
! From "Conversations General" by Philip Riley
! No specific request
! Check howdeedoing-someone someone:
[ R_1420 ;
    if ((( (actor==player) && ((noun ofclass K8_person))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1420, 1420);
    ! [2: now the current interlocutor is the noun]
    (Global_Vars-->11) = noun;
    ! [3: try howdeedoing]
    TryAction(0, player, ##A108_howdeedoing, 0, 0);
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1420, 1420, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Knocking on (B565_carry_out_knocking_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out knocking on the BOSH back door when the location is the back lot and the BOSH back door is locked:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out knocking on the BOSH back door when the location is the back lot and the BOSH back door is locked:
[ R_1494 ;
    if ((( (actor==player) && ((noun == I367_bosh_back_door) && (true)) && (self=actor,true) && ((((real_location == I325_back_lot))) && ((((Adj_106_t1_v10(I367_bosh_back_door))))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1494, 1494);
    ! [2: move margaret to biff's office]
    MoveObject(I358_margaret_chao, I429_biff_s_office, 0, false);
    ! [3: try margaret unlocking the bosh back door with the white key]
    TryAction(0, I358_margaret_chao, ##Unlock, I367_bosh_back_door, I446_white_key);
    ! [4: try margaret opening the bosh back door]
    TryAction(0, I358_margaret_chao, ##Open, I367_bosh_back_door, 0);
    ! [5: now the target location of margaret is the front office]
    WriteGProperty(10, I358_margaret_chao,p23_target_location,I295_the_front_office);
    ! [6: clear behavior of margaret]
    (PHR_1049_r64 (I358_margaret_chao));
    ! [7: add behavior walking-to to margaret]
    (PHR_1050_r73 (I191_walking_to,I358_margaret_chao));
    ! [8: add behavior locking-back-door to margaret]
    (PHR_1050_r73 (I449_locking_back_door,I358_margaret_chao));
    ! [9: add behavior waiting-for-player to margaret]
    (PHR_1050_r73 (I450_waiting_for_player,I358_margaret_chao));
    } else if (debug_rules > 1) DB_Rule(R_1494, 1494, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Knocking on (B566_report_knocking_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report knocking on the BOSH back door when the location is the back lot and the BOSH back door was locked:
!   >>> I - Number of aspects constrained >>>
! Rule 2/3 ! Report knocking on a door:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 3/3 ! Report knocking on something:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Report knocking on the BOSH back door when the location is the back lot and the BOSH back door was locked:
[ R_1495 ;
    if ((( (actor==player) && ((noun == I367_bosh_back_door) && (true)) && (self=actor,true) && ((((real_location == I325_back_lot))) && ((TestSinglePastState(1, 2, false, 1))))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1495, 1495);
    ! [2: say ~You hear the door being unlocked, and then Margaret pops her head out. 'Seriously, [Agent]? You got yourself locked out? Be more careful!'~]
    say__p=1;! [3: ~You hear the door being unlocked, and then Margaret pops her head out. 'Seriously, ~]
    ParaContent(); print "You hear the door being unlocked, and then Margaret pops her head out. ~Seriously, ";! [4: agent]
    ParaContent(); (PHR_1445_r13 ());! [5: ~? You got yourself locked out? Be more careful!'~]
    ParaContent(); print "? You got yourself locked out? Be more careful!~"; new_line; .L_Say513; .L_SayX506;! [6: rule succeeds]
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1495, 1495, 'action');
    rfalse;
];
! No specific request
! Report knocking on a door:
[ R_1459 ;
    if ((( (actor==player) && ((noun ofclass K4_door))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1459, 1459);
    ! [2: say ~[We] [give] [the noun] a quick knock, but no one seems to be home.~]
    say__p=1;! [3: we]
    ParaContent(); (PHR_764_r7 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: give]
    ConjugateVerb_33(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ ~]
    ParaContent(); print " ";! [7: the noun]
    ParaContent(); print (the) noun;! [8: ~ a quick knock, but no one seems to be home.~]
    ParaContent(); print " a quick knock, but no one seems to be home."; new_line; .L_Say514; .L_SayX507;! [9: rule succeeds]
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1459, 1459, 'action');
    rfalse;
];
! No specific request
! Report knocking on something:
[ R_1458 ;
    if ((( (actor==player) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_1458, 1458);
    ! [2: say ~[We] [give] [the noun] a quick knock, but nothing happens.~]
    say__p=1;! [3: we]
    ParaContent(); (PHR_764_r7 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: give]
    ConjugateVerb_33(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ ~]
    ParaContent(); print " ";! [7: the noun]
    ParaContent(); print (the) noun;! [8: ~ a quick knock, but nothing happens.~]
    ParaContent(); print " a quick knock, but nothing happens."; new_line; .L_Say515; .L_SayX508;! [9: rule succeeds]
    RulebookSucceeds(); rtrue;
    } else if (debug_rules > 1) DB_Rule(R_1458, 1458, 'action');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out lensing (B574_carry_out_lensing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out lensing:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out lensing:
[ R_1515 ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_1515, 1515);
    ! [2: now the player wears the astral lenses]
    WearObject(I426_astral_lenses,player);
    } else if (debug_rules > 1) DB_Rule(R_1515, 1515, 'actor');
    rfalse;
];
! ----------------------------------------------------------------------------------------------------
! Definitions of displaced and unbooked rules

! From the Standard Rules
! No specific request
! For printing the locale description ( this is the you-can-also-see rule ):
[ R_84 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    tmp_4 ! Let/loop value (deallocated by end of phrase)
    tmp_5 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    if (debug_rules) DB_Rule(R_84, 84);
    ! [2: let the domain be the parameter-object]

    		tmp_0 = parameter_value;
    ! [3: let the mentionable count be 0]

    		tmp_1 = 0;
    ! [4: repeat with item running through things]
    for (tmp_2=Prop_98(0), tmp_3=Prop_98(tmp_2): tmp_2: tmp_2=tmp_3, tmp_3=Prop_98(tmp_3))
    {! [5: now the item is not marked for listing]
        (Adj_94_t3_v10(tmp_2));
        }
    ! [6: repeat through the table of locale priorities]
    @push ct_0; @push ct_1;
    		for (tmp_2=T1_locale_priorities, tmp_3=1, ct_0=tmp_2, ct_1=tmp_3:
    			tmp_3<=TableRows(tmp_2):
    			tmp_3++, ct_0=tmp_2, ct_1=tmp_3)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [7: if the locale description priority entry is greater than 0]
        if (((TableLookUpEntry(ct_0,106,ct_1) > 0)))
        {! [8: now the notable-object entry is marked for listing]
            (Adj_94_t2_v10(TableLookUpEntry(ct_0,105,ct_1)));
            }
        ! [9: increase the mentionable count by 1]
        tmp_1 = tmp_1 + 1;;
        }
        @pull ct_1; @pull ct_0;! [10: if the mentionable count is greater than 0]
    if (((tmp_1 > 0)))
    {! [11: repeat with item running through things]
        for (tmp_2=Prop_99(0), tmp_3=Prop_99(tmp_2): tmp_2: tmp_2=tmp_3, tmp_3=Prop_99(tmp_3))
        {! [12: if the item is mentioned]
            if ((((Adj_96_t1_v10(tmp_2)))))
            {! [13: now the item is not marked for listing]
                (Adj_94_t3_v10(tmp_2));
                }
                }
        ! [14: begin the listing nondescript items activity with the domain]
        BeginActivity(V8_listing_nondescript_items, tmp_0);
        ! [15: if the number of marked for listing things is 0]
        if ((((Prop_100()) == 0)))
        {! [16: abandon the listing nondescript items activity with the domain]
            AbandonActivity(V8_listing_nondescript_items, tmp_0);
            } else {
            ! [17: if handling the listing nondescript items activity with the domain]
            if (((~~(ForActivity(V8_listing_nondescript_items, tmp_0)))))
            {! [18: if the domain is the location]
                if (((tmp_0 == real_location)))
                {! [19: say ~[We] ~ ( a )]
                    say__p=1;! [20: ~[We] ~ ( a )]
                    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),TX_R_441); .L_Say516; .L_SayX509;} else {
                    ! [21: if the domain is a supporter or the domain is an animal]
                    if ((((tmp_0 ofclass K6_supporter))) || (((tmp_0 ofclass K13_animal))))
                    {! [22: say ~On [the domain] [we] ~ ( b )]
                        say__p=1;! [23: ~On [the domain] [we] ~ ( b )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),TX_R_442); .L_Say517; .L_SayX510;} else {
                        ! [24: say ~In [the domain] [we] ~ ( c )]
                        say__p=1;! [25: ~In [the domain] [we] ~ ( c )]
                        ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),TX_R_443); .L_Say518; .L_SayX511;}
                        }
                ! [26: if the locale paragraph count is greater than 0]
                if ((((Global_Vars-->9) > 0)))
                {! [27: say ~[regarding the player][can] also see ~ ( d )]
                    say__p=1;! [28: ~[regarding the player][can] also see ~ ( d )]
                    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),TX_R_444); .L_Say519; .L_SayX512;} else {
                    ! [29: say ~[regarding the player][can] see ~ ( e )]
                    say__p=1;! [30: ~[regarding the player][can] see ~ ( e )]
                    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),TX_R_445); .L_Say520; .L_SayX513;}
                ! [31: let the common holder be nothing]

                		tmp_2 = nothing;
                ! [32: let contents form of list be true]

                		tmp_3 = 1;
                ! [33: repeat with list item running through marked for listing things]
                for (tmp_4=Prop_101(0), tmp_5=Prop_101(tmp_4): tmp_4: tmp_4=tmp_5, tmp_5=Prop_101(tmp_5))
                {! [34: if the holder of the list item is not the common holder]
                    if (((~~(((HolderOf(tmp_4)) == tmp_2)))))
                    {! [35: if the common holder is nothing]
                        if (((tmp_2 == nothing)))
                        {! [36: now the common holder is the holder of the list item]
                            tmp_2 = (HolderOf(tmp_4));
                            } else {
                            ! [37: now contents form of list is false]
                            tmp_3 = 0;
                            }
                            }
                    ! [38: if the list item is mentioned]
                    if ((((Adj_96_t1_v10(tmp_4)))))
                    {! [39: now the list item is not marked for listing]
                        (Adj_94_t3_v10(tmp_4));
                        }
                        }
                ! [40: filter list recursion to unmentioned things]
                list_filter_routine = Prop_102;
                ! [41: if contents form of list is true and the common holder is not nothing]
                if (((((tmp_3 && true) == (1 && true)))) && (((~~((tmp_2 == nothing))))))
                {! [42: list the contents of the common holder , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , listing marked items only]
                    WriteListFrom(child(tmp_2), 2776);
                    } else {
                    ! [43: say ~[a list of marked for listing things including contents]~]
                    say__p=1;! [44: a list of marked for listing things including contents]
                    ParaContent(); objectloop(tmp_4 ofclass Object)
                    			if (((tmp_4 ofclass K2_thing) && ((Adj_94_t1_v10(tmp_4)))))
                    				give tmp_4 workflag2;
                    			else
                    				give tmp_4 ~workflag2;
                    		WriteListOfMarkedObjects(ENGLISH_BIT+RECURSE_BIT+PARTINV_BIT+
                    			TERSE_BIT+CONCEAL_BIT); .L_Say521; .L_SayX514;}
                ! [45: if the domain is the location]
                if (((tmp_0 == real_location)))
                {! [46: say ~ here~ ( f )]
                    say__p=1;! [47: ~ here~ ( f )]
                    ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=ct_0),(LocalParking-->5=ct_1),(LocalParking-->6=tmp_4),(LocalParking-->7=tmp_5),TX_R_446); .L_Say522; .L_SayX515;}
                ! [48: say ~.[paragraph break]~]
                say__p=1;! [49: ~.~]
                ParaContent(); print ".";! [50: paragraph break]
                ParaContent(); DivideParagraphPoint(); new_line; .L_Say523; .L_SayX516;! [51: unfilter list recursion]
                list_filter_routine = 0;
                }
            ! [52: end the listing nondescript items activity with the domain]
            EndActivity(V8_listing_nondescript_items, tmp_0);
            }
            }
    ! [53: continue the activity]
    rfalse;
    RulebookSucceeds(); rtrue;
    rfalse;
];
! From the Standard Rules
! No specific request
! Carry out looking ( this is the room description heading rule ):
[ R_186 
    tmp_0 ! Let/loop value, e.g., 'intermediate level': object
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    if (actor == player) {
    if (debug_rules) DB_Rule(R_186, 186);
    ! [2: say bold type]
    say__p=1;! [3: bold type]
    ParaContent(); (PHR_352_r2 ()); .L_Say524; .L_SayX517;! [4: if the visibility level count is 0]
    if ((((MStack-->MstVO(20011,2)) == 0)))
    {! [5: begin the printing the name of a dark room activity]
        BeginActivity(V9_printing_the_name_of_a_da);
        ! [6: if handling the printing the name of a dark room activity]
        if (((~~(ForActivity(V9_printing_the_name_of_a_da)))))
        {! [7: say ~Darkness~ ( a )]
            say__p=1;! [8: ~Darkness~ ( a )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_447); .L_Say525; .L_SayX518;}
        ! [9: end the printing the name of a dark room activity]
        EndActivity(V9_printing_the_name_of_a_da);
        } else {
        ! [10: if the visibility ceiling is the location]
        if ((((MStack-->MstVO(20011,3)) == real_location)))
        {! [11: say ~[visibility ceiling]~]
            say__p=1;! [12: visibility ceiling]
            ParaContent(); PrintShortName((MStack-->MstVO(20011,3))); .L_Say526; .L_SayX519;} else {
            ! [13: say ~[The visibility ceiling]~]
            say__p=1;! [14: the visibility ceiling]
            ParaContent(); print (The) (MStack-->MstVO(20011,3)); .L_Say527; .L_SayX520;}
            }
    ! [15: say roman type]
    say__p=1;! [16: roman type]
    ParaContent(); (PHR_354_r3 ()); .L_Say528; .L_SayX521;! [17: let intermediate level be the visibility-holder of the actor]

    		tmp_0 = VisibilityParent(actor);
    ! [18: repeat with intermediate level count running from 2 to the visibility level count]
    for (tmp_1=2: tmp_1<=(MStack-->MstVO(20011,2)): tmp_1++)
    {! [19: if the intermediate level is a supporter or the intermediate level is an animal]
        if ((((tmp_0 ofclass K6_supporter))) || (((tmp_0 ofclass K13_animal))))
        {! [20: say ~ (on [the intermediate level])~ ( b )]
            say__p=1;! [21: ~ (on [the intermediate level])~ ( b )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_448); .L_Say529; .L_SayX522;} else {
            ! [22: say ~ (in [the intermediate level])~ ( c )]
            say__p=1;! [23: ~ (in [the intermediate level])~ ( c )]
            ParaContent(); print (TEXT_TY_Say) ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),TX_R_449); .L_Say530; .L_SayX523;}
        ! [24: let the intermediate level be the visibility-holder of the intermediate level]
        tmp_0 = VisibilityParent(tmp_0);
        }
    ! [25: say line break]
    say__p=1;! [26: line break]
    ParaContent(); new_line; .L_Say531; .L_SayX524;! [27: say run paragraph on with special look spacing]
    say__p=1;! [28: run paragraph on with special look spacing]
    ParaContent(); SpecialLookSpacingBreak(); .L_Say532; .L_SayX525;} else if (debug_rules > 1) DB_Rule(R_186, 186, 'actor');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor giving something to ( this is the block giving rule ):
[ R_249 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_249, 249);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~[The second noun] [don't] seem interested.~ ( a )]
        say__p=1;! [4: ~[The second noun] [don't] seem interested.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_450); new_line; .L_Say533; .L_SayX526;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_249, 249, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Carry out an actor giving something to ( this is the standard giving rule ):
[ R_251 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_251, 251);
    ! [2: move the noun to the second noun]
    MoveObject(noun, second, 0, false);
    } else if (debug_rules > 1) DB_Rule(R_251, 251, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor giving something to ( this is the standard report giving rule ):
[ R_252 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_252, 252);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~[We] [give] [the noun] to [the second noun].~ ( a )]
        say__p=1;! [4: ~[We] [give] [the noun] to [the second noun].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_451); new_line; .L_Say534; .L_SayX527;} else {
        ! [5: if the second noun is the player]
        if (((second == player)))
        {! [6: say ~[The actor] [give] [the noun] to [us].~ ( b )]
            say__p=1;! [7: ~[The actor] [give] [the noun] to [us].~ ( b )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_452); new_line; .L_Say535; .L_SayX528;} else {
            ! [8: say ~[The actor] [give] [the noun] to [the second noun].~ ( c )]
            say__p=1;! [9: ~[The actor] [give] [the noun] to [the second noun].~ ( c )]
            ParaContent(); print (TEXT_TY_Say) (TX_R_453); new_line; .L_Say536; .L_SayX529;}
            }
            } else if (debug_rules > 1) DB_Rule(R_252, 252, 'action');
            rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor showing something to ( this is the block showing rule ):
[ R_255 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_255, 255);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~[The second noun] [are] unimpressed.~ ( a )]
        say__p=1;! [4: ~[The second noun] [are] unimpressed.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_454); new_line; .L_Say537; .L_SayX530;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_255, 255, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor answering something that ( this is the block answering rule ):
[ R_263 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_263, 263);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [4: say ~[There] [are] no reply.~ ( a )]
        say__p=1;! [5: ~[There] [are] no reply.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_455); new_line; .L_Say538; .L_SayX531;}
    ! [6: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_263, 263, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor telling something about ( this is the block telling rule ):
[ R_265 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_265, 265);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [4: say ~This [provoke] no reaction.~ ( a )]
        say__p=1;! [5: ~This [provoke] no reaction.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_456); new_line; .L_Say539; .L_SayX532;}
    ! [6: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_265, 265, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Report an actor asking something about ( this is the block asking rule ):
[ R_266 ;
    if ((((act_requester==nothing) && ((noun ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_266, 266);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: now the prior named object is nothing]
        prior_named_noun = nothing;
        ! [4: say ~[There] [are] no reply.~ ( a )]
        say__p=1;! [5: ~[There] [are] no reply.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_457); new_line; .L_Say540; .L_SayX533;}
    ! [6: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_266, 266, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor saying yes ( this is the block saying yes rule ):
[ R_295 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_295, 295);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~That was a rhetorical question.~ ( a )]
        say__p=1;! [4: ~That was a rhetorical question.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_458); new_line; .L_Say541; .L_SayX534;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_295, 295, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor saying no ( this is the block saying no rule ):
[ R_296 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_296, 296);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~That was a rhetorical question.~ ( a )]
        say__p=1;! [4: ~That was a rhetorical question.~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_459); new_line; .L_Say542; .L_SayX535;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_296, 296, 'action');
    rfalse;
];
! From the Standard Rules
! No specific request
! Check an actor saying sorry ( this is the block saying sorry rule ):
[ R_298 ;
    if ((((act_requester==nothing)))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_298, 298);
    ! [2: if the actor is the player]
    if (((actor == player)))
    {! [3: say ~Oh, don't [if American dialect option is active]apologize[otherwise]apologise[end if].~ ( a )]
        say__p=1;! [4: ~Oh, don't [if American dialect option is active]apologize[otherwise]apologise[end if].~ ( a )]
        ParaContent(); print (TEXT_TY_Say) (TX_R_460); new_line; .L_Say543; .L_SayX536;}
    ! [5: stop the action]
    rtrue;
    } else if (debug_rules > 1) DB_Rule(R_298, 298, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Report informing someone about something ( this is the block informing rule ):
[ R_803 ;
    if ((( (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_803, 803);
    ! [2: say ~[There] [are] no reply.~ ( a )]
    say__p=1;! [3: ~[There] [are] no reply.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_461); new_line; .L_Say544; .L_SayX537;} else if (debug_rules > 1) DB_Rule(R_803, 803, 'action');
    rfalse;
];
! From "Conversation Framework" by Eric Eve
! No specific request
! Report quizzing someone about something ( this is the block quizzing rule ):
[ R_804 ;
    if ((( (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))))) { ! Runs only when pattern matches
    self = noun;
    if (debug_rules) DB_Rule(R_804, 804);
    ! [2: say ~[There] [are] no reply.~ ( a )]
    say__p=1;! [3: ~[There] [are] no reply.~ ( a )]
    ParaContent(); print (TEXT_TY_Say) (TX_R_462); new_line; .L_Say545; .L_SayX538;} else if (debug_rules > 1) DB_Rule(R_804, 804, 'action');
    rfalse;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! This is the display available quips rule:
[ R_1230 ;
    if (debug_rules) DB_Rule(R_1230, 1230);
    ! [2: if the current interlocutor is something]
    if ((((Global_Vars-->11) ofclass K2_thing)))
    {! [3: carry out the listing the available quips activity]
        CarryOutActivity(V49_listing_the_available_qu);
        }
        rfalse;
];
! From "Image Strip" by Philip Riley
! No specific request
! This is the standard placement rule:
[ R_1335 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_67();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_67 ;
    if (debug_rules) DB_Rule(R_1335, 1335);
    ! [2: blank window to graphics background color]
    (PHR_1337_r74 (BlkValueCopy(I7SFRAME, (Global_Vars-->68))));
    ! [3: follow the centered scaled drawing rule]
    FollowRulebook(R_1339);
    rfalse;
];
! From "Image Strip" by Philip Riley
! No specific request
! This is the bland graphics drawing rule:
[ R_1336 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_68();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_68 ;
    if (debug_rules) DB_Rule(R_1336, 1336);
    ! [2: blank window to graphics background color]
    (PHR_1337_r74 (BlkValueCopy(I7SFRAME, (Global_Vars-->68))));
    rfalse;
];
! From "Image Strip" by Philip Riley
! No specific request
! This is the centered scaled drawing rule:
[ R_1339 ;
    if (debug_rules) DB_Rule(R_1339, 1339);
    ! [2: draw centered scaled image in graphics window]
    MyRedrawGraphicsWindows();
    rfalse;
];
! From "Image Strip" by Philip Riley
! No specific request
! This is the tiled drawing rule:
[ R_1341 ;
    if (debug_rules) DB_Rule(R_1341, 1341);
    ! [2: draw tiled image in graphics window]
    TileFillGraphicsWindows();
    rfalse;
];
! From "Image Strip" by Philip Riley
! No specific request
! This is the fully scaled drawing rule:
[ R_1343 ;
    if (debug_rules) DB_Rule(R_1343, 1343);
    ! [2: draw fully scaled image in graphics window]
    TotalFillGraphicsWindows();
    rfalse;
];
[ I6_Rule_Shell_476 ;
    if ((((noun ofclass K28_memory)))) rfalse;
    return ACCESS_THROUGH_BARRIERS_R();
];
! Definitions of adjectives

! From the Standard Rules
! No specific request
! Definition:
[ R_0 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_1 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_2 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_3 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_4 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_5 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_6 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_7 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_8 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_39 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_40 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_41 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_42 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_43 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_44 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_45 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_46 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_47 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_48 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_49 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_50 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_51 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_52 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_53 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_54 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_55 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_56 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_57 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_58 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_59 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_60 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_61 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_62 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_63 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_64 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From the Standard Rules
! No specific request
! Definition:
[ R_93 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Epistemology" by Eric Eve
! No specific request
! Definition:
[ R_800 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Epistemology" by Eric Eve
! No specific request
! Definition:
[ R_801 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Essentials" by Philip Riley
! No specific request
! Definition:
[ R_949 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Essentials" by Philip Riley
! No specific request
! Definition:
[ R_950 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Essentials" by Philip Riley
! No specific request
! Definition:
[ R_951 
    t_0 ! Call parameter: object
    ;
    ! [2: if it is in the location]
    if (((real_location == ContainerOf(t_0))))
    {! [3: decide yes]
        rtrue;
        }
    ! [4: if it is container-here]
    if ((((Adj_45_t1_v10(t_0)))))
    {! [5: decide yes]
        rtrue;
        }
    ! [6: if it is in a container which is container-here]
    if (((ContainerOf(t_0) ofclass K5_container) && ((Adj_45_t1_v10(ContainerOf(t_0))))))
    {! [7: decide yes]
        rtrue;
        }
    ! [8: if it is on a supporter which is container-here]
    if (((SupporterOf(t_0) ofclass K6_supporter) && ((Adj_45_t1_v10(SupporterOf(t_0))))))
    {! [9: decide yes]
        rtrue;
        }
    ! [10: if it is held by a person who is available]
    if (((HolderOf(t_0) ofclass K8_person) && ((Adj_46_t1_v10(HolderOf(t_0))))))
    {! [11: decide yes]
        rtrue;
        }
    ! [12: decide no]
    rfalse;
    return false;
];
! From "Essentials" by Philip Riley
! No specific request
! Definition:
[ R_958 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Hearing" by Philip Riley
! No specific request
! Definition:
[ R_977 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Phones" by Philip Riley
! No specific request
! Definition:
[ R_1001 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Walls" by Philip Riley
! No specific request
! Definition:
[ R_1060 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Walls" by Philip Riley
! No specific request
! Definition:
[ R_1061 
    t_0 ! Call parameter: object
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: if it is wall-defined]
    if ((((Adj_50_t1_v10(t_0)))))
    {! [3: choose row with a locale of it in the table of walls]
        ct_0 = T5_walls; ct_1 = TableRowCorr(ct_0, 123, t_0);
        ! [4: if it is indoors and ( there is no has walls entry or the has walls entry is true )]
        if (((((Adj_122_t1_v10(t_0))))) && ((((ExistsTableLookUpEntry(ct_0,124,ct_1) == false))) || ((((TableLookUpEntry(ct_0,124,ct_1) && true) == (1 && true))))))
        {! [5: decide yes]
            rtrue;
            } else {
            ! [6: if ( it is outdoors or it is floating ) and ( there is a has walls entry and the has walls entry is true )]
            if ((((((Adj_123_t1_v10(t_0))))) || ((((Adj_124_t1_v10(t_0)))))) && ((((ExistsTableLookUpEntry(ct_0,124,ct_1)))) && ((((TableLookUpEntry(ct_0,124,ct_1) && true) == (1 && true))))))
            {! [7: decide yes]
                rtrue;
                } else {
                ! [8: decide no]
                rfalse;
                }
                }
                } else {
        ! [9: if it is indoors]
        if ((((Adj_122_t1_v10(t_0)))))
        {! [10: decide yes]
            rtrue;
            }
            }
    ! [11: decide no]
    rfalse;
    return false;
];
! From "Floors" by Philip Riley
! No specific request
! Definition:
[ R_1074 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Floors" by Philip Riley
! No specific request
! Definition:
[ R_1075 
    t_0 ! Call parameter: object
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: if it is floor-defined]
    if ((((Adj_52_t1_v10(t_0)))))
    {! [3: choose row with a locale of it in the table of floors]
        ct_0 = T6_floors; ct_1 = TableRowCorr(ct_0, 123, t_0);
        ! [4: if ( it is indoors or it is outdoors ) and ( there is no has floor entry or the has floor entry is true )]
        if ((((((Adj_122_t1_v10(t_0))))) || ((((Adj_123_t1_v10(t_0)))))) && ((((ExistsTableLookUpEntry(ct_0,127,ct_1) == false))) || ((((TableLookUpEntry(ct_0,127,ct_1) && true) == (1 && true))))))
        {! [5: decide yes]
            rtrue;
            } else {
            ! [6: if it is floating and ( there is a has floor entry and the has floor entry is true )]
            if (((((Adj_124_t1_v10(t_0))))) && ((((ExistsTableLookUpEntry(ct_0,127,ct_1)))) && ((((TableLookUpEntry(ct_0,127,ct_1) && true) == (1 && true))))))
            {! [7: decide yes]
                rtrue;
                } else {
                ! [8: decide no]
                rfalse;
                }
                }
                } else {
        ! [9: if it is indoors or it is outdoors]
        if (((((Adj_122_t1_v10(t_0))))) || ((((Adj_123_t1_v10(t_0))))))
        {! [10: decide yes]
            rtrue;
            }
            }
    ! [11: decide no]
    rfalse;
    return false;
];
! From "Ceilings" by Philip Riley
! No specific request
! Definition:
[ R_1087 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Ceilings" by Philip Riley
! No specific request
! Definition:
[ R_1088 
    t_0 ! Call parameter: object
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: if it is ceiling-defined]
    if ((((Adj_54_t1_v10(t_0)))))
    {! [3: choose row with a locale of it in the table of ceilings]
        ct_0 = T7_ceilings; ct_1 = TableRowCorr(ct_0, 123, t_0);
        ! [4: if it is indoors and ( there is no has ceiling entry or the has ceiling entry is true )]
        if (((((Adj_122_t1_v10(t_0))))) && ((((ExistsTableLookUpEntry(ct_0,129,ct_1) == false))) || ((((TableLookUpEntry(ct_0,129,ct_1) && true) == (1 && true))))))
        {! [5: decide yes]
            rtrue;
            } else {
            ! [6: if ( it is outdoors or it is floating ) and ( there is a has ceiling entry and the has ceiling entry is true )]
            if ((((((Adj_123_t1_v10(t_0))))) || ((((Adj_124_t1_v10(t_0)))))) && ((((ExistsTableLookUpEntry(ct_0,129,ct_1)))) && ((((TableLookUpEntry(ct_0,129,ct_1) && true) == (1 && true))))))
            {! [7: decide yes]
                rtrue;
                } else {
                ! [8: decide no]
                rfalse;
                }
                }
                } else {
        ! [9: if it is indoors]
        if ((((Adj_122_t1_v10(t_0)))))
        {! [10: decide yes]
            rtrue;
            }
            }
    ! [11: decide no]
    rfalse;
    return false;
];
! From "Ceilings" by Philip Riley
! No specific request
! Definition:
[ R_1089 
    t_0 ! Call parameter: object
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: if it is ceiling-defined]
    if ((((Adj_54_t1_v10(t_0)))))
    {! [3: choose row with a locale of it in the table of ceilings]
        ct_0 = T7_ceilings; ct_1 = TableRowCorr(ct_0, 123, t_0);
        ! [4: if there is a low ceiling entry and the low ceiling entry is true]
        if ((((ExistsTableLookUpEntry(ct_0,131,ct_1)))) && ((((TableLookUpEntry(ct_0,131,ct_1) && true) == (1 && true)))))
        {! [5: decide yes]
            rtrue;
            }
            }
    ! [6: decide no]
    rfalse;
    return false;
];
! From "Ceilings" by Philip Riley
! No specific request
! Definition:
[ R_1090 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Exit Lister" by Eric Eve
! No specific request
! Definition:
[ R_1135 
    t_0 ! Call parameter: object
    ;
    ! [2: decide on the truth state produced by the door appearance rules for it]
    return ResultOfRule(RULEBOOK_TY_to_RULE_TY(472), t_0, true, TRUTH_STATE_TY);
    return false;
];
! From "Exit Lister" by Eric Eve
! No specific request
! Definition:
[ R_1137 
    t_0 ! Call parameter: object
    ;
    ! [2: decide on the truth state produced by the room appearance rules for it]
    return ResultOfRule(RULEBOOK_TY_to_RULE_TY(473), t_0, true, TRUTH_STATE_TY);
    return false;
];
! From "Exit Lister" by Eric Eve
! No specific request
! Definition:
[ R_1140 
    t_0 ! Call parameter 'target room': object
    ;
    ! [2: if the target room is lighted]
    if ((((Adj_78_t1_v10(t_0)))))
    {! [3: decide yes]
        rtrue;
        }
    ! [4: move the light-meter to the target room]
    MoveObject(I208_light_meter, t_0, 0, false);
    ! [5: if the light-meter can see a lit thing]
    if ((((Prop_103()))))
    {! [6: decide yes]
        rtrue;
        }
    ! [7: remove the light-meter from play]
    RemoveFromPlay(I208_light_meter);
    ! [8: decide no]
    rfalse;
    return false;
];
! From "Exit Lister" by Eric Eve
! No specific request
! Definition:
[ R_1141 
    t_0 ! Call parameter 'target-destination': object
    ;
    ! [2: if dark-exits-invisible is false]
    if (((((Global_Vars-->30) && true) == (0 && true))))
    {! [3: decide no]
        rfalse;
        }
    ! [4: if not in darkness]
    if ((~~((((location==thedark))))))
    {! [5: decide no]
        rfalse;
        }
    ! [6: decide on whether or not target-destination is not light-filled]
    return ((((~~(((Adj_59_t1_v10(t_0))))))));
    return false;
];
! From "Choices" by Philip Riley
! No specific request
! Definition:
[ R_1170 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "New Light" by Philip Riley
! No specific request
! Definition:
[ R_1182 
    t_0 ! Call parameter: object
    tmp_0 ! Let/loop value, e.g., 'F': light source
    ;
    ! [2: if it contains a fluorescent light source ( called f )]
    if ((((Prop_104(t_0) && (tmp_0=deferred_calling_list-->0, true)) || (tmp_0 = 0,false))))
    {! [3: if f is lit]
        if ((((Adj_82_t1_v10(tmp_0)))))
        {! [4: decide yes]
            rtrue;
            }
            }
    ! [5: decide no]
    rfalse;
    return false;
];
! From "Memories" by Philip Riley
! No specific request
! Definition:
[ R_1193 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! Definition:
[ R_1215 
    t_0 ! Call parameter: object
    ;
    ! [2: if the current interlocutor is not a person]
    if (((~~(((Global_Vars-->11) ofclass K8_person)))))
    {! [3: no]
        rfalse;
        }
    ! [4: follow the availability rules for it]
    FollowRulebook(519, t_0, true);
    ! [5: if the outcome of the rulebook is the always available outcome]
    if ((((ResultOfRule()) == RBNO_21)))
    {! [6: yes]
        rtrue;
        }
    ! [7: if the outcome of the rulebook is the when queued outcome and it is listed in the queue of the current interlocutor]
    if (((((ResultOfRule()) == RBNO_22))) && (((LIST_OF_TY_FindItem(GProperty(OBJECT_TY, (Global_Vars-->11),p29_queue), t_0)))))
    {! [8: yes]
        rtrue;
        }
    ! [9: if the outcome of the rulebook is the unless not queued outcome and it is not listed in the queue of the current interlocutor]
    if (((((ResultOfRule()) == RBNO_23))) && (((LIST_OF_TY_FindItem(GProperty(OBJECT_TY, (Global_Vars-->11),p29_queue), t_0) == false))))
    {! [10: no]
        rfalse;
        }
    ! [11: no]
    rfalse;
    return false;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! Definition:
[ R_1216 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Simple Conversation" by Philip Riley
! No specific request
! Definition:
[ R_1223 
    t_0 ! Call parameter: object
    ;
    ! [2: if the current interlocutor is not a person]
    if (((~~(((Global_Vars-->11) ofclass K8_person)))))
    {! [3: no]
        rfalse;
        }
    ! [4: follow the plausibility rules for it]
    FollowRulebook(520, t_0, true);
    ! [5: if the outcome of the rulebook is the it is plausible outcome]
    if ((((ResultOfRule()) == RBNO_25)))
    {! [6: yes]
        rtrue;
        }
    ! [7: no]
    rfalse;
    return false;
];
! From "Glulx Entry Points" by Emily Short
! No specific request
! Definition:
[ R_1282 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Definition:
[ R_1346 
    t_0 ! Call parameter: object
    ;
    return false;
];
! From "Two-Sided Doors" by Philip Riley
! No specific request
! Definition:
[ R_1349 
    t_0 ! Call parameter: object
    ;
    return false;
];
[ Adj_0_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "worn"
      if (t_0 ofclass K2_thing) return ((((player == WearerOf(t_0)))));
    rfalse;
];
[ Adj_1_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "carried"
      if (t_0 ofclass K2_thing) return ((((player == CarrierOf(t_0)))));
    rfalse;
];
[ Adj_2_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "held"
      if (t_0 ofclass K2_thing) return ((((player == HolderOf(t_0)))));
    rfalse;
];
[ Adj_3_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "visible"
      if (t_0 ofclass K2_thing) return ((((TestVisibility(player,t_0)))));
    rfalse;
];
[ Adj_4_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "invisible"
      if (t_0 ofclass K2_thing) return (~~(((((TestVisibility(player,t_0)))))));
    rfalse;
];
[ Adj_5_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "touchable"
      if (t_0 ofclass K2_thing) return ((((TestTouchability(player,t_0)))));
    rfalse;
];
[ Adj_6_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "untouchable"
      if (t_0 ofclass K2_thing) return (~~(((((TestTouchability(player,t_0)))))));
    rfalse;
];
[ Adj_7_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "concealed"
      if (t_0 ofclass K2_thing) return ((((TestConcealment((HolderOf(t_0)),t_0)))));
    rfalse;
];
[ Adj_8_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "unconcealed"
      if (t_0 ofclass K2_thing) return (~~(((((TestConcealment((HolderOf(t_0)),t_0)))))));
    rfalse;
];
[ Adj_9_t1_v10 
    t_0 ! Call parameter: number
    ;
    ! meaning of "on-stage"
      if (t_0 ofclass K2_thing) return ((OnStage(t_0, -1)));
    rfalse;
];
[ Adj_10_t1_v10 
    t_0 ! Call parameter: number
    ;
    ! meaning of "off-stage"
      if (t_0 ofclass K2_thing) return (~~(((OnStage(t_0, -1)))));
    rfalse;
];
[ Adj_11_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "offstage"
      if (t_0 ofclass K2_thing) return (((((~~Adj_9_t1_v10(t_0))))));
    rfalse;
];
[ Adj_12_t1_v10 
    t_0 ! Call parameter: room
    ;
    ! meaning of "adjacent"
      if (t_0 ofclass K1_room) return ((((TestAdjacency(real_location,t_0)))));
    rfalse;
];
[ Adj_13_t1_v11 
    t_0 ! Call parameter: number
    ;
    ! meaning of "even"
    return (((((IntegerRemainder(t_0, 2)) == 0))));
    rfalse;
];
[ Adj_14_t1_v11 
    t_0 ! Call parameter: number
    ;
    ! meaning of "odd"
    return (~~((((((IntegerRemainder(t_0, 2)) == 0))))));
    rfalse;
];
[ Adj_15_t1_v11 
    t_0 ! Call parameter: number
    ;
    ! meaning of "positive"
    return ((((t_0 > 0))));
    rfalse;
];
[ Adj_15_t1_v12 
    t_0 ! Call parameter: real number
    ;
    ! meaning of "positive"
    return ((((REAL_NUMBER_TY_Compare(t_0, NUMBER_TY_to_REAL_NUMBER_TY(0)) > 0))));
    rfalse;
];
[ Adj_16_t1_v11 
    t_0 ! Call parameter: number
    ;
    ! meaning of "negative"
    return ((((t_0 < 0))));
    rfalse;
];
[ Adj_16_t1_v12 
    t_0 ! Call parameter: real number
    ;
    ! meaning of "negative"
    return ((((REAL_NUMBER_TY_Compare(t_0, NUMBER_TY_to_REAL_NUMBER_TY(0)) < 0))));
    rfalse;
];
[ Adj_17_t1_v14 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((TEXT_TY_Empty(t_0)));
    rfalse;
];
[ Adj_17_t1_v20 
    t_0 ! Call parameter: table name
    ;
    ! meaning of "empty"
    return ((((TableFilledRows(t_0) == 0))));
    rfalse;
];
[ Adj_17_t1_v32 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((RulebookEmpty(t_0)));
    rfalse;
];
[ Adj_17_t1_v33 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((ActivityEmpty(t_0)));
    rfalse;
];
[ Adj_17_t1_v34 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((LIST_OF_TY_Empty(t_0)));
    rfalse;
];
[ Adj_17_t1_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((RELATION_TY_Empty(t_0, -1)));
    rfalse;
];
[ Adj_18_t1_v14 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return (~~(((TEXT_TY_Empty(t_0)))));
    rfalse;
];
[ Adj_18_t1_v20 
    t_0 ! Call parameter: table name
    ;
    ! meaning of "non-empty"
    return (~~(((((TableFilledRows(t_0) == 0))))));
    rfalse;
];
[ Adj_18_t1_v32 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return (~~(((RulebookEmpty(t_0)))));
    rfalse;
];
[ Adj_18_t1_v33 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return (~~(((ActivityEmpty(t_0)))));
    rfalse;
];
[ Adj_18_t1_v34 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return (~~(((LIST_OF_TY_Empty(t_0)))));
    rfalse;
];
[ Adj_18_t1_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return (~~(((RELATION_TY_Empty(t_0, -1)))));
    rfalse;
];
[ Adj_19_t1_v14 
    t_0 ! Call parameter: number
    ;
    ! meaning of "substituted"
    return ((TEXT_TY_IsSubstituted(t_0)));
    rfalse;
];
[ Adj_20_t1_v14 
    t_0 ! Call parameter: number
    ;
    ! meaning of "unsubstituted"
    return (~~(((TEXT_TY_IsSubstituted(t_0)))));
    rfalse;
];
[ Adj_21_t1_v43 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "happening"
    return ((scene_status-->(t_0-1)==1));
    rfalse;
];
[ Adj_22_t1_v20 
    t_0 ! Call parameter: table name
    ;
    ! meaning of "full"
    return ((((TableBlankRows(t_0) == 0))));
    rfalse;
];
[ Adj_23_t1_v20 
    t_0 ! Call parameter: table name
    ;
    ! meaning of "non-full"
    return (~~(((((TableBlankRows(t_0) == 0))))));
    rfalse;
];
[ Adj_24_t1_v33 
    t_0 ! Call parameter: number
    ;
    ! meaning of "going on"
    return ((TestActivity(t_0)));
    rfalse;
];
[ Adj_25_t1_v16 
    t_0 ! Call parameter: number
    ;
    ! meaning of "active"
    return ((TestUseOption(t_0)));
    rfalse;
];
[ Adj_26_t1_v16 
    t_0 ! Call parameter: number
    ;
    ! meaning of "inactive"
    return (~~(((TestUseOption(t_0)))));
    rfalse;
];
[ Adj_27_t1_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "equivalence"
    return ((RELATION_TY_EquivalenceAdjective(t_0, -1)));
    rfalse;
];
[ Adj_28_t1_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "symmetric"
    return ((RELATION_TY_SymmetricAdjective(t_0, -1)));
    rfalse;
];
[ Adj_29_t1_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "one-to-one"
    return ((RELATION_TY_OToOAdjective(t_0, -1)));
    rfalse;
];
[ Adj_30_t1_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "one-to-various"
    return ((RELATION_TY_OToVAdjective(t_0, -1)));
    rfalse;
];
[ Adj_31_t1_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "various-to-one"
    return ((RELATION_TY_VToOAdjective(t_0, -1)));
    rfalse;
];
[ Adj_32_t1_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "various-to-various"
    return ((RELATION_TY_VToVAdjective(t_0, -1)));
    rfalse;
];
[ Adj_33_t1_v18 
    t_0 ! Call parameter: number
    ;
    ! meaning of "modal"
    return ((VerbIsModal(t_0)));
    rfalse;
];
[ Adj_34_t1_v18 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-modal"
    return (~~(((VerbIsModal(t_0)))));
    rfalse;
];
[ Adj_35_t1_v18 
    t_0 ! Call parameter: number
    ;
    ! meaning of "meaningful"
    return ((VerbIsMeaningful(t_0)));
    rfalse;
];
[ Adj_36_t1_v18 
    t_0 ! Call parameter: number
    ;
    ! meaning of "meaningless"
    return (~~(((VerbIsMeaningful(t_0)))));
    rfalse;
];
[ Adj_37_t1_v12 
    t_0 ! Call parameter: real number
    ;
    ! meaning of "infinite"
    return ((((( REAL_NUMBER_TY_Compare(t_0, 2139095040) == 0))) || ((( REAL_NUMBER_TY_Compare(t_0, -8388608) == 0)))));
    rfalse;
];
[ Adj_38_t1_v12 
    t_0 ! Call parameter: real number
    ;
    ! meaning of "finite"
    return (~~(((((( REAL_NUMBER_TY_Compare(t_0, 2139095040) == 0))) || ((( REAL_NUMBER_TY_Compare(t_0, -8388608) == 0)))))));
    rfalse;
];
[ Adj_39_t1_v12 
    t_0 ! Call parameter: number
    ;
    ! meaning of "nonexistent"
    return ((REAL_NUMBER_TY_Nan(t_0)));
    rfalse;
];
[ Adj_40_t1_v12 
    t_0 ! Call parameter: number
    ;
    ! meaning of "existent"
    return (~~(((REAL_NUMBER_TY_Nan(t_0)))));
    rfalse;
];
[ Adj_41_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "locale-supportable"
      if (t_0 ofclass K2_thing) return (((((~~(((Adj_88_t1_v10(t_0))))))) && ((((~~(((Adj_96_t1_v10(t_0))))))) && (((~~(((Adj_93_t1_v10(t_0))))))))));
    rfalse;
];
[ Adj_42_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "known"
      if (t_0 ofclass K2_thing) return ((((((Adj_118_t1_v10(t_0))))) || ((((Adj_116_t1_v10(t_0)))))));
    rfalse;
];
[ Adj_43_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "unknown"
      if (t_0 ofclass K2_thing) return ((((~~(((Adj_42_t1_v10(t_0))))))));
    rfalse;
];
[ Adj_44_t1_v10 
    t_0 ! Call parameter: region
    ;
    ! meaning of "player-containing"
      if (t_0 ofclass K9_region) return ((((TestRegionalContainment(player,t_0)))));
    rfalse;
];
[ Adj_45_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "container-here"
      if (t_0 ofclass K2_thing) return (((((ContainerOf(t_0) ofclass K5_container) && (real_location == ContainerOf(ContainerOf(t_0))))) || (((SupporterOf(t_0) ofclass K6_supporter) && (real_location == ContainerOf(SupporterOf(t_0)))))));
    rfalse;
];
[ Adj_46_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "available"
      if (t_0 ofclass K2_thing) return ((R_951(t_0)));
      if (t_0) return (GetEitherOrProperty(t_0, p136_available));
    rfalse;
];
[ Adj_47_t1_v10 
    t_0 ! Call parameter: room
    ;
    ! meaning of "powered"
      if (t_0 ofclass K1_room) return ((((ContainerOf(t_0) ofclass K9_region) && ((Adj_47_t1_v10(ContainerOf(t_0)))))));
      if (t_0) return (GetEitherOrProperty(t_0, p99_powered));
    rfalse;
];
[ Adj_48_t1_v10 
    t_0 ! Call parameter: thing
    ;
    ! meaning of "hearable"
      if (t_0 ofclass K2_thing) return (((((GProperty(10, t_0,p16_hearability) == I173_very_loud))) || ((((GProperty(10, t_0,p16_hearability) == I174_loud))) || ((((GProperty(10, t_0,p16_hearability) == I175_moderately_loud))) || ((((GProperty(10, t_0,p16_hearability) == I176_faint))) || (((GProperty(10, t_0,p16_hearability) == I177_very_faint))))))));
    rfalse;
];
[ Adj_49_t1_v10 
    t_0 ! Call parameter: person
    ;
    ! meaning of "phoning"
      if (t_0 ofclass K8_person) return ((((((RGuard_f1_5(t_0)) ofclass K20_phone))) || ((((Prop_105(t_0)))))));
    rfalse;
];
[ Adj_50_t1_v10 
    t_0 ! Call parameter: room
    ;
    ! meaning of "wall-defined"
      if (t_0 ofclass K1_room) return ((((ExistsTableLookUpCorr(T5_walls,123,123,t_0)))));
    rfalse;
];
[ Adj_51_t1_v10 
    t_0 ! Call parameter: room
    ;
    ! meaning of "walled"
      if (t_0 ofclass K1_room) return ((R_1061(t_0)));
    rfalse;
];
[ Adj_52_t1_v10 
    t_0 ! Call parameter: room
    ;
    ! meaning of "floor-defined"
      if (t_0 ofclass K1_room) return ((((ExistsTableLookUpCorr(T6_floors,123,123,t_0)))));
    rfalse;
];
[ Adj_53_t1_v10 
    t_0 ! Call parameter: room
    ;
    ! meaning of "floored"
      if (t_0 ofclass K1_room) return ((R_1075(t_0)));
    rfalse;
];
[ Adj_54_t1_v10 
    t_0 ! Call parameter: room
    ;
    ! meaning of "ceiling-defined"
      if (t_0 ofclass K1_room) return ((((ExistsTableLookUpCorr(T7_ceilings,123,123,t_0)))));
    rfalse;
];
[ Adj_55_t1_v10 
    t_0 ! Call parameter: room
    ;
    ! meaning of "ceilinged"
      if (t_0 ofclass K1_room) return ((R_1088(t_0)));
    rfalse;
];
[ Adj_56_t1_v10 
    t_0 ! Call parameter: room
    ;
    ! meaning of "low-ceilinged"
      if (t_0 ofclass K1_room) return ((R_1089(t_0)));
    rfalse;
];
[ Adj_57_t1_v10 
    t_0 ! Call parameter: room
    ;
    ! meaning of "ceiling-touchable"
      if (t_0 ofclass K1_room) return ((((((Adj_55_t1_v10(t_0))))) && ((((Adj_56_t1_v10(t_0)))))));
    rfalse;
];
[ Adj_58_t1_v10 
    t_0 ! Call parameter: door
    ;
    ! meaning of "apparent"
      if (t_0 ofclass K4_door) return ((R_1135(t_0)));
      if (t_0 ofclass K1_room) return ((R_1137(t_0)));
    rfalse;
];
[ Adj_59_t1_v10 
    t_0 ! Call parameter: room
    ;
    ! meaning of "light-filled"
      if (t_0 ofclass K1_room) return ((R_1140(t_0)));
    rfalse;
];
[ Adj_60_t1_v10 
    t_0 ! Call parameter: room
    ;
    ! meaning of "darkness-occluded"
      if (t_0 ofclass K1_room) return ((R_1141(t_0)));
    rfalse;
];
[ Adj_61_t1_v10 
    t_0 ! Call parameter: choice
    ;
    ! meaning of "unexhausted"
      if (t_0 ofclass K26_choice) return ((((~~(((Adj_147_t1_v10(t_0))))))));
    rfalse;
];
[ Adj_62_t1_v10 
    t_0 ! Call parameter: room
    ;
    ! meaning of "fluorescent-lit"
      if (t_0 ofclass K1_room) return ((R_1182(t_0)));
    rfalse;
];
[ Adj_63_t1_v10 
    t_0 ! Call parameter: memory
    ;
    ! meaning of "remembered"
      if (t_0 ofclass K28_memory) return ((((LIST_OF_TY_FindItem(GProperty(10, player,p26_remembrances), t_0)))));
    rfalse;
];
[ Adj_64_t1_v10 
    t_0 ! Call parameter: quip
    ;
    ! meaning of "q-available"
      if (t_0 ofclass K29_quip) return ((R_1215(t_0)));
    rfalse;
];
[ Adj_65_t1_v10 
    t_0 ! Call parameter: quip
    ;
    ! meaning of "off-limits"
      if (t_0 ofclass K29_quip) return ((((~~(((Adj_64_t1_v10(t_0))))))));
    rfalse;
];
[ Adj_66_t1_v10 
    t_0 ! Call parameter: quip
    ;
    ! meaning of "plausible"
      if (t_0 ofclass K29_quip) return ((R_1223(t_0)));
    rfalse;
];
[ Adj_67_t1_v67 
    t_0 ! Call parameter: g-event
    ;
    ! meaning of "independent of the player"
    return (((((t_0 == I266_timer_event))) || ((((t_0 == I272_sound_notify_event))) || ((((t_0 == I270_arrange_event))) || (((t_0 == I271_redraw_event)))))));
    rfalse;
];
[ Adj_68_t1_v67 
    t_0 ! Call parameter: g-event
    ;
    ! meaning of "dependent on the player"
    return (~~((((((t_0 == I266_timer_event))) || ((((t_0 == I272_sound_notify_event))) || ((((t_0 == I270_arrange_event))) || (((t_0 == I271_redraw_event)))))))));
    rfalse;
];
[ Adj_69_t1_v10 
    t_0 ! Call parameter: two-sided door
    ;
    ! meaning of "effectively locked"
      if (t_0 ofclass K30_two_sided_door) return ((((((LocationOf(player) == GProperty(10, t_0,p30_frontside)))) && ((((Adj_160_t1_v10(t_0)))))) || ((((LocationOf(player) == (PHR_1345_r44 (t_0))))) && ((((Adj_161_t1_v10(t_0))))))));
    rfalse;
];
[ Adj_70_t1_v10 
    t_0 ! Call parameter: two-sided door
    ;
    ! meaning of "describable"
      if (t_0 ofclass K30_two_sided_door) return (((((GProperty(10, t_0,p35_description_policy) == I282_describe_always))) || (((((Adj_101_t1_v10(t_0))))) && (((GProperty(10, t_0,p35_description_policy) == I283_only_open))))));
    rfalse;
];
[ Adj_71_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "plural-named"
      if (t_0) return (GetEitherOrProperty(t_0, pluralname));
    rfalse;
];
[ Adj_72_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "singular-named"
      if (t_0) return (GetEitherOrProperty(t_0, pluralname) == false);
    rfalse;
];
[ Adj_73_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "proper-named"
      if (t_0) return (GetEitherOrProperty(t_0, proper));
    rfalse;
];
[ Adj_74_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "improper-named"
      if (t_0) return (GetEitherOrProperty(t_0, proper) == false);
    rfalse;
];
[ Adj_75_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "ambiguously plural"
      if (t_0) return (GetEitherOrProperty(t_0, ambigpluralname));
    rfalse;
];
[ Adj_76_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "privately-named"
      if (t_0) return (GetEitherOrProperty(t_0, privately_named));
    rfalse;
];
[ Adj_77_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "publicly-named"
      if (t_0) return (GetEitherOrProperty(t_0, privately_named) == false);
    rfalse;
];
[ Adj_78_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lighted"
      if (t_0) return (GetEitherOrProperty(t_0, light));
    rfalse;
];
[ Adj_79_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "dark"
      if (t_0) return (GetEitherOrProperty(t_0, light) == false);
    rfalse;
];
[ Adj_80_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "visited"
      if (t_0) return (GetEitherOrProperty(t_0, visited));
    rfalse;
];
[ Adj_81_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unvisited"
      if (t_0) return (GetEitherOrProperty(t_0, visited) == false);
    rfalse;
];
[ Adj_82_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lit"
      if (t_0) return (GetEitherOrProperty(t_0, light));
    rfalse;
];
[ Adj_83_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unlit"
      if (t_0) return (GetEitherOrProperty(t_0, light) == false);
    rfalse;
];
[ Adj_84_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "edible"
      if (t_0) return (GetEitherOrProperty(t_0, edible));
    rfalse;
];
[ Adj_85_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "inedible"
      if (t_0) return (GetEitherOrProperty(t_0, edible) == false);
    rfalse;
];
[ Adj_86_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "fixed in place"
      if (t_0) return (GetEitherOrProperty(t_0, static));
    rfalse;
];
[ Adj_87_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "portable"
      if (t_0) return (GetEitherOrProperty(t_0, static) == false);
    rfalse;
];
[ Adj_88_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "scenery"
      if (t_0) return (GetEitherOrProperty(t_0, scenery));
    rfalse;
];
[ Adj_89_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "wearable"
      if (t_0) return (GetEitherOrProperty(t_0, clothing));
    rfalse;
];
[ Adj_90_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "pushable between rooms"
      if (t_0) return (GetEitherOrProperty(t_0, pushable));
    rfalse;
];
[ Adj_91_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "handled"
      if (t_0) return (GetEitherOrProperty(t_0, moved));
    rfalse;
];
[ Adj_92_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "described"
      if (t_0) return (GetEitherOrProperty(t_0, concealed) == false);
    rfalse;
];
[ Adj_93_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "undescribed"
      if (t_0) return (GetEitherOrProperty(t_0, concealed));
    rfalse;
];
[ Adj_94_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "marked for listing"
      if (t_0) return (GetEitherOrProperty(t_0, workflag));
    rfalse;
];
[ Adj_95_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmarked for listing"
      if (t_0) return (GetEitherOrProperty(t_0, workflag) == false);
    rfalse;
];
[ Adj_96_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "mentioned"
      if (t_0) return (GetEitherOrProperty(t_0, mentioned));
    rfalse;
];
[ Adj_97_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmentioned"
      if (t_0) return (GetEitherOrProperty(t_0, mentioned) == false);
    rfalse;
];
[ Adj_98_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "enterable"
      if (t_0) return (GetEitherOrProperty(t_0, enterable));
    rfalse;
];
[ Adj_99_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "opaque"
      if (t_0) return (GetEitherOrProperty(t_0, transparent) == false);
    rfalse;
];
[ Adj_100_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "transparent"
      if (t_0) return (GetEitherOrProperty(t_0, transparent));
    rfalse;
];
[ Adj_101_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "open"
      if (t_0) return (GetEitherOrProperty(t_0, open));
    rfalse;
];
[ Adj_102_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "closed"
      if (t_0) return (GetEitherOrProperty(t_0, open) == false);
    rfalse;
];
[ Adj_103_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "openable"
      if (t_0) return (GetEitherOrProperty(t_0, openable));
    rfalse;
];
[ Adj_104_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unopenable"
      if (t_0) return (GetEitherOrProperty(t_0, openable) == false);
    rfalse;
];
[ Adj_105_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lockable"
      if (t_0) return (GetEitherOrProperty(t_0, lockable));
    rfalse;
];
[ Adj_106_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "locked"
      if (t_0) return (GetEitherOrProperty(t_0, locked));
    rfalse;
];
[ Adj_107_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unlocked"
      if (t_0) return (GetEitherOrProperty(t_0, locked) == false);
    rfalse;
];
[ Adj_108_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "neuter"
      if (t_0) return (GetEitherOrProperty(t_0, neuter));
    rfalse;
];
[ Adj_109_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "male"
      if (t_0) return (GetEitherOrProperty(t_0, male));
    rfalse;
];
[ Adj_110_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "female"
      if (t_0) return (GetEitherOrProperty(t_0, female));
    rfalse;
];
[ Adj_111_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "nomale"
      if (t_0) return (GetEitherOrProperty(t_0, nomale));
    rfalse;
];
[ Adj_112_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "switched on"
      if (t_0) return (GetEitherOrProperty(t_0, on));
    rfalse;
];
[ Adj_113_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "switched off"
      if (t_0) return (GetEitherOrProperty(t_0, on) == false);
    rfalse;
];
[ Adj_114_t1_v43 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "recurring"
    return (GProperty(SCENE_TY, t_0, p93_recurring));
    rfalse;
];
[ Adj_115_t1_v43 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "non-recurring"
    return (GProperty(SCENE_TY, t_0, p93_recurring) == false);
    rfalse;
];
[ Adj_116_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "seen"
      if (t_0) return (GetEitherOrProperty(t_0, p95_seen));
    rfalse;
];
[ Adj_117_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unseen"
      if (t_0) return (GetEitherOrProperty(t_0, p95_seen) == false);
    rfalse;
];
[ Adj_118_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "familiar"
      if (t_0) return (GetEitherOrProperty(t_0, p97_familiar));
    rfalse;
];
[ Adj_119_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unfamiliar"
      if (t_0) return (GetEitherOrProperty(t_0, p97_familiar) == false);
    rfalse;
];
[ Adj_120_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "dimly lit"
      if (t_0) return (GetEitherOrProperty(t_0, p100_dimly_lit));
    rfalse;
];
[ Adj_121_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "fully lit"
      if (t_0) return (GetEitherOrProperty(t_0, p100_dimly_lit) == false);
    rfalse;
];
[ Adj_122_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "indoors"
      if (t_0) return (GProperty(10, t_0, p102_room_condition) == 1);
      if (t_0) return (GProperty(10, t_0, p102_room_condition) == 1);
    rfalse;
];
[ Adj_123_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "outdoors"
      if (t_0) return (GProperty(10, t_0, p102_room_condition) == 2);
      if (t_0) return (GProperty(10, t_0, p102_room_condition) == 2);
    rfalse;
];
[ Adj_124_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "floating"
      if (t_0) return (GProperty(10, t_0, p102_room_condition) == 3);
      if (t_0) return (GProperty(10, t_0, p102_room_condition) == 3);
    rfalse;
];
[ Adj_125_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "rainy"
      if (t_0) return (GetEitherOrProperty(t_0, p103_rainy));
    rfalse;
];
[ Adj_126_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "sunny"
      if (t_0) return (GetEitherOrProperty(t_0, p103_rainy) == false);
    rfalse;
];
[ Adj_127_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "outdoor-adjacent"
      if (t_0) return (GetEitherOrProperty(t_0, p105_outdoor_adjacent));
    rfalse;
];
[ Adj_128_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "audible"
      if (t_0) return (GetEitherOrProperty(t_0, p108_audible));
    rfalse;
];
[ Adj_129_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "noisy"
      if (t_0) return (GetEitherOrProperty(t_0, p109_noisy));
    rfalse;
];
[ Adj_130_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "quiet"
      if (t_0) return (GetEitherOrProperty(t_0, p109_noisy) == false);
    rfalse;
];
[ Adj_131_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "insistent"
      if (t_0) return (GetEitherOrProperty(t_0, p111_insistent));
    rfalse;
];
[ Adj_132_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "background"
      if (t_0) return (GetEitherOrProperty(t_0, p111_insistent) == false);
    rfalse;
];
[ Adj_133_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "ringing"
      if (t_0) return (GProperty(10, t_0, p113_phone_condition) == 1);
    rfalse;
];
[ Adj_134_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "idle"
      if (t_0) return (GProperty(10, t_0, p113_phone_condition) == 2);
    rfalse;
];
[ Adj_135_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "in use"
      if (t_0) return (GProperty(10, t_0, p113_phone_condition) == 3);
    rfalse;
];
[ Adj_136_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "caller id"
      if (t_0) return (GetEitherOrProperty(t_0, p114_caller_id));
    rfalse;
];
[ Adj_137_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "mobile"
      if (t_0) return (GetEitherOrProperty(t_0, p115_mobile));
    rfalse;
];
[ Adj_138_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "wired"
      if (t_0) return (GetEitherOrProperty(t_0, p115_mobile) == false);
    rfalse;
];
[ Adj_139_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "identifiable"
      if (t_0) return (GetEitherOrProperty(t_0, p117_identifiable));
    rfalse;
];
[ Adj_140_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unidentifiable"
      if (t_0) return (GetEitherOrProperty(t_0, p117_identifiable) == false);
    rfalse;
];
[ Adj_141_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "mc-enabled"
      if (t_0) return (GetEitherOrProperty(t_0, p123_mc_enabled));
    rfalse;
];
[ Adj_142_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "mc-disabled"
      if (t_0) return (GetEitherOrProperty(t_0, p123_mc_enabled) == false);
    rfalse;
];
[ Adj_143_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "always-indefinite"
      if (t_0) return (GetEitherOrProperty(t_0, p127_always_indefinite));
    rfalse;
];
[ Adj_144_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "activated"
      if (t_0) return (GetEitherOrProperty(t_0, p128_activated));
    rfalse;
];
[ Adj_145_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "marked for special listing"
      if (t_0) return (GetEitherOrProperty(t_0, p129_marked_for_special_list));
    rfalse;
];
[ Adj_146_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmarked for special listing"
      if (t_0) return (GetEitherOrProperty(t_0, p129_marked_for_special_list) == false);
    rfalse;
];
[ Adj_147_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "exhausted"
      if (t_0) return (GetEitherOrProperty(t_0, p137_exhausted));
    rfalse;
];
[ Adj_148_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "fluorescent"
      if (t_0) return (GetEitherOrProperty(t_0, p139_fluorescent));
    rfalse;
];
[ Adj_149_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "one-shot"
      if (t_0) return (GetEitherOrProperty(t_0, p141_one_shot));
    rfalse;
];
[ Adj_150_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "repeatable"
      if (t_0) return (GetEitherOrProperty(t_0, p141_one_shot) == false);
    rfalse;
];
[ Adj_151_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "questioning"
      if (t_0) return (GProperty(10, t_0, p143_quip_condition) == 1);
    rfalse;
];
[ Adj_152_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "informative"
      if (t_0) return (GProperty(10, t_0, p143_quip_condition) == 2);
    rfalse;
];
[ Adj_153_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "performative"
      if (t_0) return (GProperty(10, t_0, p143_quip_condition) == 3);
    rfalse;
];
[ Adj_154_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "ubiquitous"
      if (t_0) return (GProperty(10, t_0, p144_quip_condition_2) == 1);
    rfalse;
];
[ Adj_155_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "ignored"
      if (t_0) return (GProperty(10, t_0, p144_quip_condition_2) == 2);
    rfalse;
];
[ Adj_156_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "plausibility-normal"
      if (t_0) return (GProperty(10, t_0, p144_quip_condition_2) == 3);
    rfalse;
];
[ Adj_157_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "universal"
      if (t_0) return (GetEitherOrProperty(t_0, p145_universal));
    rfalse;
];
[ Adj_158_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "always-available"
      if (t_0) return (GetEitherOrProperty(t_0, p146_always_available));
    rfalse;
];
[ Adj_159_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "hyperspatial"
      if (t_0) return (GetEitherOrProperty(t_0, p152_hyperspatial));
    rfalse;
];
[ Adj_160_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "front-locked"
      if (t_0) return (GetEitherOrProperty(t_0, p153_front_locked));
    rfalse;
];
[ Adj_161_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "back-locked"
      if (t_0) return (GetEitherOrProperty(t_0, p154_back_locked));
    rfalse;
];
[ Adj_162_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "front-openable"
      if (t_0) return (GetEitherOrProperty(t_0, p155_front_openable));
    rfalse;
];
[ Adj_163_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "back-openable"
      if (t_0) return (GetEitherOrProperty(t_0, p156_back_openable));
    rfalse;
];
[ Adj_164_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "front-closable"
      if (t_0) return (GetEitherOrProperty(t_0, p157_front_closable));
    rfalse;
];
[ Adj_165_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "back-closable"
      if (t_0) return (GetEitherOrProperty(t_0, p158_back_closable));
    rfalse;
];
[ Adj_166_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "front-locks-the-back"
      if (t_0) return (GetEitherOrProperty(t_0, p159_front_locks_the_back));
    rfalse;
];
[ Adj_167_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "front-locks-the-front"
      if (t_0) return (GetEitherOrProperty(t_0, p160_front_locks_the_front));
    rfalse;
];
[ Adj_168_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "back-locks-the-back"
      if (t_0) return (GetEitherOrProperty(t_0, p161_back_locks_the_back));
    rfalse;
];
[ Adj_169_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "back-locks-the-front"
      if (t_0) return (GetEitherOrProperty(t_0, p162_back_locks_the_front));
    rfalse;
];
[ Adj_170_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "close-lock-the-back"
      if (t_0) return (GetEitherOrProperty(t_0, p163_close_lock_the_back));
    rfalse;
];
[ Adj_171_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "close-lock-the-front"
      if (t_0) return (GetEitherOrProperty(t_0, p164_close_lock_the_front));
    rfalse;
];
[ Adj_172_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "autolock-the-back"
      if (t_0) return (GetEitherOrProperty(t_0, p165_autolock_the_back));
    rfalse;
];
[ Adj_173_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "autolock-the-front"
      if (t_0) return (GetEitherOrProperty(t_0, p166_autolock_the_front));
    rfalse;
];
[ Adj_174_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "auto-closable"
      if (t_0) return (GetEitherOrProperty(t_0, p167_auto_closable));
    rfalse;
];
[ Adj_175_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "time-locked"
      if (t_0) return (GetEitherOrProperty(t_0, p168_time_locked));
    rfalse;
];
[ Adj_176_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "swipable"
      if (t_0) return (GetEitherOrProperty(t_0, p169_swipable));
    rfalse;
];
[ Adj_177_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (GetEitherOrProperty(t_0, absent));
    rfalse;
];
[ Adj_178_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (GetEitherOrProperty(t_0, mark_as_room));
    rfalse;
];
[ Adj_179_t1_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (GetEitherOrProperty(t_0, mark_as_thing));
    rfalse;
];
[ Adj_9_t2_v10 
    t_0 ! Call parameter: number
    ;
    ! meaning of "on-stage"
      if (t_0 ofclass K2_thing) return ((OnStage(t_0, true)));
    rfalse;
];
[ Adj_10_t2_v10 
    t_0 ! Call parameter: number
    ;
    ! meaning of "off-stage"
      if (t_0 ofclass K2_thing) return ((OnStage(t_0, false)));
    rfalse;
];
[ Adj_17_t2_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((RELATION_TY_Empty(t_0, true)));
    rfalse;
];
[ Adj_18_t2_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return ((RELATION_TY_Empty(t_0, false)));
    rfalse;
];
[ Adj_27_t2_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "equivalence"
    return ((RELATION_TY_EquivalenceAdjective(t_0, true)));
    rfalse;
];
[ Adj_28_t2_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "symmetric"
    return ((RELATION_TY_SymmetricAdjective(t_0, true)));
    rfalse;
];
[ Adj_29_t2_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "one-to-one"
    return ((RELATION_TY_OToOAdjective(t_0, true)));
    rfalse;
];
[ Adj_30_t2_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "one-to-various"
    return ((RELATION_TY_OToVAdjective(t_0, true)));
    rfalse;
];
[ Adj_31_t2_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "various-to-one"
    return ((RELATION_TY_VToOAdjective(t_0, true)));
    rfalse;
];
[ Adj_32_t2_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "various-to-various"
    return ((RELATION_TY_VToVAdjective(t_0, true)));
    rfalse;
];
[ Adj_46_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "available"
      if (t_0) return (SetEitherOrProperty(t_0, p136_available));
    rfalse;
];
[ Adj_47_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "powered"
      if (t_0) return (SetEitherOrProperty(t_0, p99_powered));
    rfalse;
];
[ Adj_71_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "plural-named"
      if (t_0) return (SetEitherOrProperty(t_0, pluralname));
    rfalse;
];
[ Adj_72_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "singular-named"
      if (t_0) return (SetEitherOrProperty(t_0, pluralname, true));
    rfalse;
];
[ Adj_73_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "proper-named"
      if (t_0) return (SetEitherOrProperty(t_0, proper));
    rfalse;
];
[ Adj_74_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "improper-named"
      if (t_0) return (SetEitherOrProperty(t_0, proper, true));
    rfalse;
];
[ Adj_75_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "ambiguously plural"
      if (t_0) return (SetEitherOrProperty(t_0, ambigpluralname));
    rfalse;
];
[ Adj_76_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "privately-named"
      if (t_0) return (SetEitherOrProperty(t_0, privately_named));
    rfalse;
];
[ Adj_77_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "publicly-named"
      if (t_0) return (SetEitherOrProperty(t_0, privately_named, true));
    rfalse;
];
[ Adj_78_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lighted"
      if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];
[ Adj_79_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "dark"
      if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];
[ Adj_80_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "visited"
      if (t_0) return (SetEitherOrProperty(t_0, visited));
    rfalse;
];
[ Adj_81_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unvisited"
      if (t_0) return (SetEitherOrProperty(t_0, visited, true));
    rfalse;
];
[ Adj_82_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lit"
      if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];
[ Adj_83_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unlit"
      if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];
[ Adj_84_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "edible"
      if (t_0) return (SetEitherOrProperty(t_0, edible));
    rfalse;
];
[ Adj_85_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "inedible"
      if (t_0) return (SetEitherOrProperty(t_0, edible, true));
    rfalse;
];
[ Adj_86_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "fixed in place"
      if (t_0) return (SetEitherOrProperty(t_0, static));
    rfalse;
];
[ Adj_87_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "portable"
      if (t_0) return (SetEitherOrProperty(t_0, static, true));
    rfalse;
];
[ Adj_88_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "scenery"
      if (t_0) return (SetEitherOrProperty(t_0, scenery));
    rfalse;
];
[ Adj_89_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "wearable"
      if (t_0) return (SetEitherOrProperty(t_0, clothing));
    rfalse;
];
[ Adj_90_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "pushable between rooms"
      if (t_0) return (SetEitherOrProperty(t_0, pushable));
    rfalse;
];
[ Adj_91_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "handled"
      if (t_0) return (SetEitherOrProperty(t_0, moved));
    rfalse;
];
[ Adj_92_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "described"
      if (t_0) return (SetEitherOrProperty(t_0, concealed, true));
    rfalse;
];
[ Adj_93_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "undescribed"
      if (t_0) return (SetEitherOrProperty(t_0, concealed));
    rfalse;
];
[ Adj_94_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "marked for listing"
      if (t_0) return (SetEitherOrProperty(t_0, workflag));
    rfalse;
];
[ Adj_95_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmarked for listing"
      if (t_0) return (SetEitherOrProperty(t_0, workflag, true));
    rfalse;
];
[ Adj_96_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "mentioned"
      if (t_0) return (SetEitherOrProperty(t_0, mentioned));
    rfalse;
];
[ Adj_97_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmentioned"
      if (t_0) return (SetEitherOrProperty(t_0, mentioned, true));
    rfalse;
];
[ Adj_98_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "enterable"
      if (t_0) return (SetEitherOrProperty(t_0, enterable));
    rfalse;
];
[ Adj_99_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "opaque"
      if (t_0) return (SetEitherOrProperty(t_0, transparent, true));
    rfalse;
];
[ Adj_100_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "transparent"
      if (t_0) return (SetEitherOrProperty(t_0, transparent));
    rfalse;
];
[ Adj_101_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "open"
      if (t_0) return (SetEitherOrProperty(t_0, open));
    rfalse;
];
[ Adj_102_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "closed"
      if (t_0) return (SetEitherOrProperty(t_0, open, true));
    rfalse;
];
[ Adj_103_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "openable"
      if (t_0) return (SetEitherOrProperty(t_0, openable));
    rfalse;
];
[ Adj_104_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unopenable"
      if (t_0) return (SetEitherOrProperty(t_0, openable, true));
    rfalse;
];
[ Adj_105_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lockable"
      if (t_0) return (SetEitherOrProperty(t_0, lockable));
    rfalse;
];
[ Adj_106_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "locked"
      if (t_0) return (SetEitherOrProperty(t_0, locked));
    rfalse;
];
[ Adj_107_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unlocked"
      if (t_0) return (SetEitherOrProperty(t_0, locked, true));
    rfalse;
];
[ Adj_108_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "neuter"
      if (t_0) return (SetEitherOrProperty(t_0, neuter));
    rfalse;
];
[ Adj_109_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "male"
      if (t_0) return (SetEitherOrProperty(t_0, male));
    rfalse;
];
[ Adj_110_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "female"
      if (t_0) return (SetEitherOrProperty(t_0, female));
    rfalse;
];
[ Adj_111_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "nomale"
      if (t_0) return (SetEitherOrProperty(t_0, nomale));
    rfalse;
];
[ Adj_112_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "switched on"
      if (t_0) return (SetEitherOrProperty(t_0, on));
    rfalse;
];
[ Adj_113_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "switched off"
      if (t_0) return (SetEitherOrProperty(t_0, on, true));
    rfalse;
];
[ Adj_114_t2_v43 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "recurring"
    return (WriteGProperty(SCENE_TY, t_0, p93_recurring, true));
    rfalse;
];
[ Adj_115_t2_v43 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "non-recurring"
    return (WriteGProperty(SCENE_TY, t_0, p93_recurring));
    rfalse;
];
[ Adj_116_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "seen"
      if (t_0) return (SetEitherOrProperty(t_0, p95_seen));
    rfalse;
];
[ Adj_117_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unseen"
      if (t_0) return (SetEitherOrProperty(t_0, p95_seen, true));
    rfalse;
];
[ Adj_118_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "familiar"
      if (t_0) return (SetEitherOrProperty(t_0, p97_familiar));
    rfalse;
];
[ Adj_119_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unfamiliar"
      if (t_0) return (SetEitherOrProperty(t_0, p97_familiar, true));
    rfalse;
];
[ Adj_120_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "dimly lit"
      if (t_0) return (SetEitherOrProperty(t_0, p100_dimly_lit));
    rfalse;
];
[ Adj_121_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "fully lit"
      if (t_0) return (SetEitherOrProperty(t_0, p100_dimly_lit, true));
    rfalse;
];
[ Adj_122_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "indoors"
      if (t_0) return (WriteGProperty(10, t_0, p102_room_condition, 1));
      if (t_0) return (WriteGProperty(10, t_0, p102_room_condition, 1));
    rfalse;
];
[ Adj_123_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "outdoors"
      if (t_0) return (WriteGProperty(10, t_0, p102_room_condition, 2));
      if (t_0) return (WriteGProperty(10, t_0, p102_room_condition, 2));
    rfalse;
];
[ Adj_124_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "floating"
      if (t_0) return (WriteGProperty(10, t_0, p102_room_condition, 3));
      if (t_0) return (WriteGProperty(10, t_0, p102_room_condition, 3));
    rfalse;
];
[ Adj_125_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "rainy"
      if (t_0) return (SetEitherOrProperty(t_0, p103_rainy));
    rfalse;
];
[ Adj_126_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "sunny"
      if (t_0) return (SetEitherOrProperty(t_0, p103_rainy, true));
    rfalse;
];
[ Adj_127_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "outdoor-adjacent"
      if (t_0) return (SetEitherOrProperty(t_0, p105_outdoor_adjacent));
    rfalse;
];
[ Adj_128_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "audible"
      if (t_0) return (SetEitherOrProperty(t_0, p108_audible));
    rfalse;
];
[ Adj_129_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "noisy"
      if (t_0) return (SetEitherOrProperty(t_0, p109_noisy));
    rfalse;
];
[ Adj_130_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "quiet"
      if (t_0) return (SetEitherOrProperty(t_0, p109_noisy, true));
    rfalse;
];
[ Adj_131_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "insistent"
      if (t_0) return (SetEitherOrProperty(t_0, p111_insistent));
    rfalse;
];
[ Adj_132_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "background"
      if (t_0) return (SetEitherOrProperty(t_0, p111_insistent, true));
    rfalse;
];
[ Adj_133_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "ringing"
      if (t_0) return (WriteGProperty(10, t_0, p113_phone_condition, 1));
    rfalse;
];
[ Adj_134_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "idle"
      if (t_0) return (WriteGProperty(10, t_0, p113_phone_condition, 2));
    rfalse;
];
[ Adj_135_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "in use"
      if (t_0) return (WriteGProperty(10, t_0, p113_phone_condition, 3));
    rfalse;
];
[ Adj_136_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "caller id"
      if (t_0) return (SetEitherOrProperty(t_0, p114_caller_id));
    rfalse;
];
[ Adj_137_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "mobile"
      if (t_0) return (SetEitherOrProperty(t_0, p115_mobile));
    rfalse;
];
[ Adj_138_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "wired"
      if (t_0) return (SetEitherOrProperty(t_0, p115_mobile, true));
    rfalse;
];
[ Adj_139_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "identifiable"
      if (t_0) return (SetEitherOrProperty(t_0, p117_identifiable));
    rfalse;
];
[ Adj_140_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unidentifiable"
      if (t_0) return (SetEitherOrProperty(t_0, p117_identifiable, true));
    rfalse;
];
[ Adj_141_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "mc-enabled"
      if (t_0) return (SetEitherOrProperty(t_0, p123_mc_enabled));
    rfalse;
];
[ Adj_142_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "mc-disabled"
      if (t_0) return (SetEitherOrProperty(t_0, p123_mc_enabled, true));
    rfalse;
];
[ Adj_143_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "always-indefinite"
      if (t_0) return (SetEitherOrProperty(t_0, p127_always_indefinite));
    rfalse;
];
[ Adj_144_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "activated"
      if (t_0) return (SetEitherOrProperty(t_0, p128_activated));
    rfalse;
];
[ Adj_145_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "marked for special listing"
      if (t_0) return (SetEitherOrProperty(t_0, p129_marked_for_special_list));
    rfalse;
];
[ Adj_146_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmarked for special listing"
      if (t_0) return (SetEitherOrProperty(t_0, p129_marked_for_special_list, true));
    rfalse;
];
[ Adj_147_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "exhausted"
      if (t_0) return (SetEitherOrProperty(t_0, p137_exhausted));
    rfalse;
];
[ Adj_148_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "fluorescent"
      if (t_0) return (SetEitherOrProperty(t_0, p139_fluorescent));
    rfalse;
];
[ Adj_149_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "one-shot"
      if (t_0) return (SetEitherOrProperty(t_0, p141_one_shot));
    rfalse;
];
[ Adj_150_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "repeatable"
      if (t_0) return (SetEitherOrProperty(t_0, p141_one_shot, true));
    rfalse;
];
[ Adj_151_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "questioning"
      if (t_0) return (WriteGProperty(10, t_0, p143_quip_condition, 1));
    rfalse;
];
[ Adj_152_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "informative"
      if (t_0) return (WriteGProperty(10, t_0, p143_quip_condition, 2));
    rfalse;
];
[ Adj_153_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "performative"
      if (t_0) return (WriteGProperty(10, t_0, p143_quip_condition, 3));
    rfalse;
];
[ Adj_154_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "ubiquitous"
      if (t_0) return (WriteGProperty(10, t_0, p144_quip_condition_2, 1));
    rfalse;
];
[ Adj_155_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "ignored"
      if (t_0) return (WriteGProperty(10, t_0, p144_quip_condition_2, 2));
    rfalse;
];
[ Adj_156_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "plausibility-normal"
      if (t_0) return (WriteGProperty(10, t_0, p144_quip_condition_2, 3));
    rfalse;
];
[ Adj_157_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "universal"
      if (t_0) return (SetEitherOrProperty(t_0, p145_universal));
    rfalse;
];
[ Adj_158_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "always-available"
      if (t_0) return (SetEitherOrProperty(t_0, p146_always_available));
    rfalse;
];
[ Adj_159_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "hyperspatial"
      if (t_0) return (SetEitherOrProperty(t_0, p152_hyperspatial));
    rfalse;
];
[ Adj_160_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "front-locked"
      if (t_0) return (SetEitherOrProperty(t_0, p153_front_locked));
    rfalse;
];
[ Adj_161_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "back-locked"
      if (t_0) return (SetEitherOrProperty(t_0, p154_back_locked));
    rfalse;
];
[ Adj_162_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "front-openable"
      if (t_0) return (SetEitherOrProperty(t_0, p155_front_openable));
    rfalse;
];
[ Adj_163_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "back-openable"
      if (t_0) return (SetEitherOrProperty(t_0, p156_back_openable));
    rfalse;
];
[ Adj_164_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "front-closable"
      if (t_0) return (SetEitherOrProperty(t_0, p157_front_closable));
    rfalse;
];
[ Adj_165_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "back-closable"
      if (t_0) return (SetEitherOrProperty(t_0, p158_back_closable));
    rfalse;
];
[ Adj_166_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "front-locks-the-back"
      if (t_0) return (SetEitherOrProperty(t_0, p159_front_locks_the_back));
    rfalse;
];
[ Adj_167_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "front-locks-the-front"
      if (t_0) return (SetEitherOrProperty(t_0, p160_front_locks_the_front));
    rfalse;
];
[ Adj_168_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "back-locks-the-back"
      if (t_0) return (SetEitherOrProperty(t_0, p161_back_locks_the_back));
    rfalse;
];
[ Adj_169_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "back-locks-the-front"
      if (t_0) return (SetEitherOrProperty(t_0, p162_back_locks_the_front));
    rfalse;
];
[ Adj_170_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "close-lock-the-back"
      if (t_0) return (SetEitherOrProperty(t_0, p163_close_lock_the_back));
    rfalse;
];
[ Adj_171_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "close-lock-the-front"
      if (t_0) return (SetEitherOrProperty(t_0, p164_close_lock_the_front));
    rfalse;
];
[ Adj_172_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "autolock-the-back"
      if (t_0) return (SetEitherOrProperty(t_0, p165_autolock_the_back));
    rfalse;
];
[ Adj_173_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "autolock-the-front"
      if (t_0) return (SetEitherOrProperty(t_0, p166_autolock_the_front));
    rfalse;
];
[ Adj_174_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "auto-closable"
      if (t_0) return (SetEitherOrProperty(t_0, p167_auto_closable));
    rfalse;
];
[ Adj_175_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "time-locked"
      if (t_0) return (SetEitherOrProperty(t_0, p168_time_locked));
    rfalse;
];
[ Adj_176_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "swipable"
      if (t_0) return (SetEitherOrProperty(t_0, p169_swipable));
    rfalse;
];
[ Adj_177_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, absent));
    rfalse;
];
[ Adj_178_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, mark_as_room));
    rfalse;
];
[ Adj_179_t2_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, mark_as_thing));
    rfalse;
];
[ Adj_9_t3_v10 
    t_0 ! Call parameter: number
    ;
    ! meaning of "on-stage"
      if (t_0 ofclass K2_thing) return ((OnStage(t_0, false)));
    rfalse;
];
[ Adj_10_t3_v10 
    t_0 ! Call parameter: number
    ;
    ! meaning of "off-stage"
      if (t_0 ofclass K2_thing) return ((OnStage(t_0, true)));
    rfalse;
];
[ Adj_17_t3_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "empty"
    return ((RELATION_TY_Empty(t_0, false)));
    rfalse;
];
[ Adj_18_t3_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "non-empty"
    return ((RELATION_TY_Empty(t_0, true)));
    rfalse;
];
[ Adj_27_t3_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "equivalence"
    return ((RELATION_TY_EquivalenceAdjective(t_0, false)));
    rfalse;
];
[ Adj_28_t3_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "symmetric"
    return ((RELATION_TY_SymmetricAdjective(t_0, false)));
    rfalse;
];
[ Adj_29_t3_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "one-to-one"
    return ((RELATION_TY_OToOAdjective(t_0, false)));
    rfalse;
];
[ Adj_30_t3_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "one-to-various"
    return ((RELATION_TY_OToVAdjective(t_0, false)));
    rfalse;
];
[ Adj_31_t3_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "various-to-one"
    return ((RELATION_TY_VToOAdjective(t_0, false)));
    rfalse;
];
[ Adj_32_t3_v30 
    t_0 ! Call parameter: number
    ;
    ! meaning of "various-to-various"
    return ((RELATION_TY_VToVAdjective(t_0, false)));
    rfalse;
];
[ Adj_46_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "available"
      if (t_0) return (SetEitherOrProperty(t_0, p136_available, true));
    rfalse;
];
[ Adj_47_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "powered"
      if (t_0) return (SetEitherOrProperty(t_0, p99_powered, true));
    rfalse;
];
[ Adj_71_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "plural-named"
      if (t_0) return (SetEitherOrProperty(t_0, pluralname, true));
    rfalse;
];
[ Adj_72_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "singular-named"
      if (t_0) return (SetEitherOrProperty(t_0, pluralname));
    rfalse;
];
[ Adj_73_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "proper-named"
      if (t_0) return (SetEitherOrProperty(t_0, proper, true));
    rfalse;
];
[ Adj_74_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "improper-named"
      if (t_0) return (SetEitherOrProperty(t_0, proper));
    rfalse;
];
[ Adj_75_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "ambiguously plural"
      if (t_0) return (SetEitherOrProperty(t_0, ambigpluralname, true));
    rfalse;
];
[ Adj_76_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "privately-named"
      if (t_0) return (SetEitherOrProperty(t_0, privately_named, true));
    rfalse;
];
[ Adj_77_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "publicly-named"
      if (t_0) return (SetEitherOrProperty(t_0, privately_named));
    rfalse;
];
[ Adj_78_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lighted"
      if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];
[ Adj_79_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "dark"
      if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];
[ Adj_80_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "visited"
      if (t_0) return (SetEitherOrProperty(t_0, visited, true));
    rfalse;
];
[ Adj_81_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unvisited"
      if (t_0) return (SetEitherOrProperty(t_0, visited));
    rfalse;
];
[ Adj_82_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lit"
      if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];
[ Adj_83_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unlit"
      if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];
[ Adj_84_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "edible"
      if (t_0) return (SetEitherOrProperty(t_0, edible, true));
    rfalse;
];
[ Adj_85_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "inedible"
      if (t_0) return (SetEitherOrProperty(t_0, edible));
    rfalse;
];
[ Adj_86_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "fixed in place"
      if (t_0) return (SetEitherOrProperty(t_0, static, true));
    rfalse;
];
[ Adj_87_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "portable"
      if (t_0) return (SetEitherOrProperty(t_0, static));
    rfalse;
];
[ Adj_88_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "scenery"
      if (t_0) return (SetEitherOrProperty(t_0, scenery, true));
    rfalse;
];
[ Adj_89_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "wearable"
      if (t_0) return (SetEitherOrProperty(t_0, clothing, true));
    rfalse;
];
[ Adj_90_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "pushable between rooms"
      if (t_0) return (SetEitherOrProperty(t_0, pushable, true));
    rfalse;
];
[ Adj_91_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "handled"
      if (t_0) return (SetEitherOrProperty(t_0, moved, true));
    rfalse;
];
[ Adj_92_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "described"
      if (t_0) return (SetEitherOrProperty(t_0, concealed));
    rfalse;
];
[ Adj_93_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "undescribed"
      if (t_0) return (SetEitherOrProperty(t_0, concealed, true));
    rfalse;
];
[ Adj_94_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "marked for listing"
      if (t_0) return (SetEitherOrProperty(t_0, workflag, true));
    rfalse;
];
[ Adj_95_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmarked for listing"
      if (t_0) return (SetEitherOrProperty(t_0, workflag));
    rfalse;
];
[ Adj_96_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "mentioned"
      if (t_0) return (SetEitherOrProperty(t_0, mentioned, true));
    rfalse;
];
[ Adj_97_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmentioned"
      if (t_0) return (SetEitherOrProperty(t_0, mentioned));
    rfalse;
];
[ Adj_98_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "enterable"
      if (t_0) return (SetEitherOrProperty(t_0, enterable, true));
    rfalse;
];
[ Adj_99_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "opaque"
      if (t_0) return (SetEitherOrProperty(t_0, transparent));
    rfalse;
];
[ Adj_100_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "transparent"
      if (t_0) return (SetEitherOrProperty(t_0, transparent, true));
    rfalse;
];
[ Adj_101_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "open"
      if (t_0) return (SetEitherOrProperty(t_0, open, true));
    rfalse;
];
[ Adj_102_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "closed"
      if (t_0) return (SetEitherOrProperty(t_0, open));
    rfalse;
];
[ Adj_103_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "openable"
      if (t_0) return (SetEitherOrProperty(t_0, openable, true));
    rfalse;
];
[ Adj_104_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unopenable"
      if (t_0) return (SetEitherOrProperty(t_0, openable));
    rfalse;
];
[ Adj_105_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "lockable"
      if (t_0) return (SetEitherOrProperty(t_0, lockable, true));
    rfalse;
];
[ Adj_106_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "locked"
      if (t_0) return (SetEitherOrProperty(t_0, locked, true));
    rfalse;
];
[ Adj_107_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unlocked"
      if (t_0) return (SetEitherOrProperty(t_0, locked));
    rfalse;
];
[ Adj_108_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "neuter"
      if (t_0) return (SetEitherOrProperty(t_0, neuter, true));
    rfalse;
];
[ Adj_109_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "male"
      if (t_0) return (SetEitherOrProperty(t_0, male, true));
    rfalse;
];
[ Adj_110_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "female"
      if (t_0) return (SetEitherOrProperty(t_0, female, true));
    rfalse;
];
[ Adj_111_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "nomale"
      if (t_0) return (SetEitherOrProperty(t_0, nomale, true));
    rfalse;
];
[ Adj_112_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "switched on"
      if (t_0) return (SetEitherOrProperty(t_0, on, true));
    rfalse;
];
[ Adj_113_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "switched off"
      if (t_0) return (SetEitherOrProperty(t_0, on));
    rfalse;
];
[ Adj_114_t3_v43 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "recurring"
    return (WriteGProperty(SCENE_TY, t_0, p93_recurring));
    rfalse;
];
[ Adj_115_t3_v43 
    t_0 ! Call parameter: scene
    ;
    ! meaning of "non-recurring"
    return (WriteGProperty(SCENE_TY, t_0, p93_recurring, true));
    rfalse;
];
[ Adj_116_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "seen"
      if (t_0) return (SetEitherOrProperty(t_0, p95_seen, true));
    rfalse;
];
[ Adj_117_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unseen"
      if (t_0) return (SetEitherOrProperty(t_0, p95_seen));
    rfalse;
];
[ Adj_118_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "familiar"
      if (t_0) return (SetEitherOrProperty(t_0, p97_familiar, true));
    rfalse;
];
[ Adj_119_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unfamiliar"
      if (t_0) return (SetEitherOrProperty(t_0, p97_familiar));
    rfalse;
];
[ Adj_120_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "dimly lit"
      if (t_0) return (SetEitherOrProperty(t_0, p100_dimly_lit, true));
    rfalse;
];
[ Adj_121_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "fully lit"
      if (t_0) return (SetEitherOrProperty(t_0, p100_dimly_lit));
    rfalse;
];
[ Adj_125_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "rainy"
      if (t_0) return (SetEitherOrProperty(t_0, p103_rainy, true));
    rfalse;
];
[ Adj_126_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "sunny"
      if (t_0) return (SetEitherOrProperty(t_0, p103_rainy));
    rfalse;
];
[ Adj_127_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "outdoor-adjacent"
      if (t_0) return (SetEitherOrProperty(t_0, p105_outdoor_adjacent, true));
    rfalse;
];
[ Adj_128_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "audible"
      if (t_0) return (SetEitherOrProperty(t_0, p108_audible, true));
    rfalse;
];
[ Adj_129_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "noisy"
      if (t_0) return (SetEitherOrProperty(t_0, p109_noisy, true));
    rfalse;
];
[ Adj_130_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "quiet"
      if (t_0) return (SetEitherOrProperty(t_0, p109_noisy));
    rfalse;
];
[ Adj_131_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "insistent"
      if (t_0) return (SetEitherOrProperty(t_0, p111_insistent, true));
    rfalse;
];
[ Adj_132_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "background"
      if (t_0) return (SetEitherOrProperty(t_0, p111_insistent));
    rfalse;
];
[ Adj_136_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "caller id"
      if (t_0) return (SetEitherOrProperty(t_0, p114_caller_id, true));
    rfalse;
];
[ Adj_137_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "mobile"
      if (t_0) return (SetEitherOrProperty(t_0, p115_mobile, true));
    rfalse;
];
[ Adj_138_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "wired"
      if (t_0) return (SetEitherOrProperty(t_0, p115_mobile));
    rfalse;
];
[ Adj_139_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "identifiable"
      if (t_0) return (SetEitherOrProperty(t_0, p117_identifiable, true));
    rfalse;
];
[ Adj_140_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unidentifiable"
      if (t_0) return (SetEitherOrProperty(t_0, p117_identifiable));
    rfalse;
];
[ Adj_141_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "mc-enabled"
      if (t_0) return (SetEitherOrProperty(t_0, p123_mc_enabled, true));
    rfalse;
];
[ Adj_142_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "mc-disabled"
      if (t_0) return (SetEitherOrProperty(t_0, p123_mc_enabled));
    rfalse;
];
[ Adj_143_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "always-indefinite"
      if (t_0) return (SetEitherOrProperty(t_0, p127_always_indefinite, true));
    rfalse;
];
[ Adj_144_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "activated"
      if (t_0) return (SetEitherOrProperty(t_0, p128_activated, true));
    rfalse;
];
[ Adj_145_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "marked for special listing"
      if (t_0) return (SetEitherOrProperty(t_0, p129_marked_for_special_list, true));
    rfalse;
];
[ Adj_146_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "unmarked for special listing"
      if (t_0) return (SetEitherOrProperty(t_0, p129_marked_for_special_list));
    rfalse;
];
[ Adj_147_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "exhausted"
      if (t_0) return (SetEitherOrProperty(t_0, p137_exhausted, true));
    rfalse;
];
[ Adj_148_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "fluorescent"
      if (t_0) return (SetEitherOrProperty(t_0, p139_fluorescent, true));
    rfalse;
];
[ Adj_149_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "one-shot"
      if (t_0) return (SetEitherOrProperty(t_0, p141_one_shot, true));
    rfalse;
];
[ Adj_150_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "repeatable"
      if (t_0) return (SetEitherOrProperty(t_0, p141_one_shot));
    rfalse;
];
[ Adj_157_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "universal"
      if (t_0) return (SetEitherOrProperty(t_0, p145_universal, true));
    rfalse;
];
[ Adj_158_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "always-available"
      if (t_0) return (SetEitherOrProperty(t_0, p146_always_available, true));
    rfalse;
];
[ Adj_159_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "hyperspatial"
      if (t_0) return (SetEitherOrProperty(t_0, p152_hyperspatial, true));
    rfalse;
];
[ Adj_160_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "front-locked"
      if (t_0) return (SetEitherOrProperty(t_0, p153_front_locked, true));
    rfalse;
];
[ Adj_161_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "back-locked"
      if (t_0) return (SetEitherOrProperty(t_0, p154_back_locked, true));
    rfalse;
];
[ Adj_162_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "front-openable"
      if (t_0) return (SetEitherOrProperty(t_0, p155_front_openable, true));
    rfalse;
];
[ Adj_163_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "back-openable"
      if (t_0) return (SetEitherOrProperty(t_0, p156_back_openable, true));
    rfalse;
];
[ Adj_164_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "front-closable"
      if (t_0) return (SetEitherOrProperty(t_0, p157_front_closable, true));
    rfalse;
];
[ Adj_165_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "back-closable"
      if (t_0) return (SetEitherOrProperty(t_0, p158_back_closable, true));
    rfalse;
];
[ Adj_166_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "front-locks-the-back"
      if (t_0) return (SetEitherOrProperty(t_0, p159_front_locks_the_back, true));
    rfalse;
];
[ Adj_167_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "front-locks-the-front"
      if (t_0) return (SetEitherOrProperty(t_0, p160_front_locks_the_front, true));
    rfalse;
];
[ Adj_168_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "back-locks-the-back"
      if (t_0) return (SetEitherOrProperty(t_0, p161_back_locks_the_back, true));
    rfalse;
];
[ Adj_169_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "back-locks-the-front"
      if (t_0) return (SetEitherOrProperty(t_0, p162_back_locks_the_front, true));
    rfalse;
];
[ Adj_170_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "close-lock-the-back"
      if (t_0) return (SetEitherOrProperty(t_0, p163_close_lock_the_back, true));
    rfalse;
];
[ Adj_171_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "close-lock-the-front"
      if (t_0) return (SetEitherOrProperty(t_0, p164_close_lock_the_front, true));
    rfalse;
];
[ Adj_172_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "autolock-the-back"
      if (t_0) return (SetEitherOrProperty(t_0, p165_autolock_the_back, true));
    rfalse;
];
[ Adj_173_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "autolock-the-front"
      if (t_0) return (SetEitherOrProperty(t_0, p166_autolock_the_front, true));
    rfalse;
];
[ Adj_174_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "auto-closable"
      if (t_0) return (SetEitherOrProperty(t_0, p167_auto_closable, true));
    rfalse;
];
[ Adj_175_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "time-locked"
      if (t_0) return (SetEitherOrProperty(t_0, p168_time_locked, true));
    rfalse;
];
[ Adj_176_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "swipable"
      if (t_0) return (SetEitherOrProperty(t_0, p169_swipable, true));
    rfalse;
];
[ Adj_177_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, absent, true));
    rfalse;
];
[ Adj_178_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, mark_as_room, true));
    rfalse;
];
[ Adj_179_t3_v10 
    t_0 ! Call parameter: object
    ;
    ! meaning of "<nameless>"
      if (t_0) return (SetEitherOrProperty(t_0, mark_as_thing, true));
    rfalse;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Timed Events
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array TimedEventsTable table 0 0;

Array TimedEventTimesTable table 0 0;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Rulebooks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


Array rulebooks_array --> B0_startup B1_turn_sequence B2_shutdown B3_scene_changing B4_when_play_begins B5_when_play_ends B6_when_scene_begins B7_when_scene_ends B8_every_turn B9_action_processing B10_setting_action_variables B11_specific_action_processi B12_player_s_action_awarenes B13_accessibility B14_reaching_inside B15_reaching_outside B16_visibility B17_persuasion B18_unsuccessful_attempt_by B19_before B20_instead B21_check B22_carry_out B23_after B24_report B25_does_the_player_mean B26_multiple_action_processi B27_when_entire_game_begins B28_when_entire_game_ends B29_before_printing_the_name B30_for_printing_the_name B31_after_printing_the_name B32_before_printing_the_plur B33_for_printing_the_plural_ B34_after_printing_the_plura B35_before_printing_a_number B36_for_printing_a_number B37_after_printing_a_number B38_before_printing_room_des B39_for_printing_room_descri B40_after_printing_room_desc B41_before_printing_inventor B42_for_printing_inventory_d B43_after_printing_inventory B44_before_listing_contents B45_for_listing_contents B46_after_listing_contents B47_before_grouping_together B48_for_grouping_together B49_after_grouping_together B50_before_writing_a_paragra B51_for_writing_a_paragraph_ B52_after_writing_a_paragrap B53_before_listing_nondescri B54_for_listing_nondescript_ B55_after_listing_nondescrip B56_before_printing_the_name B57_for_printing_the_name_of B58_after_printing_the_name_ B59_before_printing_the_desc B60_for_printing_the_descrip B61_after_printing_the_descr B62_before_printing_the_anno B63_for_printing_the_announc B64_after_printing_the_annou B65_before_printing_the_anno B66_for_printing_the_announc B67_after_printing_the_annou B68_before_printing_a_refusa B69_for_printing_a_refusal_t B70_after_printing_a_refusal B71_before_constructing_the_ B72_for_constructing_the_sta B73_after_constructing_the_s B74_before_printing_the_bann B75_for_printing_the_banner_ B76_after_printing_the_banne B77_before_reading_a_command B78_for_reading_a_command B79_after_reading_a_command B80_before_deciding_the_scop B81_for_deciding_the_scope B82_after_deciding_the_scope B83_before_deciding_the_conc B84_for_deciding_the_conceal B85_after_deciding_the_conce B86_before_deciding_whether_ B87_for_deciding_whether_all B88_after_deciding_whether_a B89_before_clarifying_the_pa B90_for_clarifying_the_parse B91_after_clarifying_the_par B92_before_asking_which_do_y B93_for_asking_which_do_you_ B94_after_asking_which_do_yo B95_before_printing_a_parser B96_for_printing_a_parser_er B97_after_printing_a_parser_ B98_before_supplying_a_missi B99_for_supplying_a_missing_ B100_after_supplying_a_missi B101_before_supplying_a_miss B102_for_supplying_a_missing B103_after_supplying_a_missi B104_before_implicitly_takin B105_for_implicitly_taking B106_after_implicitly_taking B107_before_starting_the_vir B108_for_starting_the_virtua B109_after_starting_the_virt B110_before_amusing_a_victor B111_for_amusing_a_victoriou B112_after_amusing_a_victori B113_before_printing_the_pla B114_for_printing_the_player B115_after_printing_the_play B116_before_handling_the_fin B117_for_handling_the_final_ B118_after_handling_the_fina B119_before_printing_the_loc B120_for_printing_the_locale B121_after_printing_the_loca B122_before_choosing_notable B123_for_choosing_notable_lo B124_after_choosing_notable_ B125_before_printing_a_local B126_for_printing_a_locale_p B127_after_printing_a_locale B128_before_issuing_the_resp B129_for_issuing_the_respons B130_after_issuing_the_respo B131_check_taking_inventory B132_carry_out_taking_invent B133_report_taking_inventory B134_check_taking B135_carry_out_taking B136_report_taking B137_check_removing_it_from B138_carry_out_removing_it_f B139_report_removing_it_from B140_check_dropping B141_carry_out_dropping B142_report_dropping B143_check_putting_it_on B144_carry_out_putting_it_on B145_report_putting_it_on B146_check_inserting_it_into B147_carry_out_inserting_it_ B148_report_inserting_it_int B149_check_eating B150_carry_out_eating B151_report_eating B152_check_going B153_carry_out_going B154_report_going B155_check_entering B156_carry_out_entering B157_report_entering B158_check_exiting B159_carry_out_exiting B160_report_exiting B161_check_getting_off B162_carry_out_getting_off B163_report_getting_off B164_check_looking B165_carry_out_looking B166_report_looking B167_check_examining B168_carry_out_examining B169_report_examining B170_check_looking_under B171_carry_out_looking_under B172_report_looking_under B173_check_searching B174_carry_out_searching B175_report_searching B176_check_consulting_it_abo B177_carry_out_consulting_it B178_report_consulting_it_ab B179_check_locking_it_with B180_carry_out_locking_it_wi B181_report_locking_it_with B182_check_unlocking_it_with B183_carry_out_unlocking_it_ B184_report_unlocking_it_wit B185_check_switching_on B186_carry_out_switching_on B187_report_switching_on B188_check_switching_off B189_carry_out_switching_off B190_report_switching_off B191_check_opening B192_carry_out_opening B193_report_opening B194_check_closing B195_carry_out_closing B196_report_closing B197_check_wearing B198_carry_out_wearing B199_report_wearing B200_check_taking_off B201_carry_out_taking_off B202_report_taking_off B203_check_giving_it_to B204_carry_out_giving_it_to B205_report_giving_it_to B206_check_showing_it_to B207_carry_out_showing_it_to B208_report_showing_it_to B209_check_waking B210_carry_out_waking B211_report_waking B212_check_throwing_it_at B213_carry_out_throwing_it_a B214_report_throwing_it_at B215_check_attacking B216_carry_out_attacking B217_report_attacking B218_check_kissing B219_carry_out_kissing B220_report_kissing B221_check_answering_it_that B222_carry_out_answering_it_ B223_report_answering_it_tha B224_check_telling_it_about B225_carry_out_telling_it_ab B226_report_telling_it_about B227_check_asking_it_about B228_carry_out_asking_it_abo B229_report_asking_it_about B230_check_asking_it_for B231_carry_out_asking_it_for B232_report_asking_it_for B233_check_waiting B234_carry_out_waiting B235_report_waiting B236_check_touching B237_carry_out_touching B238_report_touching B239_check_waving B240_carry_out_waving B241_report_waving B242_check_pulling B243_carry_out_pulling B244_report_pulling B245_check_pushing B246_carry_out_pushing B247_report_pushing B248_check_turning B249_carry_out_turning B250_report_turning B251_check_pushing_it_to B252_carry_out_pushing_it_to B253_report_pushing_it_to B254_check_squeezing B255_carry_out_squeezing B256_report_squeezing B257_check_saying_yes B258_carry_out_saying_yes B259_report_saying_yes B260_check_saying_no B261_carry_out_saying_no B262_report_saying_no B263_check_cutting B264_carry_out_cutting B265_report_cutting B266_check_saying_sorry B267_carry_out_saying_sorry B268_report_saying_sorry B269_check_rubbing B270_carry_out_rubbing B271_report_rubbing B272_check_buying B273_carry_out_buying B274_report_buying B275_check_quitting_the_game B276_carry_out_quitting_the_ B277_report_quitting_the_gam B278_check_saving_the_game B279_carry_out_saving_the_ga B280_report_saving_the_game B281_check_restoring_the_gam B282_carry_out_restoring_the B283_report_restoring_the_ga B284_check_restarting_the_ga B285_carry_out_restarting_th B286_report_restarting_the_g B287_check_verifying_the_sto B288_carry_out_verifying_the B289_report_verifying_the_st B290_check_switching_the_sto B291_carry_out_switching_the B292_report_switching_the_st B293_check_switching_the_sto B294_carry_out_switching_the B295_report_switching_the_st B296_check_requesting_the_st B297_carry_out_requesting_th B298_report_requesting_the_s B299_check_requesting_the_sc B300_carry_out_requesting_th B301_report_requesting_the_s B302_check_preferring_abbrev B303_carry_out_preferring_ab B304_report_preferring_abbre B305_check_preferring_unabbr B306_carry_out_preferring_un B307_report_preferring_unabb B308_check_preferring_someti B309_carry_out_preferring_so B310_report_preferring_somet B311_check_switching_score_n B312_carry_out_switching_sco B313_report_switching_score_ B314_check_switching_score_n B315_carry_out_switching_sco B316_report_switching_score_ B317_check_requesting_the_pr B318_carry_out_requesting_th B319_report_requesting_the_p B320_check_requesting_episte B321_carry_out_requesting_ep B322_report_requesting_epist B323_check_requesting_it_for B324_carry_out_requesting_it B325_report_requesting_it_fo B326_check_imploring_it_for B327_carry_out_imploring_it_ B328_report_imploring_it_for B329_check_quizzing_it_about B330_carry_out_quizzing_it_a B331_report_quizzing_it_abou B332_check_informing_it_abou B333_carry_out_informing_it_ B334_report_informing_it_abo B335_check_implicit_asking B336_carry_out_implicit_aski B337_report_implicit_asking B338_check_implicit_telling B339_carry_out_implicit_tell B340_report_implicit_telling B341_check_implicit_quizzing B342_carry_out_implicit_quiz B343_report_implicit_quizzin B344_check_implicit_informin B345_carry_out_implicit_info B346_report_implicit_informi B347_check_implicit_requesti B348_carry_out_implicit_requ B349_report_implicit_request B350_check_implicit_implorin B351_carry_out_implicit_impl B352_report_implicit_implori B353_check_saying_hello_to B354_carry_out_saying_hello_ B355_report_saying_hello_to B356_check_hailing B357_carry_out_hailing B358_report_hailing B359_check_leavetaking B360_carry_out_leavetaking B361_report_leavetaking B362_check_saying_goodbye_to B363_carry_out_saying_goodby B364_report_saying_goodbye_t B365_response B366_greeting_response B367_farewell_response B368_implicit_greeting_respo B369_implicit_farewell_respo B370_default_ask_response B371_default_ask_tell_respon B372_default_tell_response B373_default_answer_response B374_default_ask_for_respons B375_default_give_response B376_default_show_response B377_default_give_show_respo B378_default_yes_no_response B379_default_response B380_before_pausing_the_game B381_for_pausing_the_game B382_after_pausing_the_game B383_escape_detection B384_check_helping B385_carry_out_helping B386_report_helping B387_check_asking_for_identi B388_carry_out_asking_for_id B389_report_asking_for_ident B390_check_questioning_motiv B391_carry_out_questioning_m B392_report_questioning_moti B393_check_promising B394_carry_out_promising B395_report_promising B396_audibility_of B397_noisiness_of B398_before_printing_insiste B399_for_printing_insistent_ B400_after_printing_insisten B401_before_printing_backgro B402_for_printing_background B403_after_printing_backgrou B404_before_determining_the_ B405_for_determining_the_sub B406_after_determining_the_s B407_before_printing_the_sou B408_for_printing_the_sound_ B409_after_printing_the_soun B410_before_printing_the_sou B411_for_printing_the_sound_ B412_after_printing_the_soun B413_check_calling_it_on B414_carry_out_calling_it_on B415_report_calling_it_on B416_check_cold_calling_it_o B417_carry_out_cold_calling_ B418_report_cold_calling_it_ B419_check_answering B420_carry_out_answering B421_report_answering B422_check_picking_up B423_carry_out_picking_up B424_report_picking_up B425_check_ending_a_call B426_carry_out_ending_a_call B427_report_ending_a_call B428_check_hanging_up B429_carry_out_hanging_up B430_report_hanging_up B431_check_signing_off_with B432_carry_out_signing_off_w B433_report_signing_off_with B434_check_buying_it_with B435_carry_out_buying_it_wit B436_report_buying_it_with B437_check_pricing_it B438_carry_out_pricing_it B439_report_pricing_it B440_check_accounting B441_carry_out_accounting B442_report_accounting B443_check_attributing_it B444_carry_out_attributing_i B445_report_attributing_it B446_before_acting_as B447_for_acting_as B448_after_acting_as B449_interruption B450_termination B451_before_behaving_as B452_for_behaving_as B453_after_behaving_as B454_before_initializing B455_for_initializing B456_after_initializing B457_wall_description B458_wall_touch_description B459_floor_description B460_floor_touch_description B461_ceiling_description B462_ceiling_touch_descripti B463_excuse_text B464_can_t_take_that B465_can_t_move_that B466_before_list_arranging B467_for_list_arranging B468_after_list_arranging B469_before_delimiting_a_lis B470_for_delimiting_a_list B471_after_delimiting_a_list B472_door_appearance B473_room_appearance B474_check_exitstarting B475_carry_out_exitstarting B476_report_exitstarting B477_check_exitstopping B478_carry_out_exitstopping B479_report_exitstopping B480_check_exitlisting B481_carry_out_exitlisting B482_report_exitlisting B483_check_exit_colouring B484_carry_out_exit_colourin B485_report_exit_colouring B486_check_exit_symboling B487_carry_out_exit_symbolin B488_report_exit_symboling B489_before_printing_the_opt B490_for_printing_the_option B491_after_printing_the_opti B492_check_choosing B493_carry_out_choosing B494_report_choosing B495_before_listing_the_avai B496_for_listing_the_availab B497_after_listing_the_avail B498_check_looking_behind B499_carry_out_looking_behin B500_report_looking_behind B501_check_printing_memories B502_carry_out_printing_memo B503_report_printing_memorie B504_check_remembering B505_carry_out_remembering B506_report_remembering B507_check_discussing_it_wit B508_carry_out_discussing_it B509_report_discussing_it_wi B510_check_discussing B511_carry_out_discussing B512_report_discussing B513_before_queueing_quips_f B514_for_queueing_quips_foll B515_after_queueing_quips_fo B516_before_ruling_out_quips B517_for_ruling_out_quips_fo B518_after_ruling_out_quips_ B519_availability B520_plausibility B521_before_listing_the_avai B522_for_listing_the_availab B523_after_listing_the_avail B524_check_frumping B525_carry_out_frumping B526_report_frumping B527_check_helping_about_hyp B528_carry_out_helping_about B529_report_helping_about_hy B530_glulx_timed_activity B531_glulx_redrawing B532_glulx_arranging B533_glulx_sound_notificatio B534_glulx_mouse_input B535_glulx_character_input B536_glulx_line_input B537_glulx_hyperlink B538_glulx_zeroing_reference B539_glulx_resetting_windows B540_glulx_resetting_streams B541_glulx_resetting_fileref B542_glulx_object_updating B543_glulx_input_handling B544_command_counting B545_input_cancelling B546_command_showing B547_command_pasting B548_glulx_picture_selection B549_window_resizing B550_can_t_unlock_without_a_ B551_can_t_unlock_already_un B552_check_swiping_it_throug B553_carry_out_swiping_it_th B554_report_swiping_it_throu B555_check_moving_it_with B556_carry_out_moving_it_wit B557_report_moving_it_with B558_check_howdeedoing B559_carry_out_howdeedoing B560_report_howdeedoing B561_check_howdeedoing_someo B562_carry_out_howdeedoing_s B563_report_howdeedoing_some B564_check_knocking_on B565_carry_out_knocking_on B566_report_knocking_on B567_when_klimp_in_the_offic B568_when_klimp_in_the_offic B569_when_moira_in_the_offic B570_when_moira_in_the_offic B571_when_denouement_begins B572_when_denouement_ends B573_check_lensing B574_carry_out_lensing B575_report_lensing 0;

[ EMPTY_RULEBOOK 
    forbid_breaks ! Implied call parameter
    ;
    rfalse;
];
[ B0_startup 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = INITIALISE_MEMORY_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return INITIALISE_MEMORY_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = VIRTUAL_MACHINE_STARTUP_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return VIRTUAL_MACHINE_STARTUP_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = SEED_RANDOM_NUMBER_GENERATOR_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return SEED_RANDOM_NUMBER_GENERATOR_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = UPDATE_CHRONOLOGICAL_RECORDS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return UPDATE_CHRONOLOGICAL_RECORDS_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_9();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_9;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = POSITION_PLAYER_IN_MODEL_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return POSITION_PLAYER_IN_MODEL_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_10();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_10;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_11();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_11;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_12();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_12;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_13();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_13;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_14();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_14;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 11 rule(s)
];
[ B1_turn_sequence 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = PARSE_COMMAND_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return PARSE_COMMAND_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_9();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_9;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = GENERATE_ACTION_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return GENERATE_ACTION_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_16();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_16;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1457();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1457;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_15();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_15;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1206();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1206;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1210();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1210;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = TIMED_EVENTS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return TIMED_EVENTS_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = ADVANCE_TIME_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ADVANCE_TIME_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = UPDATE_CHRONOLOGICAL_RECORDS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return UPDATE_CHRONOLOGICAL_RECORDS_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_17();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_17;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = ADJUST_LIGHT_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ADJUST_LIGHT_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1166();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1166;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = NOTE_OBJECT_ACQUISITIONS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return NOTE_OBJECT_ACQUISITIONS_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_18();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_18;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 16 rule(s)
];
[ B2_shutdown 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_19();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_19;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = RESURRECT_PLAYER_IF_ASKED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return RESURRECT_PLAYER_IF_ASKED_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_20();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_20;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = ASK_FINAL_QUESTION_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ASK_FINAL_QUESTION_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
[ B3_scene_changing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = DetectSceneChange();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return DetectSceneChange;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B4_when_play_begins 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_829();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_829;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_962();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_962;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1058();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1058;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1172();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1172;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1198();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1198;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1208();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1208;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1315();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1315;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1439();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1439;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1489();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1489;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 9 rule(s)
];
Constant B5_when_play_ends = EMPTY_RULEBOOK;
[ B6_when_scene_begins 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_65();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_65;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B7_when_scene_ends = EMPTY_RULEBOOK;
[ B8_every_turn 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1002();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1002;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_839();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_839;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_981();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_981;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_997();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_997;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1045();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1045;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1190();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1190;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1374();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1374;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1377();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1377;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1414();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1414;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1509();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1509;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 10 rule(s)
];
[ B9_action_processing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_22();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_22;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_21();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_21;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_23();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_23;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = BASIC_VISIBILITY_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return BASIC_VISIBILITY_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = BASIC_ACCESSIBILITY_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return BASIC_ACCESSIBILITY_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = CARRYING_REQUIREMENTS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return CARRYING_REQUIREMENTS_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_24();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_24;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = REQUESTED_ACTIONS_REQUIRE_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return REQUESTED_ACTIONS_REQUIRE_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = CARRY_OUT_REQUESTED_ACTIONS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return CARRY_OUT_REQUESTED_ACTIONS_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = DESCEND_TO_SPECIFIC_ACTION_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return DESCEND_TO_SPECIFIC_ACTION_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_25();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_25;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 11 rule(s)
];
[ B10_setting_action_variables 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    if (action == ##Go) {
        rv = R_149();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_149;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Exit) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_172();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_172;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Look) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_184();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_184;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    return 0; ! 3 rule(s)
];
[ B11_specific_action_processi 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = WORK_OUT_DETAILS_OF_SPECIFIC_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return WORK_OUT_DETAILS_OF_SPECIFIC_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_26();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_26;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_27();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_27;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_28();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_28;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_29();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_29;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_30();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_30;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_31();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_31;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_32();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_32;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 8 rule(s)
];
[ B12_player_s_action_awarenes 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_33();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_33;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_34();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_34;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_35();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_35;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_36();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_36;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
[ B13_accessibility 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = I6_Rule_Shell_476();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return I6_Rule_Shell_476;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B14_reaching_inside 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1173();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1173;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1200();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1200;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1029();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1029;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = CANT_REACH_INSIDE_ROOMS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return CANT_REACH_INSIDE_ROOMS_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = CANT_REACH_INSIDE_CLOSED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return CANT_REACH_INSIDE_CLOSED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 5 rule(s)
];
[ B15_reaching_outside 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = CANT_REACH_OUTSIDE_CLOSED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return CANT_REACH_OUTSIDE_CLOSED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B16_visibility 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_37();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_37;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B17_persuasion 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    if (action == ##A75_hailing) {
        rv = R_828();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_828;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A76_leavetaking) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_835();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_835;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A108_howdeedoing) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1419();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1419;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    return 0; ! 3 rule(s)
];
Constant B18_unsuccessful_attempt_by = EMPTY_RULEBOOK;
[ B19_before 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    if (action == ##Show) {
        rv = R_816();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_816;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Give) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_817();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_817;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Open) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1488();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1488;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A74_saying_hello_to) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1454();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1454;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A75_hailing) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_825();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_825;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_818();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_818;
    }
    latest_rule_result-->0 = 0;
    if (action == ##Answer) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_843();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_843;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_844();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_844;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_845();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_845;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Examine) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1498();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1498;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Yes) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_840();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_840;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##No) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_841();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_841;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Sorry) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_842();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_842;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_808();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_808;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_815();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_815;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_807();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_807;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1017();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1017;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 17 rule(s)
];
[ B20_instead 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    if (action == ##Go) {
        rv = R_1399();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1399;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1401();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1401;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Remove) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1499();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1499;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A66_quizzing_it_about) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1463();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1463;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Examine) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1497();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1497;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A110_knocking_on) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1501();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1501;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Examine) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1257();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1257;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Open) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1500();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1500;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A77_saying_goodbye_to) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1026();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1026;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1027();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1027;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Examine) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1030();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1030;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A74_saying_hello_to) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1462();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1462;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A107_moving_it_with) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1410();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1410;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Insert) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1490();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1490;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1491();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1491;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Ask) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_805();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_805;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_806();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_806;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Examine) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1064();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1064;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Touch) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1067();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1067;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Examine) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1078();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1078;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Touch) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1081();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1081;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Examine) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1093();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1093;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Touch) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1096();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1096;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Enter) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1390();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1390;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1391();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1391;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1394();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1394;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1397();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1397;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1398();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1398;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1400();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1400;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1402();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1402;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1403();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1403;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Take) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1408();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1408;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##SwitchOn) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1415();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1415;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##SwitchOff) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1416();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1416;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Take) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1496();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1496;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Enter) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_961();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_961;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Open) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1039();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1039;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Close) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1040();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1040;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Examine) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1057();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1057;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A81_promising) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_972();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_972;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Look) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1446();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1446;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Go) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1106();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1106;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1481();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1481;
    }
    latest_rule_result-->0 = 0;
    if (action == ##A68_implicit_asking) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_809();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_809;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A69_implicit_telling) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_810();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_810;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A70_implicit_quizzing) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_811();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_811;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A71_implicit_informing) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_812();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_812;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A72_implicit_requesting) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_813();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_813;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A73_implicit_imploring) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_814();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_814;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    return 0; ! 49 rule(s)
];
Constant B21_check = EMPTY_RULEBOOK;
Constant B22_carry_out = EMPTY_RULEBOOK;
[ B23_after 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    if (action == ##Go) {
        rv = R_1433();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1433;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1505();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1505;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Open) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1487();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1487;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Drop) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1246();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1246;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1247();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1247;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Go) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1504();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1504;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1240();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1240;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1455();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1455;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A66_quizzing_it_about) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1417();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1417;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A103_discussing) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1262();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1262;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1264();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1264;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1406();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1406;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1407();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1407;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Enter) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1411();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1411;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##SwitchOff) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1412();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1412;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##SwitchOn) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1413();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1413;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A103_discussing) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1425();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1425;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Examine) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1471();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1471;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1472();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1472;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A103_discussing) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1473();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1473;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Examine) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1482();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1482;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Go) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1201();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1201;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    return 0; ! 22 rule(s)
];
Constant B24_report = EMPTY_RULEBOOK;
[ B25_does_the_player_mean 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    if (action == ##A84_answering) {
        rv = R_1014();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1014;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1013();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1013;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A102_discussing_it_with) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1235();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1235;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1238();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1238;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1236();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1236;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1239();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1239;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A84_answering) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1015();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1015;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1056();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1056;
    }
    latest_rule_result-->0 = 0;
    if (action == ##Take) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_38();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_38;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##A103_discussing) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1233();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1233;
        }
        latest_rule_result-->0 = 0;
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_1237();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_1237;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    if (action == ##Disrobe) {
        if (original_deadflag ~= deadflag) return 0;
        if (say__p) RulebookParBreak(forbid_breaks);
        rv = R_240();
        if (rv) {
            if (rv == 2) return reason_the_action_failed;
            return R_240;
        }
        latest_rule_result-->0 = 0;
    } else {
        if (say__p) RulebookParBreak(forbid_breaks);
    }
    return 0; ! 12 rule(s)
];
Constant B26_multiple_action_processi = EMPTY_RULEBOOK;
Constant B27_when_entire_game_begins = EMPTY_RULEBOOK;
Constant B28_when_entire_game_ends = EMPTY_RULEBOOK;
[ B29_before_printing_the_name 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_973();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_973;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_754();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_754;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_66();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_66;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_974();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_974;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1434();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1434;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 5 rule(s)
];
[ B30_for_printing_the_name 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1196();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1196;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1197();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1197;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1176();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1176;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1423();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1423;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1041();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1041;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_975();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_975;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = STANDARD_NAME_PRINTING_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return STANDARD_NAME_PRINTING_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 7 rule(s)
];
Constant B31_after_printing_the_name = EMPTY_RULEBOOK;
Constant B32_before_printing_the_plur = EMPTY_RULEBOOK;
[ B33_for_printing_the_plural_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_67();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_67;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B34_after_printing_the_plura = EMPTY_RULEBOOK;
Constant B35_before_printing_a_number = EMPTY_RULEBOOK;
[ B36_for_printing_a_number 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_68();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_68;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B37_after_printing_a_number = EMPTY_RULEBOOK;
Constant B38_before_printing_room_des = EMPTY_RULEBOOK;
Constant B39_for_printing_room_descri = EMPTY_RULEBOOK;
Constant B40_after_printing_room_desc = EMPTY_RULEBOOK;
Constant B41_before_printing_inventor = EMPTY_RULEBOOK;
Constant B42_for_printing_inventory_d = EMPTY_RULEBOOK;
Constant B43_after_printing_inventory = EMPTY_RULEBOOK;
Constant B44_before_listing_contents = EMPTY_RULEBOOK;
[ B45_for_listing_contents 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = STANDARD_CONTENTS_LISTING_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return STANDARD_CONTENTS_LISTING_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B46_after_listing_contents = EMPTY_RULEBOOK;
Constant B47_before_grouping_together = EMPTY_RULEBOOK;
Constant B48_for_grouping_together = EMPTY_RULEBOOK;
Constant B49_after_grouping_together = EMPTY_RULEBOOK;
Constant B50_before_writing_a_paragra = EMPTY_RULEBOOK;
[ B51_for_writing_a_paragraph_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1351();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1351;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1474();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1474;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1031();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1031;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1350();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1350;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1253();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1253;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1254();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1254;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
Constant B52_after_writing_a_paragrap = EMPTY_RULEBOOK;
Constant B53_before_listing_nondescri = EMPTY_RULEBOOK;
Constant B54_for_listing_nondescript_ = EMPTY_RULEBOOK;
Constant B55_after_listing_nondescrip = EMPTY_RULEBOOK;
Constant B56_before_printing_the_name = EMPTY_RULEBOOK;
Constant B57_for_printing_the_name_of = EMPTY_RULEBOOK;
Constant B58_after_printing_the_name_ = EMPTY_RULEBOOK;
Constant B59_before_printing_the_desc = EMPTY_RULEBOOK;
Constant B60_for_printing_the_descrip = EMPTY_RULEBOOK;
Constant B61_after_printing_the_descr = EMPTY_RULEBOOK;
Constant B62_before_printing_the_anno = EMPTY_RULEBOOK;
Constant B63_for_printing_the_announc = EMPTY_RULEBOOK;
Constant B64_after_printing_the_annou = EMPTY_RULEBOOK;
Constant B65_before_printing_the_anno = EMPTY_RULEBOOK;
[ B66_for_printing_the_announc 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_69();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_69;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B67_after_printing_the_annou = EMPTY_RULEBOOK;
Constant B68_before_printing_a_refusa = EMPTY_RULEBOOK;
Constant B69_for_printing_a_refusal_t = EMPTY_RULEBOOK;
Constant B70_after_printing_a_refusal = EMPTY_RULEBOOK;
Constant B71_before_constructing_the_ = EMPTY_RULEBOOK;
[ B72_for_constructing_the_sta 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1448();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1448;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1142();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1142;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1450();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1450;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B73_after_constructing_the_s = EMPTY_RULEBOOK;
Constant B74_before_printing_the_bann = EMPTY_RULEBOOK;
[ B75_for_printing_the_banner_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1447();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1447;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B76_after_printing_the_banne = EMPTY_RULEBOOK;
[ B77_before_reading_a_command 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_753();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_753;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1453();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1453;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B78_for_reading_a_command = EMPTY_RULEBOOK;
[ B79_after_reading_a_command 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1440();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1440;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1443();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1443;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B80_before_deciding_the_scop = EMPTY_RULEBOOK;
Constant B81_for_deciding_the_scope = EMPTY_RULEBOOK;
[ B82_after_deciding_the_scope 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1199();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1199;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1018();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1018;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1055();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1055;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B83_before_deciding_the_conc = EMPTY_RULEBOOK;
[ B84_for_deciding_the_conceal 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1432();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1432;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B85_after_deciding_the_conce = EMPTY_RULEBOOK;
Constant B86_before_deciding_whether_ = EMPTY_RULEBOOK;
[ B87_for_deciding_whether_all 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_74();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_74;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_70();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_70;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_73();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_73;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_72();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_72;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_71();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_71;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 5 rule(s)
];
Constant B88_after_deciding_whether_a = EMPTY_RULEBOOK;
Constant B89_before_clarifying_the_pa = EMPTY_RULEBOOK;
[ B90_for_clarifying_the_parse 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1232();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1232;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B91_after_clarifying_the_par = EMPTY_RULEBOOK;
Constant B92_before_asking_which_do_y = EMPTY_RULEBOOK;
Constant B93_for_asking_which_do_you_ = EMPTY_RULEBOOK;
Constant B94_after_asking_which_do_yo = EMPTY_RULEBOOK;
Constant B95_before_printing_a_parser = EMPTY_RULEBOOK;
Constant B96_for_printing_a_parser_er = EMPTY_RULEBOOK;
Constant B97_after_printing_a_parser_ = EMPTY_RULEBOOK;
Constant B98_before_supplying_a_missi = EMPTY_RULEBOOK;
[ B99_for_supplying_a_missing_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_75();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_75;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_160();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_160;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B100_after_supplying_a_missi = EMPTY_RULEBOOK;
Constant B101_before_supplying_a_miss = EMPTY_RULEBOOK;
[ B102_for_supplying_a_missing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1005();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1005;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1032();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1032;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B103_after_supplying_a_missi = EMPTY_RULEBOOK;
Constant B104_before_implicitly_takin = EMPTY_RULEBOOK;
[ B105_for_implicitly_taking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = STANDARD_IMPLICIT_TAKING_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return STANDARD_IMPLICIT_TAKING_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B106_after_implicitly_taking = EMPTY_RULEBOOK;
[ B107_before_starting_the_vir 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_914();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_914;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1314();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1314;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_915();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_915;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B108_for_starting_the_virtua 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = ENABLE_GLULX_ACCEL_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ENABLE_GLULX_ACCEL_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1506();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1506;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B109_after_starting_the_virt = EMPTY_RULEBOOK;
Constant B110_before_amusing_a_victor = EMPTY_RULEBOOK;
Constant B111_for_amusing_a_victoriou = EMPTY_RULEBOOK;
Constant B112_after_amusing_a_victori = EMPTY_RULEBOOK;
Constant B113_before_printing_the_pla = EMPTY_RULEBOOK;
[ B114_for_printing_the_player 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = PRINT_OBITUARY_HEADLINE_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return PRINT_OBITUARY_HEADLINE_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = PRINT_FINAL_SCORE_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return PRINT_FINAL_SCORE_R;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = DISPLAY_FINAL_STATUS_LINE_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return DISPLAY_FINAL_STATUS_LINE_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B115_after_printing_the_play = EMPTY_RULEBOOK;
[ B116_before_handling_the_fin 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_77();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_77;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_76();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_76;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = READ_FINAL_ANSWER_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return READ_FINAL_ANSWER_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B117_for_handling_the_final_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_78();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_78;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B118_after_handling_the_fina = EMPTY_RULEBOOK;
[ B119_before_printing_the_loc 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_81();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_81;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_82();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_82;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B120_for_printing_the_locale 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_83();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_83;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1043();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1043;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B121_after_printing_the_loca 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1460();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1460;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1265();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1265;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1169();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1169;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1258();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1258;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_982();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_982;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 5 rule(s)
];
Constant B122_before_choosing_notable = EMPTY_RULEBOOK;
[ B123_for_choosing_notable_lo 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_85();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_85;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B124_after_choosing_notable_ = EMPTY_RULEBOOK;
Constant B125_before_printing_a_local = EMPTY_RULEBOOK;
[ B126_for_printing_a_locale_p 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_92();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_92;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_86();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_86;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_87();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_87;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_88();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_88;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_89();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_89;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_90();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_90;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_91();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_91;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_94();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_94;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_95();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_95;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 9 rule(s)
];
Constant B127_after_printing_a_locale = EMPTY_RULEBOOK;
Constant B128_before_issuing_the_resp = EMPTY_RULEBOOK;
[ B129_for_issuing_the_respons 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = STANDARD_RESPONSE_ISSUING_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return STANDARD_RESPONSE_ISSUING_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B130_after_issuing_the_respo = EMPTY_RULEBOOK;
Constant B131_check_taking_inventory = EMPTY_RULEBOOK;
[ B132_carry_out_taking_invent 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_96();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_96;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_97();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_97;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B133_report_taking_inventory 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_98();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_98;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B134_check_taking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1073();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1073;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1085();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1085;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1102();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1102;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1037();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1037;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_99();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_99;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_100();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_100;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_101();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_101;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_102();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_102;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_103();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_103;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_104();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_104;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_105();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_105;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_106();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_106;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_107();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_107;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_108();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_108;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_109();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_109;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_110();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_110;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 16 rule(s)
];
[ B135_carry_out_taking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_111();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_111;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B136_report_taking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_112();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_112;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B137_check_removing_it_from 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_101();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_101;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_113();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_113;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_114();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_114;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_115();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_115;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
Constant B138_carry_out_removing_it_f = EMPTY_RULEBOOK;
Constant B139_report_removing_it_from = EMPTY_RULEBOOK;
[ B140_check_dropping 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1484();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1484;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_117();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_117;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_116();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_116;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_118();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_118;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_119();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_119;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_120();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_120;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_121();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_121;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 7 rule(s)
];
[ B141_carry_out_dropping 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_122();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_122;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B142_report_dropping 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_123();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_123;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B143_check_putting_it_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_124();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_124;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_125();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_125;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_126();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_126;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_127();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_127;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_128();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_128;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_129();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_129;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
[ B144_carry_out_putting_it_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_130();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_130;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B145_report_putting_it_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_131();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_131;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_132();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_132;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B146_check_inserting_it_into 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_133();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_133;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_134();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_134;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_135();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_135;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_136();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_136;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_137();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_137;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_138();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_138;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_139();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_139;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 7 rule(s)
];
[ B147_carry_out_inserting_it_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_140();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_140;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B148_report_inserting_it_int 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_141();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_141;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_142();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_142;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B149_check_eating 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_143();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_143;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_144();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_144;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_145();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_145;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_146();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_146;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
[ B150_carry_out_eating 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_147();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_147;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B151_report_eating 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_148();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_148;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B152_check_going 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1395();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1395;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1396();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1396;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1259();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1259;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1241();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1241;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1003();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1003;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_150();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_150;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_151();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_151;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_152();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_152;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_153();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_153;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_154();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_154;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_155();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_155;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 11 rule(s)
];
[ B153_carry_out_going 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_838();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_838;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1250();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1250;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_156();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_156;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_157();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_157;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_158();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_158;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 5 rule(s)
];
[ B154_report_going 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_159();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_159;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B155_check_entering 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_161();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_161;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_162();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_162;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_163();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_163;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_164();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_164;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_165();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_165;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_166();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_166;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_167();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_167;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_168();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_168;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 8 rule(s)
];
[ B156_carry_out_entering 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_169();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_169;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B157_report_entering 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_170();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_170;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_171();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_171;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B158_check_exiting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_173();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_173;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_174();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_174;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_175();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_175;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_176();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_176;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1107();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1107;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 5 rule(s)
];
[ B159_carry_out_exiting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_177();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_177;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B160_report_exiting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_178();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_178;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_179();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_179;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B161_check_getting_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_180();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_180;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B162_carry_out_getting_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_181();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_181;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B163_report_getting_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_182();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_182;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_183();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_183;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B164_check_looking = EMPTY_RULEBOOK;
[ B165_carry_out_looking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_185();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_185;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1042();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1042;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_187();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_187;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1243();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1243;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_188();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_188;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_189();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_189;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_797();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_797;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 7 rule(s)
];
[ B166_report_looking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_190();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_190;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B167_check_examining 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1086();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1086;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1103();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1103;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B168_carry_out_examining 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_799();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_799;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_191();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_191;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_192();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_192;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_193();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_193;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_194();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_194;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_195();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_195;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_196();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_196;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1352();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1352;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 8 rule(s)
];
[ B169_report_examining 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_197();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_197;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B170_check_looking_under = EMPTY_RULEBOOK;
[ B171_carry_out_looking_under 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_198();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_198;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B172_report_looking_under 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_199();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_199;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B173_check_searching 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_200();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_200;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_201();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_201;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B174_carry_out_searching = EMPTY_RULEBOOK;
[ B175_report_searching 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_202();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_202;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_203();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_203;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_204();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_204;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B176_check_consulting_it_abo = EMPTY_RULEBOOK;
Constant B177_carry_out_consulting_it = EMPTY_RULEBOOK;
[ B178_report_consulting_it_ab 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_205();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_205;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B179_check_locking_it_with 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1353();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1353;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1354();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1354;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_206();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_206;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_207();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_207;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_208();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_208;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_209();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_209;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
[ B180_carry_out_locking_it_wi 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1355();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1355;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_210();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_210;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B181_report_locking_it_with 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_211();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_211;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B182_check_unlocking_it_with 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1389();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1389;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1361();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1361;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1363();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1363;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_212();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_212;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_213();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_213;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_214();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_214;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
[ B183_carry_out_unlocking_it_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1360();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1360;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1362();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1362;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_215();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_215;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B184_report_unlocking_it_wit 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_216();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_216;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B185_check_switching_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_217();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_217;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_218();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_218;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B186_carry_out_switching_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_219();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_219;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B187_report_switching_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_220();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_220;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B188_check_switching_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_221();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_221;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_222();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_222;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B189_carry_out_switching_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_223();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_223;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B190_report_switching_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_224();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_224;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B191_check_opening 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1486();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1486;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1365();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1365;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1366();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1366;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_225();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_225;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_226();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_226;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_227();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_227;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
[ B192_carry_out_opening 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1364();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1364;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_228();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_228;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_798();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_798;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B193_report_opening 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_229();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_229;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_230();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_230;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B194_check_closing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1367();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1367;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_231();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_231;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_232();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_232;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B195_carry_out_closing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1368();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1368;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_233();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_233;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B196_report_closing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_234();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_234;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B197_check_wearing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_235();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_235;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_236();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_236;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_237();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_237;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B198_carry_out_wearing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1244();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1244;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_238();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_238;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B199_report_wearing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_239();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_239;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B200_check_taking_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_241();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_241;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_242();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_242;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B201_carry_out_taking_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1245();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1245;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_243();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_243;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B202_report_taking_off 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_244();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_244;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B203_check_giving_it_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_245();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_245;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_246();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_246;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_247();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_247;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_248();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_248;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_250();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_250;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 5 rule(s)
];
Constant B204_carry_out_giving_it_to = EMPTY_RULEBOOK;
[ B205_report_giving_it_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_869();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_869;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_882();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_882;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B206_check_showing_it_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_253();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_253;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_254();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_254;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B207_carry_out_showing_it_to = EMPTY_RULEBOOK;
[ B208_report_showing_it_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_869();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_869;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_883();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_883;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B209_check_waking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_256();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_256;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B210_carry_out_waking = EMPTY_RULEBOOK;
Constant B211_report_waking = EMPTY_RULEBOOK;
[ B212_check_throwing_it_at 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_257();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_257;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_258();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_258;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_259();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_259;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B213_carry_out_throwing_it_a = EMPTY_RULEBOOK;
Constant B214_report_throwing_it_at = EMPTY_RULEBOOK;
[ B215_check_attacking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1070();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1070;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1099();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1099;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1069();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1069;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1098();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1098;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1083();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1083;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_260();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_260;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
Constant B216_carry_out_attacking = EMPTY_RULEBOOK;
Constant B217_report_attacking = EMPTY_RULEBOOK;
[ B218_check_kissing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_261();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_261;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_262();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_262;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B219_carry_out_kissing = EMPTY_RULEBOOK;
Constant B220_report_kissing = EMPTY_RULEBOOK;
Constant B221_check_answering_it_that = EMPTY_RULEBOOK;
Constant B222_carry_out_answering_it_ = EMPTY_RULEBOOK;
[ B223_report_answering_it_tha 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_869();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_869;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_881();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_881;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B224_check_telling_it_about 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1214();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1214;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_264();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_264;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B225_carry_out_telling_it_ab = EMPTY_RULEBOOK;
[ B226_report_telling_it_about 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_869();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_869;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_879();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_879;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B227_check_asking_it_about 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1213();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1213;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B228_carry_out_asking_it_abo = EMPTY_RULEBOOK;
[ B229_report_asking_it_about 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_869();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_869;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_877();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_877;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B230_check_asking_it_for 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_267();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_267;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_268();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_268;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B231_carry_out_asking_it_for = EMPTY_RULEBOOK;
Constant B232_report_asking_it_for = EMPTY_RULEBOOK;
Constant B233_check_waiting = EMPTY_RULEBOOK;
Constant B234_carry_out_waiting = EMPTY_RULEBOOK;
[ B235_report_waiting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_269();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_269;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B236_check_touching = EMPTY_RULEBOOK;
Constant B237_carry_out_touching = EMPTY_RULEBOOK;
[ B238_report_touching 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_270();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_270;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_271();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_271;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_272();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_272;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B239_check_waving 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_273();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_273;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B240_carry_out_waving = EMPTY_RULEBOOK;
[ B241_report_waving 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_274();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_274;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B242_check_pulling 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_275();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_275;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_276();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_276;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_277();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_277;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B243_carry_out_pulling = EMPTY_RULEBOOK;
[ B244_report_pulling 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_278();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_278;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B245_check_pushing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1392();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1392;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_279();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_279;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_280();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_280;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_281();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_281;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
Constant B246_carry_out_pushing = EMPTY_RULEBOOK;
[ B247_report_pushing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_282();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_282;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B248_check_turning 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1393();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1393;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_283();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_283;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_284();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_284;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_285();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_285;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
Constant B249_carry_out_turning = EMPTY_RULEBOOK;
[ B250_report_turning 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_286();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_286;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B251_check_pushing_it_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_287();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_287;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_288();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_288;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_289();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_289;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_290();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_290;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_291();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_291;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_292();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_292;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
Constant B252_carry_out_pushing_it_to = EMPTY_RULEBOOK;
Constant B253_report_pushing_it_to = EMPTY_RULEBOOK;
[ B254_check_squeezing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_293();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_293;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B255_carry_out_squeezing = EMPTY_RULEBOOK;
[ B256_report_squeezing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_294();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_294;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B257_check_saying_yes = EMPTY_RULEBOOK;
Constant B258_carry_out_saying_yes = EMPTY_RULEBOOK;
[ B259_report_saying_yes 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_869();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_869;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_886();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_886;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B260_check_saying_no = EMPTY_RULEBOOK;
Constant B261_carry_out_saying_no = EMPTY_RULEBOOK;
[ B262_report_saying_no 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_869();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_869;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_887();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_887;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B263_check_cutting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1072();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1072;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1101();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1101;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1071();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1071;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1100();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1100;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1084();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1084;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_297();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_297;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
Constant B264_carry_out_cutting = EMPTY_RULEBOOK;
Constant B265_report_cutting = EMPTY_RULEBOOK;
Constant B266_check_saying_sorry = EMPTY_RULEBOOK;
Constant B267_carry_out_saying_sorry = EMPTY_RULEBOOK;
[ B268_report_saying_sorry 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_869();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_869;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_888();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_888;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B269_check_rubbing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1068();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1068;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1082();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1082;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1097();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1097;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_299();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_299;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
Constant B270_carry_out_rubbing = EMPTY_RULEBOOK;
[ B271_report_rubbing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_300();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_300;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B272_check_buying 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_301();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_301;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B273_carry_out_buying = EMPTY_RULEBOOK;
Constant B274_report_buying = EMPTY_RULEBOOK;
Constant B275_check_quitting_the_game = EMPTY_RULEBOOK;
[ B276_carry_out_quitting_the_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = QUIT_THE_GAME_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return QUIT_THE_GAME_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B277_report_quitting_the_gam = EMPTY_RULEBOOK;
Constant B278_check_saving_the_game = EMPTY_RULEBOOK;
[ B279_carry_out_saving_the_ga 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = SAVE_THE_GAME_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return SAVE_THE_GAME_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B280_report_saving_the_game = EMPTY_RULEBOOK;
Constant B281_check_restoring_the_gam = EMPTY_RULEBOOK;
[ B282_carry_out_restoring_the 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = RESTORE_THE_GAME_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return RESTORE_THE_GAME_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B283_report_restoring_the_ga = EMPTY_RULEBOOK;
Constant B284_check_restarting_the_ga = EMPTY_RULEBOOK;
[ B285_carry_out_restarting_th 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = RESTART_THE_GAME_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return RESTART_THE_GAME_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B286_report_restarting_the_g = EMPTY_RULEBOOK;
Constant B287_check_verifying_the_sto = EMPTY_RULEBOOK;
[ B288_carry_out_verifying_the 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = VERIFY_THE_STORY_FILE_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return VERIFY_THE_STORY_FILE_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B289_report_verifying_the_st = EMPTY_RULEBOOK;
Constant B290_check_switching_the_sto = EMPTY_RULEBOOK;
[ B291_carry_out_switching_the 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = SWITCH_TRANSCRIPT_ON_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return SWITCH_TRANSCRIPT_ON_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B292_report_switching_the_st = EMPTY_RULEBOOK;
Constant B293_check_switching_the_sto = EMPTY_RULEBOOK;
[ B294_carry_out_switching_the 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = SWITCH_TRANSCRIPT_OFF_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return SWITCH_TRANSCRIPT_OFF_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B295_report_switching_the_st = EMPTY_RULEBOOK;
Constant B296_check_requesting_the_st = EMPTY_RULEBOOK;
[ B297_carry_out_requesting_th 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = ANNOUNCE_STORY_FILE_VERSION_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ANNOUNCE_STORY_FILE_VERSION_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B298_report_requesting_the_s = EMPTY_RULEBOOK;
Constant B299_check_requesting_the_sc = EMPTY_RULEBOOK;
[ B300_carry_out_requesting_th 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = ANNOUNCE_SCORE_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ANNOUNCE_SCORE_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B301_report_requesting_the_s = EMPTY_RULEBOOK;
Constant B302_check_preferring_abbrev = EMPTY_RULEBOOK;
[ B303_carry_out_preferring_ab 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = PREFER_ABBREVIATED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return PREFER_ABBREVIATED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B304_report_preferring_abbre 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = REP_PREFER_ABBREVIATED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return REP_PREFER_ABBREVIATED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B305_check_preferring_unabbr = EMPTY_RULEBOOK;
[ B306_carry_out_preferring_un 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = PREFER_UNABBREVIATED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return PREFER_UNABBREVIATED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B307_report_preferring_unabb 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = REP_PREFER_UNABBREVIATED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return REP_PREFER_UNABBREVIATED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B308_check_preferring_someti = EMPTY_RULEBOOK;
[ B309_carry_out_preferring_so 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = PREFER_SOMETIMES_ABBREVIATED_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return PREFER_SOMETIMES_ABBREVIATED_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B310_report_preferring_somet 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = REP_PREFER_SOMETIMES_ABBR_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return REP_PREFER_SOMETIMES_ABBR_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B311_check_switching_score_n = EMPTY_RULEBOOK;
[ B312_carry_out_switching_sco 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = SWITCH_SCORE_NOTIFY_ON_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return SWITCH_SCORE_NOTIFY_ON_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B313_report_switching_score_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = REP_SWITCH_NOTIFY_ON_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return REP_SWITCH_NOTIFY_ON_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B314_check_switching_score_n = EMPTY_RULEBOOK;
[ B315_carry_out_switching_sco 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = SWITCH_SCORE_NOTIFY_OFF_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return SWITCH_SCORE_NOTIFY_OFF_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B316_report_switching_score_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = REP_SWITCH_NOTIFY_OFF_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return REP_SWITCH_NOTIFY_OFF_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B317_check_requesting_the_pr = EMPTY_RULEBOOK;
[ B318_carry_out_requesting_th 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = ANNOUNCE_PRONOUN_MEANINGS_R();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return ANNOUNCE_PRONOUN_MEANINGS_R;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B319_report_requesting_the_p = EMPTY_RULEBOOK;
Constant B320_check_requesting_episte = EMPTY_RULEBOOK;
Constant B321_carry_out_requesting_ep = EMPTY_RULEBOOK;
[ B322_report_requesting_epist 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_802();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_802;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B323_check_requesting_it_for = EMPTY_RULEBOOK;
Constant B324_carry_out_requesting_it = EMPTY_RULEBOOK;
[ B325_report_requesting_it_fo 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_869();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_869;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_884();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_884;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B326_check_imploring_it_for = EMPTY_RULEBOOK;
Constant B327_carry_out_imploring_it_ = EMPTY_RULEBOOK;
[ B328_report_imploring_it_for 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_869();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_869;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_885();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_885;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B329_check_quizzing_it_about 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_846();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_846;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B330_carry_out_quizzing_it_a = EMPTY_RULEBOOK;
[ B331_report_quizzing_it_abou 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_869();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_869;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_878();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_878;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B332_check_informing_it_abou 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_847();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_847;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1212();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1212;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B333_carry_out_informing_it_ = EMPTY_RULEBOOK;
[ B334_report_informing_it_abo 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_869();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_869;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_880();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_880;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B335_check_implicit_asking = EMPTY_RULEBOOK;
Constant B336_carry_out_implicit_aski = EMPTY_RULEBOOK;
Constant B337_report_implicit_asking = EMPTY_RULEBOOK;
Constant B338_check_implicit_telling = EMPTY_RULEBOOK;
Constant B339_carry_out_implicit_tell = EMPTY_RULEBOOK;
Constant B340_report_implicit_telling = EMPTY_RULEBOOK;
Constant B341_check_implicit_quizzing = EMPTY_RULEBOOK;
Constant B342_carry_out_implicit_quiz = EMPTY_RULEBOOK;
Constant B343_report_implicit_quizzin = EMPTY_RULEBOOK;
Constant B344_check_implicit_informin = EMPTY_RULEBOOK;
Constant B345_carry_out_implicit_info = EMPTY_RULEBOOK;
Constant B346_report_implicit_informi = EMPTY_RULEBOOK;
Constant B347_check_implicit_requesti = EMPTY_RULEBOOK;
Constant B348_carry_out_implicit_requ = EMPTY_RULEBOOK;
Constant B349_report_implicit_request = EMPTY_RULEBOOK;
Constant B350_check_implicit_implorin = EMPTY_RULEBOOK;
Constant B351_carry_out_implicit_impl = EMPTY_RULEBOOK;
Constant B352_report_implicit_implori = EMPTY_RULEBOOK;
[ B353_check_saying_hello_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_820();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_820;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_821();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_821;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B354_carry_out_saying_hello_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_822();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_822;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B355_report_saying_hello_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_871();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_871;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1012();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1012;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_824();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_824;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_823();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_823;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
[ B356_check_hailing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_826();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_826;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B357_carry_out_hailing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_827();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_827;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B358_report_hailing = EMPTY_RULEBOOK;
[ B359_check_leavetaking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_833();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_833;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B360_carry_out_leavetaking 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_836();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_836;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_834();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_834;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B361_report_leavetaking = EMPTY_RULEBOOK;
[ B362_check_saying_goodbye_to 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_831();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_831;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B363_carry_out_saying_goodby 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_832();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_832;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B364_report_saying_goodbye_t 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_870();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_870;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_837();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_837;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B365_response 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1465();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1465;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1467();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1467;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1468();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1468;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1469();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1469;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1470();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1470;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 5 rule(s)
];
[ B366_greeting_response 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1404();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1404;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1466();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1466;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B367_farewell_response = EMPTY_RULEBOOK;
Constant B368_implicit_greeting_respo = EMPTY_RULEBOOK;
Constant B369_implicit_farewell_respo = EMPTY_RULEBOOK;
[ B370_default_ask_response 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_874();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_874;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B371_default_ask_tell_respon 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_876();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_876;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B372_default_tell_response 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_874();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_874;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B373_default_answer_response 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_873();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_873;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B374_default_ask_for_respons 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_876();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_876;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B375_default_give_response 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_875();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_875;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B376_default_show_response 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_875();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_875;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B377_default_give_show_respo 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_876();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_876;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B378_default_yes_no_response 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_876();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_876;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B379_default_response 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_872();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_872;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B380_before_pausing_the_game = EMPTY_RULEBOOK;
[ B381_for_pausing_the_game 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_895();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_895;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B382_after_pausing_the_game = EMPTY_RULEBOOK;
[ B383_escape_detection 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_937();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_937;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_938();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_938;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_939();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_939;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_940();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_940;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_941();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_941;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_942();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_942;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 6 rule(s)
];
Constant B384_check_helping = EMPTY_RULEBOOK;
Constant B385_carry_out_helping = EMPTY_RULEBOOK;
Constant B386_report_helping = EMPTY_RULEBOOK;
[ B387_check_asking_for_identi 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_967();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_967;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_968();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_968;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B388_carry_out_asking_for_id = EMPTY_RULEBOOK;
Constant B389_report_asking_for_ident = EMPTY_RULEBOOK;
[ B390_check_questioning_motiv 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_969();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_969;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_970();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_970;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B391_carry_out_questioning_m = EMPTY_RULEBOOK;
Constant B392_report_questioning_moti = EMPTY_RULEBOOK;
[ B393_check_promising 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_971();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_971;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B394_carry_out_promising = EMPTY_RULEBOOK;
Constant B395_report_promising = EMPTY_RULEBOOK;
[ B396_audibility_of 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_978();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_978;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_979();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_979;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B397_noisiness_of 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1000();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1000;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_980();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_980;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B398_before_printing_insiste = EMPTY_RULEBOOK;
[ B399_for_printing_insistent_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_994();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_994;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B400_after_printing_insisten = EMPTY_RULEBOOK;
Constant B401_before_printing_backgro = EMPTY_RULEBOOK;
[ B402_for_printing_background 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_995();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_995;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B403_after_printing_backgrou 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_983();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_983;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B404_before_determining_the_ = EMPTY_RULEBOOK;
[ B405_for_determining_the_sub 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_984();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_984;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B406_after_determining_the_s = EMPTY_RULEBOOK;
Constant B407_before_printing_the_sou = EMPTY_RULEBOOK;
[ B408_for_printing_the_sound_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_985();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_985;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_986();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_986;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_990();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_990;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_991();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_991;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_992();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_992;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 5 rule(s)
];
Constant B409_after_printing_the_soun = EMPTY_RULEBOOK;
Constant B410_before_printing_the_sou = EMPTY_RULEBOOK;
[ B411_for_printing_the_sound_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_998();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_998;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_993();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_993;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B412_after_printing_the_soun = EMPTY_RULEBOOK;
[ B413_check_calling_it_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1483();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1483;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1006();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1006;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1009();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1009;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
[ B414_carry_out_calling_it_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1007();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1007;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B415_report_calling_it_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1008();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1008;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B416_check_cold_calling_it_o 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1004();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1004;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B417_carry_out_cold_calling_ = EMPTY_RULEBOOK;
Constant B418_report_cold_calling_it_ = EMPTY_RULEBOOK;
[ B419_check_answering 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1010();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1010;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B420_carry_out_answering 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1011();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1011;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B421_report_answering = EMPTY_RULEBOOK;
Constant B422_check_picking_up = EMPTY_RULEBOOK;
Constant B423_carry_out_picking_up = EMPTY_RULEBOOK;
[ B424_report_picking_up 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1016();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1016;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B425_check_ending_a_call 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1019();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1019;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1020();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1020;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B426_carry_out_ending_a_call 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1022();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1022;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1021();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1021;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B427_report_ending_a_call = EMPTY_RULEBOOK;
Constant B428_check_hanging_up = EMPTY_RULEBOOK;
[ B429_carry_out_hanging_up 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1023();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1023;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1028();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1028;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B430_report_hanging_up 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1025();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1025;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B431_check_signing_off_with = EMPTY_RULEBOOK;
Constant B432_carry_out_signing_off_w = EMPTY_RULEBOOK;
[ B433_report_signing_off_with 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1024();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1024;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B434_check_buying_it_with 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1033();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1033;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B435_carry_out_buying_it_wit 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1034();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1034;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B436_report_buying_it_with = EMPTY_RULEBOOK;
Constant B437_check_pricing_it = EMPTY_RULEBOOK;
[ B438_carry_out_pricing_it 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1035();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1035;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B439_report_pricing_it = EMPTY_RULEBOOK;
Constant B440_check_accounting = EMPTY_RULEBOOK;
[ B441_carry_out_accounting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1036();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1036;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B442_report_accounting = EMPTY_RULEBOOK;
Constant B443_check_attributing_it = EMPTY_RULEBOOK;
[ B444_carry_out_attributing_i 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1038();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1038;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B445_report_attributing_it = EMPTY_RULEBOOK;
Constant B446_before_acting_as = EMPTY_RULEBOOK;
[ B447_for_acting_as 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1046();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1046;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B448_after_acting_as = EMPTY_RULEBOOK;
Constant B449_interruption = EMPTY_RULEBOOK;
Constant B450_termination = EMPTY_RULEBOOK;
Constant B451_before_behaving_as = EMPTY_RULEBOOK;
[ B452_for_behaving_as 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1431();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1431;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1492();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1492;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1493();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1493;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1054();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1054;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
Constant B453_after_behaving_as = EMPTY_RULEBOOK;
Constant B454_before_initializing = EMPTY_RULEBOOK;
Constant B455_for_initializing = EMPTY_RULEBOOK;
Constant B456_after_initializing = EMPTY_RULEBOOK;
[ B457_wall_description 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1062();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1062;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B458_wall_touch_description 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1065();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1065;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B459_floor_description 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1076();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1076;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B460_floor_touch_description 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1079();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1079;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B461_ceiling_description 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1091();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1091;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B462_ceiling_touch_descripti 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1094();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1094;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B463_excuse_text 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1104();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1104;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B464_can_t_take_that 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1108();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1108;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B465_can_t_move_that 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1110();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1110;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B466_before_list_arranging = EMPTY_RULEBOOK;
[ B467_for_list_arranging 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1129();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1129;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B468_after_list_arranging = EMPTY_RULEBOOK;
Constant B469_before_delimiting_a_lis = EMPTY_RULEBOOK;
[ B470_for_delimiting_a_list 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1134();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1134;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B471_after_delimiting_a_list = EMPTY_RULEBOOK;
[ B472_door_appearance 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1136();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1136;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B473_room_appearance 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1139();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1139;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1138();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1138;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B474_check_exitstarting = EMPTY_RULEBOOK;
[ B475_carry_out_exitstarting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1148();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1148;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B476_report_exitstarting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1149();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1149;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B477_check_exitstopping = EMPTY_RULEBOOK;
[ B478_carry_out_exitstopping 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1146();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1146;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B479_report_exitstopping 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1147();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1147;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B480_check_exitlisting = EMPTY_RULEBOOK;
[ B481_carry_out_exitlisting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1150();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1150;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B482_report_exitlisting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1158();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1158;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B483_check_exit_colouring = EMPTY_RULEBOOK;
[ B484_carry_out_exit_colourin 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1162();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1162;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B485_report_exit_colouring = EMPTY_RULEBOOK;
Constant B486_check_exit_symboling = EMPTY_RULEBOOK;
[ B487_carry_out_exit_symbolin 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1160();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1160;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B488_report_exit_symboling 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1161();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1161;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B489_before_printing_the_opt = EMPTY_RULEBOOK;
[ B490_for_printing_the_option 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1167();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1167;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1178();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1178;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1231();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1231;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1168();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1168;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
Constant B491_after_printing_the_opti = EMPTY_RULEBOOK;
[ B492_check_choosing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1171();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1171;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B493_carry_out_choosing = EMPTY_RULEBOOK;
Constant B494_report_choosing = EMPTY_RULEBOOK;
Constant B495_before_listing_the_avai = EMPTY_RULEBOOK;
[ B496_for_listing_the_availab 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1177();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1177;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B497_after_listing_the_avail = EMPTY_RULEBOOK;
[ B498_check_looking_behind 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1183();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1183;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B499_carry_out_looking_behin 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1184();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1184;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B500_report_looking_behind 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1185();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1185;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1186();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1186;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B501_check_printing_memories 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1191();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1191;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B502_carry_out_printing_memo = EMPTY_RULEBOOK;
[ B503_report_printing_memorie 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1192();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1192;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B504_check_remembering = EMPTY_RULEBOOK;
Constant B505_carry_out_remembering = EMPTY_RULEBOOK;
[ B506_report_remembering 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1194();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1194;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B507_check_discussing_it_wit 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1202();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1202;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B508_carry_out_discussing_it = EMPTY_RULEBOOK;
Constant B509_report_discussing_it_wi = EMPTY_RULEBOOK;
[ B510_check_discussing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1203();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1203;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1204();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1204;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B511_carry_out_discussing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1205();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1205;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B512_report_discussing = EMPTY_RULEBOOK;
Constant B513_before_queueing_quips_f = EMPTY_RULEBOOK;
[ B514_for_queueing_quips_foll 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1207();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1207;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B515_after_queueing_quips_fo = EMPTY_RULEBOOK;
Constant B516_before_ruling_out_quips = EMPTY_RULEBOOK;
[ B517_for_ruling_out_quips_fo 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1211();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1211;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B518_after_ruling_out_quips_ = EMPTY_RULEBOOK;
[ B519_availability 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1219();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1219;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1221();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1221;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1260();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1260;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1261();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1261;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1263();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1263;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1405();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1405;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1418();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1418;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1424();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1424;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1426();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1426;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1427();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1427;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1428();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1428;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1429();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1429;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1217();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1217;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1218();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1218;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1220();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1220;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1222();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1222;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 16 rule(s)
];
[ B520_plausibility 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1421();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1421;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1224();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1224;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1225();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1225;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1226();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1226;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 4 rule(s)
];
Constant B521_before_listing_the_avai = EMPTY_RULEBOOK;
[ B522_for_listing_the_availab 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1229();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1229;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B523_after_listing_the_avail = EMPTY_RULEBOOK;
Constant B524_check_frumping = EMPTY_RULEBOOK;
Constant B525_carry_out_frumping = EMPTY_RULEBOOK;
[ B526_report_frumping 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1234();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1234;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B527_check_helping_about_hyp = EMPTY_RULEBOOK;
[ B528_carry_out_helping_about 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1266();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1266;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B529_report_helping_about_hy = EMPTY_RULEBOOK;
Constant B530_glulx_timed_activity = EMPTY_RULEBOOK;
[ B531_glulx_redrawing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1325();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1325;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B532_glulx_arranging 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1324();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1324;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B533_glulx_sound_notificatio = EMPTY_RULEBOOK;
Constant B534_glulx_mouse_input = EMPTY_RULEBOOK;
Constant B535_glulx_character_input = EMPTY_RULEBOOK;
Constant B536_glulx_line_input = EMPTY_RULEBOOK;
Constant B537_glulx_hyperlink = EMPTY_RULEBOOK;
[ B538_glulx_zeroing_reference 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1316();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1316;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1320();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1320;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B539_glulx_resetting_windows 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1318();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1318;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1322();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1322;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B540_glulx_resetting_streams = EMPTY_RULEBOOK;
Constant B541_glulx_resetting_fileref = EMPTY_RULEBOOK;
[ B542_glulx_object_updating 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1326();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1326;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B543_glulx_input_handling 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    p ! rulebook parameter
    ;
    original_deadflag = deadflag;
    p = parameter_value;
    parameter_value = p;
    rv = R_1302();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1302;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1294();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1294;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1295();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1295;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1296();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1296;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1297();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1297;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1298();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1298;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1299();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1299;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1300();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1300;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    parameter_value = p;
    rv = R_1301();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1301;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 9 rule(s)
];
[ B544_command_counting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1307();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1307;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B545_input_cancelling 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1308();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1308;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B546_command_showing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1311();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1311;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B547_command_pasting 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1313();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1313;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B548_glulx_picture_selection 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1508();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1508;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1333();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1333;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
[ B549_window_resizing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1512();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1512;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B550_can_t_unlock_without_a_ 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1356();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1356;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B551_can_t_unlock_already_un 
    forbid_breaks ! Implied call parameter
    rv ! return value
    p ! rulebook parameter
    ;
    p = parameter_value;
    parameter_value = p;
    rv = R_1358();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1358;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B552_check_swiping_it_throug 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1387();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1387;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1388();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1388;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 2 rule(s)
];
Constant B553_carry_out_swiping_it_th = EMPTY_RULEBOOK;
Constant B554_report_swiping_it_throu = EMPTY_RULEBOOK;
[ B555_check_moving_it_with 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1409();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1409;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B556_carry_out_moving_it_wit = EMPTY_RULEBOOK;
Constant B557_report_moving_it_with = EMPTY_RULEBOOK;
[ B558_check_howdeedoing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1422();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1422;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B559_carry_out_howdeedoing = EMPTY_RULEBOOK;
Constant B560_report_howdeedoing = EMPTY_RULEBOOK;
[ B561_check_howdeedoing_someo 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1420();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1420;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B562_carry_out_howdeedoing_s = EMPTY_RULEBOOK;
Constant B563_report_howdeedoing_some = EMPTY_RULEBOOK;
Constant B564_check_knocking_on = EMPTY_RULEBOOK;
[ B565_carry_out_knocking_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1494();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1494;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
[ B566_report_knocking_on 
    forbid_breaks ! Implied call parameter
    rv ! return value
    original_deadflag ! saved state
    ;
    original_deadflag = deadflag;
    rv = R_1495();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1495;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1459();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1459;
    }
    latest_rule_result-->0 = 0;
    if (original_deadflag ~= deadflag) return 0;
    if (say__p) RulebookParBreak(forbid_breaks);
    rv = R_1458();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1458;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 3 rule(s)
];
Constant B567_when_klimp_in_the_offic = EMPTY_RULEBOOK;
Constant B568_when_klimp_in_the_offic = EMPTY_RULEBOOK;
Constant B569_when_moira_in_the_offic = EMPTY_RULEBOOK;
Constant B570_when_moira_in_the_offic = EMPTY_RULEBOOK;
Constant B571_when_denouement_begins = EMPTY_RULEBOOK;
Constant B572_when_denouement_ends = EMPTY_RULEBOOK;
Constant B573_check_lensing = EMPTY_RULEBOOK;
[ B574_carry_out_lensing 
    forbid_breaks ! Implied call parameter
    rv ! return value
    ;
    rv = R_1515();
    if (rv) {
        if (rv == 2) return reason_the_action_failed;
        return R_1515;
    }
    latest_rule_result-->0 = 0;
    return 0; ! 1 rule(s)
];
Constant B575_report_lensing = EMPTY_RULEBOOK;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Scenes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


[ DetectSceneChange 
    chs ! count of changes made
    ch ! flag: change made
    ;
    if (scene_status-->0 == 1) {
        if ((((deadflag~=0)))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Entire Game' ends]^";
            if (GProperty(43, 1, p93_recurring)) scene_status-->0 = 0; else scene_status-->0 = 2; FollowRulebook(28);
            FollowRulebook(WHEN_SCENE_ENDS_RB, 1);
            scene_ended-->0 = the_time;
            scene_endings-->0 = (scene_endings-->0)|2;
            scene_latest_ending-->0 = 1;
            jump CScene;
        }
    }
    if (scene_status-->0 == 0) {
        if ((((deadflag==0)))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Entire Game' begins]^";
            scene_status-->0 = 1; FollowRulebook(WHEN_SCENE_BEGINS_RB, 1);
            FollowRulebook(27);
            scene_started-->0 = the_time;
            scene_endings-->0 = (scene_endings-->0)|1;
            scene_latest_ending-->0 = 0;
            jump CScene;
        }
    }
    if (scene_status-->1 == 1) {
    }
    if (scene_status-->1 == 0) {
        if ((((I454_bosh_chief_s_office == ContainerOf(I419_chief_huffton_klimp))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Klimp in-the-office' begins]^";
            scene_status-->1 = 1; FollowRulebook(WHEN_SCENE_BEGINS_RB, 2);
            FollowRulebook(567);
            scene_started-->1 = the_time;
            scene_endings-->1 = (scene_endings-->1)|1;
            scene_latest_ending-->1 = 0;
            jump CScene;
        }
    }
    if (scene_status-->2 == 1) {
    }
    if (scene_status-->2 == 0) {
        if ((((I456_moira_s_office == ContainerOf(I427_moira_zin))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Moira in-the-office' begins]^";
            scene_status-->2 = 1; FollowRulebook(WHEN_SCENE_BEGINS_RB, 3);
            FollowRulebook(569);
            scene_started-->2 = the_time;
            scene_endings-->2 = (scene_endings-->2)|1;
            scene_latest_ending-->2 = 0;
            jump CScene;
        }
    }
    if (scene_status-->3 == 1) {
    }
    if (scene_status-->3 == 0) {
    }
    .CScene;
    if (chs>20) ">--> The scene change machinery is stuck.";

    if (ch>0) DetectSceneChange(++chs);

    rfalse;
];

#IFDEF DEBUG;
[ ShowSceneStatus 
    chs ! internal use only
    sc ! internal use only
    ch ! internal use only
    ;
    if (scene_status-->0 == 1) {
        print "Scene 'Entire Game' playing (for ", the_time-(scene_started-->0), " mins now)^";
    } else {
        if (scene_latest_ending-->0 > 0) {
            print "Scene 'Entire Game' ended";
            print "^";
        }
    }
    if (scene_status-->1 == 1) {
        print "Scene 'Klimp in-the-office' playing (for ", the_time-(scene_started-->1), " mins now)^";
    } else {
        if (scene_latest_ending-->1 > 0) {
            print "Scene 'Klimp in-the-office' ended";
            print "^";
        }
    }
    if (scene_status-->2 == 1) {
        print "Scene 'Moira in-the-office' playing (for ", the_time-(scene_started-->2), " mins now)^";
    } else {
        if (scene_latest_ending-->2 > 0) {
            print "Scene 'Moira in-the-office' ended";
            print "^";
        }
    }
    if (scene_status-->3 == 1) {
        print "Scene 'Denouement' playing (for ", the_time-(scene_started-->3), " mins now)^";
    } else {
        if (scene_latest_ending-->3 > 0) {
            print "Scene 'Denouement' ended";
            print "^";
        }
    }
];

#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: The New Library
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====




! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Summary
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Action Data
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant AD_ACTION = 0; ! The I6 action number (0 to 4095)
Constant AD_REQUIREMENTS = 1; ! Such as requiring light; a bitmap, see below
Constant AD_NOUN_KOV = 2; ! Kind of value of the first noun
Constant AD_SECOND_KOV = 3; ! Kind of value of the second noun
Constant AD_VARIABLES_CREATOR = 4; ! Routine to initialise variables owned
Constant AD_VARIABLES_ID = 5; ! Frame ID for variables owned by action

Constant AD_RECORD_SIZE = 6;

[ FindAction fa t;
	if (fa == -1) fa = action;
	t = 1;
	while (t <= ActionData-->0) {
		if (fa == ActionData-->t) return t;
		t = t + AD_RECORD_SIZE;
	}
	rfalse;
];

[ ActionNumberIndexed i;
	if ((i>=0) && (i < AD_RECORDS)) return ActionData-->(i*AD_RECORD_SIZE + AD_ACTION + 1);
	return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Requirements Bitmap
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant TOUCH_NOUN_ABIT   = $$00000001;
Constant TOUCH_SECOND_ABIT = $$00000010;
Constant LIGHT_ABIT        = $$00000100;
Constant NEED_NOUN_ABIT    = $$00001000;
Constant NEED_SECOND_ABIT  = $$00010000;
Constant OUT_OF_WORLD_ABIT = $$00100000;
Constant CARRY_NOUN_ABIT   = $$01000000;
Constant CARRY_SECOND_ABIT = $$10000000;

[ NeedToCarryNoun;       return TestActionMask(CARRY_NOUN_ABIT); ];
[ NeedToCarrySecondNoun; return TestActionMask(CARRY_SECOND_ABIT); ];
[ NeedToTouchNoun;       return TestActionMask(TOUCH_NOUN_ABIT); ];
[ NeedToTouchSecondNoun; return TestActionMask(TOUCH_SECOND_ABIT); ];
[ NeedLightForAction;    return TestActionMask(LIGHT_ABIT); ];

[ TestActionMask match mask at; 
	at = FindAction(-1); 
	if (at == 0) rfalse; 
	mask = ActionData-->(at+AD_REQUIREMENTS); 
	if (mask & match) rtrue; 
	rfalse; 
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Try Action
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TryAction req by ac n s stora smeta tbits saved_command text_of_command;
	if (stora) return STORED_ACTION_TY_New(ac, n, s, by, req, stora);
	tbits = req & (16+32);
	req = req & 1;
	@push actor; @push act_requester; @push inp1; @push inp2;
	@push parsed_number; smeta = meta;
	actor = by; if (req) act_requester = player; else act_requester = 0;

	by = FindAction(ac);
	if (by) {
		if (ActionData-->(by+AD_NOUN_KOV) == OBJECT_TY) inp1 = n;
		else { inp1 = 1; parsed_number = n; }
		if (ActionData-->(by+AD_SECOND_KOV) == OBJECT_TY) inp2 = s;
		else { inp2 = 1; parsed_number = s; }
		if (((ActionData-->(by+AD_NOUN_KOV) == UNDERSTANDING_TY) ||
			(ActionData-->(by+AD_SECOND_KOV) == UNDERSTANDING_TY)) && (tbits)) {
			saved_command = BlkValueCreate(TEXT_TY);
			BlkValueCast(saved_command, SNIPPET_TY, players_command);
			text_of_command = BlkValueCreate(TEXT_TY);
			BlkValueCopy(text_of_command, parsed_number);
			SetPlayersCommand(text_of_command);
			if (tbits == 16) {
				n = players_command; inp1 = 1; parsed_number = players_command;
			} else {
				s = players_command; inp2 = 1; parsed_number = players_command;
			}
			BlkValueFree(text_of_command);
			@push consult_from; @push consult_words;
			consult_from = 1; consult_words = parsed_number - 100;
		}
	}

	BeginAction(ac, n, s, 0, true);

	if (saved_command) {
		@pull consult_words; @pull consult_from;
		SetPlayersCommand(saved_command);
		BlkValueFree(saved_command);
	}

	meta = smeta; @pull parsed_number;
	@pull inp2; @pull inp1; @pull act_requester; @pull actor;
	TrackActions(true, smeta);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: I6 Angle Brackets
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ R_Process a i j;
	@push inp1; @push inp2;
    inp1 = i; inp2 = j; BeginAction(a, i, j);
    @pull inp2; @pull inp1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Conversion
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global converted_action_outcome = -1;
[ GVS_Convert ac n s;
	converted_action_outcome = BeginAction(ac, n, s);
	if (converted_action_outcome == true) FollowRulebook( 23, nothing, true );
	rtrue;
];

[ ConvertToRequest X AN Y Z;
	WORK_OUT_DETAILS_OF_SPECIFIC_R();
	if (X == player) TryAction(false, X, AN, Y, Z);
	else TryAction(true, X, AN, Y, Z);
	rtrue;
];

[ ConvertToGoingWithPush i oldrm newrm infl;
	i=noun;
	if (IndirectlyContains(noun, actor) == false) { move i to actor; infl = true; }
	move_pushing = i;
	oldrm = LocationOf(noun);
	BeginAction(##Go, second);
	newrm = LocationOf(actor);
	move_pushing = nothing; move i to newrm;
	if (newrm ~= oldrm) {
		if (IndirectlyContains(i, player)) TryAction(0, player, ##Look, 0, 0);
		RulebookSucceeds();
	} else RulebookFails();
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Implicit Take
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ImplicitTake obj ks;
	if (actor == player) { STANDARD_IMPLICIT_TAKING_RM('A', obj); }
	else {
		if (TestVisibility(player, actor))
			STANDARD_IMPLICIT_TAKING_RM('B', obj, actor);
	}
	ClearParagraphing(3);
	@push keep_silent; keep_silent = true;
	@push say__p; @push say__pc; ClearParagraphing(4);
	if (act_requester) TryAction(true, actor, ##Take, obj, nothing);
	else TryAction(false, actor, ##Take, obj, nothing);
	DivideParagraphPoint(); @pull say__pc; @pull say__p; AdjustParagraphPoint(); @pull keep_silent;
	if (obj in actor) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Look After Going
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LookAfterGoing;
	GoingLookBreak();
	AbbreviatedRoomDescription();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Abbreviated Room Description
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ AbbreviatedRoomDescription  prior_action pos frame_id;
	prior_action = action; 

	action = ##Look;
	pos = FindAction(##Look);
	if ((pos) && (ActionData-->(pos+AD_VARIABLES_CREATOR))) {
		frame_id = ActionData-->(pos+AD_VARIABLES_ID);
		Mstack_Create_Frame(ActionData-->(pos+AD_VARIABLES_CREATOR), frame_id);
		FollowRulebook(SETTING_ACTION_VARIABLES_RB);
		(MStack-->MstVO(frame_id, 0)) = prior_action; ! "room-describing action"
		(MStack-->MstVO(frame_id, 1)) = true; ! "abbreviated form allowed"
	}
	LookSub(); ! The I6 verb routine for "looking"
	if (frame_id) Mstack_Destroy_Frame(ActionData-->(pos+AD_VARIABLES_CREATOR), frame_id);

	action = prior_action;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Begin Action
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BeginAction a n s moi notrack  rv;
	ChronologyPoint();

	@push action; @push noun; @push second; @push self; @push multiple_object_item;

	action = a; noun = n; second = s; self = noun; multiple_object_item = moi;
	if (action < 4096) rv = ActionPrimitive();

	@pull multiple_object_item; @pull self; @pull second; @pull noun; @pull action;
	
	if (notrack == false) TrackActions(true, meta);
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Action Primitive
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ActionPrimitive  rv p1 p2 p3 p4 p5 frame_id;
	MStack_CreateRBVars(ACTION_PROCESSING_RB);

	if ((keep_silent == false) && (multiflag == false)) DivideParagraphPoint();
	reason_the_action_failed = 0;

	frame_id = -1;
	p1 = FindAction(action);
	if ((p1) && (ActionData-->(p1+AD_VARIABLES_CREATOR))) {
		frame_id = ActionData-->(p1+AD_VARIABLES_ID);
		Mstack_Create_Frame(ActionData-->(p1+AD_VARIABLES_CREATOR), frame_id);
	}
	if (ActionVariablesNotTypeSafe()) {
		if (actor ~= player) { ACTION_PROCESSING_INTERNAL_RM('K'); new_line; }
		if (frame_id ~= -1)
			Mstack_Destroy_Frame(ActionData-->(p1+AD_VARIABLES_CREATOR), frame_id);
		MStack_DestroyRBVars(ACTION_PROCESSING_RB);
		return;
	}

	FollowRulebook(SETTING_ACTION_VARIABLES_RB);

	#IFDEF DEBUG;
	if ((trace_actions) && (FindAction(-1))) {
		print "["; p1=actor; p2=act_requester; p3=action; p4=noun; p5=second;
		DB_Action(p1,p2,p3,p4,p5);
		print "]^"; ClearParagraphing(5);
	}
	++debug_rule_nesting;
	#ENDIF;
	TrackActions(false, meta);
	if ((meta) && (actor ~= player)) {
		ACTION_PROCESSING_INTERNAL_RM('A', actor); new_line; rv = RS_FAILS; }
	else if (meta) { DESCEND_TO_SPECIFIC_ACTION_R(); rv = RulebookOutcome(); }
	else { FollowRulebook(ACTION_PROCESSING_RB); rv = RulebookOutcome(); }
	#IFDEF DEBUG;
	--debug_rule_nesting;
	if ((trace_actions) && (FindAction(-1))) {
		print "["; DB_Action(p1,p2,p3,p4,p5); print " - ";
		switch (rv) {
			RS_SUCCEEDS: print "succeeded";
			RS_FAILS: print "failed";
				#IFNDEF MEMORY_ECONOMY;
				if (reason_the_action_failed)
					print " the ",
						(RulePrintingRule) reason_the_action_failed;
			    #ENDIF;
			default: print "ended without result";
		}
		print "]^"; say__p = 1;
		SetRulebookOutcome(rv); ! In case disturbed by printing activities
	}
	#ENDIF;
	if (rv == RS_SUCCEEDS) UpdateActionBitmap();
	if (frame_id ~= -1) {
		p1 = FindAction(action);
		Mstack_Destroy_Frame(ActionData-->(p1+AD_VARIABLES_CREATOR), frame_id);
	}
	MStack_DestroyRBVars(ACTION_PROCESSING_RB);
	if ((keep_silent == false) && (multiflag == false)) DivideParagraphPoint();
	if (rv == RS_SUCCEEDS) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Internal Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ACTION_PROCESSING_INTERNAL_R; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Type Safety
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ActionVariablesNotTypeSafe mask noun_kova second_kova at;
	at = FindAction(-1); if (at == 0) rfalse; ! For any I6-defined actions

	noun_kova = ActionData-->(at+AD_NOUN_KOV);
	second_kova = ActionData-->(at+AD_SECOND_KOV);

	!print "at = ", at, " nst = ", noun_kova, "^";
	!print "consult_from = ", consult_from, " consult_words = ", consult_from, "^";
	!print "inp1 = ", inp1, " noun = ", noun, "^";
	!print "inp2 = ", inp2, " second = ", second, "^";
	!print "sst = ", second_kova, "^";

	if (noun_kova == SNIPPET_TY or UNDERSTANDING_TY) {
	    if (inp1 ~= 1) { inp2 = inp1; second = noun; }
	    parsed_number = 100*consult_from + consult_words;
	    inp1 = 1; noun = nothing; ! noun = parsed_number;
	}
	if (second_kova == SNIPPET_TY or UNDERSTANDING_TY) {
	    parsed_number = 100*consult_from + consult_words;
	    inp2 = 1; second = nothing; ! second = parsed_number;
	}

	mask = ActionData-->(at+AD_REQUIREMENTS);
	if (mask & OUT_OF_WORLD_ABIT) { meta = 1; rfalse; }
	meta = 0;

	if (inp1 == 1) {
	    if (noun_kova == OBJECT_TY) {
	    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('B'); new_line; }
	        rtrue;
	    }
	} else {
	    if (noun_kova ~= OBJECT_TY) {
	    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('C'); new_line; }
	        rtrue;
	    }
	    if ((mask & NEED_NOUN_ABIT) && (noun == nothing)) {
	    	@push act_requester; act_requester = nothing;
	        CarryOutActivity(SUPPLYING_A_MISSING_NOUN_ACT);
	        @pull act_requester;
	        if (noun == nothing) {
	        	if (say__p) rtrue;
		    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('D'); new_line; }
		        rtrue;
	    	}
	    }
	    if (((mask & NEED_NOUN_ABIT) == 0) && (noun ~= nothing)) {
	    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('E'); new_line; }
	        rtrue;
	    }
	}

	if (inp2 == 1) {
	    if (second_kova == OBJECT_TY) {
	    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('F'); new_line; }
	        rtrue;
	    }
	} else {
	    if (second_kova ~= OBJECT_TY) {
	    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('G'); new_line; }
	        rtrue;
	    }
	    if ((mask & NEED_SECOND_ABIT) && (second == nothing)) {
	        @push act_requester; act_requester = nothing;
	        CarryOutActivity(SUPPLYING_A_MISSING_SECOND_ACT);
	        @pull act_requester;
	        if (second == nothing) {
	        	if (say__p) rtrue;
		    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('H'); new_line; }
		        rtrue;
	        }
	    }
	    if (((mask & NEED_SECOND_ABIT) == 0) && (second ~= nothing)) {
	    	if (actor == player) { ACTION_PROCESSING_INTERNAL_RM('I'); new_line; }
	        rtrue;
	    }
	}

	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Basic Visibility Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BASIC_VISIBILITY_R;
	if (act_requester) rfalse;
	if ((NeedLightForAction()) &&
		(actor == player) &&
		(FollowRulebook(VISIBLE_RB)) &&
		(RulebookSucceeded())) {
		BeginActivity(REFUSAL_TO_ACT_IN_DARK_ACT);
		if (ForActivity(REFUSAL_TO_ACT_IN_DARK_ACT)==false) {
			BASIC_VISIBILITY_RM('A'); new_line;
		}
		EndActivity(REFUSAL_TO_ACT_IN_DARK_ACT);
		reason_the_action_failed = BASIC_VISIBILITY_R;
		RulebookFails();
		rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Basic Accessibility Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BASIC_ACCESSIBILITY_R mask at;
	if (act_requester) rfalse;
	at = FindAction(-1);
	if (at == 0) rfalse;
	mask = ActionData-->(at+AD_REQUIREMENTS);

	if ((mask & TOUCH_NOUN_ABIT) && noun && (inp1 ~= 1)) {
		if (noun ofclass K3_direction) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R; 
			if (actor~=player) rtrue;
			BASIC_ACCESSIBILITY_RM('A'); new_line;
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R; 
			rtrue;
		}
		if (ObjectIsUntouchable(noun, (actor~=player), actor)) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R;
			rtrue;
		}
	}

	if ((mask & TOUCH_SECOND_ABIT) && second && (inp2 ~= 1)) {
		if (second ofclass K3_direction) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R;
			if (actor~=player) rtrue;
			BASIC_ACCESSIBILITY_RM('A'); new_line;
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R; 
			rtrue;
		}
		if (ObjectIsUntouchable(second, (actor~=player), actor)) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R;
			rtrue;
		}
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Carrying Requirements Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CARRYING_REQUIREMENTS_R mask at;
	
	at = FindAction(-1);
	if (at == 0) rfalse;
	mask = ActionData-->(at+AD_REQUIREMENTS);

	if ((mask & TOUCH_NOUN_ABIT) && noun && (inp1 ~= 1)) {
		if ((mask & CARRY_NOUN_ABIT) && (noun notin actor)) {
			CarryOutActivity(IMPLICITLY_TAKING_ACT, noun);
			if (noun notin actor) {
				RulebookFails();
				reason_the_action_failed = CARRYING_REQUIREMENTS_R;
				rtrue;
			}
		}
	}

	if ((mask & TOUCH_SECOND_ABIT) && second && (inp2 ~= 1)) {
		if ((mask & CARRY_SECOND_ABIT) && (second notin actor)) {
			CarryOutActivity(IMPLICITLY_TAKING_ACT, second);
 			if (second notin actor) {
				RulebookFails();
				reason_the_action_failed = CARRYING_REQUIREMENTS_R;
				rtrue;
			}
		}
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Standard Implicit Taking Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STANDARD_IMPLICIT_TAKING_R;
	ImplicitTake(parameter_value);
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Requested Actions Require Persuasion Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ REQUESTED_ACTIONS_REQUIRE_R rv;
	if ((actor ~= player) && (act_requester)) {
		@push say__p;
		say__p = 0;
		rv = FollowRulebook(PERSUADE_RB);
		if (RulebookSucceeded() == false) {
			if ((deadflag == false) && (say__p == FALSE)) {
				REQUESTED_ACTIONS_REQUIRE_RM('A', actor);
				new_line;
			}
			ActRulebookFails(rv); rtrue;
		}
		@pull say__p;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Carry Out Requested Actions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CARRY_OUT_REQUESTED_ACTIONS_R rv;
	if ((actor ~= player) && (act_requester)) {
		@push act_requester; act_requester = nothing;
		rv = BeginAction(action, noun, second);
		if (((meta) || (rv == false)) && (deadflag == false)) {
			if (FollowRulebook(UNSUCCESSFUL_ATTEMPT_RB) == false) {
				CARRY_OUT_REQUESTED_ACTIONS_RM('A', actor); new_line;
			}
		}
		@pull act_requester;
		FollowRulebook(AFTER_RB);
		ActRulebookSucceeds();
		rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Generic Verb Subroutine
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array Details_of_Specific_Action-->5;

[ GenericVerbSub ch co re vis rv;
	@push converted_action_outcome;
	converted_action_outcome = -1;

	Details_of_Specific_Action-->0 = true;
	if (meta) Details_of_Specific_Action-->0 = false;
	Details_of_Specific_Action-->1 = keep_silent;
	Details_of_Specific_Action-->2 = ch; ! Check rules for the action
	Details_of_Specific_Action-->3 = co; ! Carry out rules for the action
	Details_of_Specific_Action-->4 = re; ! Report rules for the action

	FollowRulebook(SPECIFIC_ACTION_PROCESSING_RB, 0, true);
	if ((RulebookFailed()) && (converted_action_outcome == 1)) ActRulebookSucceeds();

	@pull converted_action_outcome;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Work Out Details Of Specific Action Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WORK_OUT_DETAILS_OF_SPECIFIC_R;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 0) = Details_of_Specific_Action-->0;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 1) = Details_of_Specific_Action-->1;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 2) = Details_of_Specific_Action-->2;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 3) = Details_of_Specific_Action-->3;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 4) = Details_of_Specific_Action-->4;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Actions Bitmap
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestActionBitmap obj act i j k bitmap;
	if (obj == nothing) bitmap = ActionHappened;
	else {
		if (~~(obj provides action_bitmap)) rfalse;
		bitmap = obj.&action_bitmap;
	}
	if (act == -1) return (((bitmap->0) & 1) ~= 0); 
	for (i=0, k=2: i<ActionCount: i++) {
		if (act == ActionCoding-->i) {
			return (((bitmap->j) & k) ~= 0);
		}
		k = k*2; if (k == 256) { k = 1; j++; }
	}
	rfalse;
];

[ UpdateActionBitmap;
	SetActionBitmap(noun, action);
	if (action == ##Go) SetActionBitmap(location, ##Enter);
];

[ SetActionBitmap obj act i j k bitmap;
	for (i=0, k=2: i<ActionCount: i++) {
		if (act == ActionCoding-->i) {
			if (obj provides action_bitmap) {
				bitmap = obj.&action_bitmap;
				bitmap->0 = (bitmap->0) | 1;
				bitmap->j = (bitmap->j) | k;
			}
			ActionHappened->0 = (ActionHappened->0) | 1;
			ActionHappened->j = (ActionHappened->j) | k;
		}
		k = k*2; if (k == 256) { k = 1; j++; }
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Actions.i6t: Printing Actions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SayActionName act; DB_Action(0, 0, act, 0, 0, 2); ];

[ DA_Name n; if (n ofclass K3_direction) print (name) n; else print (the) n; ];
[ DA_Topic x a b c d i cf cw;
	cw = x%100; cf = x/100;
	print "~";
	for (a=cf:d<cw:d++,a++) {
		wn = a; b = WordAddress(a); c = WordLength(a);
		for (i=b:i<b+c:i++) {
			print (char) 0->i;
		}
		if (d<cw-1) print " ";
	}
	print "~";
];
[ DA_Number n; print n; ];
[ DA_TruthState n; if (n==0) print "false"; else print "true"; ];
[ DB_Action ac acr act n s for_say t at l j v c clc;
	if ((for_say == 0) && (debug_rule_nesting > 0))
		print "(", debug_rule_nesting, ") ";
	if ((ac ~= player) && (for_say ~= 2)) {
		if (acr) print "asking ", (the) ac, " to try ";
		else print (the) ac, " ";
	}
	DB_Action_Details(act, n, s, for_say);
	if ((keep_silent) && (for_say == 0)) print " - silently";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: The Activities Stack
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant MAX_NESTED_ACTIVITIES = 20;
Global activities_sp = 0;
Array activities_stack --> MAX_NESTED_ACTIVITIES;
Array activity_parameters_stack --> MAX_NESTED_ACTIVITIES;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Rule Debugging Inhibition
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global inhibit_flag = 0;
Global saved_debug_rules = 0;
[ FixInhibitFlag n act inhibit_rule_debugging;
	for (n=0:n<activities_sp:n++) {
		act = activities_stack-->n;
		if (act == PRINTING_THE_NAME_ACT or PRINTING_THE_PLURAL_NAME_ACT or
			PRINTING_ROOM_DESC_DETAILS_ACT or PRINTING_INVENTORY_DETAILS_ACT or
			LISTING_CONTENTS_ACT or GROUPING_TOGETHER_ACT or PRINTING_RESPONSE_ACT)
				inhibit_rule_debugging = true;
	}
	if ((inhibit_flag == false) && (inhibit_rule_debugging)) {
		saved_debug_rules = debug_rules;
		debug_rules = 0;
	}
	if ((inhibit_flag) && (inhibit_rule_debugging == false)) {
		debug_rules = saved_debug_rules;
	}
	inhibit_flag = inhibit_rule_debugging;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Testing Activities
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestActivity A desc val i;
	for (i=0:i<activities_sp:i++)
		if (activities_stack-->i == A) {
			if (desc) {
				if ((desc)(activity_parameters_stack-->i)) rtrue;
			} else if (val) {
				if (val == activity_parameters_stack-->i) rtrue;
			} else rtrue;
		}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Emptiness
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ActivityEmpty A x;
	x = Activity_before_rulebooks-->A;
	if (rulebooks_array-->x ~= EMPTY_RULEBOOK) rfalse;
	x = Activity_for_rulebooks-->A;
	if (rulebooks_array-->x ~= EMPTY_RULEBOOK) rfalse;
	x = Activity_after_rulebooks-->A;
	if (rulebooks_array-->x ~= EMPTY_RULEBOOK) rfalse;
	rtrue;
];

[ RulebookEmpty rb;
	if (rulebooks_array-->rb ~= EMPTY_RULEBOOK) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Process Activity Rulebook
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ProcessActivityRulebook rulebook parameter  rv;
	@push self;
	if (parameter) self = parameter;
	rv = FollowRulebook(rulebook, parameter, true);
	@pull self;
	if (rv) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Carrying Out Activities
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CarryOutActivity A o rv;
	BeginActivity(A, o);
	rv = ForActivity(A, o);
	EndActivity(A, o);
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Begin
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BeginActivity A o x;
	if (activities_sp == MAX_NESTED_ACTIVITIES) return RunTimeProblem(RTP_TOOMANYACTS);
	activity_parameters_stack-->activities_sp = o;
	activities_stack-->(activities_sp++) = A;
	FixInhibitFlag();
	MStack_CreateAVVars(A);
	if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
	o = ProcessActivityRulebook(Activity_before_rulebooks-->A, o);
	if (Activity_atb_rulebooks->A) action = x;
	return o;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: For
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ForActivity A o x;
	if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
	o = ProcessActivityRulebook(Activity_for_rulebooks-->A, o);
	if (Activity_atb_rulebooks->A) action = x;
	return o;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: End
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ EndActivity A o rv x;
	if ((activities_sp > 0) && (activities_stack-->(activities_sp-1) == A)) {
		if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
		rv = ProcessActivityRulebook(Activity_after_rulebooks-->A, o);
		if (Activity_atb_rulebooks->A) action = x;
		activities_sp--; FixInhibitFlag();
		MStack_DestroyAVVars(A);
		return rv;
	}
	return RunTimeProblem(RTP_CANTABANDON);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Activities.i6t: Abandon
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ AbandonActivity A o;
	if ((activities_sp > 0) && (activities_stack-->(activities_sp-1) == A)) {
		activities_sp--; FixInhibitFlag();
		MStack_DestroyAVVars(A);
		return;
	}
	return RunTimeProblem(RTP_CANTEND);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Figures.i6t: Resource Usage
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array ResourceUsageFlags ->
	(30+0+5);


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Figures.i6t: Figures
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DisplayFigure resource_ID one_time;
	if ((one_time) && (ResourceUsageFlags->resource_ID)) return;
	ResourceUsageFlags->resource_ID = true;
	print "^"; VM_Picture(resource_ID); print "^";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Figures.i6t: Sound Effects
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PlaySound resource_ID one_time;
	if (resource_ID == 0) return; ! The "silence" non-sound effect
	if ((one_time) && (ResourceUsageFlags->resource_ID)) return;
	ResourceUsageFlags->resource_ID = true;
	VM_SoundEffect(resource_ID);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Language
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF PLUGIN_FILES;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Structure
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant AUXF_MAGIC = 0; ! First word holds a safety constant
Constant AUXF_MAGIC_VALUE = 16339; ! Should be first word of any valid file structure
Constant AUXF_STATUS = 1; ! One of the following:
	Constant AUXF_STATUS_IS_CLOSED = 1; ! Currently closed, or perhaps doesn't exist
	Constant AUXF_STATUS_IS_OPEN_FOR_READ = 2;
	Constant AUXF_STATUS_IS_OPEN_FOR_WRITE = 3;
	Constant AUXF_STATUS_IS_OPEN_FOR_APPEND = 4;
Constant AUXF_BINARY = 2; ! False for text files (I7 default), true for binary
Constant AUXF_STREAM = 3; ! Stream for an open file (meaningless otherwise)
Constant AUXF_FILENAME = 4; ! Packed address of constant string
Constant AUXF_IFID_OF_OWNER = 5; ! UUID_ARRAY if owned by this project, or
	! string array of IFID of owner wrapped in //...//, or NULL to leave open


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Instances
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant NO_EXTERNAL_FILES 0;
Array TableOfExternalFiles --> 0 0;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Errors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_Error extf err_text  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) {
		print "^*** Error on unknown file: ", (string) err_text, " ***^";
	} else {
		struc = TableOfExternalFiles-->extf;
		print "^*** Error on file '",
			(string) struc-->AUXF_FILENAME, "': ",
			(string) err_text, " ***^";
	}
	RunTimeProblem(RTP_FILEIOERROR);
	return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Glulx Material
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF TARGET_GLULX;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Existence
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_Exists extf  fref struc rv usage;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) rfalse;
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	rv = glk_fileref_does_file_exist(fref);
	glk_fileref_destroy(fref);
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Readiness
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_Ready extf  struc fref usage str ch;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) rfalse;
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	if (glk_fileref_does_file_exist(fref) == false) {
		glk_fileref_destroy(fref);
		rfalse;
	}
	str = glk_stream_open_file(fref, filemode_Read, 0);
	ch = glk_get_char_stream(str);
	glk_stream_close(str, 0);
	glk_fileref_destroy(fref);
	if (ch ~= '*') rfalse;
	rtrue;
];

[ FileIO_MarkReady extf readiness  struc fref str ch usage;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to open a non-file");
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	if (glk_fileref_does_file_exist(fref) == false) {
		glk_fileref_destroy(fref);
		return FileIO_Error(extf, "only existing files can be marked");
	}
	if (struc-->AUXF_STATUS ~= AUXF_STATUS_IS_CLOSED) {
		glk_fileref_destroy(fref);
		return FileIO_Error(extf, "only closed files can be marked");
	}
	str = glk_stream_open_file(fref, filemode_ReadWrite, 0);
	glk_stream_set_position(str, 0, 0); ! seek start
	if (readiness) ch = '*'; else ch = '-';
	glk_put_char_stream(str, ch); ! mark as complete
	glk_stream_close(str, 0);
	glk_fileref_destroy(fref);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Open File
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_Open extf write_flag append_flag
	struc fref str mode ix ch not_this_ifid owner force_header usage;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to open a non-file");
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_STATUS ~= AUXF_STATUS_IS_CLOSED)
		return FileIO_Error(extf, "tried to open a file already open");
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	if (write_flag) {
		if (append_flag) {
			mode = filemode_WriteAppend;
			if (glk_fileref_does_file_exist(fref) == false)
				force_header = true;
		}
		else mode = filemode_Write;
	} else {
		mode = filemode_Read;
		if (glk_fileref_does_file_exist(fref) == false) {
			glk_fileref_destroy(fref);
			return FileIO_Error(extf, "tried to open a file which does not exist");
		}
	}
	str = glk_stream_open_file(fref, mode, 0);
	glk_fileref_destroy(fref);
	if (str == 0) return FileIO_Error(extf, "tried to open a file but failed");
	struc-->AUXF_STREAM = str;
	if (write_flag) {
		if (append_flag)
			struc-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_APPEND;
		else
			struc-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_WRITE;
		glk_stream_set_current(str);
		if ((append_flag == FALSE) || (force_header)) {
			print "- ";
			for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
			print " ", (string) struc-->AUXF_FILENAME, "^";
		}
	} else {
		struc-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_READ;
		ch = FileIO_GetC(extf);
		if (ch ~= '-' or '*') { jump BadFile; }
		if (ch == '-')
			return FileIO_Error(extf, "tried to open a file which was incomplete");
		ch = FileIO_GetC(extf);
		if (ch ~= ' ') { jump BadFile; }
		ch = FileIO_GetC(extf);
		if (ch ~= '/') { jump BadFile; }
		ch = FileIO_GetC(extf);
		if (ch ~= '/') { jump BadFile; }
		owner = struc-->AUXF_IFID_OF_OWNER;
		ix = 3;
		if (owner == UUID_ARRAY) ix = 8;
		if (owner ~= NULL) {
			for (: ix <= owner->0: ix++) {
				ch = FileIO_GetC(extf);
				if (ch == -1) { jump BadFile; }
				if (ch ~= owner->ix) not_this_ifid = true;
				if (ch == ' ') break;
			}
			if (not_this_ifid == false) {
				ch = FileIO_GetC(extf);
				if (ch ~= ' ') { jump BadFile; }
			}
		}
		while (ch ~= -1) {
			ch = FileIO_GetC(extf);
			if (ch == 10 or 13) break;
		}
		if (not_this_ifid) {
			struc-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
			glk_stream_close(str, 0);
			return FileIO_Error(extf,
				"tried to open a file owned by another project");
		}
	}
	return struc-->AUXF_STREAM;
	.BadFile;
	struc-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
	glk_stream_close(str, 0);
	return FileIO_Error(extf, "tried to open a file which seems to be malformed");
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Close File
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_Close extf  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to open a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_STATUS ~=
		AUXF_STATUS_IS_OPEN_FOR_READ or
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND)
		return FileIO_Error(extf, "tried to close a file which is not open");
	if (struc-->AUXF_STATUS ==
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND) {
		glk_stream_set_position(struc-->AUXF_STREAM, 0, 0); ! seek start
		glk_put_char_stream(struc-->AUXF_STREAM, '*'); ! mark as complete
	}
	glk_stream_close(struc-->AUXF_STREAM, 0);
	struc-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Get Character
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_GetC extf  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) return -1;
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_STATUS ~= AUXF_STATUS_IS_OPEN_FOR_READ) return -1;
	return glk_get_char_stream(struc-->AUXF_STREAM);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Put Character
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_PutC extf char  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) return -1;
		return FileIO_Error(extf, "tried to write to a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_STATUS ~=
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND)
		return FileIO_Error(extf,
			"tried to write to a file which is not open for writing");
	return glk_put_char_stream(struc-->AUXF_STREAM, char);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Print Line
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_PrintLine extf ch  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to write to a non-file");
	struc = TableOfExternalFiles-->extf;
	for (::) {
		ch = FileIO_GetC(extf);
		if (ch == -1) rfalse;
		if (ch == 10 or 13) { print "^"; rtrue; }
		print (char) ch;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Print Contents
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_PrintContents extf tab  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to access a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "printing text will not work with binary files");
	if (FileIO_Open(extf, false) == 0) rfalse;
	while (FileIO_PrintLine(extf)) ;
	FileIO_Close(extf);
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Print Text
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_PutContents extf text append_flag  struc str ch oldstream;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to access a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "writing text will not work with binary files");
	oldstream = glk_stream_get_current();
	str = FileIO_Open(extf, true, append_flag);
	if (str == 0) rfalse;
	@push say__p; @push say__pc;
	ClearParagraphing(19);
	TEXT_TY_Say(text);
	FileIO_Close(extf);
	if (oldstream) glk_stream_set_current(oldstream);
	@pull say__pc; @pull say__p;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Serialising Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FileIO_PutTable extf tab rv  struc oldstream;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to write table to a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "writing a table will not work with binary files");
	oldstream = glk_stream_get_current();
	if (FileIO_Open(extf, true) == 0) rfalse;
	rv = TablePrint(tab);
	FileIO_Close(extf);
	if (oldstream) glk_stream_set_current(oldstream);
	if (rv) return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
	rtrue;
];

[ FileIO_GetTable extf tab  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to read table from a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "reading a table will not work with binary files");
	if (FileIO_Open(extf, false) == 0) rfalse;
	TableRead(tab, extf);
	FileIO_Close(extf);
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Z-Machine Stubs
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFNOT; ! TARGET_GLULX
[ FileIO_Exists extf; rfalse; ];
[ FileIO_Ready extf; rfalse; ];
[ FileIO_GetC extf; return -1; ];
[ FileIO_PutTable extf tab;
	return FileIO_Error(extf, "external files can only be used under Glulx");
];
[ FileIO_MarkReady extf status; FileIO_PutTable(extf); ];
[ FileIO_GetTable extf tab; FileIO_PutTable(extf); ];
[ FileIO_PrintContents extf; FileIO_PutTable(extf); ];
[ FileIO_PutContents extf; FileIO_PutTable(extf); ];
#ENDIF; ! TARGET_GLULX


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! FileIO.i6t: Back To Core
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFNOT; ! PLUGIN_FILES
[ FileIO_GetC extf; return -1; ];
#ENDIF; ! PLUGIN_FILES


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: The Memory Stack
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant MAX_MSTACK_FRAME = 2 + 6;
Constant MSTACK_CAPACITY = 20;
Constant MSTACK_SIZE = MSTACK_CAPACITY*MAX_MSTACK_FRAME;

Array MStack --> MSTACK_SIZE;
Global MStack_Top = 0; ! Topmost word currently used


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Create Frame
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Mstack_Create_Frame creator id extent;
	if (creator == 0) rfalse;
	extent = creator.call(MStack_Top+2, 1);
	if (extent == 0) rfalse;
	if (MStack_Top + MAX_MSTACK_FRAME >= MSTACK_SIZE + 2) {
		RunTimeProblem(RTP_MSTACKMEMORY, MSTACK_SIZE);
		Mstack_Backtrace();
		rfalse;
	}
	MStack_Top++;
	MStack-->MStack_Top = id;
	MStack_Top++;
	MStack_Top = MStack_Top + extent;
	MStack-->MStack_Top = -(extent+2);
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Destroy Frame
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Mstack_Destroy_Frame creator id pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) rfalse; ! Not found: do nothing
	MStack_Top = pos - 2; ! Clear mstack down to just below this frame
	if (creator) creator.call(pos, -1);
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Seek Frame
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global MStack_Frame_Extent = 0;

[ Mstack_Seek_Frame id pos;
	pos = MStack_Top;
	while ((pos > 0) && (MStack-->pos ~= 0)) {
		MStack_Frame_Extent = MStack-->pos;
		pos = pos + MStack_Frame_Extent;
		MStack_Frame_Extent = (-2) - MStack_Frame_Extent;
		if (MStack-->(pos+1) == id) return pos+2;
	}
	MStack_Frame_Extent = 0;
	return 0; ! Not found
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Backtrace
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Mstack_Backtrace pos k;
	print "Mstack backtrace: size ", MStack_Top+1, " words^";
	pos = MStack_Top;
	while (MStack-->pos ~= 0) {
		MStack_Frame_Extent = MStack-->pos;
		pos = pos + MStack_Frame_Extent;
		MStack_Frame_Extent = (-2) - MStack_Frame_Extent;
		print "Block at ", pos+2,
			" owner ID ", MStack-->(pos+1), " size ", MStack_Frame_Extent, "^";
		for (k=0: k<MStack_Frame_Extent: k++) print MStack-->(pos+2+k), " ";
		print "^";
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Access to Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MstVO id off pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) {
		print "Variable unavailable for this action, activity or rulebook: ",
			"internal ID number ",
			id, "/", off, "^";
		rfalse;
	}
	if ((off<0) || (off >= MStack_Frame_Extent)) {
		print "Variable stack offset wrong: ", id, "/", off, " at ", pos, "^";
		rfalse;
	}
	return pos+off;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Access to Nonexistent Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MstVON id off pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) {
		return 0; ! word position 0 on the M-stack
	}
	if ((off<0) || (off >= MStack_Frame_Extent)) {
		print "Variable stack offset wrong: ", id, "/", off, " at ", pos, "^";
		rfalse;
	}
	return pos+off;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Rulebook Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFNDEF MEMORY_ECONOMY;
Array rulebook_var_creators --> 0 0 0 0 0 0 0 0 0 RBSTVC_9 0 RBSTVC_11 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
#endif;
[  RBSTVC_9 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = selfobj; pos++;
    } else {
        pos++;
    }
    return 1;
];
[  RBSTVC_11 
    pos ! Implied call parameter
    state ! Implied call parameter
    ;
    if (state == 1) {
        MStack-->pos = false; pos++;
        MStack-->pos = false; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = false; pos++;
    } else {
        pos++;
        pos++;
        pos++;
        pos++;
        pos++;
        pos++;
    }
    return 6;
];


[ MStack_CreateRBVars rb cr;
#ifdef MEMORY_ECONOMY;
switch (rb) {
9: cr = RBSTVC_9;
11: cr = RBSTVC_11;
}
#IFNOT;
cr = rulebook_var_creators-->rb;
#endif;

	if (cr == 0) return;
	Mstack_Create_Frame(cr, rb);
];

[ MStack_DestroyRBVars rb cr;
#ifdef MEMORY_ECONOMY;
switch (rb) {
9: cr = RBSTVC_9;
11: cr = RBSTVC_11;
}
#IFNOT;
cr = rulebook_var_creators-->rb;
#endif;

	if (cr == 0) return;
	Mstack_Destroy_Frame(cr, rb);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! MStack.i6t: Activity Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array activity_var_creators --> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;


[ MStack_CreateAVVars av cr;
	cr = activity_var_creators-->av;
	if (cr == 0) return;
	Mstack_Create_Frame(cr, av + 10000);
];

[ MStack_DestroyAVVars av cr;
	cr = activity_var_creators-->av;
	if (cr == 0) return;
	Mstack_Destroy_Frame(cr, av + 10000);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Perform Undo
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Perform_Undo;
	#ifdef PREVENT_UNDO; IMMEDIATELY_UNDO_RM('A'); new_line; return; #endif;
	if (IterationsOfTurnSequence == 0) { IMMEDIATELY_UNDO_RM('B'); new_line; return; }
	if (undo_flag == 0) { IMMEDIATELY_UNDO_RM('C'); new_line; return; }
	if (undo_flag == 1) { IMMEDIATELY_UNDO_RM('D'); new_line; return; }
	if (VM_Undo() == 0) { IMMEDIATELY_UNDO_RM('F'); new_line; }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Announce Score Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ANNOUNCE_SCORE_R;
	if (actor ~= player) rfalse;
	#Iftrue USE_SCORING == 0; ANNOUNCE_SCORE_RM('C'); new_line;
	#ifnot; ANNOUNCE_SCORE_RM('A'); PrintRank();
	#endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Switch Score Notification On Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SWITCH_SCORE_NOTIFY_ON_R;
	if (actor ~= player) rfalse;
	#Iftrue USE_SCORING == 0; ANNOUNCE_SCORE_R();
	#ifnot; notify_mode=1; #endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Standard Report Switching Score Notification On Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ REP_SWITCH_NOTIFY_ON_R;
	if (actor ~= player) rfalse;
	#Iftrue USE_SCORING ~= 0; REP_SWITCH_NOTIFY_ON_RM('A'); new_line; #endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Switch Score Notification Off Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SWITCH_SCORE_NOTIFY_OFF_R;
	if (actor ~= player) rfalse;
	#Iftrue USE_SCORING == 0; ANNOUNCE_SCORE_R();
	#ifnot; notify_mode=0; #endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Standard Report Switching Score Notification Off Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ REP_SWITCH_NOTIFY_OFF_R;
	if (actor ~= player) rfalse;
	#Iftrue USE_SCORING ~= 0; REP_SWITCH_NOTIFY_OFF_RM('A'); new_line; #endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Prefer Sometimes Abbreviated Room Descriptions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PREFER_SOMETIMES_ABBREVIATED_R;
	if (actor ~= player) rfalse;
	lookmode=1;
]; ! Brief


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Standard Report Prefer Sometimes Abbreviated Room Descriptions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ REP_PREFER_SOMETIMES_ABBR_R;
	if (actor ~= player) rfalse;
	print (TEXT_TY_Say) Story; REP_PREFER_SOMETIMES_ABBR_RM('A'); new_line;
]; ! Brief


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Prefer Unabbreviated Room Descriptions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PREFER_UNABBREVIATED_R;
	if (actor ~= player) rfalse;
	lookmode=2;
]; ! Verbose


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Standard Report Prefer Unabbreviated Room Descriptions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ REP_PREFER_UNABBREVIATED_R;
	if (actor ~= player) rfalse;
	print (TEXT_TY_Say) Story; REP_PREFER_UNABBREVIATED_RM('A'); new_line;
]; ! Verbose


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Prefer Abbreviated Room Descriptions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PREFER_ABBREVIATED_R;
	if (actor ~= player) rfalse;
	lookmode=3;
]; ! Superbrief


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Standard Report Prefer Abbreviated Room Descriptions Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ REP_PREFER_ABBREVIATED_R;
	if (actor ~= player) rfalse;
	print (TEXT_TY_Say) Story; REP_PREFER_ABBREVIATED_RM('A'); new_line;
]; ! Superbrief


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! OutOfWorld.i6t: Announce Pronoun Meanings Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ANNOUNCE_PRONOUN_MEANINGS_R x y c d;
	if (actor ~= player) rfalse;
	ANNOUNCE_PRONOUN_MEANINGS_RM('A');

	c = (LanguagePronouns-->0)/3;
	if (player ~= selfobj) c++;

	if (c==0) { ANNOUNCE_PRONOUN_MEANINGS_RM('D'); rtrue; }

	for (x = 1, d = 0 : x <= LanguagePronouns-->0: x = x+3) {
		print "~", (address) LanguagePronouns-->x, "~ ";
		y = LanguagePronouns-->(x+2);
		if (y == NULL) ANNOUNCE_PRONOUN_MEANINGS_RM('C');
		else { ANNOUNCE_PRONOUN_MEANINGS_RM('B'); print (the) y; }
		d++;
		if (d < c-1) print ", ";
		if (d == c-1) {
			#ifdef SERIAL_COMMA; print ","; #endif;
			LIST_WRITER_INTERNAL_RM('C');
		}
	}
	if (player ~= selfobj) {
		print "~", (address) ME1__WD, "~ "; ANNOUNCE_PRONOUN_MEANINGS_RM('B');
		c = player; player = selfobj;
		print (the) c; player = c;
	}
	".";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Paragraph Control
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: State
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

!Constant TRACE_I7_SPACING;

[ ClearParagraphing r;
	say__p = 0; say__pc = 0;
];

[ DivideParagraphPoint;
	#ifdef TRACE_I7_SPACING; print "[DPP", say__p, say__pc, "]"; #endif;
	if (say__p) {
		new_line; say__p = 0; say__pc = say__pc | PARA_COMPLETED;
		say__pc_save = true;
		if (say__pc & PARA_PROMPTSKIP) say__pc = say__pc - PARA_PROMPTSKIP;
		if (say__pc & PARA_SUPPRESSPROMPTSKIP) say__pc = say__pc - PARA_SUPPRESSPROMPTSKIP;
	}
	#ifdef TRACE_I7_SPACING; print "[-->", say__p, say__pc, "]"; #endif;
	say__pc = say__pc | PARA_CONTENTEXPECTED;
	say__pc_save = (say__pc & PARA_COMPLETED);
];

[ AdjustParagraphPoint;
	#ifdef TRACE_I7_SPACING; print "[APP ", say__p, " ", say__pc, " ", say__pc_save, "]^"; #endif;
	if (say__pc_save) say__pc = (say__pc | PARA_COMPLETED);
];

[ ParaContent;
	if (say__pc & PARA_CONTENTEXPECTED) {
		say__pc = say__pc - PARA_CONTENTEXPECTED;
		say__p = 1;
	}
];

[ GoingLookBreak;
	! if (say__pc & PARA_COMPLETED == 0) new_line;
	ClearParagraphing(10);
];

[ CommandClarificationBreak;
	new_line;
	ClearParagraphing(11);
];

[ RunParagraphOn;
	#ifdef TRACE_I7_SPACING; print "[RPO", say__p, say__pc, "]"; #endif;
	say__p = 0;
	say__pc = say__pc | PARA_PROMPTSKIP;
	say__pc = say__pc | PARA_SUPPRESSPROMPTSKIP;
];

[ SpecialLookSpacingBreak;
	#ifdef TRACE_I7_SPACING; print "[SLS", say__p, say__pc, "]"; #endif;
	say__p = 0;
	say__pc = say__pc | PARA_PROMPTSKIP;
];

[ EnsureBreakBeforePrompt;
	if ((say__p) ||
		((say__pc & PARA_PROMPTSKIP) && ((say__pc & PARA_SUPPRESSPROMPTSKIP)==0)))
		new_line;
	ClearParagraphing(12);
];

[ PrintSingleParagraph matter;
	say__p = 1;
	say__pc = say__pc | PARA_NORULEBOOKBREAKS;
	TEXT_TY_Say(matter);
	DivideParagraphPoint(13);
	say__pc = 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Say Number
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STextSubstitution;
	if (say__n ~= 1) print "s";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Prompt
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintPrompt i;
	RunTimeProblemShow();
	ClearRTP();
	style roman;
	EnsureBreakBeforePrompt();
	TEXT_TY_Say( (Global_Vars-->1) );
	ClearBoxedText();
	ClearParagraphing(14);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Boxed Quotations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global pending_boxed_quotation; ! a routine to overlay the quotation on screen

[ DisplayBoxedQuotation Q;
	pending_boxed_quotation = Q;
];

[ ClearBoxedText i;
	if (pending_boxed_quotation) {
		for (i=0: Runtime_Quotations_Displayed-->i: i++)
			if (Runtime_Quotations_Displayed-->i == pending_boxed_quotation) {
				pending_boxed_quotation = 0;
				return;
			}
		Runtime_Quotations_Displayed-->i = pending_boxed_quotation;

		ClearParagraphing(15);
		pending_boxed_quotation();
		ClearParagraphing(16);

		pending_boxed_quotation = 0;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Score Notification
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NotifyTheScore d;
#Iftrue USE_SCORING ~= 0;
	if (notify_mode == 1) {
		DivideParagraphPoint();
		VM_Style(NOTE_VMSTY);
		d = score-last_score;
		if (d > 0) { ANNOUNCE_SCORE_RM('D', d); }
		else if (d < 0) { ANNOUNCE_SCORE_RM('E', -d); }
		new_line;
		VM_Style(NORMAL_VMSTY);
	}
#Endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Status Line
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef TARGET_ZCODE;
#Iftrue (#version_number == 6);
[ DrawStatusLine; Z6_DrawStatusLine(); ];
#Endif;
#Endif;

#Ifndef DrawStatusLine;
[ DrawStatusLine width posb;
	@push say__p; @push say__pc;
	BeginActivity(CONSTRUCTING_STATUS_LINE_ACT);
	VM_StatusLineHeight(1); VM_MoveCursorInStatusLine(1, 1); 
	if (statuswin_current) {
		width = VM_ScreenWidth(); posb = width-15;
		spaces width;
		ClearParagraphing(17);
		if (ForActivity(CONSTRUCTING_STATUS_LINE_ACT) == false) {
			VM_MoveCursorInStatusLine(1, 2);
			TEXT_TY_Say(left_hand_status_line);
			VM_MoveCursorInStatusLine(1, posb);
			TEXT_TY_Say(right_hand_status_line);
		}
		VM_MoveCursorInStatusLine(1, 1); VM_MainWindow();
	}
	ClearParagraphing(18);
	EndActivity(CONSTRUCTING_STATUS_LINE_ACT);
	@pull say__pc; @pull say__p;
];
#Endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Status Line Utilities
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array T_SL_Score_Moves --> CONSTANT_PACKED_TEXT_STORAGE SL_Score_Moves;

[ SL_Score_Moves;
	if (not_yet_in_play) return;
	#Iftrue USE_SCORING > 0; print sline1, "/", sline2; #endif;
];

Array T_SL_Location --> CONSTANT_PACKED_TEXT_STORAGE SL_Location;

[ SL_Location even_before;
	if ((not_yet_in_play) && (even_before == false)) return;
	if (location == thedark) {
		BeginActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);
		if (ForActivity(PRINTING_NAME_OF_DARK_ROOM_ACT) == false)
 			DARKNESS_NAME_INTERNAL_RM('A');
		EndActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);
	} else {
		FindVisibilityLevels();
		if (visibility_ceiling == location) print (name) location;
		else print (The) visibility_ceiling;
	}
];

[ DARKNESS_NAME_INTERNAL_R; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Banner
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Banner;
   BeginActivity(PRINTING_BANNER_TEXT_ACT);
   if (ForActivity(PRINTING_BANNER_TEXT_ACT) == false) {
	   	VM_Style(HEADER_VMSTY);
		TEXT_TY_Say(Story);
		VM_Style(NORMAL_VMSTY);
		new_line;
		TEXT_TY_Say(Headline);
		#ifdef Story_Author;
		print " by "; TEXT_TY_Say(Story_Author);
		#endif; ! Story_Author
		new_line;
		VM_Describe_Release();
		print " / Inform 7 build ", (PrintI6Text) NI_BUILD_COUNT, " ";
		print "(I6/v"; inversion;
		print " lib ", (PrintI6Text) LibRelease, ") ";
		#Ifdef STRICT_MODE;
		print "S";
		#Endif; ! STRICT_MODE
		#Ifdef DEBUG;
		print "D";
		#Endif; ! DEBUG
		new_line;
    }
    EndActivity(PRINTING_BANNER_TEXT_ACT);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Print Decimal Number
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DecimalNumber num; print num; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Print English Number
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ EnglishNumber n; LanguageNumber(n); ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Print Text
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintI6Text x;
	if (x ofclass String) print (string) x;
	if (x ofclass Routine) return (x)();
	if (x == EMPTY_TEXT_PACKED) rfalse;
	rtrue;
];
[ I7_String x; TEXT_TY_Say(x); ]; ! An alternative name now used only by extensions


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Print Or Run
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintOrRun obj prop no_break  pv st routine_return_value;
	@push self; self = obj;
	if (prop == 0) {
		print (name) prop; routine_return_value = true;
	} else {
		routine_return_value = TEXT_TY_Say(obj.prop);
	}
	@pull self;
	if (routine_return_value) {
		say__p = 1;
		if (no_break == false) {
			new_line;
			DivideParagraphPoint();
		}
	}

	return routine_return_value;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Short Name Storage
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array StorageForShortName buffer 250;

[ CPrintOrRun obj prop  v length i;
    if ((obj ofclass String or Routine) || (prop == 0))
        VM_PrintToBuffer (StorageForShortName, 160, obj);
    else {
    	if (obj.prop == NULL) rfalse;
        if (metaclass(obj.prop) == Routine or String)
            VM_PrintToBuffer(StorageForShortName, 160, obj, prop);
        else return RunTimeError(2, obj, prop);
	}

    length = StorageForShortName-->0;

    StorageForShortName->WORDSIZE = VM_LowerToUpperCase(StorageForShortName->WORDSIZE);
    for (i=WORDSIZE: i<length+WORDSIZE: i++) print (char) StorageForShortName->i;
    if (i>WORDSIZE) say__p = 1;

    return;
];

[ Cap str nocaps;
    if (nocaps) print (string) str;
    else CPrintOrRun(str, 0);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Object Names I
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PSN__ o;
    if (o == 0) { LIST_WRITER_INTERNAL_RM('Y'); rtrue; }
    switch (metaclass(o)) {
		Routine:  print "<routine ", o, ">"; rtrue;
		String:   print "<string ~", (string) o, "~>"; rtrue;
		nothing:  print "<illegal object number ", o, ">"; rtrue;
    }
    RegardingSingleObject(o);
    CarryOutActivity(PRINTING_THE_NAME_ACT, o);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Standard Name Printing Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global caps_mode = false;

[ STANDARD_NAME_PRINTING_R obj;
	obj = parameter_value;
    if (obj == 0) {
    	LIST_WRITER_INTERNAL_RM('Y'); return;
    }
    switch (metaclass(obj)) {
		Routine:  print "<routine ", obj, ">"; return;
		String:   print "<string ~", (string) obj, "~>"; return;
		nothing:  print "<illegal object number ", obj, ">"; return;
    }
    if (obj == player) { 
   	    if (indef_mode == NULL && caps_mode) PRINT_PROTAGONIST_INTERNAL_RM('A');
   	    else PRINT_PROTAGONIST_INTERNAL_RM('B');
   	    return;
   	}
    #Ifdef LanguagePrintShortName;
    if (LanguagePrintShortName(obj)) return;
    #Endif; ! LanguagePrintShortName
    if (indef_mode && obj.&short_name_indef ~= 0 &&
    	PrintOrRun(obj, short_name_indef, true) ~= 0) return;
    if (caps_mode &&
    	obj.&cap_short_name ~= 0 && PrintOrRun(obj, cap_short_name, true) ~= 0) {
    	caps_mode = false;
    	return;
    }
    if (obj.&short_name ~= 0 && PrintOrRun(obj, short_name, true) ~= 0) return;
    print (object) obj;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Internal Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PRINT_PROTAGONIST_INTERNAL_R; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Object Names II
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global short_name_case;

[ PrefaceByArticle obj acode pluralise capitalise  i artform findout artval;
    if (obj provides articles) {
        artval=(obj.&articles)-->(acode+short_name_case*LanguageCases);
        if (capitalise)
            print (Cap) artval, " ";
        else
            print (string) artval, " ";
        if (pluralise) return;
        print (PSN__) obj; return;
    }

    i = GetGNAOfObject(obj);
    if (pluralise) {
        if (i < 3 || (i >= 6 && i < 9)) i = i + 3;
    }
    i = LanguageGNAsToArticles-->i;

    artform = LanguageArticles
        + 3*WORDSIZE*LanguageContractionForms*(short_name_case + i*LanguageCases);

    #Iftrue (LanguageContractionForms == 2);
    if (artform-->acode ~= artform-->(acode+3)) findout = true;
    #Endif; ! LanguageContractionForms
    #Iftrue (LanguageContractionForms == 3);
    if (artform-->acode ~= artform-->(acode+3)) findout = true;
    if (artform-->(acode+3) ~= artform-->(acode+6)) findout = true;
    #Endif; ! LanguageContractionForms
    #Iftrue (LanguageContractionForms == 4);
    if (artform-->acode ~= artform-->(acode+3)) findout = true;
    if (artform-->(acode+3) ~= artform-->(acode+6)) findout = true;
    if (artform-->(acode+6) ~= artform-->(acode+9)) findout = true;
    #Endif; ! LanguageContractionForms
    #Iftrue (LanguageContractionForms > 4);
    findout = true;
    #Endif; ! LanguageContractionForms

    #Ifdef TARGET_ZCODE;
    if (standard_interpreter ~= 0 && findout) {
        StorageForShortName-->0 = 160;
        @output_stream 3 StorageForShortName;
        if (pluralise) print (number) pluralise; else print (PSN__) obj;
        @output_stream -3;
        acode = acode + 3*LanguageContraction(StorageForShortName + 2);
    }
    #Ifnot; ! TARGET_GLULX
    if (findout) {
        if (pluralise)
            Glulx_PrintAnyToArray(StorageForShortName, 160, EnglishNumber, pluralise);
        else
            Glulx_PrintAnyToArray(StorageForShortName, 160, PSN__, obj);
        acode = acode + 3*LanguageContraction(StorageForShortName);
    }
    #Endif; ! TARGET_

    Cap (artform-->acode, ~~capitalise); ! print article
    if (pluralise) return;
    print (PSN__) obj;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Object Names III
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IndefArt obj i;
	if (obj == 0) { LIST_WRITER_INTERNAL_RM('Y'); rtrue; }
    i = indef_mode; indef_mode = true;
    if (obj has proper) { indef_mode = NULL; print (PSN__) obj; indef_mode = i; return; }
    if ((obj provides article) && (TEXT_TY_Compare(obj.article, EMPTY_TEXT_VALUE) ~= 0)) {
        PrintOrRun(obj, article, true); print " ", (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 2); indef_mode = i;
];

[ CIndefArt obj i;
	if (obj == 0) { LIST_WRITER_INTERNAL_RM('X'); rtrue; }
    i = indef_mode; indef_mode = true;
    if (obj has proper) {
    	indef_mode = NULL;
		caps_mode = true;
    	print (PSN__) obj;
    	indef_mode = i;
    	caps_mode = false;
    	return;
    }
    if ((obj provides article) && (TEXT_TY_Compare(obj.article, EMPTY_TEXT_VALUE) ~= 0)) {
        TEXT_TY_Say_Capitalised(obj.article); print " ", (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 2, 0, 1); indef_mode = i;
];

[ DefArt obj i;
    i = indef_mode; indef_mode = false;
    if ((~~obj ofclass Object) || obj has proper) {
        indef_mode = NULL; print (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 1); indef_mode = i;
];

[ CDefArt obj i;
    i = indef_mode; indef_mode = false;
    if ((obj ofclass Object) && (obj has proper || obj == player)) {
    	indef_mode = NULL;
    	caps_mode = true;
    	print (PSN__) obj;
    	indef_mode = i;
    	caps_mode = false;
    	return;
    }
    if ((~~obj ofclass Object) || obj has proper) {
        indef_mode = NULL; print (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 0); indef_mode = i;
];

[ PrintShortName obj i;
    i = indef_mode; indef_mode = NULL;
    PSN__(obj); indef_mode = i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Printing.i6t: Say One Of
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ I7_SOO_PAR oldval count; if (count <= 1) return count; return random(count); ];
[ I7_SOO_RAN oldval count v; if (count <= 1) return count;
	v = oldval; while (v == oldval) v = random(count); return v; ];
[ I7_SOO_STI oldval count v; if (oldval) return oldval; return I7_SOO_PAR(oldval, count); ];
[ I7_SOO_CYC oldval count; oldval++; if (oldval > count) oldval = 1; return oldval; ];
[ I7_SOO_STOP oldval count; oldval++; if (oldval > count) oldval = count; return oldval; ];
[ I7_SOO_TAP oldval count tn rn c; if (count <= 1) return count; tn = count*(count+1)/2;
	rn = random(tn); for (c=1:c<=count:c++) { rn = rn - c; if (rn<=0) return (count-c+1); } ];
[ I7_SOO_TRAN oldval count; if (oldval<count) return oldval+1; 
	return count + 1 + I7_SOO_RAN(oldval%(count+1), count); ];
[ I7_SOO_TPAR oldval count; if (oldval<count) return oldval+1; 
	return count + 1 + I7_SOO_PAR(oldval%(count+1), count); ];

Array I7_SOO_SHUF->32;

[ I7_SOO_SHU oldval count sd ct v i j s ssd scope cc base;
	base = count+1;
	v = oldval%base; oldval = oldval/base; ct = oldval%base; sd = oldval/base;
	if (count > 32) return I7_SOO_PAR(oldval, count);
	if (count <= 1) v = count;
	else {
		!print "^In v=", v, " ct=", ct, " sd=", sd, "^";
		cc = base*base;
		scope = (MAX_POSITIVE_NUMBER-1)/cc;
		!print "Scope = ", scope, "^";
		if (sd == 0) { sd = random(scope); ct=0; }
		for (i=0:i<count:i++) I7_SOO_SHUF->i = i;
		ssd = sd;
		for (i=0:i<count-1:i++) {
			j = (sd)%(count-i)+i; sd = (sd*31973)+17; if (sd<0) sd=-sd;
			s = I7_SOO_SHUF->j; I7_SOO_SHUF->j = I7_SOO_SHUF->i; I7_SOO_SHUF->i = s;
		}
		!for (i=0:i<count:i++) print I7_SOO_SHUF->i, " "; print "^";
		v = (I7_SOO_SHUF->ct)+1;
		ct++; if (ct >= count) { ct = 0; ssd = 0; }
	}
	!print "Out v=", v, " ct=", ct, " ssd=", sd, "^";
	!print "Return ", v + ct*base + ssd*base*base, "^";
	return v + ct*base + ssd*base*base;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Relation Records
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RR_NAME     		5;
Constant RR_PERMISSIONS		6;
Constant RR_STORAGE			7;
Constant RR_KIND			8;
Constant RR_HANDLER			9;
Constant RR_DESCRIPTION		10;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Valency Adjectives
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant VALENCY_MASK = RELS_EQUIVALENCE+RELS_SYMMETRIC+RELS_X_UNIQUE+RELS_Y_UNIQUE;
[ RELATION_TY_EquivalenceAdjective rel set  perms state handler;
	perms = RlnGetF(rel, RR_PERMISSIONS);
	if (perms & RELS_EQUIVALENCE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		perms = perms + RELS_EQUIVALENCE;
		if (perms & RELS_SYMMETRIC == 0) perms = perms + RELS_SYMMETRIC;
	}
	if ((set == false) && (state)) {
		perms = perms - RELS_EQUIVALENCE;
		if (perms & RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;
	}
	RlnSetF(rel, RR_PERMISSIONS, perms);
	handler = RlnGetF(rel, RR_HANDLER);
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to an equivalence relation ***";		
];

[ RELATION_TY_SymmetricAdjective rel set  perms state handler;
	perms = RlnGetF(rel, RR_PERMISSIONS);
	if (perms & RELS_SYMMETRIC) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) perms = perms + RELS_SYMMETRIC;
	if ((set == false) && (state)) perms = perms - RELS_SYMMETRIC;
	RlnSetF(rel, RR_PERMISSIONS, perms);
	handler = RlnGetF(rel, RR_HANDLER);
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a symmetric relation ***";		
];

[ RELATION_TY_OToOAdjective rel set  perms state handler i;
	perms = RlnGetF(rel, RR_PERMISSIONS);
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_X_UNIQUE+RELS_Y_UNIQUE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;
		if (perms & RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	RlnSetF(rel, RR_PERMISSIONS, perms);
	handler = RlnGetF(rel, RR_HANDLER);
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a one-to-one relation ***";		
];

[ RELATION_TY_OToVAdjective rel set  perms state handler;
	perms = RlnGetF(rel, RR_PERMISSIONS);
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_X_UNIQUE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
		if (perms & RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;
		if (perms & RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	RlnSetF(rel, RR_PERMISSIONS, perms);
	handler = RlnGetF(rel, RR_HANDLER);
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a one-to-various relation ***";		
];

[ RELATION_TY_VToOAdjective rel set  perms state handler;
	perms = RlnGetF(rel, RR_PERMISSIONS);
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_Y_UNIQUE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;
		if (perms & RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;
		if (perms & RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	RlnSetF(rel, RR_PERMISSIONS, perms);
	handler = RlnGetF(rel, RR_HANDLER);
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a various-to-one relation ***";		
];

[ RELATION_TY_VToVAdjective rel set  perms state handler;
	perms = RlnGetF(rel, RR_PERMISSIONS);
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == 0) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;
	}
	RlnSetF(rel, RR_PERMISSIONS, perms);
	handler = RlnGetF(rel, RR_HANDLER);
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a various-to-various relation ***";		
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: One To One Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_Now1to1 obj1 relation_property obj2 ol; ! Assert 1-1 true
	if (obj2) objectloop (ol provides relation_property)
		if (ol.relation_property == obj2) ol.relation_property = nothing;
	if (obj1) obj1.relation_property = obj2;
];

[ Relation_NowN1toV obj1 relation_property obj2; ! Assert 1-1 false
	if ((obj1) && (obj1.relation_property == obj2)) obj1.relation_property = nothing;
];

[ Relation_Now1to1V obj1 obj2 KOV relation_property ol N; ! Assert 1-1 true
	if (obj2) {
		N = KOVDomainSize(KOV);
		for (ol=1: ol<=N: ol++)
			if (GProperty(KOV, ol, relation_property) == obj2)
				WriteGProperty(KOV, ol, relation_property, 0);
	}
	if (obj1) WriteGProperty(KOV, obj1, relation_property, obj2);
];

[ Relation_NowN1toVV obj1 obj2 KOV relation_property; ! Assert 1-1 false
	if ((obj1) && (GProperty(KOV, obj1, relation_property) == obj2))
		WriteGProperty(KOV, obj1, relation_property, 0);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Symmetric One To One Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_NowS1to1 obj1 relation_property obj2; ! Assert symmetric 1-1 true
	if ((obj1 ofclass Object) && (obj1 provides relation_property) &&
		(obj2 ofclass Object) && (obj2 provides relation_property)) {
		if (obj1.relation_property) { (obj1.relation_property).relation_property = 0; }
		if (obj2.relation_property) { (obj2.relation_property).relation_property = 0; }
		obj1.relation_property = obj2; obj2.relation_property = obj1;
	}
];

[ Relation_NowSN1to1 obj1 relation_property obj2; ! Assert symmetric 1-1 false
	if ((obj1 ofclass Object) && (obj1 provides relation_property) &&
		(obj2 ofclass Object) && (obj2 provides relation_property) &&
		(obj1.relation_property == obj2)) {
		obj1.relation_property = 0; obj2.relation_property = 0;
	}
];

[ Relation_NowS1to1V obj1 obj2 KOV relation_property; ! Assert symmetric 1-1 true
	if (GProperty(KOV, obj1, relation_property))
		WriteGProperty(KOV, GProperty(KOV, obj1, relation_property), relation_property, 0);
	if (GProperty(KOV, obj2, relation_property)) 
		WriteGProperty(KOV, GProperty(KOV, obj2, relation_property), relation_property, 0);
	WriteGProperty(KOV, obj1, relation_property, obj2);
	WriteGProperty(KOV, obj2, relation_property, obj1);
];

[ Relation_NowSN1to1V obj1 obj2 KOV relation_property; ! Assert symmetric 1-1 false
	if (GProperty(KOV, obj1, relation_property) == obj2) {
		WriteGProperty(KOV, obj1, relation_property, 0);
		WriteGProperty(KOV, obj2, relation_property, 0);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Various To Various Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant VTOVS_LEFT_INDEX_PROP = 0;
Constant VTOVS_RIGHT_INDEX_PROP = 1;
Constant VTOVS_LEFT_DOMAIN_SIZE = 2;
Constant VTOVS_RIGHT_DOMAIN_SIZE = 3;
Constant VTOVS_LEFT_PRINTING_ROUTINE = 4;
Constant VTOVS_RIGHT_PRINTING_ROUTINE = 5;
Constant VTOVS_CACHE_BROKEN = 6;
Constant VTOVS_CACHE = 7;

[ Relation_NowVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
	if (sym && (obj2 ~= obj1)) { Relation_NowVtoV(obj2, relation, obj1, false); }
	vtov_structure = RlnGetF(relation, RR_STORAGE);
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	vtov_structure-->VTOVS_CACHE_BROKEN = true; ! Mark any cache as broken
	if (pr) {
		if ((obj1 ofclass Object) && (obj1 provides pr)) i1 = obj1.pr;
		else return RunTimeProblem(RTP_IMPREL, obj1, relation);
	} else i1 = obj1-1;
	if (pr2) {
		if ((obj2 ofclass Object) && (obj2 provides pr2)) i2 = obj2.pr2;
		else return RunTimeProblem(RTP_IMPREL, obj2, relation);
	} else i2 = obj2-1;
	pr = i1*(vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE) + i2;
	i1 = IncreasingPowersOfTwo_TB-->(pr%16);
	pr = pr/16 + 8;
	vtov_structure-->pr = (vtov_structure-->pr) | i1;
];

[ Relation_NowNVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
	if (sym && (obj2 ~= obj1)) { Relation_NowNVtoV(obj2, relation, obj1, false); }
	vtov_structure = RlnGetF(relation, RR_STORAGE);
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	vtov_structure-->VTOVS_CACHE_BROKEN = true; ! Mark any cache as broken
	if (pr) {
		if ((obj1 ofclass Object) && (obj1 provides pr)) i1 = obj1.pr;
		else return RunTimeProblem(RTP_IMPREL, obj1, relation);
	} else i1 = obj1-1;
	if (pr2) {
		if ((obj2 ofclass Object) && (obj2 provides pr2)) i2 = obj2.pr2;
		else return RunTimeProblem(RTP_IMPREL, obj2, relation);
	} else i2 = obj2-1;
	pr = i1*(vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE) + i2;
	i1 = IncreasingPowersOfTwo_TB-->(pr%16);
	pr = pr/16 + 8;
	if ((vtov_structure-->pr) & i1) vtov_structure-->pr = vtov_structure-->pr - i1;
];

[ Relation_TestVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
	vtov_structure = RlnGetF(relation, RR_STORAGE);
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	if (sym && (obj2 > obj1)) { sym = obj1; obj1 = obj2; obj2 = sym; }
	if (pr) {
		if ((obj1 ofclass Object) && (obj1 provides pr)) i1 = obj1.pr;
		else { RunTimeProblem(RTP_IMPREL, obj1, relation); rfalse; }
	} else i1 = obj1-1;
	if (pr2) {
		if ((obj2 ofclass Object) && (obj2 provides pr2)) i2 = obj2.pr2;
		else { RunTimeProblem(RTP_IMPREL, obj2, relation); rfalse; }
	} else i2 = obj2-1;
	pr = i1*(vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE) + i2;
	i1 = IncreasingPowersOfTwo_TB-->(pr%16);
	pr = pr/16 + 8;
	if ((vtov_structure-->pr) & i1) rtrue; rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Equivalence Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_NowEquiv obj1 relation_property obj2 big little;
	big = obj1.relation_property; little = obj2.relation_property;
	if (big == little) return;
	if (big < little) { little = obj1.relation_property; big = obj2.relation_property; }
	objectloop (obj1 provides relation_property)
		if (obj1.relation_property == big) obj1.relation_property = little;
];

[ Relation_NowNEquiv obj1 relation_property obj2 old new;
	old = obj1.relation_property; new = obj2.relation_property;
	if (old ~= new) return;
	new = 0;
	objectloop (obj2 provides relation_property)
		if (obj2.relation_property > new) new = obj2.relation_property;
	new++;
	obj1.relation_property = new;
];

[ Relation_NowEquivV obj1 obj2 KOV relation_property n big little i;
	big = GProperty(KOV, obj1, relation_property);
	little = GProperty(KOV, obj2, relation_property);
	if (big == little) return;
	if (big < little) {
		little = GProperty(KOV, obj1, relation_property);
		big = GProperty(KOV, obj2, relation_property);
	}
	n = KOVDomainSize(KOV);
	for (i=1: i<=n: i++)
		if (GProperty(KOV, i, relation_property) == big)
			WriteGProperty(KOV, i, relation_property, little);
];

[ Relation_NowNEquivV obj1 obj2 KOV relation_property n old new i;
	old = GProperty(KOV, obj1, relation_property); 
	new = GProperty(KOV, obj2, relation_property);
	if (old ~= new) return;
	new = 0;
	n = KOVDomainSize(KOV);
	for (i=1: i<=n: i++)
		if (GProperty(KOV, i, relation_property) > new)
			new = GProperty(KOV, i, relation_property);
	new++;
	WriteGProperty(KOV, obj1, relation_property, new);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Show Various to Various
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_ShowVtoV relation sym x obj1 obj2 pr pr2 proutine1 proutine2 vtov_structure;
	vtov_structure = RlnGetF(relation, RR_STORAGE);
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	proutine1 = vtov_structure-->VTOVS_LEFT_PRINTING_ROUTINE;
	proutine2 = vtov_structure-->VTOVS_RIGHT_PRINTING_ROUTINE;
 
	if (pr && pr2) {
		objectloop (obj1 provides pr)
		  objectloop (obj2 provides pr2) {
				if (sym && obj2 > obj1) continue;
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  ", (The) obj1;
					if (sym) print "  <=>  "; else print "  >=>  ";
					print (the) obj2, "^";
				}
		  }
		return;
	}
	if (pr && (pr2==0)) {
		objectloop (obj1 provides pr)
		  for (obj2=1:obj2<=vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE:obj2++) {
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  ", (The) obj1, "  >=>  ";
					(proutine2).call(obj2);
					print "^";
				}
		  }
		return;
	}
	if ((pr==0) && (pr2)) {
		for (obj1=1:obj1<=vtov_structure-->2:obj1++)
		  objectloop (obj2 provides pr2) {
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  ";
					(proutine1).call(obj1);
					print "  >=>  ", (the) obj2, "^";
				}
		  }
		return;
	}
	for (obj1=1:obj1<=vtov_structure-->2:obj1++)
		  for (obj2=1:obj2<=vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE:obj2++)
			if (Relation_TestVtoV(obj1, relation, obj2)) {
				if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
				print "  ";
				(proutine1).call(obj1);
				print "  >=>  ";
				(proutine2).call(obj2);
				print "^";
		  }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Show One to One
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_ShowOtoO relation sym x relation_property t N obj1 obj2;
	relation_property = RlnGetF(relation, RR_STORAGE);
	t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0); ! Kind of left term
	N = KOVDomainSize(t);
	if (t == OBJECT_TY) {
		objectloop (obj1 provides relation_property) {
			obj2 = obj1.relation_property;
			if (sym && obj2 < obj1) continue;
			if (obj2 == 0) continue;
			if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
			print "  ", (The) obj1;
			if (sym) print "  ==  "; else print "  >=>  ";
			print (the) obj2, "^";
		}
	} else {
		for (obj1=1: obj1<=N: obj1++) {
			obj2 = GProperty(t, obj1, relation_property);
			if (sym && obj2 < obj1) continue;
			if (obj2 == 0) continue;
			if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
			print "  ";
			PrintKindValuePair(t, obj1);
			if (sym) print "  ==  "; else print "  >=>  ";
			PrintKindValuePair(t, obj2);
			print "^";
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Show Reversed One to One
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_RShowOtoO relation sym x relation_property obj1 obj2 t1 t2 N1 N2;
	relation_property = RlnGetF(relation, RR_STORAGE);
	t1 = KindBaseTerm(RlnGetF(relation, RR_KIND), 0); ! Kind of left term
	t2 = KindBaseTerm(RlnGetF(relation, RR_KIND), 1); ! Kind of right term
	if (t2 == OBJECT_TY) {
		if (t1 == OBJECT_TY) {
			objectloop (obj1) {
				objectloop (obj2 provides relation_property) {
					if (obj2.relation_property ~= obj1) continue;
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  ", (The) obj1;
					print "  >=>  ";
					print (the) obj2, "^";
				}
			}
		} else {
			N1 = KOVDomainSize(t1);
			for (obj1=1: obj1<=N1: obj1++) {
				objectloop (obj2 provides relation_property) {
					if (obj2.relation_property ~= obj1) continue;
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  "; PrintKindValuePair(t1, obj1);
					print "  >=>  ";
					print (the) obj2, "^";
				}
			}
		}
	} else {
		N2 = KOVDomainSize(t2);
		if (t1 == OBJECT_TY) {
			objectloop (obj1) {
				for (obj2=1: obj2<=N2: obj2++) {
					if (GProperty(t2, obj2, relation_property) ~= obj1) continue;
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  ", (The) obj1;
					print "  >=>  ";
					PrintKindValuePair(t2, obj2);
					print "^";
				}
			}
		} else {
			N1 = KOVDomainSize(t1);
			for (obj1=1: obj1<=N1: obj1++) {
				for (obj2=1: obj2<=N2: obj2++) {
					if (GProperty(t2, obj2, relation_property) ~= obj1) continue;
					if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }
					print "  ";
					PrintKindValuePair(t1, obj1);
					print "  >=>  ";
					PrintKindValuePair(t2, obj2);
					print "^";
				}
			}
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Show Equivalence
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RSE_Flip KOV v relation_property x;
	x = GProperty(KOV, v, relation_property); x = -x;
	WriteGProperty(KOV, v, relation_property, x);
];
[ RSE_Set KOV v relation_property;
	if (GProperty(KOV, v, relation_property) < 0) rtrue; rfalse;
];
[ Relation_ShowEquiv relation relation_property obj1 obj2 v c d somegroups t N x;
	print (string) RlnGetF(relation, RR_DESCRIPTION), ":^";
	relation_property = RlnGetF(relation, RR_STORAGE);
	t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0); ! Kind of left term
	N = KOVDomainSize(t);
	if (t == OBJECT_TY) {
		objectloop (obj1 provides relation_property)
			obj1.relation_property = -(obj1.relation_property);
		objectloop (obj1 provides relation_property) {
			if (obj1.relation_property < 0) {
				v = obj1.relation_property; c = 0;
				objectloop (obj2 has workflag2) give obj2 ~workflag2;
				objectloop (obj2 provides relation_property) {
					if (obj2.relation_property == v) {
						give obj2 workflag2;
						obj2.relation_property = -v;
						c++;
					}
				}
				if (c>1) {
					somegroups = true;
					print "  { ";
					WriteListOfMarkedObjects(ENGLISH_BIT);
					print " }^";
				} else obj1.relation_property = v;
			}
		}
		objectloop (obj2 has workflag2) give obj2 ~workflag2;
		c = 0; objectloop (obj1 provides relation_property)
			if (obj1.relation_property < 0) { c++; give obj1 workflag2; }
		if (c == 0) return;
		if (somegroups) print "  and "; else print "  ";
		if (c < 4) { WriteListOfMarkedObjects(ENGLISH_BIT); print " in"; }
		else print c;
		if (c == 1) print " a";
		print " single-member group";
		if (c > 1) print "s";
		print "^";
		objectloop (obj1 provides relation_property)
			if (obj1.relation_property < 0)
				obj1.relation_property = -(obj1.relation_property);
	} else {
		! A slower method, since we have less efficient storage:
		for (obj1 = 1: obj1 <= N: obj1++)
			RSE_Flip(t, obj1, relation_property);
		for (obj1 = 1: obj1 <= N: obj1++) {
			if (RSE_Set(t, obj1, relation_property)) {
				v = GProperty(t, obj1, relation_property);
				c = 0;
				for (obj2 = 1: obj2 <= N: obj2++)
					if (GProperty(t, obj2, relation_property) == v)
						c++;
				if (c>1) {
					somegroups = true;
					print "  {";
					d = 0;
					for (obj2 = 1: obj2 <= N: obj2++) {
						if (GProperty(t, obj2, relation_property) == v) {
							print " "; PrintKindValuePair(t, obj2);
							if (d < c-1) print ","; print " ";
							RSE_Flip(t, obj2, relation_property);
							d++;
						}
					}
					print "}^";
				} else WriteGProperty(t, obj1, relation_property, v);
			}
		}
		objectloop (obj2 has workflag2) give obj2 ~workflag2;
		c = 0;
		for (obj1 = 1: obj1 <= N: obj1++)
			if (RSE_Set(t, obj1, relation_property)) c++;
		if (c == 0) return;
		if (somegroups) print "  and "; else print "  ";
		if (c == 1) print "a"; else print c;
		print " single-member group";
		if (c > 1) print "s";
		print "^";
		for (obj1 = 1: obj1 <= N: obj1++)
			if (RSE_Set(t, obj1, relation_property))
				RSE_Flip(t, obj1, relation_property);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Relation Emptying
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ Relation_EmptyOtoO relation sym clear relation_property obj1 obj2 t1 t2 N1 N2;
	relation_property = RlnGetF(relation, RR_STORAGE);
	t1 = KindBaseTerm(RlnGetF(relation, RR_KIND), 0); ! Kind of left term
	t2 = KindBaseTerm(RlnGetF(relation, RR_KIND), 1); ! Kind of right term
	if (t2 == OBJECT_TY) {
		objectloop (obj2 provides relation_property) {
			obj1 = obj2.relation_property;
			if (obj1) {
				if (clear) obj2.relation_property = nothing;
				else rfalse;
			}
		}
	} else {
		for (obj2=1: obj2<=N2: obj2++) {
			obj1 = GProperty(t2, obj2, relation_property);
			if (obj1) {
				if (clear) WriteGProperty(t2, obj2, relation_property, 0);
				else rfalse;
			}
		}
	}
	if (t1 ~= t2) {
		if (t1 == OBJECT_TY) {
			objectloop (obj1 provides relation_property) {
				obj2 = obj1.relation_property;
				if (obj2) {
					if (clear) obj1.relation_property = nothing;
					else rfalse;
				}
			}
		} else {
			for (obj1=1: obj1<=N2: obj1++) {
				obj2 = GProperty(t1, obj1, relation_property);
				if (obj2) {
					if (clear) WriteGProperty(t1, obj1, relation_property, 0);
					else rfalse;
				}
			}
		}
	}
	rtrue;
];
[ Relation_EmptyEquiv relation sym clear
	relation_property obj1 obj2 t N v;
	relation_property = RlnGetF(relation, RR_STORAGE);
	t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0); ! Kind of left term
	N = KOVDomainSize(t);
	if (clear) {
		v = 1;
		if (t == OBJECT_TY) {
			objectloop (obj1 provides relation_property)
				obj1.relation_property = v++;
		} else {
			for (obj1=1: obj1<=N: obj1++)
				WriteGProperty(t, obj1, relation_property, v++);
		}
		rtrue;
	}	
	if (t == OBJECT_TY) {
		objectloop (obj1 provides relation_property)
			objectloop (obj2 provides relation_property)
				if ((obj1 < obj2) && (obj1.relation_property == obj2.relation_property))
					rfalse;
	} else {
		for (obj1=1: obj1<=N: obj1++)
			for (obj2=obj1+1: obj1<=N: obj1++)
				if (GProperty(t, obj1, relation_property) == GProperty(t, obj2, relation_property))
					rfalse;
	}
	rtrue;
];
[ Relation_EmptyVtoV relation sym clear vtov_structure obj1 obj2 pr pr2 proutine1 proutine2;
	vtov_structure = RlnGetF(relation, RR_STORAGE);
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	proutine1 = vtov_structure-->VTOVS_LEFT_PRINTING_ROUTINE;
	proutine2 = vtov_structure-->VTOVS_RIGHT_PRINTING_ROUTINE;
 
	if (pr && pr2) {
		objectloop (obj1 provides pr)
			objectloop (obj2 provides pr2) {
				if (sym && obj2 > obj1) continue;
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (clear) Relation_NowNVtoV(obj1, relation, obj2, sym);
					else rfalse;
				}
			}
		return;
	}
	if (pr && (pr2==0)) {
		objectloop (obj1 provides pr)
			for (obj2=1:obj2<=vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE:obj2++) {
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (clear) Relation_NowNVtoV(obj1, relation, obj2, sym);
					else rfalse;
				}
			}
		return;
	}
	if ((pr==0) && (pr2)) {
		for (obj1=1:obj1<=vtov_structure-->2:obj1++)
			objectloop (obj2 provides pr2) {
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (clear) Relation_NowNVtoV(obj1, relation, obj2, sym);
					else rfalse;
				}
			}
		return;
	}
	for (obj1=1:obj1<=vtov_structure-->2:obj1++)
		for (obj2=1:obj2<=vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE:obj2++)
			if (Relation_TestVtoV(obj1, relation, obj2)) {
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (clear) Relation_NowNVtoV(obj1, relation, obj2, sym);
					else rfalse;
				}
		}
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Map Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifndef FAST_ROUTE_FINDING;
#ifndef SLOW_ROUTE_FINDING;
#ifdef TARGET_GLULX;
Constant FAST_ROUTE_FINDING;
#ifnot;
Constant SLOW_ROUTE_FINDING;
#endif;
#endif;
#endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Cache Control
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant NUM_DOORS = 8;
Constant NUM_ROOMS = 49;

Array DoorRoutingViable -> NUM_DOORS+1;

Global map_has_changed = true;
Global last_filter; Global last_use_doors;

[ SignalMapChange; map_has_changed = true; ];

[ MapRouteTo from to filter use_doors count  oy oyi ds;
	if (from == nothing) return nothing;
	if (to == nothing) return nothing;
	if (from == to) return nothing;
	if ((filter) && (filter(from) == 0)) return nothing;
	if ((filter) && (filter(to) == 0)) return nothing;
	if ((last_filter ~= filter) || (last_use_doors ~= use_doors)) map_has_changed = true;
	oyi = 0;
	objectloop (oy has mark_as_room) {
		if ((filter == 0) || (filter(oy))) {
			if (oy.room_index == -1) map_has_changed = true;
			oy.room_index = oyi++;
		} else {
			if (oy.room_index >= 0) map_has_changed = true;
			oy.room_index = -1;
		}
	}
	oyi = 0;
	objectloop (oy ofclass K4_door) {
		ds = false;
		if ((use_doors & 2) ||
			(oy has open) || ((oy has openable) && (oy hasnt locked))) ds = true;
		if (DoorRoutingViable->oyi ~= ds) map_has_changed = true;
		DoorRoutingViable->oyi = ds;
		oyi++;
	}
	if (map_has_changed) {
		#ifdef FAST_ROUTE_FINDING; ComputeFWMatrix(filter, use_doors); #endif;
		map_has_changed = false; last_filter = filter; last_use_doors = use_doors;
	}
	#ifdef FAST_ROUTE_FINDING;
	if (count) return FastCountRouteTo(from, to, filter, use_doors);
	return FastRouteTo(from, to, filter, use_doors);
	#ifnot;
	if (count) return SlowCountRouteTo(from, to, filter, use_doors);
	return SlowRouteTo(from, to, filter, use_doors);
	#endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Fast Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifdef FAST_ROUTE_FINDING;
Array FWMatrix --> NUM_ROOMS*NUM_ROOMS;

[ FastRouteTo from to filter use_doors diri i dir oy;
	if (from == to) return nothing;
	i = (FWMatrix-->(from.room_index*NUM_ROOMS + to.room_index))/No_Directions;
	if (i == 0) return nothing;
	diri = (FWMatrix-->(from.room_index*NUM_ROOMS + to.room_index))%No_Directions;
	i=0; objectloop (dir ofclass K3_direction) {
		if (i == diri) return dir;
		i++;
	}
	return nothing;
];

[ FastCountRouteTo from to filter use_doors  k;
	if (from == to) return 0;
	k = (FWMatrix-->(from.room_index*NUM_ROOMS + to.room_index))/No_Directions;
	if (k == 0) return -1;
	return k;
];

[ ComputeFWMatrix filter use_doors  oy ox oj axy ayj axj dir diri nd row;
	objectloop (oy has mark_as_room) if (oy.room_index >= 0)
		objectloop (ox has mark_as_room) if (ox.room_index >= 0)
			FWMatrix-->(oy.room_index*NUM_ROOMS + ox.room_index) = 0;

	objectloop (oy has mark_as_room) if (oy.room_index >= 0) {
		row = (oy.IK1_Count)*No_Directions;
		for (diri=0: diri<No_Directions: diri++) {
			ox = Map_Storage-->(row+diri);
			if ((ox) && (ox has mark_as_room) && (ox.room_index >= 0)) {
				FWMatrix-->(oy.room_index*NUM_ROOMS + ox.room_index) = No_Directions + diri;
				continue;
			}
			if (use_doors && (ox ofclass K4_door) &&
				((use_doors & 2) || (DoorRoutingViable->(ox.IK4_Count)))) {
				@push location; location = oy;
				ox = ox.door_to();
				@pull location;
				if ((ox) && (ox has mark_as_room) && (ox.room_index >= 0)) {
					FWMatrix-->(oy.room_index*NUM_ROOMS + ox.room_index) = No_Directions + diri;
					continue;
				}
			}
		}	
	}

	objectloop (oy has mark_as_room) if (oy.room_index >= 0)
		objectloop (ox has mark_as_room) if (ox.room_index >= 0) {
			axy = (FWMatrix-->(ox.room_index*NUM_ROOMS + oy.room_index))/No_Directions;
			if (axy > 0)
				objectloop (oj has mark_as_room) if (oj.room_index >= 0) {
					ayj = (FWMatrix-->(oy.room_index*NUM_ROOMS + oj.room_index))/No_Directions;
					if (ayj > 0) {
						!print "Is it faster to go from ", (name) ox, " to ",
						!   (name) oj, " via ", (name) oy, "?^";
						axj = (FWMatrix-->(ox.room_index*NUM_ROOMS + oj.room_index))/
							No_Directions;
						if ((axj == 0) || (axy + ayj < axj)) {
							!print "Yes^";
							FWMatrix-->(ox.room_index*NUM_ROOMS + oj.room_index) =
								(axy + ayj)*No_Directions +
								(FWMatrix-->(ox.room_index*NUM_ROOMS + oy.room_index))%
									No_Directions;
						}
					}
				}
		}
];
#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Slow Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifndef FAST_ROUTE_FINDING;
[ SlowRouteTo from to filter use_doors  obj dir in_direction progressed sl through_door;
	if (from == nothing) return nothing;
	if (to == nothing) return nothing;
	if (from == to) return nothing;
	objectloop (obj has mark_as_room) obj.vector = 0;
	to.vector = 1;
	!print "Routing from ", (the) from, " to ", (the) to, "^";
	while (true) {
		progressed = false;
		!print "Pass begins^";
		objectloop (obj has mark_as_room)
			if ((filter == 0) || (filter(obj)))
				if (obj.vector == 0)
					objectloop (dir ofclass K3_direction) {
						in_direction = Map_Storage-->((obj.IK1_Count)*No_Directions + dir.IK3_Count);
						if (in_direction == nothing) continue;
						!print (the) obj, " > ", (the) dir, " > ", (the) in_direction, "^";
						if ((in_direction)
							&& (in_direction has mark_as_room)
							&& (in_direction.vector > 0)
							&& ((filter == 0) || (filter(in_direction)))) {
							obj.vector = dir | WORD_HIGHBIT;
							!print "* ", (the) obj, " vector is ", (the) dir, "^";
							progressed = true;
							continue;
						}
						if (use_doors && (in_direction ofclass K4_door) &&
							((use_doors & 2) ||
							 (in_direction has open) ||
							 ((in_direction has openable) && (in_direction hasnt locked)))) {
							sl = location; location = obj;
							through_door = in_direction.door_to();
							location = sl;
							!print "Through door is ", (the) through_door, "^";
							if ((through_door)
								&& (through_door has mark_as_room)
								&& (through_door.vector > 0)
								&& ((filter == 0) || (filter(through_door)))) {
								obj.vector = dir | WORD_HIGHBIT;
								!print "* ", (the) obj, " vector is ", (the) dir, "^";
								progressed = true;
								continue;
							}
						}
					}
		objectloop (obj has mark_as_room) obj.vector = obj.vector &~ WORD_HIGHBIT;
		if (from.vector) return from.vector;
		if (progressed == false) return from.vector;
	}
];

[ SlowCountRouteTo from to filter use_doors obj i;
	if (from == nothing) return -1;
	if (to == nothing) return -1;
	if (from == to) return 0;
	if (from has mark_as_room && to has mark_as_room) {
		obj = MapRouteTo(from,to,filter,use_doors);
		if (obj == nothing) return -1;
		i = 0; obj = from;
		while ((obj ~= to) && (i<NUM_ROOMS)) { i++; obj = MapConnection(obj,obj.vector); }
		return i;
	}
	return -1;
];
#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Relation Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant MAX_ROUTE_LENGTH = 266 + 32;

[ RelationRouteTo relation from to count  handler;
	if (count) {
		if (from == nothing) return -1;
		if (to == nothing) return -1;
		if (relation == 0) return -1;
	} else {
		if (from == nothing) return nothing;
		if (to == nothing) return nothing;
		if (relation == 0) return nothing;
	}
	if (from == to) return nothing;
	if (((RlnGetF(relation, RR_PERMISSIONS)) & RELS_ROUTE_FIND) == 0) {
		RunTimeProblem(RTP_ROUTELESS);
		return nothing;
	}
	if (RlnGetF(relation, RR_STORAGE) == 0) return nothing;
	handler = RlnGetF(relation, RR_HANDLER);
	if (count) return handler(relation, RELS_ROUTE_FIND_COUNT, from, to);
	return handler(relation, RELS_ROUTE_FIND, from, to);
];

[ RelFollowVector rv from to  obj i;
	if (rv == nothing) return -1;
	i = 0; obj = from;
	while ((obj ~= to) && (i<=MAX_ROUTE_LENGTH)) { i++; obj = obj.vector; }
	return i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: One To Various Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ OtoVRelRouteTo relation_property from to previous;
	while ((to) && (to provides relation_property) && (to.relation_property)) {
		previous = to.relation_property;
		previous.vector = to;
		if (previous == from) return to;
		to = previous;
	}
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Various To One Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VtoORelRouteTo relation_property from to next  start;
	start = from;
	while ((from) && (from provides relation_property) && (from.relation_property)) {
		next = from.relation_property;
		from.vector = next;
		if (next == to) return start.vector;
		from = next;
	}
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Slow Various To Various Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ VtoVRelRouteTo relation from to count obj obj2 related progressed left_ix pr2 i vtov_structure;
	vtov_structure = RlnGetF(relation, RR_STORAGE);
	if (vtov_structure-->VTOVS_CACHE)
		return FastVtoVRelRouteTo(relation, from, to, count);
	left_ix = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	objectloop (obj ofclass Object && obj provides vector) obj.vector = 0;
	to.vector = 1;
	while (true) {
		progressed = false;
		objectloop (obj ofclass Object && obj provides left_ix)
			if (obj.vector == 0) {
				objectloop (obj2 ofclass Object && obj2 provides pr2 && obj2.vector > 0) {
					if (Relation_TestVtoV(obj, relation, obj2)) {
						obj.vector = obj2 | WORD_HIGHBIT;
						progressed = true;
						continue;
					}
				}
			}
		objectloop (obj ofclass Object && obj provides left_ix)
			obj.vector = obj.vector &~ WORD_HIGHBIT;
		if (from.vector) break;
		if (progressed == false) break;
	}
	if (count) {
		if (from.vector == nothing) return -1;
		i = 0; obj = from;
		while ((obj ~= to) && (i<=MAX_ROUTE_LENGTH)) { i++; obj = obj.vector; }
		return i;
	}
	return from.vector;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Fast Various To Various Route-Finding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FastVtoVRelRouteTo relation from to count
	domainsize cache cache2 left_ix ox oy oj offset axy axj ayj;
	domainsize = RlnGetF(relation, RR_STORAGE)-->2; ! Number of left instances
	left_ix = RlnGetF(relation, RR_STORAGE)-->VTOVS_LEFT_INDEX_PROP;
	if ((from provides left_ix) && (to provides left_ix)) {
		if (domainsize < 256) {
			cache = RlnGetF(relation, RR_STORAGE)-->VTOVS_CACHE;
			cache2 = cache + domainsize*domainsize;
			if (RlnGetF(relation, RR_STORAGE)-->VTOVS_CACHE_BROKEN == true) {
				RlnGetF(relation, RR_STORAGE)-->VTOVS_CACHE_BROKEN = false;
				objectloop (oy provides left_ix)
					objectloop (ox provides left_ix)
						if (Relation_TestVtoV(oy, relation, ox)) {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache->offset = 1;
							cache2->offset = ox.left_ix;
						} else {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache->offset = 0;
							cache2->offset = 255;
						}
				for (oy=0: oy<domainsize: oy++)
					for (ox=0: ox<domainsize: ox++) {
						axy = cache->(ox*domainsize + oy);
						if (axy > 0)
							for (oj=0: oj<domainsize: oj++) {
								ayj = cache->(oy*domainsize + oj);
								if (ayj > 0) {
									offset = ox*domainsize + oj;
									axj = cache->offset;
									if ((axj == 0) || (axy + ayj < axj)) {
										cache->offset = (axy + ayj);
										cache2->offset = cache2->(ox*domainsize + oy);
									}
								}
							}
					}
			}
			if (count) {
				count = cache->((from.left_ix)*domainsize + (to.left_ix));
				if (count == 0) return -1;
				return count;
			}
			oy = cache2->((from.left_ix)*domainsize + (to.left_ix));
			if (oy < 255)
				objectloop (ox provides left_ix)
					if (ox.left_ix == oy) return ox;
			return nothing;
		} else {
			cache = RlnGetF(relation, RR_STORAGE)-->VTOVS_CACHE;
			cache2 = cache + WORDSIZE*domainsize*domainsize;
			if (RlnGetF(relation, RR_STORAGE)-->VTOVS_CACHE_BROKEN == true) {
				RlnGetF(relation, RR_STORAGE)-->VTOVS_CACHE_BROKEN = false;
				objectloop (oy provides left_ix)
					objectloop (ox provides left_ix)
						if (Relation_TestVtoV(oy, relation, ox)) {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache-->offset = 1;
							cache2-->offset = ox;
						} else {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache-->offset = 0;
							cache2-->offset = nothing;
						}
				for (oy=0: oy<domainsize: oy++)
					for (ox=0: ox<domainsize: ox++) {
						axy = cache-->(ox*domainsize + oy);
						if (axy > 0)
							for (oj=0: oj<domainsize: oj++) {
								ayj = cache-->(oy*domainsize + oj);
								if (ayj > 0) {
									offset = ox*domainsize + oj;
									axj = cache-->offset;
									if ((axj == 0) || (axy + ayj < axj)) {
										cache-->offset = (axy + ayj);
										cache2-->offset = cache2-->(ox*domainsize + oy);
									}
								}
							}
					}
			}
			if (count) {
				count = cache-->((from.left_ix)*domainsize + (to.left_ix));
				if (count == 0) return -1;
				return count;
			}
			return cache2-->((from.left_ix)*domainsize + (to.left_ix));
		}
	}
	if (count) return -1;
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Relations.i6t: Iterating Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ IterateRelations callback;
	callback(Rel_Record_67);
    callback(Rel_Record_69);
    callback(Rel_Record_71);
    callback(Rel_Record_73);
    callback(Rel_Record_75);
    callback(Rel_Record_77);
    callback(Rel_Record_79);
    callback(Rel_Record_81);
    callback(Rel_Record_83);
    callback(Rel_Record_85);
    callback(Rel_Record_87);
    callback(Rel_Record_89);
    callback(Rel_Record_91);
    callback(Rel_Record_93);
    callback(Rel_Record_95);
    callback(Rel_Record_97);

];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Reporting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array RTP_Buffer --> 7;
[ RunTimeProblem n par1 par2 par3 ln file;
	if (RTP_Buffer-->0 == -1) {
		RTP_Buffer-->0 = n; 
		RTP_Buffer-->1 = par1; 
		RTP_Buffer-->2 = par2;
		RTP_Buffer-->3 = par3;
		RTP_Buffer-->4 = ln;
		RTP_Buffer-->5 = file;
	}
	RunTimeProblemShow();
];
[ ClearRTP;
	RTP_Buffer-->0 = -1;
	RTP_Buffer-->6 = false;
];
[ SuspendRTP;
	RTP_Buffer-->6 = true;
];
[ ResumeRTP;
	RTP_Buffer-->6 = false;
];
[ RunTimeProblemShow   n par1 par2 par3 ln file i c;
	if (RTP_Buffer-->0 == -1 or -2) return;
	if (RTP_Buffer-->6) return;

	n = RTP_Buffer-->0; 
	par1 = RTP_Buffer-->1; 
	par2 = RTP_Buffer-->2;
	par3 = RTP_Buffer-->3;
	ln = RTP_Buffer-->4;
	file = RTP_Buffer-->5;
	RTP_Buffer-->0 = -2;

	print "^*** Run-time problem P", n;
	if (ln) {
		print " (at paragraph ", ln, " in ";
		if (file == 0) print "the source text";
		else ShowOneExtension(file);
		print ")";
	}
	print ": ";
	switch(n) {
		RTP_BACKDROP:
			print "Tried to move ", (the) par1, " (a backdrop) to ", (the) par2,
				", which is not a region.^";
		RTP_CANTCHANGE:
			print "Tried to change player to ", (the) par1, ", which is not a person.^";
		RTP_NOEXIT:
		    print "Tried to change ", (the) par2, " exit of ", (the) par1,
		    	", but it didn't seem to have such an exit to change.^";
		RTP_EXITDOOR:
		    print "Tried to change ", (the) par2, " exit of ", (the) par1,
		    	", but it led to a door, not a room.^";
		RTP_IMPREL:
			print "Tried to access an inappropriate relation for ", (the) par1,
				", violating '", (string) RlnGetF(par2, RR_DESCRIPTION), "'.^";
		RTP_TOOMANYRULEBOOKS:
			print "Too many rulebooks in simultaneous use.^";
		RTP_TOOMANYEVENTS:
			print "Too many timed events are going on at once.^";
		RTP_BADPROPERTY:
			print "Tried to access non-existent property for ", (the) par1, ".^";
		RTP_UNPROVIDED:
			print "Since ", (the) par1, " is not allowed the property ~",
					(string) par2, "~, it is against the rules to try to use it.^";
		RTP_UNSET:
			print "Although ", (the) par1, " is allowed to have the property ~",
				(string) par2, "~, no value was ever given, so it can't now be used.^";
		RTP_TOOMANYACTS:
			print "Too many activities are going on at once.^";
		RTP_CANTABANDON:
			print "Tried to abandon an activity which wasn't going on.^";
		RTP_CANTEND:
			print "Tried to end an activity which wasn't going on.^";
		RTP_CANTMOVENOTHING:
			print "You can't move nothing.^";
		RTP_CANTREMOVENOTHING:
			print "You can't remove nothing from play.^";
		RTP_DIVZERO:
			print "You can't divide by zero.^";
		RTP_BADVALUEPROPERTY:
			print "Tried to access property for a value which didn't fit: ",
				"if this were a number it would be ", par1, ".^";
		RTP_NOTBACKDROP:
			print "Tried to move ", (the) par1, " (not a backdrop) to ", (the) par2,
				", which is a region.^";
		RTP_TABLE_NOCOL:
			print "Attempt to look up a non-existent column in the table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOCORR:
			print "Attempt to look up a non-existent correspondence in the table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOROW:
			print "Attempt to look up a non-existent row in the table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOENTRY:
			print "Attempt to look up a non-existent entry at column ", par2,
				", row ", par3, " of the table '", (PrintTableName) par1, "'.^";
		RTP_TABLE_NOTABLE:
			print "Attempt to blank out a row from a non-existent table (value ",
				par1, ").^";
		RTP_TABLE_NOTABLE2:
			print "Attempt to access an entry from a non-existent table.^";
		RTP_TABLE_NOMOREBLANKS:
			print "Attempt to choose a blank row in a table with none left: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOROWS:
			print "Attempt to choose a random row in an entirely blank table: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_CANTRUNTHROUGH:
			print "Attempt to repeat through a table in a tricky column order: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_CANTSORT:
			print "Attempt to sort a table whose ordering must remain fixed: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_CANTSAVE:
			print "Attempt to save a table to a file whose data is unstable: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_WONTFIT:
			print "File being read has too many rows or columns to fit into table: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_BADFILE:
			print "File being read is not a previously saved table: table '",
				(PrintTableName) par1, "'.^";
		RTP_NOTINAROOM:
			print "Attempt to test if the current location is '",
				(the) par1, "', which is not a room or region.^";
		RTP_BADTOPIC:
			print "Attempt to see if a snippet of text matches something which
				is not a topic.^";
		RTP_ROUTELESS:
			print "Attempt to find route or count steps through an implicit
				relation.^";
		RTP_PROPOFNOTHING:
			print "Attempt to use a property of the 'nothing' non-object: property ",
				(PrintPropertyName) par2, "^";
		RTP_DECIDEONWRONGKIND:
			print "Attempt to 'decide on V' where V is the wrong kind of object.^";
		RTP_DECIDEONNOTHING:
			print "Attempt to 'decide on nothing'.^";
		RTP_LOWLEVELERROR:
			print "Low level error.^";
		RTP_DONTIGNORETURNSEQUENCE:
			print "Attempt to ignore the turn sequence rules.^";
		RTP_SAYINVALIDSNIPPET:
			print "Attempt to say a snippet value which is currently invalid: words ",
				par1, " to ", par2, ".^";
		RTP_SPLICEINVALIDSNIPPET:
			print "Attempt to splice a snippet value which is currently invalid: words ",
				par1, " to ", par2, ".^";
		RTP_INCLUDEINVALIDSNIPPET:
			print "Attempt to match a snippet value which is currently invalid: words ",
				par1, " to ", par2, ".^";
		RTP_LISTWRITERMEMORY:
			print "The list-writer has run out of memory.^";
		RTP_CANTREMOVEPLAYER:
			print "Attempt to remove the player from play.^";
		RTP_CANTBEOFFSTAGE:
			print "Attempt to move the player off-stage.^";
		RTP_CANTREMOVEDOORS:
			print "Attempt to remove a door from play.^";
		RTP_CANTCHANGEOFFSTAGE:
			print "Attempt to change the player to a person off-stage.^";
		RTP_MSTACKMEMORY:
			print "The memory stack is exhausted.^";
		RTP_TYPECHECK:
			print "Phrase applied to an incompatible kind of value.^";
		RTP_FILEIOERROR:
			print "Error handling external file.^";
		RTP_HEAPERROR:
			print "Memory allocation proved impossible.^";
		RTP_LISTRANGEERROR:
			print "Attempt to use list item which does not exist.^";
		RTP_LISTSIZENEGATIVE:
			print "Attempt to resize list to ", par1, " entries - there must ",
			"always be 0 or more.^";	
		RTP_REGEXPSYNTAXERROR:
			print "Syntax error in regular expression.^";
		RTP_NOGLULXUNICODE:
			print "This interpreter does not support Unicode.^";
		RTP_BACKDROPONLY:
			print "Only backdrops can be moved to multiple places.^";
		RTP_NOTTHING:
			print "Tried to move ", (the) par1, " (not a thing) to ", (the) par2,
				", but only things can move around.^";
		RTP_SCENEHASNTSTARTED:
			print "The scene ", (PrintSceneName) par1,
				" hasn't started, so you can't ask when it did.^";
		RTP_SCENEHASNTENDED:
			print "The scene ", (PrintSceneName) par1,
				" hasn't ended, so you can't ask when it did.^";
		RTP_NEGATIVEROOT:
			print "You can't take the square root of a negative number.^";
		RTP_CANTITERATE:
			print "You can't implicitly repeat through the values of this kind: ",
				"a problem arising from a description which started out here - ~",
				(string) par1, "~.^";
		RTP_WRONGASSIGNEDKIND:
			print "Attempt to set a variable to the wrong kind of object: ",
				"you wrote '", (string) par2, "', which sets the value to ", (the) par1,
				" - but that doesn't have the kind '", (string) par3, "'.^";			
		RTP_RELKINDVIOLATION:
			print "Tried to change a relation for objects with the wrong kinds: ",
				(string) RlnGetF(par3, RR_DESCRIPTION), ", but you tried to ",
				"relate (or unrelate) ", (the) par1, " to ", (the) par2, ".^";
		RTP_CANTMAKEPART:
			print "Tried to make the player part of something: ",
				(the) par1, ".^";
		RTP_TEXTTOKENTOOHARD:
			print "This use of '[text]' is too complicated.^";
		RTP_RELATIONCHANGEIMPOSSIBLE:
			print "This change of the relation's nature is impossible in play.^";
		RTP_RELMINIMAL:
			print "This operation can't be done with the relation '",
				(string) RlnGetF(par3, RR_DESCRIPTION), "'.^";
		RTP_REGIONSNOTADJACENT:
			print "You can't test whether something is adjacent to a region: ",
				"such as, in this case, ", (the) par1, ".^";
		}
	print "^";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Low-Level Errors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant MAX_TIMERS = 0;
[ RunTimeError n p1 p2;
    #Ifdef DEBUG;
    print "** Library error ", n, " (", p1, ",", p2, ") **^** ";
    switch (n) {
      1:    print "preposition not found (this should not occur)";
      2:    print "Property value not routine or string: ~", (property) p2, "~ of ~", (name) p1,
                  "~ (", p1, ")";
      3:    print "Entry in property list not routine or string: ~", (property) p2, "~ list of ~",
                  (name) p1, "~ (", p1, ")";
      4:    print "Too many timers/daemons are active simultaneously.
                  The limit is the library constant MAX_TIMERS (currently ",
                  MAX_TIMERS, ") and should be increased";
      5:    print "Object ~", (name) p1, "~ has no ~time_left~ property";
      7:    print "The object ~", (name) p1, "~ can only be used as a player object if it has
                  the ~number~ property";
      8:    print "Attempt to take random entry from an empty table array";
      9:    print p1, " is not a valid direction property number";
      10:   print "The player-object is outside the object tree";
      11:   print "The room ~", (name) p1, "~ has no ~description~ property";
      12:   print "Tried to set a non-existent pronoun using SetPronoun";
      13:   print "A 'topic' token can only be followed by a preposition";
      default: print "(unexplained)";
    }
    print " **^";
    #Ifnot;
    print "** Library error ", n, " (", p1, ",", p2, ") **^";
    #Endif; ! DEBUG
    RunTimeProblem(RTP_LOWLEVELERROR);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Argument Type Checking Failed
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ArgumentTypeFailed line file;
	RunTimeProblem(RTP_TYPECHECK, 0, 0, 0, line, file);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Return Type Checking Failed
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CheckKindReturned V K;
	if (V ofclass K) return V;
	if (v == nothing) RunTimeProblem(RTP_DECIDEONNOTHING);
	else RunTimeProblem(RTP_DECIDEONWRONGKIND);
	return V;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Whether Provides
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WhetherProvides obj either_or p issue_rtp  off i textual a l;
	if (metaclass(obj) ~= Object) rfalse;
	if (p<0) p = ~p;
	if (either_or) {
		if (p < FBNA_PROP_NUMBER) off = attributed_property_offsets-->p;
		else off = valued_property_offsets-->p;
	} else off = valued_property_offsets-->p;
	if (off<0) {
		if (issue_rtp) RunTimeProblem(RTP_BADPROPERTY, obj);
		rfalse;
	}
	textual = property_metadata-->off; off++;
	
	if (ScanPropertyMetadata(obj, off)) jump PermissionFound;
	if (obj provides KD_Count) {
		l = obj.KD_Count;
		while (l > 0) {
			a = l*2;
			if (ScanPropertyMetadata(KindHierarchy-->a, off)) jump PermissionFound;
			l = KindHierarchy-->(a+1);
		}
	}
	if (issue_rtp) RunTimeProblem(RTP_UNPROVIDED, obj, textual);
	rfalse;

	.PermissionFound;
		if (either_or) rtrue;
		if (obj provides p) rtrue;
		if (issue_rtp) RunTimeProblem(RTP_UNSET, obj, textual);
		rfalse;
];

[ PrintPropertyName  p  off textual;
	if (p<0) p = ~p;
	off = valued_property_offsets-->p;
	textual = property_metadata-->off;
	print (string) textual;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Scan Property Metadata
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ScanPropertyMetadata obj off i;
	for (i=off: property_metadata-->i >= 0: i++)
		if (obj == property_metadata-->i) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Get Either-Or Property
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GetEitherOrProperty o p;
	if (o == nothing) rfalse;
	if (p<0) p = ~p;
	if (WhetherProvides(o, true, p, false)) {
		if (p<FBNA_PROP_NUMBER) { if (o has p) rtrue; rfalse; }
		if ((o provides p) && (o.p)) rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Set Either-Or Property
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SetEitherOrProperty o p negate adj;
	if (p<0) { p = ~p; negate = ~negate; }
	if (adj) {
		(adj)(o);
	} else if (WhetherProvides(o, true, p, true)) {
		if (negate) {
			if (p<FBNA_PROP_NUMBER) give o ~p; else o.p = false;
		} else {
			if (p<FBNA_PROP_NUMBER) give o p; else o.p = true;
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Value Property
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GProperty K V pr obj;
	if (K == OBJECT_TY) obj = V; else obj = KOV_representatives-->K;
	if (obj == 0) { RunTimeProblem(RTP_PROPOFNOTHING, obj, pr); rfalse; }
	if (obj provides pr) {
		if (K == OBJECT_TY) {
			if (pr == door_to) return obj.pr();
			if (WhetherProvides(V, false, pr, true)) return obj.pr;
			rfalse;
		}
		if (obj ofclass K0_kind)
			WhetherProvides(V, false, pr, true); ! to force a run-time problem
		if ((V < 1) || (V > obj.value_range)) {
			RunTimeProblem(RTP_BADVALUEPROPERTY); return 0; }
		return (obj.pr)-->(V+COL_HSIZE);
	} else {
		if (obj ofclass K0_kind)
			WhetherProvides(V, false, pr, true); ! to force a run-time problem
	}
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Write Value Property
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteGProperty K V pr val obj;
	if (K == OBJECT_TY) obj = V; else obj = KOV_representatives-->K;
	if (obj == 0) { RunTimeProblem(RTP_PROPOFNOTHING, obj, pr); rfalse; }
	if (K == OBJECT_TY) {
		if (WhetherProvides(V, false, pr, true)) obj.pr = val;
	} else {
		if ((V < 1) || (V > obj.value_range))
			return RunTimeProblem(RTP_BADVALUEPROPERTY);
		if (obj provides pr) { (obj.pr)-->(V+COL_HSIZE) = val; }
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RTP.i6t: Printing Property Names
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PROPERTY_TY_Say v;
	print "property ", v;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Latest Rule Result
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RS_NEITHER		= 0;
Constant RS_SUCCEEDS	= 1;
Constant RS_FAILS		= 2;

Array latest_rule_result --> 3;

[ RecordRuleOutcome usage rule1 rule2;
	if ((latest_rule_result-->0 == RS_SUCCEEDS or RS_FAILS) &&
		(KOVIsBlockValue(latest_rule_result-->1)))
		BlkValueFree(latest_rule_result-->2);
	if ((usage == RS_SUCCEEDS or RS_FAILS) && (KOVIsBlockValue(rule1)))
		rule2 = BlkValueCopy(BlkValueCreate(rule1), rule2);
	latest_rule_result-->0 = usage;
	latest_rule_result-->1 = rule1;
	latest_rule_result-->2 = rule2;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Following
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global process_rulebook_count; ! Depth of processing recursion
Global debugging_rules = false; ! Are we tracing rule invocations?

[ FollowRulebook rulebook parameter no_paragraph_skips
	rv ss spv;
	ss = self;
	if ((Protect_I7_Arrays-->0 ~= 16339) || (Protect_I7_Arrays-->1 ~= 12345)) {
		print "^^*** Fatal programming error: I7 arrays corrupted ***^^";
		@quit;
	}
	if (parameter) { self = parameter; parameter_object = parameter; }
	spv = parameter_value; parameter_value = parameter;
	! we won't need parameter again, so can reuse it
	parameter = debugging_rules;
	#ifndef MEMORY_ECONOMY;
	if (debugging_rules) {
		DebugRulebooks(rulebook, parameter);
		process_rulebook_count = process_rulebook_count + debugging_rules;
	}
	#endif;
	if ((rulebook >= 0) && (rulebook < NUMBER_RULEBOOKS_CREATED)) {
		rv = rulebooks_array-->rulebook;
		if (rv ~= EMPTY_RULEBOOK) {
			if (rulebook ~= ACTION_PROCESSING_RB) MStack_CreateRBVars(rulebook);
			if (say__p) RulebookParBreak(no_paragraph_skips);
			rv = rv(no_paragraph_skips);
			if (rulebook ~= ACTION_PROCESSING_RB) MStack_DestroyRBVars(rulebook);
		} else {
			rv = 0;
		}
	} else {
		if (say__p) RulebookParBreak(no_paragraph_skips);
		rv = indirect(rulebook);
		if (rv == 2) rv = reason_the_action_failed;
		else if (rv) rv = rulebook;
	}
	if (rv) {
		#ifndef MEMORY_ECONOMY;
		if (debugging_rules) {
			process_rulebook_count = process_rulebook_count - debugging_rules;
			if (process_rulebook_count < 0) process_rulebook_count = 0;
			spaces(2*process_rulebook_count);
	  	    if (latest_rule_result-->0 == RS_SUCCEEDS) print "[stopped: success]^";
	  	    if (latest_rule_result-->0 == RS_FAILS) print "[stopped: fail]^";
		}
		#endif;
	} else {
		if (debugging_rules)
			process_rulebook_count = process_rulebook_count - debugging_rules;
		latest_rule_result-->0 = RS_NEITHER;
	}
	debugging_rules = parameter;
	self = ss; parameter_value = spv;
	return rv;
];

[ RulebookParBreak no_paragraph_skips;
	if ((no_paragraph_skips == false) && (say__pc & PARA_NORULEBOOKBREAKS == 0))
		DivideParagraphPoint();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Specifying Outcomes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ActRulebookSucceeds rule_id;
	if (rule_id) reason_the_action_failed = rule_id;
	RulebookSucceeds();
];

[ ActRulebookFails rule_id;
	if (rule_id) reason_the_action_failed = rule_id;
	RulebookFails();
];

[ RulebookSucceeds weak_kind value;
	RecordRuleOutcome(RS_SUCCEEDS, weak_kind, value);
];

[ RulebookFails weak_kind value;
	RecordRuleOutcome(RS_FAILS, weak_kind, value);
];

[ RuleHasNoOutcome;
	RecordRuleOutcome(RS_NEITHER, 0, 0);
];

[ SetRulebookOutcome a;
	latest_rule_result-->0 = a;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Discovering Outcomes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RulebookOutcome a;
	a = latest_rule_result-->0;
	if ((a == RS_FAILS) || (a == RS_SUCCEEDS)) return a;
	return RS_NEITHER;
];

[ RulebookFailed;
	if (latest_rule_result-->0 == RS_FAILS) rtrue; rfalse;
];

[ RulebookSucceeded;
	if (latest_rule_result-->0 == RS_SUCCEEDS) rtrue; rfalse;
];

[ ResultOfRule RB V F K a;
	if (RB) FollowRulebook(RB, V, F);
	a = latest_rule_result-->0;
	if ((a == RS_FAILS) || (a == RS_SUCCEEDS)) {
		a = latest_rule_result-->1;
		if (a) return latest_rule_result-->2;
	}
	if (K) return DefaultValueOfKOV(K);
	return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Printing Rule Names
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFNDEF MEMORY_ECONOMY;
Array RulebookNames -->
    "Startup rulebook" ! 0
    "Turn sequence rulebook" ! 1
    "Shutdown rulebook" ! 2
    "Scene changing rulebook" ! 3
    "When play begins rulebook" ! 4
    "When play ends rulebook" ! 5
    "When scene begins rulebook" ! 6
    "When scene ends rulebook" ! 7
    "Every turn rulebook" ! 8
    "Action-processing rulebook" ! 9
    "Setting action variables rulebook" ! 10
    "specific action-processing rulebook" ! 11
    "player's action awareness rulebook" ! 12
    "Accessibility rulebook" ! 13
    "Reaching inside rulebook" ! 14
    "Reaching outside rulebook" ! 15
    "Visibility rulebook" ! 16
    "Persuasion rulebook" ! 17
    "Unsuccessful attempt by rulebook" ! 18
    "Before rulebook" ! 19
    "Instead rulebook" ! 20
    "Check rulebook" ! 21
    "Carry out rulebook" ! 22
    "After rulebook" ! 23
    "Report rulebook" ! 24
    "does the player mean rulebook" ! 25
    "multiple action processing rulebook" ! 26
    "when Entire Game begins rulebook" ! 27
    "when Entire Game ends rulebook" ! 28
    "before Printing the name rulebook" ! 29
    "for Printing the name rulebook" ! 30
    "after Printing the name rulebook" ! 31
    "before Printing the plural name rulebook" ! 32
    "for Printing the plural name rulebook" ! 33
    "after Printing the plural name rulebook" ! 34
    "before Printing a number rulebook" ! 35
    "for Printing a number rulebook" ! 36
    "after Printing a number rulebook" ! 37
    "before Printing room description details rulebook" ! 38
    "for Printing room description details rulebook" ! 39
    "after Printing room description details rulebook" ! 40
    "before Printing inventory details rulebook" ! 41
    "for Printing inventory details rulebook" ! 42
    "after Printing inventory details rulebook" ! 43
    "before Listing contents rulebook" ! 44
    "for Listing contents rulebook" ! 45
    "after Listing contents rulebook" ! 46
    "before Grouping together rulebook" ! 47
    "for Grouping together rulebook" ! 48
    "after Grouping together rulebook" ! 49
    "before Writing a paragraph about rulebook" ! 50
    "for Writing a paragraph about rulebook" ! 51
    "after Writing a paragraph about rulebook" ! 52
    "before Listing nondescript items rulebook" ! 53
    "for Listing nondescript items rulebook" ! 54
    "after Listing nondescript items rulebook" ! 55
    "before Printing the name of a dark room rulebook" ! 56
    "for Printing the name of a dark room rulebook" ! 57
    "after Printing the name of a dark room rulebook" ! 58
    "before Printing the description of a dark room rulebook" ! 59
    "for Printing the description of a dark room rulebook" ! 60
    "after Printing the description of a dark room rulebook" ! 61
    "before Printing the announcement of darkness rulebook" ! 62
    "for Printing the announcement of darkness rulebook" ! 63
    "after Printing the announcement of darkness rulebook" ! 64
    "before Printing the announcement of light rulebook" ! 65
    "for Printing the announcement of light rulebook" ! 66
    "after Printing the announcement of light rulebook" ! 67
    "before Printing a refusal to act in the dark rulebook" ! 68
    "for Printing a refusal to act in the dark rulebook" ! 69
    "after Printing a refusal to act in the dark rulebook" ! 70
    "before Constructing the status line rulebook" ! 71
    "for Constructing the status line rulebook" ! 72
    "after Constructing the status line rulebook" ! 73
    "before Printing the banner text rulebook" ! 74
    "for Printing the banner text rulebook" ! 75
    "after Printing the banner text rulebook" ! 76
    "before Reading a command rulebook" ! 77
    "for Reading a command rulebook" ! 78
    "after Reading a command rulebook" ! 79
    "before Deciding the scope rulebook" ! 80
    "for Deciding the scope rulebook" ! 81
    "after Deciding the scope rulebook" ! 82
    "before Deciding the concealed possessions rulebook" ! 83
    "for Deciding the concealed possessions rulebook" ! 84
    "after Deciding the concealed possessions rulebook" ! 85
    "before Deciding whether all includes rulebook" ! 86
    "for Deciding whether all includes rulebook" ! 87
    "after Deciding whether all includes rulebook" ! 88
    "before Clarifying the parser's choice rulebook" ! 89
    "for Clarifying the parser's choice rulebook" ! 90
    "after Clarifying the parser's choice rulebook" ! 91
    "before Asking which do you mean rulebook" ! 92
    "for Asking which do you mean rulebook" ! 93
    "after Asking which do you mean rulebook" ! 94
    "before Printing a parser error rulebook" ! 95
    "for Printing a parser error rulebook" ! 96
    "after Printing a parser error rulebook" ! 97
    "before Supplying a missing noun rulebook" ! 98
    "for Supplying a missing noun rulebook" ! 99
    "after Supplying a missing noun rulebook" ! 100
    "before Supplying a missing second noun rulebook" ! 101
    "for Supplying a missing second noun rulebook" ! 102
    "after Supplying a missing second noun rulebook" ! 103
    "before Implicitly taking rulebook" ! 104
    "for Implicitly taking rulebook" ! 105
    "after Implicitly taking rulebook" ! 106
    "before Starting the virtual machine rulebook" ! 107
    "for Starting the virtual machine rulebook" ! 108
    "after Starting the virtual machine rulebook" ! 109
    "before Amusing a victorious player rulebook" ! 110
    "for Amusing a victorious player rulebook" ! 111
    "after Amusing a victorious player rulebook" ! 112
    "before Printing the player's obituary rulebook" ! 113
    "for Printing the player's obituary rulebook" ! 114
    "after Printing the player's obituary rulebook" ! 115
    "before Handling the final question rulebook" ! 116
    "for Handling the final question rulebook" ! 117
    "after Handling the final question rulebook" ! 118
    "before Printing the locale description rulebook" ! 119
    "for Printing the locale description rulebook" ! 120
    "after Printing the locale description rulebook" ! 121
    "before Choosing notable locale objects rulebook" ! 122
    "for Choosing notable locale objects rulebook" ! 123
    "after Choosing notable locale objects rulebook" ! 124
    "before Printing a locale paragraph about rulebook" ! 125
    "for Printing a locale paragraph about rulebook" ! 126
    "after Printing a locale paragraph about rulebook" ! 127
    "before Issuing the response text rulebook" ! 128
    "for Issuing the response text rulebook" ! 129
    "after Issuing the response text rulebook" ! 130
    "check Taking inventory rulebook" ! 131
    "carry out Taking inventory rulebook" ! 132
    "report Taking inventory rulebook" ! 133
    "check Taking rulebook" ! 134
    "carry out Taking rulebook" ! 135
    "report Taking rulebook" ! 136
    "check Removing it from rulebook" ! 137
    "carry out Removing it from rulebook" ! 138
    "report Removing it from rulebook" ! 139
    "check Dropping rulebook" ! 140
    "carry out Dropping rulebook" ! 141
    "report Dropping rulebook" ! 142
    "check Putting it on rulebook" ! 143
    "carry out Putting it on rulebook" ! 144
    "report Putting it on rulebook" ! 145
    "check Inserting it into rulebook" ! 146
    "carry out Inserting it into rulebook" ! 147
    "report Inserting it into rulebook" ! 148
    "check Eating rulebook" ! 149
    "carry out Eating rulebook" ! 150
    "report Eating rulebook" ! 151
    "check Going rulebook" ! 152
    "carry out Going rulebook" ! 153
    "report Going rulebook" ! 154
    "check Entering rulebook" ! 155
    "carry out Entering rulebook" ! 156
    "report Entering rulebook" ! 157
    "check Exiting rulebook" ! 158
    "carry out Exiting rulebook" ! 159
    "report Exiting rulebook" ! 160
    "check Getting off rulebook" ! 161
    "carry out Getting off rulebook" ! 162
    "report Getting off rulebook" ! 163
    "check Looking rulebook" ! 164
    "carry out Looking rulebook" ! 165
    "report Looking rulebook" ! 166
    "check Examining rulebook" ! 167
    "carry out Examining rulebook" ! 168
    "report Examining rulebook" ! 169
    "check Looking under rulebook" ! 170
    "carry out Looking under rulebook" ! 171
    "report Looking under rulebook" ! 172
    "check Searching rulebook" ! 173
    "carry out Searching rulebook" ! 174
    "report Searching rulebook" ! 175
    "check Consulting it about rulebook" ! 176
    "carry out Consulting it about rulebook" ! 177
    "report Consulting it about rulebook" ! 178
    "check Locking it with rulebook" ! 179
    "carry out Locking it with rulebook" ! 180
    "report Locking it with rulebook" ! 181
    "check Unlocking it with rulebook" ! 182
    "carry out Unlocking it with rulebook" ! 183
    "report Unlocking it with rulebook" ! 184
    "check Switching on rulebook" ! 185
    "carry out Switching on rulebook" ! 186
    "report Switching on rulebook" ! 187
    "check Switching off rulebook" ! 188
    "carry out Switching off rulebook" ! 189
    "report Switching off rulebook" ! 190
    "check Opening rulebook" ! 191
    "carry out Opening rulebook" ! 192
    "report Opening rulebook" ! 193
    "check Closing rulebook" ! 194
    "carry out Closing rulebook" ! 195
    "report Closing rulebook" ! 196
    "check Wearing rulebook" ! 197
    "carry out Wearing rulebook" ! 198
    "report Wearing rulebook" ! 199
    "check Taking off rulebook" ! 200
    "carry out Taking off rulebook" ! 201
    "report Taking off rulebook" ! 202
    "check Giving it to rulebook" ! 203
    "carry out Giving it to rulebook" ! 204
    "report Giving it to rulebook" ! 205
    "check Showing it to rulebook" ! 206
    "carry out Showing it to rulebook" ! 207
    "report Showing it to rulebook" ! 208
    "check Waking rulebook" ! 209
    "carry out Waking rulebook" ! 210
    "report Waking rulebook" ! 211
    "check Throwing it at rulebook" ! 212
    "carry out Throwing it at rulebook" ! 213
    "report Throwing it at rulebook" ! 214
    "check Attacking rulebook" ! 215
    "carry out Attacking rulebook" ! 216
    "report Attacking rulebook" ! 217
    "check Kissing rulebook" ! 218
    "carry out Kissing rulebook" ! 219
    "report Kissing rulebook" ! 220
    "check Answering it that rulebook" ! 221
    "carry out Answering it that rulebook" ! 222
    "report Answering it that rulebook" ! 223
    "check Telling it about rulebook" ! 224
    "carry out Telling it about rulebook" ! 225
    "report Telling it about rulebook" ! 226
    "check Asking it about rulebook" ! 227
    "carry out Asking it about rulebook" ! 228
    "report Asking it about rulebook" ! 229
    "check Asking it for rulebook" ! 230
    "carry out Asking it for rulebook" ! 231
    "report Asking it for rulebook" ! 232
    "check Waiting rulebook" ! 233
    "carry out Waiting rulebook" ! 234
    "report Waiting rulebook" ! 235
    "check Touching rulebook" ! 236
    "carry out Touching rulebook" ! 237
    "report Touching rulebook" ! 238
    "check Waving rulebook" ! 239
    "carry out Waving rulebook" ! 240
    "report Waving rulebook" ! 241
    "check Pulling rulebook" ! 242
    "carry out Pulling rulebook" ! 243
    "report Pulling rulebook" ! 244
    "check Pushing rulebook" ! 245
    "carry out Pushing rulebook" ! 246
    "report Pushing rulebook" ! 247
    "check Turning rulebook" ! 248
    "carry out Turning rulebook" ! 249
    "report Turning rulebook" ! 250
    "check Pushing it to rulebook" ! 251
    "carry out Pushing it to rulebook" ! 252
    "report Pushing it to rulebook" ! 253
    "check Squeezing rulebook" ! 254
    "carry out Squeezing rulebook" ! 255
    "report Squeezing rulebook" ! 256
    "check Saying yes rulebook" ! 257
    "carry out Saying yes rulebook" ! 258
    "report Saying yes rulebook" ! 259
    "check Saying no rulebook" ! 260
    "carry out Saying no rulebook" ! 261
    "report Saying no rulebook" ! 262
    "check Cutting rulebook" ! 263
    "carry out Cutting rulebook" ! 264
    "report Cutting rulebook" ! 265
    "check Saying sorry rulebook" ! 266
    "carry out Saying sorry rulebook" ! 267
    "report Saying sorry rulebook" ! 268
    "check Rubbing rulebook" ! 269
    "carry out Rubbing rulebook" ! 270
    "report Rubbing rulebook" ! 271
    "check Buying rulebook" ! 272
    "carry out Buying rulebook" ! 273
    "report Buying rulebook" ! 274
    "check Quitting the game rulebook" ! 275
    "carry out Quitting the game rulebook" ! 276
    "report Quitting the game rulebook" ! 277
    "check Saving the game rulebook" ! 278
    "carry out Saving the game rulebook" ! 279
    "report Saving the game rulebook" ! 280
    "check Restoring the game rulebook" ! 281
    "carry out Restoring the game rulebook" ! 282
    "report Restoring the game rulebook" ! 283
    "check Restarting the game rulebook" ! 284
    "carry out Restarting the game rulebook" ! 285
    "report Restarting the game rulebook" ! 286
    "check Verifying the story file rulebook" ! 287
    "carry out Verifying the story file rulebook" ! 288
    "report Verifying the story file rulebook" ! 289
    "check Switching the story transcript on rulebook" ! 290
    "carry out Switching the story transcript on rulebook" ! 291
    "report Switching the story transcript on rulebook" ! 292
    "check Switching the story transcript off rulebook" ! 293
    "carry out Switching the story transcript off rulebook" ! 294
    "report Switching the story transcript off rulebook" ! 295
    "check Requesting the story file version rulebook" ! 296
    "carry out Requesting the story file version rulebook" ! 297
    "report Requesting the story file version rulebook" ! 298
    "check Requesting the score rulebook" ! 299
    "carry out Requesting the score rulebook" ! 300
    "report Requesting the score rulebook" ! 301
    "check Preferring abbreviated room descriptions rulebook" ! 302
    "carry out Preferring abbreviated room descriptions rulebook" ! 303
    "report Preferring abbreviated room descriptions rulebook" ! 304
    "check Preferring unabbreviated room descriptions rulebook" ! 305
    "carry out Preferring unabbreviated room descriptions rulebook" ! 306
    "report Preferring unabbreviated room descriptions rulebook" ! 307
    "check Preferring sometimes abbreviated room descriptions rulebook" ! 308
    "carry out Preferring sometimes abbreviated room descriptions rulebook" ! 309
    "report Preferring sometimes abbreviated room descriptions rulebook" ! 310
    "check Switching score notification on rulebook" ! 311
    "carry out Switching score notification on rulebook" ! 312
    "report Switching score notification on rulebook" ! 313
    "check Switching score notification off rulebook" ! 314
    "carry out Switching score notification off rulebook" ! 315
    "report Switching score notification off rulebook" ! 316
    "check Requesting the pronoun meanings rulebook" ! 317
    "carry out Requesting the pronoun meanings rulebook" ! 318
    "report Requesting the pronoun meanings rulebook" ! 319
    "check Requesting epistemic status of rulebook" ! 320
    "carry out Requesting epistemic status of rulebook" ! 321
    "report Requesting epistemic status of rulebook" ! 322
    "check Requesting it for rulebook" ! 323
    "carry out Requesting it for rulebook" ! 324
    "report Requesting it for rulebook" ! 325
    "check Imploring it for rulebook" ! 326
    "carry out Imploring it for rulebook" ! 327
    "report Imploring it for rulebook" ! 328
    "check Quizzing it about rulebook" ! 329
    "carry out Quizzing it about rulebook" ! 330
    "report Quizzing it about rulebook" ! 331
    "check Informing it about rulebook" ! 332
    "carry out Informing it about rulebook" ! 333
    "report Informing it about rulebook" ! 334
    "check Implicit-asking rulebook" ! 335
    "carry out Implicit-asking rulebook" ! 336
    "report Implicit-asking rulebook" ! 337
    "check implicit-telling rulebook" ! 338
    "carry out implicit-telling rulebook" ! 339
    "report implicit-telling rulebook" ! 340
    "check implicit-quizzing rulebook" ! 341
    "carry out implicit-quizzing rulebook" ! 342
    "report implicit-quizzing rulebook" ! 343
    "check implicit-informing rulebook" ! 344
    "carry out implicit-informing rulebook" ! 345
    "report implicit-informing rulebook" ! 346
    "check implicit-requesting rulebook" ! 347
    "carry out implicit-requesting rulebook" ! 348
    "report implicit-requesting rulebook" ! 349
    "check implicit-imploring rulebook" ! 350
    "carry out implicit-imploring rulebook" ! 351
    "report implicit-imploring rulebook" ! 352
    "check Saying hello to rulebook" ! 353
    "carry out Saying hello to rulebook" ! 354
    "report Saying hello to rulebook" ! 355
    "check Hailing rulebook" ! 356
    "carry out Hailing rulebook" ! 357
    "report Hailing rulebook" ! 358
    "check Leavetaking rulebook" ! 359
    "carry out Leavetaking rulebook" ! 360
    "report Leavetaking rulebook" ! 361
    "check Saying goodbye to rulebook" ! 362
    "carry out Saying goodbye to rulebook" ! 363
    "report Saying goodbye to rulebook" ! 364
    "response rulebook" ! 365
    "greeting response rulebook" ! 366
    "farewell response rulebook" ! 367
    "implicit greeting response rulebook" ! 368
    "implicit farewell response rulebook" ! 369
    "default ask response rulebook" ! 370
    "default ask-tell response rulebook" ! 371
    "default tell response rulebook" ! 372
    "default answer response rulebook" ! 373
    "default ask-for response rulebook" ! 374
    "default give response rulebook" ! 375
    "default show response rulebook" ! 376
    "default give-show response rulebook" ! 377
    "default yes-no response rulebook" ! 378
    "default response rulebook" ! 379
    "before Pausing the game rulebook" ! 380
    "for Pausing the game rulebook" ! 381
    "after Pausing the game rulebook" ! 382
    "escape detection rulebook" ! 383
    "check Helping rulebook" ! 384
    "carry out Helping rulebook" ! 385
    "report Helping rulebook" ! 386
    "check asking for identification rulebook" ! 387
    "carry out asking for identification rulebook" ! 388
    "report asking for identification rulebook" ! 389
    "check Questioning motives rulebook" ! 390
    "carry out Questioning motives rulebook" ! 391
    "report Questioning motives rulebook" ! 392
    "check promising rulebook" ! 393
    "carry out promising rulebook" ! 394
    "report promising rulebook" ! 395
    "Audibility of rulebook" ! 396
    "Noisiness of rulebook" ! 397
    "before printing insistent sounds rulebook" ! 398
    "for printing insistent sounds rulebook" ! 399
    "after printing insistent sounds rulebook" ! 400
    "before printing background sounds rulebook" ! 401
    "for printing background sounds rulebook" ! 402
    "after printing background sounds rulebook" ! 403
    "before Determining the subjective volume rulebook" ! 404
    "for Determining the subjective volume rulebook" ! 405
    "after Determining the subjective volume rulebook" ! 406
    "before Printing the sound description rulebook" ! 407
    "for Printing the sound description rulebook" ! 408
    "after Printing the sound description rulebook" ! 409
    "before Printing the sound action rulebook" ! 410
    "for Printing the sound action rulebook" ! 411
    "after Printing the sound action rulebook" ! 412
    "check Calling it on rulebook" ! 413
    "carry out Calling it on rulebook" ! 414
    "report Calling it on rulebook" ! 415
    "check Cold-calling it on rulebook" ! 416
    "carry out Cold-calling it on rulebook" ! 417
    "report Cold-calling it on rulebook" ! 418
    "check Answering rulebook" ! 419
    "carry out Answering rulebook" ! 420
    "report Answering rulebook" ! 421
    "check PIcking up rulebook" ! 422
    "carry out PIcking up rulebook" ! 423
    "report PIcking up rulebook" ! 424
    "check Ending a call rulebook" ! 425
    "carry out Ending a call rulebook" ! 426
    "report Ending a call rulebook" ! 427
    "check Hanging up rulebook" ! 428
    "carry out Hanging up rulebook" ! 429
    "report Hanging up rulebook" ! 430
    "check Signing off with rulebook" ! 431
    "carry out Signing off with rulebook" ! 432
    "report Signing off with rulebook" ! 433
    "check Buying it with rulebook" ! 434
    "carry out Buying it with rulebook" ! 435
    "report Buying it with rulebook" ! 436
    "check Pricing it rulebook" ! 437
    "carry out Pricing it rulebook" ! 438
    "report Pricing it rulebook" ! 439
    "check Accounting rulebook" ! 440
    "carry out Accounting rulebook" ! 441
    "report Accounting rulebook" ! 442
    "check Attributing it rulebook" ! 443
    "carry out Attributing it rulebook" ! 444
    "report Attributing it rulebook" ! 445
    "before Acting as rulebook" ! 446
    "for Acting as rulebook" ! 447
    "after Acting as rulebook" ! 448
    "Interruption rulebook" ! 449
    "Termination rulebook" ! 450
    "before behaving as rulebook" ! 451
    "for behaving as rulebook" ! 452
    "after behaving as rulebook" ! 453
    "before initializing rulebook" ! 454
    "for initializing rulebook" ! 455
    "after initializing rulebook" ! 456
    "wall description rulebook" ! 457
    "wall touch description rulebook" ! 458
    "floor description rulebook" ! 459
    "floor touch description rulebook" ! 460
    "ceiling description rulebook" ! 461
    "ceiling touch description rulebook" ! 462
    "excuse text rulebook" ! 463
    "can't take that rulebook" ! 464
    "can't move that rulebook" ! 465
    "before List arranging rulebook" ! 466
    "for List arranging rulebook" ! 467
    "after List arranging rulebook" ! 468
    "before Delimiting a list rulebook" ! 469
    "for Delimiting a list rulebook" ! 470
    "after Delimiting a list rulebook" ! 471
    "door appearance rulebook" ! 472
    "room appearance rulebook" ! 473
    "check ExitStarting rulebook" ! 474
    "carry out ExitStarting rulebook" ! 475
    "report ExitStarting rulebook" ! 476
    "check ExitStopping rulebook" ! 477
    "carry out ExitStopping rulebook" ! 478
    "report ExitStopping rulebook" ! 479
    "check ExitListing rulebook" ! 480
    "carry out ExitListing rulebook" ! 481
    "report ExitListing rulebook" ! 482
    "check exit colouring rulebook" ! 483
    "carry out exit colouring rulebook" ! 484
    "report exit colouring rulebook" ! 485
    "check exit symboling rulebook" ! 486
    "carry out exit symboling rulebook" ! 487
    "report exit symboling rulebook" ! 488
    "before Printing the options paragraph rulebook" ! 489
    "for Printing the options paragraph rulebook" ! 490
    "after Printing the options paragraph rulebook" ! 491
    "check Choosing rulebook" ! 492
    "carry out Choosing rulebook" ! 493
    "report Choosing rulebook" ! 494
    "before Listing the available choices rulebook" ! 495
    "for Listing the available choices rulebook" ! 496
    "after Listing the available choices rulebook" ! 497
    "check Looking behind rulebook" ! 498
    "carry out Looking behind rulebook" ! 499
    "report Looking behind rulebook" ! 500
    "check printing memories rulebook" ! 501
    "carry out printing memories rulebook" ! 502
    "report printing memories rulebook" ! 503
    "check remembering rulebook" ! 504
    "carry out remembering rulebook" ! 505
    "report remembering rulebook" ! 506
    "check Discussing it with rulebook" ! 507
    "carry out Discussing it with rulebook" ! 508
    "report Discussing it with rulebook" ! 509
    "check Discussing rulebook" ! 510
    "carry out Discussing rulebook" ! 511
    "report Discussing rulebook" ! 512
    "before Queueing quips following rulebook" ! 513
    "for Queueing quips following rulebook" ! 514
    "after Queueing quips following rulebook" ! 515
    "before Ruling out quips following rulebook" ! 516
    "for Ruling out quips following rulebook" ! 517
    "after Ruling out quips following rulebook" ! 518
    "availability rulebook" ! 519
    "plausibility rulebook" ! 520
    "before Listing the available quips rulebook" ! 521
    "for Listing the available quips rulebook" ! 522
    "after Listing the available quips rulebook" ! 523
    "check frumping rulebook" ! 524
    "carry out frumping rulebook" ! 525
    "report frumping rulebook" ! 526
    "check helping about hyperspace rulebook" ! 527
    "carry out helping about hyperspace rulebook" ! 528
    "report helping about hyperspace rulebook" ! 529
    "glulx timed activity rulebook" ! 530
    "glulx redrawing rulebook" ! 531
    "glulx arranging rulebook" ! 532
    "glulx sound notification rulebook" ! 533
    "glulx mouse input rulebook" ! 534
    "glulx character input rulebook" ! 535
    "glulx line input rulebook" ! 536
    "glulx hyperlink rulebook" ! 537
    "glulx zeroing-reference rulebook" ! 538
    "glulx resetting-windows rulebook" ! 539
    "glulx resetting-streams rulebook" ! 540
    "glulx resetting-filerefs rulebook" ! 541
    "glulx object-updating rulebook" ! 542
    "glulx input handling rulebook" ! 543
    "command-counting rulebook" ! 544
    "input-cancelling rulebook" ! 545
    "command-showing rulebook" ! 546
    "command-pasting rulebook" ! 547
    "glulx picture selection rulebook" ! 548
    "window resizing rulebook" ! 549
    "can't unlock without a lock description rulebook" ! 550
    "can't unlock already unlocked description rulebook" ! 551
    "check Swiping it through rulebook" ! 552
    "carry out Swiping it through rulebook" ! 553
    "report Swiping it through rulebook" ! 554
    "check moving it with rulebook" ! 555
    "carry out moving it with rulebook" ! 556
    "report moving it with rulebook" ! 557
    "check howdeedoing rulebook" ! 558
    "carry out howdeedoing rulebook" ! 559
    "report howdeedoing rulebook" ! 560
    "check howdeedoing-someone rulebook" ! 561
    "carry out howdeedoing-someone rulebook" ! 562
    "report howdeedoing-someone rulebook" ! 563
    "check Knocking on rulebook" ! 564
    "carry out Knocking on rulebook" ! 565
    "report Knocking on rulebook" ! 566
    "when Klimp in-the-office begins rulebook" ! 567
    "when Klimp in-the-office ends rulebook" ! 568
    "when Moira in-the-office begins rulebook" ! 569
    "when Moira in-the-office ends rulebook" ! 570
    "when Denouement begins rulebook" ! 571
    "when Denouement ends rulebook" ! 572
    "check lensing rulebook" ! 573
    "carry out lensing rulebook" ! 574
    "report lensing rulebook" ! 575
;


#ENDIF; ! MEMORY_ECONOMY

[ RulePrintingRule R p1;
#ifndef MEMORY_ECONOMY;
	if ((R>=0) && (R<NUMBER_RULEBOOKS_CREATED)) {
		print (string) (RulebookNames-->R);
	} else {
        if (R == R_9) { print "declare everything initially unmentioned rule"; rtrue; } ! rule 0
        if (R == R_10) { print "start in the correct scenes rule"; rtrue; } ! rule 1
        if (R == R_11) { print "when play begins stage rule"; rtrue; } ! rule 2
        if (R == R_12) { print "fix baseline scoring rule"; rtrue; } ! rule 3
        if (R == R_13) { print "display banner rule"; rtrue; } ! rule 4
        if (R == R_14) { print "initial room description rule"; rtrue; } ! rule 5
        if (R == R_15) { print "every turn stage rule"; rtrue; } ! rule 6
        if (R == R_18) { print "notify score changes rule"; rtrue; } ! rule 7
        if (R == R_19) { print "when play ends stage rule"; rtrue; } ! rule 8
        if (R == R_20) { print "print player's obituary rule"; rtrue; } ! rule 9
        if (R == R_21) { print "set pronouns from items from multiple object lists rule"; rtrue; } ! rule 10
        if (R == R_22) { print "announce items from multiple object lists rule"; rtrue; } ! rule 11
        if (R == R_23) { print "before stage rule"; rtrue; } ! rule 12
        if (R == R_24) { print "instead stage rule"; rtrue; } ! rule 13
        if (R == R_25) { print "end action-processing in success rule"; rtrue; } ! rule 14
        if (R == R_26) { print "investigate player's awareness before action rule"; rtrue; } ! rule 15
        if (R == R_27) { print "check stage rule"; rtrue; } ! rule 16
        if (R == R_28) { print "carry out stage rule"; rtrue; } ! rule 17
        if (R == R_29) { print "after stage rule"; rtrue; } ! rule 18
        if (R == R_30) { print "investigate player's awareness after action rule"; rtrue; } ! rule 19
        if (R == R_31) { print "report stage rule"; rtrue; } ! rule 20
        if (R == R_33) { print "player aware of his own actions rule"; rtrue; } ! rule 21
        if (R == R_34) { print "player aware of actions by visible actors rule"; rtrue; } ! rule 22
        if (R == R_35) { print "player aware of actions on visible nouns rule"; rtrue; } ! rule 23
        if (R == R_36) { print "player aware of actions on visible second nouns rule"; rtrue; } ! rule 24
        if (R == R_37) { print "can't act in the dark rule"; rtrue; } ! rule 25
        if (R == R_38) { print "very unlikely to mean taking what's already carried rule"; rtrue; } ! rule 26
        if (R == R_65) { print "scene description text rule"; rtrue; } ! rule 27
        if (R == R_66) { print "make named things mentioned rule"; rtrue; } ! rule 28
        if (R == R_67) { print "standard printing the plural name rule"; rtrue; } ! rule 29
        if (R == R_68) { print "standard printing a number of something rule"; rtrue; } ! rule 30
        if (R == R_69) { print "look around once light available rule"; rtrue; } ! rule 31
        if (R == R_70) { print "exclude scenery from take all rule"; rtrue; } ! rule 32
        if (R == R_71) { print "exclude people from take all rule"; rtrue; } ! rule 33
        if (R == R_72) { print "exclude fixed in place things from take all rule"; rtrue; } ! rule 34
        if (R == R_73) { print "exclude indirect possessions from take all rule"; rtrue; } ! rule 35
        if (R == R_74) { print "exclude people from drop all rule"; rtrue; } ! rule 36
        if (R == R_75) { print "block vaguely going rule"; rtrue; } ! rule 37
        if (R == R_76) { print "print the final prompt rule"; rtrue; } ! rule 38
        if (R == R_77) { print "print the final question rule"; rtrue; } ! rule 39
        if (R == R_78) { print "standard respond to final question rule"; rtrue; } ! rule 40
        if (R == R_81) { print "initialise locale description rule"; rtrue; } ! rule 41
        if (R == R_82) { print "find notable locale objects rule"; rtrue; } ! rule 42
        if (R == R_83) { print "interesting locale paragraphs rule"; rtrue; } ! rule 43
        if (R == R_84) { print "you-can-also-see rule"; rtrue; } ! rule 44
        if (R == R_85) { print "standard notable locale objects rule"; rtrue; } ! rule 45
        if (R == R_86) { print "don't mention player's supporter in room descriptions rule"; rtrue; } ! rule 46
        if (R == R_87) { print "don't mention scenery in room descriptions rule"; rtrue; } ! rule 47
        if (R == R_88) { print "don't mention undescribed items in room descriptions rule"; rtrue; } ! rule 48
        if (R == R_89) { print "set pronouns from items in room descriptions rule"; rtrue; } ! rule 49
        if (R == R_90) { print "offer items to writing a paragraph about rule"; rtrue; } ! rule 50
        if (R == R_91) { print "use initial appearance in room descriptions rule"; rtrue; } ! rule 51
        if (R == R_92) { print "initial appearance on supporters rule"; rtrue; } ! rule 52
        if (R == R_94) { print "describe what's on scenery supporters in room descriptions rule"; rtrue; } ! rule 53
        if (R == R_95) { print "describe what's on mentioned supporters in room descriptions rule"; rtrue; } ! rule 54
        if (R == R_96) { print "print empty inventory rule"; rtrue; } ! rule 55
        if (R == R_97) { print "print standard inventory rule"; rtrue; } ! rule 56
        if (R == R_98) { print "report other people taking inventory rule"; rtrue; } ! rule 57
        if (R == R_99) { print "can't take yourself rule"; rtrue; } ! rule 58
        if (R == R_100) { print "can't take other people rule"; rtrue; } ! rule 59
        if (R == R_101) { print "can't take component parts rule"; rtrue; } ! rule 60
        if (R == R_102) { print "can't take people's possessions rule"; rtrue; } ! rule 61
        if (R == R_103) { print "can't take items out of play rule"; rtrue; } ! rule 62
        if (R == R_104) { print "can't take what you're inside rule"; rtrue; } ! rule 63
        if (R == R_105) { print "can't take what's already taken rule"; rtrue; } ! rule 64
        if (R == R_106) { print "can't take scenery rule"; rtrue; } ! rule 65
        if (R == R_107) { print "can only take things rule"; rtrue; } ! rule 66
        if (R == R_108) { print "can't take what's fixed in place rule"; rtrue; } ! rule 67
        if (R == R_109) { print "use player's holdall to avoid exceeding carrying capacity rule"; rtrue; } ! rule 68
        if (R == R_110) { print "can't exceed carrying capacity rule"; rtrue; } ! rule 69
        if (R == R_111) { print "standard taking rule"; rtrue; } ! rule 70
        if (R == R_112) { print "standard report taking rule"; rtrue; } ! rule 71
        if (R == R_113) { print "can't remove what's not inside rule"; rtrue; } ! rule 72
        if (R == R_114) { print "can't remove from people rule"; rtrue; } ! rule 73
        if (R == R_115) { print "convert remove to take rule"; rtrue; } ! rule 74
        if (R == R_116) { print "can't drop yourself rule"; rtrue; } ! rule 75
        if (R == R_117) { print "can't drop body parts rule"; rtrue; } ! rule 76
        if (R == R_118) { print "can't drop what's already dropped rule"; rtrue; } ! rule 77
        if (R == R_119) { print "can't drop what's not held rule"; rtrue; } ! rule 78
        if (R == R_120) { print "can't drop clothes being worn rule"; rtrue; } ! rule 79
        if (R == R_121) { print "can't drop if this exceeds carrying capacity rule"; rtrue; } ! rule 80
        if (R == R_122) { print "standard dropping rule"; rtrue; } ! rule 81
        if (R == R_123) { print "standard report dropping rule"; rtrue; } ! rule 82
        if (R == R_124) { print "convert put to drop where possible rule"; rtrue; } ! rule 83
        if (R == R_125) { print "can't put what's not held rule"; rtrue; } ! rule 84
        if (R == R_126) { print "can't put something on itself rule"; rtrue; } ! rule 85
        if (R == R_127) { print "can't put onto what's not a supporter rule"; rtrue; } ! rule 86
        if (R == R_128) { print "can't put clothes being worn rule"; rtrue; } ! rule 87
        if (R == R_129) { print "can't put if this exceeds carrying capacity rule"; rtrue; } ! rule 88
        if (R == R_130) { print "standard putting rule"; rtrue; } ! rule 89
        if (R == R_131) { print "concise report putting rule"; rtrue; } ! rule 90
        if (R == R_132) { print "standard report putting rule"; rtrue; } ! rule 91
        if (R == R_133) { print "convert insert to drop where possible rule"; rtrue; } ! rule 92
        if (R == R_134) { print "can't insert what's not held rule"; rtrue; } ! rule 93
        if (R == R_135) { print "can't insert something into itself rule"; rtrue; } ! rule 94
        if (R == R_136) { print "can't insert into closed containers rule"; rtrue; } ! rule 95
        if (R == R_137) { print "can't insert into what's not a container rule"; rtrue; } ! rule 96
        if (R == R_138) { print "can't insert clothes being worn rule"; rtrue; } ! rule 97
        if (R == R_139) { print "can't insert if this exceeds carrying capacity rule"; rtrue; } ! rule 98
        if (R == R_140) { print "standard inserting rule"; rtrue; } ! rule 99
        if (R == R_141) { print "concise report inserting rule"; rtrue; } ! rule 100
        if (R == R_142) { print "standard report inserting rule"; rtrue; } ! rule 101
        if (R == R_143) { print "can't eat unless edible rule"; rtrue; } ! rule 102
        if (R == R_144) { print "can't eat clothing without removing it first rule"; rtrue; } ! rule 103
        if (R == R_145) { print "can't eat other people's food rule"; rtrue; } ! rule 104
        if (R == R_146) { print "can't eat portable food without carrying it rule"; rtrue; } ! rule 105
        if (R == R_147) { print "standard eating rule"; rtrue; } ! rule 106
        if (R == R_148) { print "standard report eating rule"; rtrue; } ! rule 107
        if (R == R_149) { print "standard set going variables rule"; rtrue; } ! rule 108
        if (R == R_150) { print "stand up before going rule"; rtrue; } ! rule 109
        if (R == R_151) { print "can't travel in what's not a vehicle rule"; rtrue; } ! rule 110
        if (R == R_152) { print "can't go through undescribed doors rule"; rtrue; } ! rule 111
        if (R == R_153) { print "can't go through closed doors rule"; rtrue; } ! rule 112
        if (R == R_154) { print "determine map connection rule"; rtrue; } ! rule 113
        if (R == R_155) { print "can't go that way rule"; rtrue; } ! rule 114
        if (R == R_156) { print "move player and vehicle rule"; rtrue; } ! rule 115
        if (R == R_157) { print "move floating objects rule"; rtrue; } ! rule 116
        if (R == R_158) { print "check light in new location rule"; rtrue; } ! rule 117
        if (R == R_159) { print "describe room gone into rule"; rtrue; } ! rule 118
        if (R == R_160) { print "find what to enter rule"; rtrue; } ! rule 119
        if (R == R_161) { print "convert enter door into go rule"; rtrue; } ! rule 120
        if (R == R_162) { print "convert enter compass direction into go rule"; rtrue; } ! rule 121
        if (R == R_163) { print "can't enter what's already entered rule"; rtrue; } ! rule 122
        if (R == R_164) { print "can't enter what's not enterable rule"; rtrue; } ! rule 123
        if (R == R_165) { print "can't enter closed containers rule"; rtrue; } ! rule 124
        if (R == R_166) { print "can't enter if this exceeds carrying capacity rule"; rtrue; } ! rule 125
        if (R == R_167) { print "can't enter something carried rule"; rtrue; } ! rule 126
        if (R == R_168) { print "implicitly pass through other barriers rule"; rtrue; } ! rule 127
        if (R == R_169) { print "standard entering rule"; rtrue; } ! rule 128
        if (R == R_170) { print "standard report entering rule"; rtrue; } ! rule 129
        if (R == R_171) { print "describe contents entered into rule"; rtrue; } ! rule 130
        if (R == R_173) { print "convert exit into go out rule"; rtrue; } ! rule 131
        if (R == R_174) { print "can't exit when not inside anything rule"; rtrue; } ! rule 132
        if (R == R_175) { print "can't exit closed containers rule"; rtrue; } ! rule 133
        if (R == R_176) { print "convert exit into get off rule"; rtrue; } ! rule 134
        if (R == R_177) { print "standard exiting rule"; rtrue; } ! rule 135
        if (R == R_178) { print "standard report exiting rule"; rtrue; } ! rule 136
        if (R == R_179) { print "describe room emerged into rule"; rtrue; } ! rule 137
        if (R == R_180) { print "can't get off things rule"; rtrue; } ! rule 138
        if (R == R_181) { print "standard getting off rule"; rtrue; } ! rule 139
        if (R == R_182) { print "standard report getting off rule"; rtrue; } ! rule 140
        if (R == R_183) { print "describe room stood up into rule"; rtrue; } ! rule 141
        if (R == R_184) { print "determine visibility ceiling rule"; rtrue; } ! rule 142
        if (R == R_185) { print "declare everything unmentioned rule"; rtrue; } ! rule 143
        if (R == R_186) { print "room description heading rule"; rtrue; } ! rule 144
        if (R == R_187) { print "room description body text rule"; rtrue; } ! rule 145
        if (R == R_188) { print "room description paragraphs about objects rule"; rtrue; } ! rule 146
        if (R == R_189) { print "check new arrival rule"; rtrue; } ! rule 147
        if (R == R_190) { print "other people looking rule"; rtrue; } ! rule 148
        if (R == R_191) { print "standard examining rule"; rtrue; } ! rule 149
        if (R == R_192) { print "examine directions rule"; rtrue; } ! rule 150
        if (R == R_193) { print "examine containers rule"; rtrue; } ! rule 151
        if (R == R_194) { print "examine supporters rule"; rtrue; } ! rule 152
        if (R == R_195) { print "examine devices rule"; rtrue; } ! rule 153
        if (R == R_196) { print "examine undescribed things rule"; rtrue; } ! rule 154
        if (R == R_197) { print "report other people examining rule"; rtrue; } ! rule 155
        if (R == R_198) { print "standard looking under rule"; rtrue; } ! rule 156
        if (R == R_199) { print "report other people looking under rule"; rtrue; } ! rule 157
        if (R == R_200) { print "can't search unless container or supporter rule"; rtrue; } ! rule 158
        if (R == R_201) { print "can't search closed opaque containers rule"; rtrue; } ! rule 159
        if (R == R_202) { print "standard search containers rule"; rtrue; } ! rule 160
        if (R == R_203) { print "standard search supporters rule"; rtrue; } ! rule 161
        if (R == R_204) { print "report other people searching rule"; rtrue; } ! rule 162
        if (R == R_205) { print "block consulting rule"; rtrue; } ! rule 163
        if (R == R_206) { print "can't lock without a lock rule"; rtrue; } ! rule 164
        if (R == R_207) { print "can't lock what's already locked rule"; rtrue; } ! rule 165
        if (R == R_208) { print "can't lock what's open rule"; rtrue; } ! rule 166
        if (R == R_209) { print "can't lock without the correct key rule"; rtrue; } ! rule 167
        if (R == R_210) { print "standard locking rule"; rtrue; } ! rule 168
        if (R == R_211) { print "standard report locking rule"; rtrue; } ! rule 169
        if (R == R_212) { print "can't unlock without a lock rule"; rtrue; } ! rule 170
        if (R == R_213) { print "can't unlock what's already unlocked rule"; rtrue; } ! rule 171
        if (R == R_214) { print "can't unlock without the correct key rule"; rtrue; } ! rule 172
        if (R == R_215) { print "standard unlocking rule"; rtrue; } ! rule 173
        if (R == R_216) { print "standard report unlocking rule"; rtrue; } ! rule 174
        if (R == R_217) { print "can't switch on unless switchable rule"; rtrue; } ! rule 175
        if (R == R_218) { print "can't switch on what's already on rule"; rtrue; } ! rule 176
        if (R == R_219) { print "standard switching on rule"; rtrue; } ! rule 177
        if (R == R_220) { print "standard report switching on rule"; rtrue; } ! rule 178
        if (R == R_221) { print "can't switch off unless switchable rule"; rtrue; } ! rule 179
        if (R == R_222) { print "can't switch off what's already off rule"; rtrue; } ! rule 180
        if (R == R_223) { print "standard switching off rule"; rtrue; } ! rule 181
        if (R == R_224) { print "standard report switching off rule"; rtrue; } ! rule 182
        if (R == R_225) { print "can't open unless openable rule"; rtrue; } ! rule 183
        if (R == R_226) { print "can't open what's locked rule"; rtrue; } ! rule 184
        if (R == R_227) { print "can't open what's already open rule"; rtrue; } ! rule 185
        if (R == R_228) { print "standard opening rule"; rtrue; } ! rule 186
        if (R == R_229) { print "reveal any newly visible interior rule"; rtrue; } ! rule 187
        if (R == R_230) { print "standard report opening rule"; rtrue; } ! rule 188
        if (R == R_231) { print "can't close unless openable rule"; rtrue; } ! rule 189
        if (R == R_232) { print "can't close what's already closed rule"; rtrue; } ! rule 190
        if (R == R_233) { print "standard closing rule"; rtrue; } ! rule 191
        if (R == R_234) { print "standard report closing rule"; rtrue; } ! rule 192
        if (R == R_235) { print "can't wear what's not clothing rule"; rtrue; } ! rule 193
        if (R == R_236) { print "can't wear what's not held rule"; rtrue; } ! rule 194
        if (R == R_237) { print "can't wear what's already worn rule"; rtrue; } ! rule 195
        if (R == R_238) { print "standard wearing rule"; rtrue; } ! rule 196
        if (R == R_239) { print "standard report wearing rule"; rtrue; } ! rule 197
        if (R == R_241) { print "can't take off what's not worn rule"; rtrue; } ! rule 198
        if (R == R_242) { print "can't exceed carrying capacity when taking off rule"; rtrue; } ! rule 199
        if (R == R_243) { print "standard taking off rule"; rtrue; } ! rule 200
        if (R == R_244) { print "standard report taking off rule"; rtrue; } ! rule 201
        if (R == R_245) { print "can't give what you haven't got rule"; rtrue; } ! rule 202
        if (R == R_246) { print "can't give to yourself rule"; rtrue; } ! rule 203
        if (R == R_247) { print "can't give to a non-person rule"; rtrue; } ! rule 204
        if (R == R_248) { print "can't give clothes being worn rule"; rtrue; } ! rule 205
        if (R == R_249) { print "block giving rule"; rtrue; } ! rule 206
        if (R == R_250) { print "can't exceed carrying capacity when giving rule"; rtrue; } ! rule 207
        if (R == R_251) { print "standard giving rule"; rtrue; } ! rule 208
        if (R == R_252) { print "standard report giving rule"; rtrue; } ! rule 209
        if (R == R_253) { print "can't show what you haven't got rule"; rtrue; } ! rule 210
        if (R == R_254) { print "convert show to yourself to examine rule"; rtrue; } ! rule 211
        if (R == R_255) { print "block showing rule"; rtrue; } ! rule 212
        if (R == R_256) { print "block waking rule"; rtrue; } ! rule 213
        if (R == R_257) { print "implicitly remove thrown clothing rule"; rtrue; } ! rule 214
        if (R == R_258) { print "futile to throw things at inanimate objects rule"; rtrue; } ! rule 215
        if (R == R_259) { print "block throwing at rule"; rtrue; } ! rule 216
        if (R == R_260) { print "block attacking rule"; rtrue; } ! rule 217
        if (R == R_261) { print "kissing yourself rule"; rtrue; } ! rule 218
        if (R == R_262) { print "block kissing rule"; rtrue; } ! rule 219
        if (R == R_263) { print "block answering rule"; rtrue; } ! rule 220
        if (R == R_264) { print "telling yourself rule"; rtrue; } ! rule 221
        if (R == R_265) { print "block telling rule"; rtrue; } ! rule 222
        if (R == R_266) { print "block asking rule"; rtrue; } ! rule 223
        if (R == R_267) { print "asking yourself for something rule"; rtrue; } ! rule 224
        if (R == R_268) { print "translate asking for to giving rule"; rtrue; } ! rule 225
        if (R == R_269) { print "standard report waiting rule"; rtrue; } ! rule 226
        if (R == R_270) { print "report touching yourself rule"; rtrue; } ! rule 227
        if (R == R_271) { print "report touching other people rule"; rtrue; } ! rule 228
        if (R == R_272) { print "report touching things rule"; rtrue; } ! rule 229
        if (R == R_273) { print "can't wave what's not held rule"; rtrue; } ! rule 230
        if (R == R_274) { print "report waving things rule"; rtrue; } ! rule 231
        if (R == R_275) { print "can't pull what's fixed in place rule"; rtrue; } ! rule 232
        if (R == R_276) { print "can't pull scenery rule"; rtrue; } ! rule 233
        if (R == R_277) { print "can't pull people rule"; rtrue; } ! rule 234
        if (R == R_278) { print "report pulling rule"; rtrue; } ! rule 235
        if (R == R_279) { print "can't push what's fixed in place rule"; rtrue; } ! rule 236
        if (R == R_280) { print "can't push scenery rule"; rtrue; } ! rule 237
        if (R == R_281) { print "can't push people rule"; rtrue; } ! rule 238
        if (R == R_282) { print "report pushing rule"; rtrue; } ! rule 239
        if (R == R_283) { print "can't turn what's fixed in place rule"; rtrue; } ! rule 240
        if (R == R_284) { print "can't turn scenery rule"; rtrue; } ! rule 241
        if (R == R_285) { print "can't turn people rule"; rtrue; } ! rule 242
        if (R == R_286) { print "report turning rule"; rtrue; } ! rule 243
        if (R == R_287) { print "can't push unpushable things rule"; rtrue; } ! rule 244
        if (R == R_288) { print "can't push to non-directions rule"; rtrue; } ! rule 245
        if (R == R_289) { print "can't push vertically rule"; rtrue; } ! rule 246
        if (R == R_290) { print "can't push from within rule"; rtrue; } ! rule 247
        if (R == R_291) { print "standard pushing in directions rule"; rtrue; } ! rule 248
        if (R == R_292) { print "block pushing in directions rule"; rtrue; } ! rule 249
        if (R == R_293) { print "innuendo about squeezing people rule"; rtrue; } ! rule 250
        if (R == R_294) { print "report squeezing rule"; rtrue; } ! rule 251
        if (R == R_295) { print "block saying yes rule"; rtrue; } ! rule 252
        if (R == R_296) { print "block saying no rule"; rtrue; } ! rule 253
        if (R == R_297) { print "block cutting rule"; rtrue; } ! rule 254
        if (R == R_298) { print "block saying sorry rule"; rtrue; } ! rule 255
        if (R == R_299) { print "can't rub another person rule"; rtrue; } ! rule 256
        if (R == R_300) { print "report rubbing rule"; rtrue; } ! rule 257
        if (R == R_301) { print "block buying rule"; rtrue; } ! rule 258
        if (R == R_753) { print "clear LPR rule"; rtrue; } ! rule 259
        if (R == R_797) { print "mark items as seen when looking rule"; rtrue; } ! rule 260
        if (R == R_798) { print "mark items as seen on opening a container rule"; rtrue; } ! rule 261
        if (R == R_799) { print "mark items as seen on examining rule"; rtrue; } ! rule 262
        if (R == R_802) { print "report epistemic status rule"; rtrue; } ! rule 263
        if (R == R_803) { print "block informing rule"; rtrue; } ! rule 264
        if (R == R_804) { print "block quizzing rule"; rtrue; } ! rule 265
        if (R == R_805) { print "asking a woman about herself rule"; rtrue; } ! rule 266
        if (R == R_806) { print "asking a man about himself rule"; rtrue; } ! rule 267
        if (R == R_807) { print "implicit-conversing needs current interlocutor rule"; rtrue; } ! rule 268
        if (R == R_808) { print "can't converse with absent interlocutor rule"; rtrue; } ! rule 269
        if (R == R_815) { print "greet a new interlocutor rule"; rtrue; } ! rule 270
        if (R == R_816) { print "showing needs an interlocutor rule"; rtrue; } ! rule 271
        if (R == R_817) { print "giving needs an interlocutor rule"; rtrue; } ! rule 272
        if (R == R_818) { print "giving orders needs an interlocutor rule"; rtrue; } ! rule 273
        if (R == R_820) { print "can't greet current interlocutor rule"; rtrue; } ! rule 274
        if (R == R_821) { print "can't greet yourself rule"; rtrue; } ! rule 275
        if (R == R_822) { print "note current interlocutor when greeted rule"; rtrue; } ! rule 276
        if (R == R_823) { print "can't greet inanimate objects rule"; rtrue; } ! rule 277
        if (R == R_824) { print "default greeting rule"; rtrue; } ! rule 278
        if (R == R_825) { print "change greeting command to greeting rule"; rtrue; } ! rule 279
        if (R == R_826) { print "check what's being hailed rule"; rtrue; } ! rule 280
        if (R == R_827) { print "standard hailing rule"; rtrue; } ! rule 281
        if (R == R_828) { print "allow hailing rule"; rtrue; } ! rule 282
        if (R == R_831) { print "can't say goodbye to someone you're not talking to rule"; rtrue; } ! rule 283
        if (R == R_832) { print "reset interlocutor on saying goodbye rule"; rtrue; } ! rule 284
        if (R == R_833) { print "don't allow saying goodbye to no-one rule"; rtrue; } ! rule 285
        if (R == R_834) { print "standard leavetaking rule"; rtrue; } ! rule 286
        if (R == R_835) { print "alllow leavetaking rule"; rtrue; } ! rule 287
        if (R == R_836) { print "convert npc leavetaking to player leavetaking rule"; rtrue; } ! rule 288
        if (R == R_837) { print "default saying goodbye rule"; rtrue; } ! rule 289
        if (R == R_838) { print "say goodbye when moving rule"; rtrue; } ! rule 290
        if (R == R_839) { print "reset protocol rule"; rtrue; } ! rule 291
        if (R == R_840) { print "greet before saying yes rule"; rtrue; } ! rule 292
        if (R == R_841) { print "greet before saying no rule"; rtrue; } ! rule 293
        if (R == R_842) { print "greet before saying sorry rule"; rtrue; } ! rule 294
        if (R == R_843) { print "change answering yes to saying yes rule"; rtrue; } ! rule 295
        if (R == R_844) { print "change answering no to saying no rule"; rtrue; } ! rule 296
        if (R == R_845) { print "change answering sorry to saying sorry rule"; rtrue; } ! rule 297
        if (R == R_846) { print "block asking about something unknown rule"; rtrue; } ! rule 298
        if (R == R_847) { print "block telling about something unknown rule"; rtrue; } ! rule 299
        if (R == R_869) { print "standard response rule"; rtrue; } ! rule 300
        if (R == R_870) { print "standard report farewell rule"; rtrue; } ! rule 301
        if (R == R_871) { print "standard report greeting rule"; rtrue; } ! rule 302
        if (R == R_872) { print "unresponsive rule"; rtrue; } ! rule 303
        if (R == R_873) { print "try default tell response rule"; rtrue; } ! rule 304
        if (R == R_874) { print "try default ask-tell response rule"; rtrue; } ! rule 305
        if (R == R_875) { print "try default give-show response rule"; rtrue; } ! rule 306
        if (R == R_876) { print "try default response rule"; rtrue; } ! rule 307
        if (R == R_877) { print "default asking rule"; rtrue; } ! rule 308
        if (R == R_878) { print "default quizzing rule"; rtrue; } ! rule 309
        if (R == R_879) { print "default telling rule"; rtrue; } ! rule 310
        if (R == R_880) { print "default informing rule"; rtrue; } ! rule 311
        if (R == R_881) { print "default answering rule"; rtrue; } ! rule 312
        if (R == R_882) { print "default giving rule"; rtrue; } ! rule 313
        if (R == R_883) { print "default showing rule"; rtrue; } ! rule 314
        if (R == R_884) { print "default requesting rule"; rtrue; } ! rule 315
        if (R == R_885) { print "default imploring rule"; rtrue; } ! rule 316
        if (R == R_886) { print "default yes rule"; rtrue; } ! rule 317
        if (R == R_887) { print "default no rule"; rtrue; } ! rule 318
        if (R == R_888) { print "default sorry rule"; rtrue; } ! rule 319
        if (R == R_895) { print "standard pausing the game rule"; rtrue; } ! rule 320
        if (R == R_914) { print "sort the Table of User Styles rule"; rtrue; } ! rule 321
        if (R == R_915) { print "set text styles rule"; rtrue; } ! rule 322
        if (R == R_973) { print "broadcast spoken facts rule"; rtrue; } ! rule 323
        if (R == R_974) { print "player learns facts rule"; rtrue; } ! rule 324
        if (R == R_975) { print "silence actual output of facts rule"; rtrue; } ! rule 325
        if (R == R_980) { print "default noisiness rule"; rtrue; } ! rule 326
        if (R == R_983) { print "make sure hearing works before the first turn rule"; rtrue; } ! rule 327
        if (R == R_992) { print "default sound description rule"; rtrue; } ! rule 328
        if (R == R_1000) { print "phone noisiness rule"; rtrue; } ! rule 329
        if (R == R_1010) { print "check actor answering phone rule"; rtrue; } ! rule 330
        if (R == R_1016) { print "report picking up the phone rule"; rtrue; } ! rule 331
        if (R == R_1017) { print "can't touch through the phone rule"; rtrue; } ! rule 332
        if (R == R_1018) { print "place callee in scope rule"; rtrue; } ! rule 333
        if (R == R_1029) { print "long-distance speaking rule"; rtrue; } ! rule 334
        if (R == R_1042) { print "new room description heading rule"; rtrue; } ! rule 335
        if (R == R_1043) { print "new you-can-also-see rule"; rtrue; } ! rule 336
        if (R == R_1045) { print "run behavior rule"; rtrue; } ! rule 337
        if (R == R_1055) { print "place the room in scope while looking rule"; rtrue; } ! rule 338
        if (R == R_1062) { print "standard wall description rule"; rtrue; } ! rule 339
        if (R == R_1064) { print "standard examine wall rule"; rtrue; } ! rule 340
        if (R == R_1065) { print "standard wall touch description rule"; rtrue; } ! rule 341
        if (R == R_1067) { print "standard touch walls rule"; rtrue; } ! rule 342
        if (R == R_1068) { print "standard check rubbing the walls rule"; rtrue; } ! rule 343
        if (R == R_1069) { print "block attacking the walls rule"; rtrue; } ! rule 344
        if (R == R_1070) { print "block attacking no walls rule"; rtrue; } ! rule 345
        if (R == R_1071) { print "block cutting the walls rule"; rtrue; } ! rule 346
        if (R == R_1072) { print "block cutting no walls rule"; rtrue; } ! rule 347
        if (R == R_1073) { print "block taking non-existent walls rule"; rtrue; } ! rule 348
        if (R == R_1076) { print "standard floor description rule"; rtrue; } ! rule 349
        if (R == R_1078) { print "standard examine floor rule"; rtrue; } ! rule 350
        if (R == R_1079) { print "standard floor touch description rule"; rtrue; } ! rule 351
        if (R == R_1081) { print "standard touch floor rule"; rtrue; } ! rule 352
        if (R == R_1082) { print "standard check rubbing the floor rule"; rtrue; } ! rule 353
        if (R == R_1083) { print "block attacking the Floor rule"; rtrue; } ! rule 354
        if (R == R_1084) { print "block cutting the Floor rule"; rtrue; } ! rule 355
        if (R == R_1085) { print "block taking non-existent floor rule"; rtrue; } ! rule 356
        if (R == R_1086) { print "standard looking down rule"; rtrue; } ! rule 357
        if (R == R_1091) { print "standard ceiling description rule"; rtrue; } ! rule 358
        if (R == R_1093) { print "standard examine ceiling rule"; rtrue; } ! rule 359
        if (R == R_1094) { print "standard ceiling touch description rule"; rtrue; } ! rule 360
        if (R == R_1096) { print "standard touch ceiling rule"; rtrue; } ! rule 361
        if (R == R_1097) { print "standard check rubbing the ceiling rule"; rtrue; } ! rule 362
        if (R == R_1098) { print "block attacking the Ceiling rule"; rtrue; } ! rule 363
        if (R == R_1099) { print "block attacking no ceiling rule"; rtrue; } ! rule 364
        if (R == R_1100) { print "block cutting the Ceiling rule"; rtrue; } ! rule 365
        if (R == R_1101) { print "block cutting no Ceiling rule"; rtrue; } ! rule 366
        if (R == R_1102) { print "block taking non-existent ceiling rule"; rtrue; } ! rule 367
        if (R == R_1103) { print "standard looking up rule"; rtrue; } ! rule 368
        if (R == R_1104) { print "standard excuse text rule"; rtrue; } ! rule 369
        if (R == R_1107) { print "new can't exit when not inside anything rule"; rtrue; } ! rule 370
        if (R == R_1108) { print "standard can't take that rule"; rtrue; } ! rule 371
        if (R == R_1110) { print "standard can't move that rule"; rtrue; } ! rule 372
        if (R == R_1134) { print "standard delimiting rule"; rtrue; } ! rule 373
        if (R == R_1136) { print "default door appearance rule"; rtrue; } ! rule 374
        if (R == R_1138) { print "default room appearance rule"; rtrue; } ! rule 375
        if (R == R_1139) { print "hyperspace appearance rule"; rtrue; } ! rule 376
        if (R == R_1142) { print "exit lister status line rule"; rtrue; } ! rule 377
        if (R == R_1146) { print "standard Exit Stopping rule"; rtrue; } ! rule 378
        if (R == R_1147) { print "report exit stopping rule"; rtrue; } ! rule 379
        if (R == R_1148) { print "standard Exit Starting rule"; rtrue; } ! rule 380
        if (R == R_1149) { print "report exit starting rule"; rtrue; } ! rule 381
        if (R == R_1150) { print "standard carry out exit listing rule"; rtrue; } ! rule 382
        if (R == R_1158) { print "explain exit listing rule"; rtrue; } ! rule 383
        if (R == R_1160) { print "standard exit symboling rule"; rtrue; } ! rule 384
        if (R == R_1162) { print "standard exit colouring rule"; rtrue; } ! rule 385
        if (R == R_1166) { print "options paragraph stage rule"; rtrue; } ! rule 386
        if (R == R_1199) { print "quip scope handling rule"; rtrue; } ! rule 387
        if (R == R_1201) { print "clear current interlocutor on going rule"; rtrue; } ! rule 388
        if (R == R_1203) { print "block exhausted one-shot quips rule"; rtrue; } ! rule 389
        if (R == R_1206) { print "queue quips rule"; rtrue; } ! rule 390
        if (R == R_1210) { print "ruling out quips rule"; rtrue; } ! rule 391
        if (R == R_1217) { print "exhausted quip availability rule"; rtrue; } ! rule 392
        if (R == R_1218) { print "universal availability rule"; rtrue; } ! rule 393
        if (R == R_1219) { print "can't talk to the wrong person rule"; rtrue; } ! rule 394
        if (R == R_1220) { print "always-available rule"; rtrue; } ! rule 395
        if (R == R_1221) { print "queued quip rule"; rtrue; } ! rule 396
        if (R == R_1222) { print "basic availability rule"; rtrue; } ! rule 397
        if (R == R_1224) { print "ignoreability rule"; rtrue; } ! rule 398
        if (R == R_1225) { print "ubiquity rule"; rtrue; } ! rule 399
        if (R == R_1226) { print "basic plausibility rule"; rtrue; } ! rule 400
        if (R == R_1230) { print "display available quips rule"; rtrue; } ! rule 401
        if (R == R_1243) { print "room description astral passages rule"; rtrue; } ! rule 402
        if (R == R_1294) { print "redirect to GEP timed activity rule"; rtrue; } ! rule 403
        if (R == R_1295) { print "redirect to GEP character input rule"; rtrue; } ! rule 404
        if (R == R_1296) { print "redirect to GEP line input rule"; rtrue; } ! rule 405
        if (R == R_1297) { print "redirect to GEP mouse input rule"; rtrue; } ! rule 406
        if (R == R_1298) { print "redirect to GEP arranging rule"; rtrue; } ! rule 407
        if (R == R_1299) { print "redirect to GEP redrawing rule"; rtrue; } ! rule 408
        if (R == R_1300) { print "redirect to GEP sound notification rule"; rtrue; } ! rule 409
        if (R == R_1301) { print "redirect to GEP hyperlink rule"; rtrue; } ! rule 410
        if (R == R_1302) { print "debounce arrange event rule"; rtrue; } ! rule 411
        if (R == R_1307) { print "ordinary checking for content rule"; rtrue; } ! rule 412
        if (R == R_1308) { print "cancelling input in the main window rule"; rtrue; } ! rule 413
        if (R == R_1311) { print "print text to the input prompt rule"; rtrue; } ! rule 414
        if (R == R_1313) { print "glue replacement command into parse buffer rule"; rtrue; } ! rule 415
        if (R == R_1315) { print "graphics window construction rule"; rtrue; } ! rule 416
        if (R == R_1316) { print "default removing reference to picwin rule"; rtrue; } ! rule 417
        if (R == R_1318) { print "default choosing picwin rule"; rtrue; } ! rule 418
        if (R == R_1320) { print "default removing reference to hidewin rule"; rtrue; } ! rule 419
        if (R == R_1322) { print "default choosing hidewin rule"; rtrue; } ! rule 420
        if (R == R_1324) { print "default arranging behavior rule"; rtrue; } ! rule 421
        if (R == R_1325) { print "default redrawing behavior rule"; rtrue; } ! rule 422
        if (R == R_1326) { print "automatic redrawing window rule"; rtrue; } ! rule 423
        if (R == R_1333) { print "default picture selection rule"; rtrue; } ! rule 424
        if (R == R_1335) { print "standard placement rule"; rtrue; } ! rule 425
        if (R == R_1336) { print "bland graphics drawing rule"; rtrue; } ! rule 426
        if (R == R_1339) { print "centered scaled drawing rule"; rtrue; } ! rule 427
        if (R == R_1341) { print "tiled drawing rule"; rtrue; } ! rule 428
        if (R == R_1343) { print "fully scaled drawing rule"; rtrue; } ! rule 429
        if (R == R_1352) { print "examine two-sided doors rule"; rtrue; } ! rule 430
        if (R == R_1353) { print "can't lock a two-sided door without a lock rule"; rtrue; } ! rule 431
        if (R == R_1354) { print "can't lock a two-sided door that's already locked rule"; rtrue; } ! rule 432
        if (R == R_1355) { print "standard two-sided door locking rule"; rtrue; } ! rule 433
        if (R == R_1356) { print "standard can't unlock without a lock description rule"; rtrue; } ! rule 434
        if (R == R_1358) { print "standard can't unlock already unlocked description rule"; rtrue; } ! rule 435
        if (R == R_1360) { print "start lock countdown rule"; rtrue; } ! rule 436
        if (R == R_1361) { print "can't unlock a two-sided door without a lock rule"; rtrue; } ! rule 437
        if (R == R_1362) { print "standard two-sided door unlocking rule"; rtrue; } ! rule 438
        if (R == R_1363) { print "can't unlock a two-sided door that's already unlocked rule"; rtrue; } ! rule 439
        if (R == R_1364) { print "start close countdown rule"; rtrue; } ! rule 440
        if (R == R_1365) { print "can't open a two-sided door unless openable rule"; rtrue; } ! rule 441
        if (R == R_1366) { print "can't open a two-sided door that's locked rule"; rtrue; } ! rule 442
        if (R == R_1367) { print "can't close a two-sided door unless openable rule"; rtrue; } ! rule 443
        if (R == R_1368) { print "lock auto-locking two-sided doors rule"; rtrue; } ! rule 444
        if (R == R_1374) { print "autolock countdown rule"; rtrue; } ! rule 445
        if (R == R_1377) { print "autoclose countdown rule"; rtrue; } ! rule 446
        if (R == R_1389) { print "can't unlock without the correct card key rule"; rtrue; } ! rule 447
        if (R == R_1433) { print "speak to margaret when she enters the front office rule"; rtrue; } ! rule 448
        if (R == R_1453) { print "reset skip sounds rule"; rtrue; } ! rule 449
        if (R == R_1454) { print "skip sounds on implicit hello rule"; rtrue; } ! rule 450
        if (R == R_1457) { print "postponement rule"; rtrue; } ! rule 451
        if (R == R_1498) { print "now you know vent-screws rule"; rtrue; } ! rule 452
        if (R == R_1508) { print "bosh picture selection rule"; rtrue; } ! rule 453
        if (R == LITTLE_USED_DO_NOTHING_R) { print "little-used do nothing rule"; rtrue; } ! rule 454
        if (R == VIRTUAL_MACHINE_STARTUP_R) { print "virtual machine startup rule"; rtrue; } ! rule 455
        if (R == INITIALISE_MEMORY_R) { print "initialise memory rule"; rtrue; } ! rule 456
        if (R == SEED_RANDOM_NUMBER_GENERATOR_R) { print "seed random number generator rule"; rtrue; } ! rule 457
        if (R == UPDATE_CHRONOLOGICAL_RECORDS_R) { print "update chronological records rule"; rtrue; } ! rule 458
        if (R == POSITION_PLAYER_IN_MODEL_R) { print "position player in model world rule"; rtrue; } ! rule 459
        if (R == ADJUST_LIGHT_R) { print "adjust light rule"; rtrue; } ! rule 460
        if (R == ADVANCE_TIME_R) { print "advance time rule"; rtrue; } ! rule 461
        if (R == GENERATE_ACTION_R) { print "generate action rule"; rtrue; } ! rule 462
        if (R == NOTE_OBJECT_ACQUISITIONS_R) { print "note object acquisitions rule"; rtrue; } ! rule 463
        if (R == PARSE_COMMAND_R) { print "parse command rule"; rtrue; } ! rule 464
        if (R == TIMED_EVENTS_R) { print "timed events rule"; rtrue; } ! rule 465
        if (R == RESURRECT_PLAYER_IF_ASKED_R) { print "resurrect player if asked rule"; rtrue; } ! rule 466
        if (R == ASK_FINAL_QUESTION_R) { print "ask the final question rule"; rtrue; } ! rule 467
        if (R == DetectSceneChange) { print "scene change machinery rule"; rtrue; } ! rule 468
        if (R == BASIC_ACCESSIBILITY_R) { print "basic accessibility rule"; rtrue; } ! rule 469
        if (R == BASIC_VISIBILITY_R) { print "basic visibility rule"; rtrue; } ! rule 470
        if (R == CARRYING_REQUIREMENTS_R) { print "carrying requirements rule"; rtrue; } ! rule 471
        if (R == REQUESTED_ACTIONS_REQUIRE_R) { print "requested actions require persuasion rule"; rtrue; } ! rule 472
        if (R == CARRY_OUT_REQUESTED_ACTIONS_R) { print "carry out requested actions rule"; rtrue; } ! rule 473
        if (R == DESCEND_TO_SPECIFIC_ACTION_R) { print "descend to specific action-processing rule"; rtrue; } ! rule 474
        if (R == WORK_OUT_DETAILS_OF_SPECIFIC_R) { print "work out details of specific action rule"; rtrue; } ! rule 475
        if (R == I6_Rule_Shell_476) { print "access through barriers rule"; rtrue; } ! rule 476
        if (R == CANT_REACH_INSIDE_CLOSED_R) { print "can't reach inside closed containers rule"; rtrue; } ! rule 477
        if (R == CANT_REACH_INSIDE_ROOMS_R) { print "can't reach inside rooms rule"; rtrue; } ! rule 478
        if (R == CANT_REACH_OUTSIDE_CLOSED_R) { print "can't reach outside closed containers rule"; rtrue; } ! rule 479
        if (R == LIST_WRITER_INTERNAL_R) { print "list writer internal rule"; rtrue; } ! rule 480
        if (R == ACTION_PROCESSING_INTERNAL_R) { print "action processing internal rule"; rtrue; } ! rule 481
        if (R == PARSER_ERROR_INTERNAL_R) { print "parser error internal rule"; rtrue; } ! rule 482
        if (R == PARSER_N_ERROR_INTERNAL_R) { print "parser nothing error internal rule"; rtrue; } ! rule 483
        if (R == DARKNESS_NAME_INTERNAL_R) { print "darkness name internal rule"; rtrue; } ! rule 484
        if (R == PARSER_COMMAND_INTERNAL_R) { print "parser command internal rule"; rtrue; } ! rule 485
        if (R == PARSER_CLARIF_INTERNAL_R) { print "parser clarification internal rule"; rtrue; } ! rule 486
        if (R == YES_OR_NO_QUESTION_INTERNAL_R) { print "yes or no question internal rule"; rtrue; } ! rule 487
        if (R == PRINT_PROTAGONIST_INTERNAL_R) { print "print protagonist internal rule"; rtrue; } ! rule 488
        if (R == STANDARD_NAME_PRINTING_R) { print "standard name printing rule"; rtrue; } ! rule 489
        if (R == STANDARD_CONTENTS_LISTING_R) { print "standard contents listing rule"; rtrue; } ! rule 490
        if (R == STANDARD_IMPLICIT_TAKING_R) { print "standard implicit taking rule"; rtrue; } ! rule 491
        if (R == ENABLE_GLULX_ACCEL_R) { print "enable Glulx acceleration rule"; rtrue; } ! rule 492
        if (R == PRINT_OBITUARY_HEADLINE_R) { print "print obituary headline rule"; rtrue; } ! rule 493
        if (R == PRINT_FINAL_SCORE_R) { print "print final score rule"; rtrue; } ! rule 494
        if (R == DISPLAY_FINAL_STATUS_LINE_R) { print "display final status line rule"; rtrue; } ! rule 495
        if (R == IMMEDIATELY_RESTART_VM_R) { print "immediately restart the VM rule"; rtrue; } ! rule 496
        if (R == IMMEDIATELY_RESTORE_SAVED_R) { print "immediately restore saved game rule"; rtrue; } ! rule 497
        if (R == IMMEDIATELY_QUIT_R) { print "immediately quit rule"; rtrue; } ! rule 498
        if (R == IMMEDIATELY_UNDO_R) { print "immediately undo rule"; rtrue; } ! rule 499
        if (R == READ_FINAL_ANSWER_R) { print "read the final answer rule"; rtrue; } ! rule 500
        if (R == STANDARD_RESPONSE_ISSUING_R) { print "standard issuing the response text rule"; rtrue; } ! rule 501
        if (R == QUIT_THE_GAME_R) { print "quit the game rule"; rtrue; } ! rule 502
        if (R == SAVE_THE_GAME_R) { print "save the game rule"; rtrue; } ! rule 503
        if (R == RESTORE_THE_GAME_R) { print "restore the game rule"; rtrue; } ! rule 504
        if (R == RESTART_THE_GAME_R) { print "restart the game rule"; rtrue; } ! rule 505
        if (R == VERIFY_THE_STORY_FILE_R) { print "verify the story file rule"; rtrue; } ! rule 506
        if (R == SWITCH_TRANSCRIPT_ON_R) { print "switch the story transcript on rule"; rtrue; } ! rule 507
        if (R == SWITCH_TRANSCRIPT_OFF_R) { print "switch the story transcript off rule"; rtrue; } ! rule 508
        if (R == ANNOUNCE_STORY_FILE_VERSION_R) { print "announce the story file version rule"; rtrue; } ! rule 509
        if (R == ANNOUNCE_SCORE_R) { print "announce the score rule"; rtrue; } ! rule 510
        if (R == PREFER_ABBREVIATED_R) { print "prefer abbreviated room descriptions rule"; rtrue; } ! rule 511
        if (R == REP_PREFER_ABBREVIATED_R) { print "standard report preferring abbreviated room descriptions rule"; rtrue; } ! rule 512
        if (R == PREFER_UNABBREVIATED_R) { print "prefer unabbreviated room descriptions rule"; rtrue; } ! rule 513
        if (R == REP_PREFER_UNABBREVIATED_R) { print "standard report preferring unabbreviated room descriptions rule"; rtrue; } ! rule 514
        if (R == PREFER_SOMETIMES_ABBREVIATED_R) { print "prefer sometimes abbreviated room descriptions rule"; rtrue; } ! rule 515
        if (R == REP_PREFER_SOMETIMES_ABBR_R) { print "standard report preferring sometimes abbreviated room descriptions rule"; rtrue; } ! rule 516
        if (R == SWITCH_SCORE_NOTIFY_ON_R) { print "switch score notification on rule"; rtrue; } ! rule 517
        if (R == REP_SWITCH_NOTIFY_ON_R) { print "standard report switching score notification on rule"; rtrue; } ! rule 518
        if (R == SWITCH_SCORE_NOTIFY_OFF_R) { print "switch score notification off rule"; rtrue; } ! rule 519
        if (R == REP_SWITCH_NOTIFY_OFF_R) { print "standard report switching score notification off rule"; rtrue; } ! rule 520
        if (R == ANNOUNCE_PRONOUN_MEANINGS_R) { print "announce the pronoun meanings rule"; rtrue; } ! rule 521
        if (R == R_16) { print "A first turn sequence rule"; rtrue; } ! rule 522
        if (R == R_17) { print "A last turn sequence rule"; rtrue; } ! rule 523
        if (R == R_32) { print "last specific action-processing rule"; rtrue; } ! rule 524
        if (R == R_172) { print "Setting action variables for exiting"; rtrue; } ! rule 525
        if (R == R_240) { print "Does the player mean taking off something worn"; rtrue; } ! rule 526
        if (R == R_754) { print "Before printing the name of a person ( called P )"; rtrue; } ! rule 527
        if (R == R_809) { print "Instead of implicit-asking"; rtrue; } ! rule 528
        if (R == R_810) { print "Instead of implicit-telling"; rtrue; } ! rule 529
        if (R == R_811) { print "Instead of implicit-quizzing"; rtrue; } ! rule 530
        if (R == R_812) { print "Instead of implicit-informing"; rtrue; } ! rule 531
        if (R == R_813) { print "Instead of implicit-requesting"; rtrue; } ! rule 532
        if (R == R_814) { print "Instead of implicit-imploring"; rtrue; } ! rule 533
        if (R == R_829) { print "When play begins"; rtrue; } ! rule 534
        if (R == R_937) { print "Escape detection for 98"; rtrue; } ! rule 535
        if (R == R_938) { print "Escape detection for 105"; rtrue; } ! rule 536
        if (R == R_939) { print "Escape detection for 114"; rtrue; } ! rule 537
        if (R == R_940) { print "Escape detection for 102"; rtrue; } ! rule 538
        if (R == R_941) { print "Escape detection for 118"; rtrue; } ! rule 539
        if (R == R_942) { print "Last escape detection for a number ( called N )"; rtrue; } ! rule 540
        if (R == R_961) { print "Instead of entering an unenterable room"; rtrue; } ! rule 541
        if (R == R_962) { print "When play begins"; rtrue; } ! rule 542
        if (R == R_967) { print "Check asking for identification when current interlocutor is nothing"; rtrue; } ! rule 543
        if (R == R_968) { print "Check asking for identification"; rtrue; } ! rule 544
        if (R == R_969) { print "Check questioning motives when current interlocutor is nothing"; rtrue; } ! rule 545
        if (R == R_970) { print "Check questioning motives"; rtrue; } ! rule 546
        if (R == R_971) { print "Check promising when the current interlocutor is nothing"; rtrue; } ! rule 547
        if (R == R_972) { print "Instead of promising when the current interlocutor is not nothing"; rtrue; } ! rule 548
        if (R == R_978) { print "Audibility of a thing ( called T ) when location is indoors"; rtrue; } ! rule 549
        if (R == R_979) { print "Audibility of a thing ( called T ) when location is outdoors"; rtrue; } ! rule 550
        if (R == R_981) { print "Every turn"; rtrue; } ! rule 551
        if (R == R_982) { print "After printing the locale description"; rtrue; } ! rule 552
        if (R == R_984) { print "Rule for determining the subjective volume for something ( called T )"; rtrue; } ! rule 553
        if (R == R_985) { print "Rule for printing the sound description for something ( called noise ) when noise is visible"; rtrue; } ! rule 554
        if (R == R_986) { print "Rule for printing the sound description for something ( called T ) when the player carries T"; rtrue; } ! rule 555
        if (R == R_990) { print "Rule for printing the sound description for something ( called T ) when T is enclosed by the location"; rtrue; } ! rule 556
        if (R == R_991) { print "Rule for printing the sound description for something ( called T ) when the number of moves from the location to the location of T , using doors is 1"; rtrue; } ! rule 557
        if (R == R_993) { print "Rule for printing the sound action for something"; rtrue; } ! rule 558
        if (R == R_994) { print "Rule for printing insistent sounds"; rtrue; } ! rule 559
        if (R == R_995) { print "Rule for printing background sounds"; rtrue; } ! rule 560
        if (R == R_997) { print "Every turn"; rtrue; } ! rule 561
        if (R == R_998) { print "Rule for printing the sound action for a phone"; rtrue; } ! rule 562
        if (R == R_1002) { print "Every turn when player is calling something ( called P ) and player is talking with nobody"; rtrue; } ! rule 563
        if (R == R_1003) { print "Check an actor going when actor is talking on a phone ( called P ) and P is wired"; rtrue; } ! rule 564
        if (R == R_1004) { print "Check Cold-calling something on something"; rtrue; } ! rule 565
        if (R == R_1005) { print "Rule for supplying a missing second noun while cold-calling"; rtrue; } ! rule 566
        if (R == R_1006) { print "Check an actor calling a phone ( called the callee phone ) on a phone ( called the caller phone )"; rtrue; } ! rule 567
        if (R == R_1007) { print "Carry out an actor calling a phone ( called the callee phone ) on a phone ( called the caller phone )"; rtrue; } ! rule 568
        if (R == R_1008) { print "Report an actor calling a phone ( called the callee phone ) on a phone ( called the caller phone )"; rtrue; } ! rule 569
        if (R == R_1009) { print "Check an actor calling someone ( called the callee ) on something ( called the caller phone )"; rtrue; } ! rule 570
        if (R == R_1011) { print "Carry out an actor answering a phone ( called the phone )"; rtrue; } ! rule 571
        if (R == R_1012) { print "Report player saying hello to someone ( called P ) when player is talking with P"; rtrue; } ! rule 572
        if (R == R_1013) { print "Does the player mean answering a phone ( called P ) when P is ringing"; rtrue; } ! rule 573
        if (R == R_1014) { print "Does the player mean answering a phone ( called P ) when P is not ringing"; rtrue; } ! rule 574
        if (R == R_1015) { print "Does the player mean answering the player"; rtrue; } ! rule 575
        if (R == R_1019) { print "Check ending a call when the player is not phoning"; rtrue; } ! rule 576
        if (R == R_1020) { print "Check an actor ending a call when the the actor is not phoning and the actor is not the player"; rtrue; } ! rule 577
        if (R == R_1021) { print "Carry out an actor ending a call when the actor is talking with someone ( called the callee )"; rtrue; } ! rule 578
        if (R == R_1022) { print "Carry out an actor ending a call when the actor is talking with nobody"; rtrue; } ! rule 579
        if (R == R_1023) { print "Carry out an actor hanging up something ( called P )"; rtrue; } ! rule 580
        if (R == R_1024) { print "Report an actor signing off with a person ( called callee )"; rtrue; } ! rule 581
        if (R == R_1025) { print "Report an actor hanging up"; rtrue; } ! rule 582
        if (R == R_1026) { print "Instead of player saying goodbye to someone ( called callee ) while the actor is talking with the callee and the current interlocutor is not nothing"; rtrue; } ! rule 583
        if (R == R_1027) { print "Instead of player saying goodbye to someone ( called callee ) while the actor is talking with the callee and the current interlocutor is nothing"; rtrue; } ! rule 584
        if (R == R_1028) { print "Carry out player hanging up"; rtrue; } ! rule 585
        if (R == R_1030) { print "Instead of examining a phone ( called P ) when the noun is ringing"; rtrue; } ! rule 586
        if (R == R_1031) { print "Rule for writing a paragraph about a person ( called P ) when P is phoning"; rtrue; } ! rule 587
        if (R == R_1032) { print "Rule for supplying a missing second noun while buying something ( called the product ) with"; rtrue; } ! rule 588
        if (R == R_1033) { print "Check buying something ( called the product ) with something ( called damoney )"; rtrue; } ! rule 589
        if (R == R_1034) { print "Carry out buying something ( called the product ) with something ( called damoney )"; rtrue; } ! rule 590
        if (R == R_1035) { print "Carry out pricing"; rtrue; } ! rule 591
        if (R == R_1036) { print "Carry out accounting"; rtrue; } ! rule 592
        if (R == R_1037) { print "Check taking something ( called target )"; rtrue; } ! rule 593
        if (R == R_1038) { print "Carry out Attributing"; rtrue; } ! rule 594
        if (R == R_1039) { print "Instead of opening a desk ( called D )"; rtrue; } ! rule 595
        if (R == R_1040) { print "Instead of closing a desk ( called D )"; rtrue; } ! rule 596
        if (R == R_1041) { print "Rule for printing the name of the player"; rtrue; } ! rule 597
        if (R == R_1046) { print "Rule for acting as someone ( called P )"; rtrue; } ! rule 598
        if (R == R_1054) { print "Rule for behaving as a person ( called P ) when the the current behavior of P is walking-to"; rtrue; } ! rule 599
        if (R == R_1056) { print "Does the player mean doing anything to the location"; rtrue; } ! rule 600
        if (R == R_1057) { print "Instead of examining a room"; rtrue; } ! rule 601
        if (R == R_1058) { print "When play begins"; rtrue; } ! rule 602
        if (R == R_1106) { print "Instead of going nowhere"; rtrue; } ! rule 603
        if (R == R_1129) { print "Rule for list arranging"; rtrue; } ! rule 604
        if (R == R_1161) { print "Report exit symboling"; rtrue; } ! rule 605
        if (R == R_1167) { print "first for printing the options paragraph rule"; rtrue; } ! rule 606
        if (R == R_1168) { print "last for printing the options paragraph rule"; rtrue; } ! rule 607
        if (R == R_1169) { print "After printing the locale description when first options paragraph is true"; rtrue; } ! rule 608
        if (R == R_1171) { print "Check choosing"; rtrue; } ! rule 609
        if (R == R_1172) { print "When play begins"; rtrue; } ! rule 610
        if (R == R_1173) { print "A rule for reaching inside the room of choices"; rtrue; } ! rule 611
        if (R == R_1176) { print "Rule for printing the name of a direction ( called dir ) while listing the available choices"; rtrue; } ! rule 612
        if (R == R_1177) { print "For listing the available choices"; rtrue; } ! rule 613
        if (R == R_1178) { print "For printing the options paragraph"; rtrue; } ! rule 614
        if (R == R_1183) { print "Check looking behind something when nothing is behind the noun and the behind description of the noun is ~~"; rtrue; } ! rule 615
        if (R == R_1184) { print "Carry out looking behind something"; rtrue; } ! rule 616
        if (R == R_1185) { print "Report looking behind something when the behind description of the noun is not ~~"; rtrue; } ! rule 617
        if (R == R_1186) { print "Report looking behind something"; rtrue; } ! rule 618
        if (R == R_1190) { print "Every turn"; rtrue; } ! rule 619
        if (R == R_1191) { print "Check printing memories"; rtrue; } ! rule 620
        if (R == R_1192) { print "Report printing memories"; rtrue; } ! rule 621
        if (R == R_1194) { print "report remembering a memory"; rtrue; } ! rule 622
        if (R == R_1196) { print "Rule for printing the name of an informative quip ( called Q ) while listing the available quips"; rtrue; } ! rule 623
        if (R == R_1197) { print "Rule for printing the name of a questioning quip ( called Q ) while listing the available quips"; rtrue; } ! rule 624
        if (R == R_1198) { print "When play begins"; rtrue; } ! rule 625
        if (R == R_1200) { print "rule for reaching inside the room of quips"; rtrue; } ! rule 626
        if (R == R_1202) { print "Check discussing something with someone"; rtrue; } ! rule 627
        if (R == R_1204) { print "Check discussing something"; rtrue; } ! rule 628
        if (R == R_1205) { print "Carry out discussing something"; rtrue; } ! rule 629
        if (R == R_1207) { print "For queueing quips following a quip ( called Q )"; rtrue; } ! rule 630
        if (R == R_1208) { print "When play begins"; rtrue; } ! rule 631
        if (R == R_1211) { print "For ruling out quips following a quip ( called Q )"; rtrue; } ! rule 632
        if (R == R_1212) { print "check informing someone about something"; rtrue; } ! rule 633
        if (R == R_1213) { print "check asking someone about something"; rtrue; } ! rule 634
        if (R == R_1214) { print "check telling someone about something"; rtrue; } ! rule 635
        if (R == R_1229) { print "For listing the available quips"; rtrue; } ! rule 636
        if (R == R_1231) { print "For printing the options paragraph"; rtrue; } ! rule 637
        if (R == R_1232) { print "Rule for clarifying the parser's choice of a quip ( called Q )"; rtrue; } ! rule 638
        if (R == R_1233) { print "Does the player mean discussing an off-limits quip ( called Q )"; rtrue; } ! rule 639
        if (R == R_1234) { print "report frumping"; rtrue; } ! rule 640
        if (R == R_1235) { print "Does the player mean discussing an off-limits quip ( called Q ) with the current interlocutor"; rtrue; } ! rule 641
        if (R == R_1236) { print "Does the player mean discussing an off-limits quip ( called Q ) with someone ( called P )"; rtrue; } ! rule 642
        if (R == R_1237) { print "Does the player mean discussing an q-available quip"; rtrue; } ! rule 643
        if (R == R_1238) { print "Does the player mean discussing an q-available quip with the current interlocutor"; rtrue; } ! rule 644
        if (R == R_1239) { print "Does the player mean discussing an q-available quip with someone"; rtrue; } ! rule 645
        if (R == R_1240) { print "After going to hyperspace"; rtrue; } ! rule 646
        if (R == R_1241) { print "Check going a hyperspatial direction"; rtrue; } ! rule 647
        if (R == R_1244) { print "Carry out wearing the astral lenses"; rtrue; } ! rule 648
        if (R == R_1245) { print "Carry out taking off the astral lenses"; rtrue; } ! rule 649
        if (R == R_1246) { print "After dropping the mystic compass when the Ethereal Pillar is nowhere"; rtrue; } ! rule 650
        if (R == R_1247) { print "After dropping the mystic compass when the Ethereal Pillar is in the Featureless Hyperplane"; rtrue; } ! rule 651
        if (R == R_1250) { print "Carry out going a direction ( called D ) from Featureless Hyperplane"; rtrue; } ! rule 652
        if (R == R_1253) { print "Rule for writing a paragraph about the Ethereal Pillar"; rtrue; } ! rule 653
        if (R == R_1254) { print "Rule for writing a paragraph about the mystic compass"; rtrue; } ! rule 654
        if (R == R_1257) { print "Instead of examining the mystic compass when the location is Featureless Hyperplane"; rtrue; } ! rule 655
        if (R == R_1258) { print "After printing the locale description when the location is Featureless Hyperplane"; rtrue; } ! rule 656
        if (R == R_1259) { print "Check going down from Featureless Hyperplane"; rtrue; } ! rule 657
        if (R == R_1260) { print "An availability rule for no-thumb-drive"; rtrue; } ! rule 658
        if (R == R_1261) { print "An availability rule for yes-thumb-drive"; rtrue; } ! rule 659
        if (R == R_1262) { print "After discussing yes-thumb-drive"; rtrue; } ! rule 660
        if (R == R_1263) { print "An availability rule for hand over the thumb drive"; rtrue; } ! rule 661
        if (R == R_1264) { print "After discussing hand over the thumb drive"; rtrue; } ! rule 662
        if (R == R_1265) { print "After printing the locale description when player is in the field office chief's office and Doris greeted the player is false"; rtrue; } ! rule 663
        if (R == R_1266) { print "Carry out helping about hyperspace"; rtrue; } ! rule 664
        if (R == R_1314) { print "Before starting the virtual machine"; rtrue; } ! rule 665
        if (R == R_1350) { print "Rule for writing a paragraph about a two-sided door ( called D ) when D is describable"; rtrue; } ! rule 666
        if (R == R_1351) { print "Rule for writing a paragraph about a two-sided door ( called D ) when D is not describable"; rtrue; } ! rule 667
        if (R == R_1387) { print "Check swiping something swipable through a swipe lock"; rtrue; } ! rule 668
        if (R == R_1388) { print "Check swiping something swipable through a swipe door"; rtrue; } ! rule 669
        if (R == R_1390) { print "Instead of entering the office_"; rtrue; } ! rule 670
        if (R == R_1391) { print "Instead of entering car 1"; rtrue; } ! rule 671
        if (R == R_1392) { print "Check pushing car 1"; rtrue; } ! rule 672
        if (R == R_1393) { print "Check turning car 1"; rtrue; } ! rule 673
        if (R == R_1394) { print "Instead of entering the laundromat-facade"; rtrue; } ! rule 674
        if (R == R_1395) { print "Check going northwest from the strip mall parking lot south when the player does not know break-in-to-laundromat"; rtrue; } ! rule 675
        if (R == R_1396) { print "Check going northwest from the strip mall parking lot south when the player knows break-in-to-laundromat"; rtrue; } ! rule 676
        if (R == R_1397) { print "Instead of entering the swamp-facade"; rtrue; } ! rule 677
        if (R == R_1398) { print "Instead of entering the pawn-shop-facade"; rtrue; } ! rule 678
        if (R == R_1399) { print "Instead of going nowhere from the Parking Lot South"; rtrue; } ! rule 679
        if (R == R_1400) { print "Instead of entering the automatic car wash"; rtrue; } ! rule 680
        if (R == R_1401) { print "Instead of going nowhere from the Parking Lot North"; rtrue; } ! rule 681
        if (R == R_1402) { print "Instead of entering the convenience-store-facade"; rtrue; } ! rule 682
        if (R == R_1403) { print "Instead of entering the military-facade"; rtrue; } ! rule 683
        if (R == R_1404) { print "Greeting response for Dave"; rtrue; } ! rule 684
        if (R == R_1405) { print "An availability rule for for-a-screwdriver-pawn"; rtrue; } ! rule 685
        if (R == R_1406) { print "After discussing for-a-screwdriver-pawn"; rtrue; } ! rule 686
        if (R == R_1407) { print "After discussing about the laundromat owner"; rtrue; } ! rule 687
        if (R == R_1408) { print "Instead of taking the handtruck"; rtrue; } ! rule 688
        if (R == R_1409) { print "Check moving something with"; rtrue; } ! rule 689
        if (R == R_1410) { print "Instead of moving the filing cabinets with the handtruck"; rtrue; } ! rule 690
        if (R == R_1411) { print "After entering the broken washing machine"; rtrue; } ! rule 691
        if (R == R_1412) { print "After switching off the light switch"; rtrue; } ! rule 692
        if (R == R_1413) { print "After switching on the light switch"; rtrue; } ! rule 693
        if (R == R_1414) { print "Every turn"; rtrue; } ! rule 694
        if (R == R_1415) { print "Instead of switching on the flashlight"; rtrue; } ! rule 695
        if (R == R_1416) { print "Instead of switching off the flashlight"; rtrue; } ! rule 696
        if (R == R_1417) { print "After quizzing the clerk about the glass case"; rtrue; } ! rule 697
        if (R == R_1418) { print "An availability rule for for-a-screwdriver-clerk"; rtrue; } ! rule 698
        if (R == R_1419) { print "Persuasion rule for asking people to try howdeedoing"; rtrue; } ! rule 699
        if (R == R_1420) { print "Check howdeedoing-someone someone"; rtrue; } ! rule 700
        if (R == R_1421) { print "A plausibility rule for how-are-you"; rtrue; } ! rule 701
        if (R == R_1422) { print "Check howdeedoing"; rtrue; } ! rule 702
        if (R == R_1423) { print "Rule for printing the name of Margaret Chao"; rtrue; } ! rule 703
        if (R == R_1424) { print "An availability rule for about the whereabouts of the desk key"; rtrue; } ! rule 704
        if (R == R_1425) { print "After discussing the whereabouts of the desk key"; rtrue; } ! rule 705
        if (R == R_1426) { print "An availability rule for about the status of the computer"; rtrue; } ! rule 706
        if (R == R_1427) { print "An availability rule for for the wrench"; rtrue; } ! rule 707
        if (R == R_1428) { print "An availability rule for for-a-screwdriver"; rtrue; } ! rule 708
        if (R == R_1429) { print "An availability rule for to unlock the backdoor"; rtrue; } ! rule 709
        if (R == R_1431) { print "Rule for behaving as Margaret when the current behavior of Margaret is throw out boxes"; rtrue; } ! rule 710
        if (R == R_1432) { print "Rule for deciding the concealed possessions of margaret"; rtrue; } ! rule 711
        if (R == R_1434) { print "Before printing the name of a thing ( called item )"; rtrue; } ! rule 712
        if (R == R_1439) { print "When play begins"; rtrue; } ! rule 713
        if (R == R_1440) { print "After reading a command when current play mode is picking character"; rtrue; } ! rule 714
        if (R == R_1443) { print "After reading a command"; rtrue; } ! rule 715
        if (R == R_1446) { print "Instead of looking when current play mode is picking character"; rtrue; } ! rule 716
        if (R == R_1447) { print "Rule for printing the banner text when current play mode is picking character"; rtrue; } ! rule 717
        if (R == R_1448) { print "Rule for constructing the status line when current play mode is picking character"; rtrue; } ! rule 718
        if (R == R_1450) { print "Rule for constructing the status line"; rtrue; } ! rule 719
        if (R == R_1455) { print "After going to a room"; rtrue; } ! rule 720
        if (R == R_1458) { print "Report knocking on something"; rtrue; } ! rule 721
        if (R == R_1459) { print "Report knocking on a door"; rtrue; } ! rule 722
        if (R == R_1460) { print "After printing the locale description when the location is the front office for the first time during denouement"; rtrue; } ! rule 723
        if (R == R_1462) { print "Instead of an actor saying hello to someone when the noun is busy with respect to the actor"; rtrue; } ! rule 724
        if (R == R_1463) { print "Instead of quizzing someone about something when the noun is busy with respect to the actor"; rtrue; } ! rule 725
        if (R == R_1465) { print "Response of Klimp when asked about aliens"; rtrue; } ! rule 726
        if (R == R_1466) { print "Greeting response for Klimp"; rtrue; } ! rule 727
        if (R == R_1467) { print "Response of Klimp when asked about Moira"; rtrue; } ! rule 728
        if (R == R_1468) { print "Response of Klimp when asked about Margaret"; rtrue; } ! rule 729
        if (R == R_1469) { print "Response of Klimp when asked about the Bureau of Strange Happenings"; rtrue; } ! rule 730
        if (R == R_1470) { print "Response of Klimp when asked about Senator Savra"; rtrue; } ! rule 731
        if (R == R_1471) { print "After examining the juvenile sasquatch skull"; rtrue; } ! rule 732
        if (R == R_1472) { print "After examining the astral lenses"; rtrue; } ! rule 733
        if (R == R_1473) { print "After discussing to borrow the lenses"; rtrue; } ! rule 734
        if (R == R_1474) { print "Rule for writing a paragraph about Margaret Chao when the location is the front office"; rtrue; } ! rule 735
        if (R == R_1481) { print "Instead of stealing equipment"; rtrue; } ! rule 736
        if (R == R_1482) { print "After examining the desk"; rtrue; } ! rule 737
        if (R == R_1483) { print "Check calling someone on the green smartphone"; rtrue; } ! rule 738
        if (R == R_1484) { print "Check dropping the green smartphone"; rtrue; } ! rule 739
        if (R == R_1486) { print "Check opening Biff's desk's drawer when biff's desk's drawer is locked and the blue flipphone is in biff's desk's drawer and the blue flipphone is ringing for the first time"; rtrue; } ! rule 740
        if (R == R_1487) { print "After opening Biff's desk's drawer for the first time"; rtrue; } ! rule 741
        if (R == R_1488) { print "Before opening BOSH back door when BOSH back door is locked"; rtrue; } ! rule 742
        if (R == R_1489) { print "When play begins"; rtrue; } ! rule 743
        if (R == R_1490) { print "Instead of an actor inserting biff-flattened-boxes into the dumpster"; rtrue; } ! rule 744
        if (R == R_1491) { print "Instead of an actor inserting margaret-flattened-boxes into the dumpster"; rtrue; } ! rule 745
        if (R == R_1492) { print "Rule for behaving as margaret when the the current behavior of margaret is locking-back-door"; rtrue; } ! rule 746
        if (R == R_1493) { print "Rule for behaving as margaret when the the current behavior of margaret is waiting-for-player"; rtrue; } ! rule 747
        if (R == R_1494) { print "Carry out knocking on the BOSH back door when the location is the back lot and the BOSH back door is locked"; rtrue; } ! rule 748
        if (R == R_1495) { print "Report knocking on the BOSH back door when the location is the back lot and the BOSH back door was locked"; rtrue; } ! rule 749
        if (R == R_1496) { print "Instead of taking the cardboard boxes"; rtrue; } ! rule 750
        if (R == R_1497) { print "Instead of examining Biff's computer when the thumb drive is not seen"; rtrue; } ! rule 751
        if (R == R_1499) { print "Instead of removing hex wrench from heating vent when the heating vent is closed"; rtrue; } ! rule 752
        if (R == R_1500) { print "Instead of opening the heating vent when the heating vent is locked"; rtrue; } ! rule 753
        if (R == R_1501) { print "Instead of knocking on the closet door when the location is the utility closet and the closet door is locked and the closet door is closed"; rtrue; } ! rule 754
        if (R == R_1504) { print "After going from a room ( called R1 ) to a room ( called R2 )"; rtrue; } ! rule 755
        if (R == R_1505) { print "After going from the Front Office to the BOSH office hallway for the first time"; rtrue; } ! rule 756
        if (R == R_1506) { print "Rule for starting the virtual machine"; rtrue; } ! rule 757
        if (R == R_1509) { print "Every turn"; rtrue; } ! rule 758
        if (R == R_1512) { print "A window resizing rule"; rtrue; } ! rule 759
        if (R == R_1515) { print "Carry out lensing"; rtrue; } ! rule 760

		print "(nameless rule at address ", R, ")";
	}
#ifnot;
	if ((R>=0) && (R<NUMBER_RULEBOOKS_CREATED)) {
		print "(rulebook ", R, ")";
	} else {
		print "(rule at address ", R, ")";
	}
#endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Casting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RULEBOOK_TY_to_RULE_TY r;
	return r;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Rulebooks.i6t: Debugging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DebugRulebooks subs parameter i;
	spaces(2*process_rulebook_count);
	print "[", (RulePrintingRule) subs;
	if (parameter) print " / on O", parameter;
	print "]^";
];

[ DB_Rule R N blocked;
	if (R==0) return;
	print "[Rule ~", (RulePrintingRule) R, "~ ";
	#ifdef NUMBERED_RULES; print "(", N, ") "; #endif;
	if (blocked == false) "applies.]";
	print "does not apply (wrong ", (address) blocked, ").]^";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: Storage
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global I7S_Tab; ! The array to be sorted, which can have almost any format
Global I7S_Col; ! The "column number" in the array, if any
Global I7S_Dir; ! The direction of sorting: ascending (1) or descending (-1)
Global I7S_Swap; ! The current routine for swapping two fields
Global I7S_Comp; ! The current routine for comparing two fields

#ifdef MEASURE_SORT_PERFORMANCE;
Global I7S_CCOUNT; Global I7S_CCOUNT2; Global I7S_XCOUNT; ! For testing only
#endif;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: Front End
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SetSortDomain swapf compf;
	I7S_Swap = swapf;
	I7S_Comp = compf;
];

[ SortArray tab col dir size test_flag algorithm;
	I7S_Tab = tab;
	I7S_Col = col;
	I7S_Dir = dir;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_CCOUNT = 0;
	I7S_CCOUNT2 = 0;
	I7S_XCOUNT = 0;
	#endif;
	SortRange(0, size, algorithm);
	#ifdef MEASURE_SORT_PERFORMANCE;
	if (test_flag)
		print "Sorted array of size ", size, " with ", I7S_CCOUNT2, "*10000 + ", I7S_CCOUNT,
			" comparisons and ", I7S_XCOUNT, " exchanges^";
	#endif;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: Sort Range
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SortRange x y algorithm;
	if (y - x < 2) return;
	if (algorithm) {
		(algorithm)(x, y);
	} else {
		InPlaceMergeSortAlgorithm(x, y);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: Comparison and Exchange
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CompareFields x y;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_CCOUNT++;
	if (I7S_CCOUNT == 10000) { I7S_CCOUNT = 0; I7S_CCOUNT2++; }
	#endif;
	return I7S_Dir*I7S_Comp(I7S_Tab, I7S_Col, x+1, y+1, I7S_Dir);
];

[ ExchangeFields x y r;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_XCOUNT++;
	if (I7S_XCOUNT < 0) { print "XO^"; I7S_XCOUNT = 0; }
	#endif;
	r = I7S_Swap(I7S_Tab, x+1, y+1);
	
	return r; 
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: 4W37 Sort
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ OldSortAlgorithm x y
	f i j;
	if (y - x < 2) return;
	f = true;
	while (f) {
		f = false;
		for (i=x:i<y:i++)
		    for (j=i+1:j<y:j++)
				if (CompareFields(i, j) > 0) {
					ExchangeFields(i, j); f = true; break;
				}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: Insertion Sort
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ InsertionSortAlgorithm from to
	i j;
	if (to > from+1) { 
		for (i = from+1: i < to: i++) { 
			for (j = i: j > from: j--) { 
				if (CompareFields(j, j-1) < 0) 
					ExchangeFields(j, j-1);
				else break;
			}
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Sort.i6t: In-Place Mergesort
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ InPlaceMergeSortAlgorithm from to
	middle;
	if (to - from < 12) {
		if (to - from < 2) return;
		InsertionSortAlgorithm(from, to);
		return;
	}
	middle = (from + to)/2; 
	InPlaceMergeSortAlgorithm(from, middle); 
	InPlaceMergeSortAlgorithm(middle, to); 
	IPMS_Merge(from, middle, to, middle-from, to - middle); 
];

[ IPMS_Lower from to val
	len half mid;
	len = to - from;
	while (len > 0) { 
		half = len/2; 
		mid = from + half;
		if (CompareFields(mid, val) < 0) {
			from = mid + 1;
			len = len - half -1; 
		} else len = half;
	}
	return from;
];

[ IPMS_Upper from to val
	len half mid;
	len = to - from;
	while (len > 0) { 
		half = len/2; 
		mid = from + half;
		if (CompareFields(val, mid) < 0)
			len = half;
		else {
			from = mid + 1;
			len = len - half -1; 
		}
	}
	return from;
];

[ IPMS_Reverse from to;
	while (from < to) {
		ExchangeFields(from++, to--);
	}
];

[ IPMS_Rotate from mid to
	n val shift p1 p2;
	if ((from==mid) || (mid==to)) return; 
	IPMS_Reverse(from, mid-1); 
	IPMS_Reverse(mid, to-1); 
	IPMS_Reverse(from, to-1);
];

[ IPMS_Merge from pivot to len1 len2
	first_cut second_cut len11 len22 new_mid;
	if ((len1 == 0) || (len2 == 0)) return; 
	if (len1+len2 == 2) { 
		if (CompareFields(pivot, from) < 0) 
		ExchangeFields(pivot, from); 
		return; 
	}
	if (len1 > len2) { 
		len11 = len1/2; 
		first_cut = from + len11; 
		second_cut = IPMS_Lower(pivot, to, first_cut); 
		len22 = second_cut - pivot; 
	} else { 
		len22 = len2/2; 
		second_cut = pivot + len22; 
		first_cut = IPMS_Upper(from, pivot, second_cut); 
		len11 = first_cut - from; 
	} 
	IPMS_Rotate(first_cut, pivot, second_cut); 
	new_mid = first_cut + len22; 
	IPMS_Merge(from, first_cut, new_mid, len11, len22); 
	IPMS_Merge(new_mid, second_cut, to, len1 - len11, len2 - len22); 
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant TB_COLUMN_REAL        $8000;
Constant TB_COLUMN_SIGNED      $4000;
Constant TB_COLUMN_TOPIC       $2000;
Constant TB_COLUMN_DONTSORTME  $1000;
Constant TB_COLUMN_NOBLANKBITS $0800;
Constant TB_COLUMN_CANEXCHANGE $0400;
Constant TB_COLUMN_ALLOCATED   $0200;
Constant TB_COLUMN_NUMBER      $01ff; ! Mask to remove upper bit flags

Constant COL_HSIZE 2; ! Column header size: two words (ID/flags, blank bits)


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Find Column
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableFindCol tab col f i no_cols n;
	no_cols = tab-->0;
	for (i=1: i<=no_cols: i++)
		if (col == ((tab-->i)-->1) & TB_COLUMN_NUMBER) return i;
	if (f) { RunTimeProblem(RTP_TABLE_NOCOL, tab); return 0; }
	return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Number of Rows
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableRows tab first_col;
	first_col = tab-->1; if (first_col == 0) return 0;
	return (first_col-->0) - COL_HSIZE;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Blanks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant TABLE_NOVALUE = IMPROBABLE_VALUE;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Masks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array CheckTableEntryIsBlank_LU
	->	$$00000001
		$$00000010
		$$00000100
		$$00001000
		$$00010000
		$$00100000
		$$01000000
		$$10000000;
Array CheckTableEntryIsNonBlank_LU
	->	$$11111110
		$$11111101
		$$11111011
		$$11110111
		$$11101111
		$$11011111
		$$10111111
		$$01111111;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Testing Blankness
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CheckTableEntryIsBlank tab col row i at;
	if (col >= 100) col = TableFindCol(tab, col);
	if (col == 0) rtrue;
	if ((tab-->col)-->(row+COL_HSIZE) ~= TABLE_NOVALUE) {
		print "*** CTEIB on nonblank value ", tab, " ", col, " ", row, " ***^";
	}
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) rtrue;
	row--;
	at = ((tab-->col)-->2) + (row/8);
	if ((TB_Blanks->at) & (CheckTableEntryIsBlank_LU->(row%8))) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Force Entry Blank
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ForceTableEntryBlank tab col row i at oldv flags;
	if (col >= 100) col = TableFindCol(tab, col);
	if (col == 0) rtrue;
	flags = (tab-->col)-->1;
	oldv = (tab-->col)-->(row+COL_HSIZE);
	if ((flags & TB_COLUMN_ALLOCATED) && (oldv ~= 0 or TABLE_NOVALUE))
		BlkValueFree(oldv);
	(tab-->col)-->(row+COL_HSIZE) = TABLE_NOVALUE;
	if (flags & TB_COLUMN_NOBLANKBITS) return;
	row--;
	at = ((tab-->col)-->2) + (row/8);
	(TB_Blanks->at) = (TB_Blanks->at) | (CheckTableEntryIsBlank_LU->(row%8));
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Force Entry Non-Blank
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ForceTableEntryNonBlank tab col row i at oldv flags tc kov;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) return;
	flags = (tab-->col)-->1;
	oldv = (tab-->col)-->(row+COL_HSIZE);
	if ((flags & TB_COLUMN_ALLOCATED) &&
		(oldv == 0 or TABLE_NOVALUE)) {
		kov = UNKNOWN_TY;
		tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
		kov = TC_KOV(tc);
		if (kov ~= UNKNOWN_TY) {
			(tab-->col)-->(row+COL_HSIZE) = BlkValueCreate(kov);
		}
	}
	row--;
	at = ((tab-->col)-->2) + (row/8);
	(TB_Blanks->at) = (TB_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(row%8));
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Swapping Blank Bits
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableSwapBlankBits tab row1 row2 col at1 at2 bit1 bit2;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) return;
	row1--;
	at1 = ((tab-->col)-->2) + (row1/8);
	row2--;
	at2 = ((tab-->col)-->2) + (row2/8);
	bit1 = ((TB_Blanks->at1) & (CheckTableEntryIsBlank_LU->(row1%8)));
	bit2 = ((TB_Blanks->at2) & (CheckTableEntryIsBlank_LU->(row2%8)));
	if (bit1) bit1 = true; 
	if (bit2) bit2 = true;
	if (bit1 == bit2) return;
	if (bit1) {
		(TB_Blanks->at1)
			= (TB_Blanks->at1) & (CheckTableEntryIsNonBlank_LU->(row1%8));
		(TB_Blanks->at2)
			= (TB_Blanks->at2) | (CheckTableEntryIsBlank_LU->(row2%8));
	} else {
		(TB_Blanks->at1)
			= (TB_Blanks->at1) | (CheckTableEntryIsBlank_LU->(row1%8));
		(TB_Blanks->at2)
			= (TB_Blanks->at2) & (CheckTableEntryIsNonBlank_LU->(row2%8));
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Moving Blank Bits Down
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableMoveBlankBitsDown tab row1 row2 col at atp1 bit rx;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) return;
	row1--; row2--;
	! Read blank bit for row1:
	at = ((tab-->col)-->2) + (row1/8);
	bit = ((TB_Blanks->at) & (CheckTableEntryIsBlank_LU->(row1%8)));
	if (bit) bit = true;
	! Loop through, setting each blank bit to the next:
	for (rx=row1:rx<row2:rx++) {
		atp1 = ((tab-->col)-->2) + ((rx+1)/8);
		at = ((tab-->col)-->2) + (rx/8);
		if ((TB_Blanks->atp1) & (CheckTableEntryIsBlank_LU->((rx+1)%8))) {
			(TB_Blanks->at)
				= (TB_Blanks->at) | (CheckTableEntryIsBlank_LU->(rx%8));
		} else {
			(TB_Blanks->at)
				= (TB_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(rx%8));
		}
	}
	! Write bit to blank bit for row2:
	at = ((tab-->col)-->2) + (row2/8);
	if (bit) {
		(TB_Blanks->at)
			= (TB_Blanks->at) | (CheckTableEntryIsBlank_LU->(row2%8));
	} else {
		(TB_Blanks->at)
			= (TB_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(row2%8));
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Table Row Corresponding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableRowCorr tab col lookup_value lookup_col i j f v;
	if (col >= 100) col=TableFindCol(tab, col, true);
	lookup_col = tab-->col;
	j = lookup_col-->0 - COL_HSIZE;
	if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED) f=1;
	if (f) {
		for (i=1:i<=j:i++) {
			v = lookup_col-->(i+COL_HSIZE);
			if ((v == TABLE_NOVALUE) &&
				(CheckTableEntryIsBlank(tab,col,i))) continue;
			if (BlkValueCompare(v, lookup_value) == 0)
				return i;
		}
	} else {
		for (i=1:i<=j:i++) {
			if ((lookup_value == TABLE_NOVALUE) &&
				(CheckTableEntryIsBlank(tab,col,i))) continue;
			if (lookup_col-->(i+COL_HSIZE) == lookup_value) return i;
		}
	}
	return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];

[ ExistsTableRowCorr tab col entry i k v f kov;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rfalse;
	f=0;
	if (((tab-->col)-->1) & TB_COLUMN_TOPIC) f=1;
	else if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED) f=2;
	k = TableRows(tab);
	for (i=1:i<=k:i++) {
		v = (tab-->col)-->(i+COL_HSIZE);
		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i))) continue;
		switch (f) {
			1: if ((v)(entry/100, entry%100) ~= GPR_FAIL) return i;
			2: if (BlkValueCompare(v, entry) == 0) return i;
			default: if (v == entry) return i;
		}
	}
	! print "Giving up^";
	return 0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Table Look Up Corresponding Row
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableLookUpCorr tab col1 col2 lookup_value write_flag write_value cola1 cola2 i j v f;
	if (col1 >= 100) col1=TableFindCol(tab, col1, true);
	if (col2 >= 100) col2=TableFindCol(tab, col2, true);
	cola1 = tab-->col1;
	cola2 = tab-->col2;
	j = cola2-->0;
	f=0;
	if (((tab-->col2)-->1) & TB_COLUMN_ALLOCATED) f=1;
	if (((tab-->col2)-->1) & TB_COLUMN_TOPIC) f=2;
	for (i=1+COL_HSIZE:i<=j:i++) {
		v = cola2-->i;

		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col2,i-COL_HSIZE))) continue;
		if (f == 1) {
			if (BlkValueCompare(v, lookup_value) ~= 0) continue;
		} else if (f == 2) {
			if ((v)(lookup_value/100, lookup_value%100) == GPR_FAIL) continue;
		} else {
			if (v ~= lookup_value) continue;
		}
		if (write_flag) {
			if (write_flag == 4) ForceTableEntryBlank(tab,col1,i-COL_HSIZE);
			else ForceTableEntryNonBlank(tab,col1,i-COL_HSIZE);
			switch (write_flag) {
				1: cola1-->i = write_value;
				2: cola1-->i = cola1-->i + write_value;
				3: cola1-->i = cola1-->i - write_value;
				5: return cola1-->i;
			}
			rfalse;
		}
		v = cola1-->i;
		if ((v == TABLE_NOVALUE) &&
			(CheckTableEntryIsBlank(tab,col1,i-COL_HSIZE))) continue;
		return v;
	}
	return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];

[ ExistsTableLookUpCorr tab col1 col2 lookup_value cola1 cola2 i j f;
	if (col1 >= 100) col1=TableFindCol(tab, col1, false);
	if (col2 >= 100) col2=TableFindCol(tab, col2, false);
	if (col1*col2 == 0) rfalse;
	cola1 = tab-->col1; cola2 = tab-->col2;
	j = cola2-->0;
	f=0;
	if (((tab-->col2)-->1) & TB_COLUMN_ALLOCATED) f=1;
	if (((tab-->col2)-->1) & TB_COLUMN_TOPIC) f=2;
	for (i=1+COL_HSIZE:i<=j:i++) {
		if ((cola1-->i == TABLE_NOVALUE) &&
			(CheckTableEntryIsBlank(tab,col1,i-COL_HSIZE))) continue;
		if (f == 1) {
			if (BlkValueCompare(cola2-->i, lookup_value) ~= 0) continue;
		} else if (f == 2) {
			if ((cola2-->i)(lookup_value/100, lookup_value%100) == GPR_FAIL) continue;
		} else {
			if (cola2-->i ~= lookup_value) continue;
		}
		rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Table Look Up Entry
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableLookUpEntry tab col index write_flag write_value v;
	if (tab == 0) return RunTimeProblem(RTP_TABLE_NOTABLE2);
	if (col >= 100) col=TableFindCol(tab, col, true);
	if ((index < 1) || (index > TableRows(tab))) {
		RunTimeProblem(RTP_TABLE_NOROW, tab, index); index = 1;
	}
	if (write_flag) {
		switch(write_flag) {
			1:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) = write_value;
			2:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) =
					((tab-->col)-->(index+COL_HSIZE)) + write_value;
			3:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) =
					((tab-->col)-->(index+COL_HSIZE)) - write_value;
			4:	ForceTableEntryBlank(tab,col,index);
			5:	ForceTableEntryNonBlank(tab,col,index);
				return ((tab-->col)-->(index+COL_HSIZE));
		}
		rfalse;
	}
	v = ((tab-->col)-->(index+COL_HSIZE));
	if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,index))) {
		RunTimeProblem(RTP_TABLE_NOENTRY, tab, col, index); rfalse;
	}
	return v;
];

[ ExistsTableLookUpEntry tab col index v;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rfalse;
	if ((index<1) || (index > TableRows(tab))) rfalse;
	v = ((tab-->col)-->(index+COL_HSIZE));
	if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,index)))
		rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Blank Rows
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableRowIsBlank tab j k;
	for (k=1:k<=tab-->0:k++) {
		if (((tab-->k)-->(j+COL_HSIZE)) ~= TABLE_NOVALUE) rfalse;
		if (CheckTableEntryIsBlank(tab, k, j) == false) rfalse;
	}
	rtrue;
];

[ TableBlankOutRow tab row k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE);
	for (k=1:k<=tab-->0:k++)
		ForceTableEntryBlank(tab, k, row);
];

[ TableBlankOutColumn tab col n k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE);
	n = TableRows(tab);
	for (k=1:k<=n:k++)
		ForceTableEntryBlank(tab, col, k);
];

[ TableBlankOutAll tab n k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE);
	n = TableRows(tab);
	for (k=1:k<=n:k++)
		TableBlankOutRow(tab, k);
];

[ TableBlankRows tab i j c;
	i = TableRows(tab); !print i, " rows^";
	for (j=1:j<=i:j++)
		if (TableRowIsBlank(tab, j)) c++;
	!print c, " blank^";
	return c;
];

[ TableFilledRows tab;
	return TableRows(tab) - TableBlankRows(tab);
];

[ TableBlankRow tab i j;
	i = TableRows(tab);
	for (j=1:j<=i:j++)
		if (TableRowIsBlank(tab, j)) return j;
	RunTimeProblem(RTP_TABLE_NOMOREBLANKS, tab);
	return i;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Random Row
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableRandomRow tab i j k;
	i = TableRows(tab);
	j = TableFilledRows(tab);
	if (j==0) return RunTimeProblem(RTP_TABLE_NOROWS, tab);
	if (j>1) j = random(j);
	for (k=1:k<=i:k++) {
		if (TableRowIsBlank(tab, k) == false) j--;
		if (j==0) return k;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Swap Rows
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableSwapRows tab i j k l v1 v2;
	if (i==j) return;
	l = tab-->0;
	for (k=1:k<=l:k++) {
		v1 = (tab-->k)-->(i+COL_HSIZE);
		v2 = (tab-->k)-->(j+COL_HSIZE);
		(tab-->k)-->(i+COL_HSIZE) = v2;
		(tab-->k)-->(j+COL_HSIZE) = v1;
		if ((v1 == TABLE_NOVALUE) || (v2 == TABLE_NOVALUE))
			TableSwapBlankBits(tab, i, j, k);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Compare Rows
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableCompareRows tab col row1 row2 dir val1 val2 bl1 bl2 f;
	if (col >= 100) col=TableFindCol(tab, col, false);
	val1 = (tab-->col)-->(row1+COL_HSIZE);
	val2 = (tab-->col)-->(row2+COL_HSIZE);
	if (val1 == TABLE_NOVALUE) bl1 = CheckTableEntryIsBlank(tab,col,row1);
	if (val2 == TABLE_NOVALUE) bl2 = CheckTableEntryIsBlank(tab,col,row2);
	if ((val1 == val2) && (bl1 == bl2)) {
		if (val1 ~= TABLE_NOVALUE) return 0;
		if (bl1 == false) return 0;
		! The two entries are both blank:
		if (TableRowIsBlank(tab, row1)) {
		    if (TableRowIsBlank(tab, row2)) return 0;
		    return -1*dir;
		}
		if (TableRowIsBlank(tab, row2)) return dir;
		return 0;
	}
	if (bl1) return dir;
	if (bl2) return -1*dir;
	f = ((tab-->col)-->1);
	if (f & TB_COLUMN_ALLOCATED) {
		if (BlkValueCompare(val2, val1) < 0) return 1;
		return -1;
	} else if (f & TB_COLUMN_REAL) {
		if (REAL_NUMBER_TY_Compare(val1, val2) > 0) return 1;
		return -1;
	} else if (f & TB_COLUMN_SIGNED) {
		if (val1 > val2) return 1;
		return -1;
	} else {
		if (UnsignedCompare(val1, val2) > 0) return 1;
		return -1;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Move Row Down
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableMoveRowDown tab r1 r2 rx k l m v f;
	if (r1==r2) return;
	l = tab-->0;
	for (k=1:k<=l:k++) {
		f = false;
		m = (tab-->k)-->(r1+COL_HSIZE);
		if (m == TABLE_NOVALUE) f = true;
		for (rx=r1:rx<r2:rx++) {
			v = (tab-->k)-->(rx+COL_HSIZE+1);
			(tab-->k)-->(rx+COL_HSIZE) = v;
			if (v == TABLE_NOVALUE) f = true;
		}
		(tab-->k)-->(r2+COL_HSIZE) = m;
		if (f) TableMoveBlankBitsDown(tab, r1, r2, k);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Shuffle
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableShuffle tab i to;
	TableMoveBlanksToBack(tab, 1, TableRows(tab));
	to = TableFilledRows(tab);
	for (i=2:i<=to:i++) TableSwapRows(tab, i, random(i));
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Next Row
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableNextRow tab col row dir i k val v dv min_dv min_at signed_arithmetic f blk z;
	if (col >= 100) col=TableFindCol(tab, col, false);
	f = ((tab-->col)-->1);
	if (f & TB_COLUMN_ALLOCATED) blk = true;
	signed_arithmetic = f & TB_COLUMN_SIGNED;
	#Iftrue (WORDSIZE == 2);
	if (row == 0) {
		if (signed_arithmetic) {
		    if (dir == 1) val = $8000; else val = $7fff;
		} else {
		    if (dir == 1) val = 0; else val = $ffff;
		}
	} else val = (tab-->col)-->(row+COL_HSIZE);
	if (signed_arithmetic) min_dv = $7fff; else min_dv = $ffff;
	#ifnot; ! WORDSIZE == 4
	if (row == 0) {
		if (signed_arithmetic) {
		    if (dir == 1) val = $80000000; else val = $7fffffff;
		} else {
		    if (dir == 1) val = 0; else val = $ffffffff;
		}
	} else val = (tab-->col)-->(row+COL_HSIZE);
	if (signed_arithmetic) min_dv = $7fffffff; else min_dv = $ffffffff;
	#endif;
	k = TableRows(tab);
	if (dir == 1) {
		for (i=1:i<=k:i++) {
		    v = (tab-->col)-->(i+COL_HSIZE);
		    if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
		    	continue;
		    if (blk) {
		    	dv = v;
				if (row == 0) z = 1; else z = BlkValueCompare(v, val);
				f = (((z > 0) || ((z == 0) && (i > row))) &&
					((min_at == 0) || (BlkValueCompare(v, min_dv) < 0)));
		    } else {
				dv = dir*v;
				if (signed_arithmetic)
				f = (((dv > dir*val) || ((v == val) && (i>row))) &&
					  (dv < min_dv));
				else
				f = (((UnsignedCompare(dv, dir*val) > 0) || ((v == val) && (i>row))) &&
					  (UnsignedCompare(dv, min_dv) < 0));
			}
		    if (f) { min_dv = dv; min_at = i; }
		}
	} else {
		for (i=k:i>=1:i--) {
		    v = (tab-->col)-->(i+COL_HSIZE);
		    if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
		    	continue;
		    if (blk) {
		    	dv = v;
		    	if (row == 0) z = -1; else z = BlkValueCompare(v, val);
				f = (((z < 0) || ((z == 0) && (i < row))) &&
					((min_at == 0) || (BlkValueCompare(v, min_dv) > 0)));
		    } else {
				dv = dir*v;
				if (signed_arithmetic)
				f = (((dv > dir*val) || ((v == val) && (i<row))) &&
					  (dv < min_dv));
				else
				f = (((UnsignedCompare(dv, dir*val) > 0) || ((v == val) && (i<row))) &&
					  (UnsignedCompare(dv, min_dv) < 0));
			}
		    if (f) { min_dv = dv; min_at = i; }
		}
	}
	return min_at;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Move Blanks to Back
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableMoveBlanksToBack tab fromrow torow i fbl lnbl blc;
	if (torow < fromrow) return;
	fbl = 0; lnbl = 0;
	for (i=fromrow: i<=torow: i++)
		if (TableRowIsBlank(tab, i)) {
			if (fbl == 0) fbl = i;
			blc++;
		} else {
			lnbl = i;
		}
	if ((fbl>0) && (lnbl>0) && (fbl < lnbl)) {
		TableMoveRowDown(tab, fbl, lnbl); ! Move first blank just past last nonblank
		TableMoveBlanksToBack(tab, fbl, lnbl-1);
	}
	return torow-blc; ! Final non-blank row
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Sort
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableSort tab col dir test_flag algorithm i j k f;
	for (i=1:i<=tab-->0:i++) {
		j = tab-->i; ! Address of column table
		if ((j-->1) & TB_COLUMN_DONTSORTME)
		    return RunTimeProblem(RTP_TABLE_CANTSORT, tab);
	}
	if (col >= 100) col=TableFindCol(tab, col, false);
	k = TableRows(tab);
	k = TableMoveBlanksToBack(tab, 1, k);
	if (test_flag) {
		print "After moving blanks to back:^"; TableColumnDebug(tab, col);
	}

	SetSortDomain(TableSwapRows, TableCompareRows);
	SortArray(tab, col, dir, k, test_flag, algorithm);

	if (test_flag) {
		print "Final state:^"; TableColumnDebug(tab, col);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Print Table Name
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintTableName T;
	switch(T) {
  TheEmptyTable: print "(the empty table)"; return;
  T0_final_question_options: print "Table of Final Question Options"; return;
  T1_locale_priorities: print "Table of Locale Priorities"; return;
  T2_ordinary_status: print "Table of Ordinary Status"; return;
  T3_user_styles: print "Table of User Styles"; return;
  T4_all_known_facts: print "Table of All Known Facts"; return;
  T5_walls: print "Table of Walls"; return;
  T6_floors: print "Table of Floors"; return;
  T7_ceilings: print "Table of Ceilings"; return;
  T8_excuses: print "Table of Excuses"; return;
  T9_frustrated_taking: print "Table of Frustrated Taking"; return;
  T10_scored_listing: print "Table of Scored Listing"; return;
  T11_list_style_assignments: print "Table of List Style Assignments"; return;
  T12_exit_status: print "Table of Exit Status"; return;
  T13_standard_status: print "Table of Standard Status"; return;
  T14_exit_symbols: print "Table of Exit Symbols"; return;
  T18_fancy_status: print "Table of Fancy Status"; return;
  T19_transitions: print "Table of Transitions"; return;

		default: print "** No such table **";
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Print Table to File
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TablePrint tab i j k row col v tc kov;
	for (i=1:i<=tab-->0:i++) {
		j = tab-->i; ! Address of column table
		if (((j-->1) & TB_COLUMN_CANEXCHANGE) == 0)
		    rtrue;
	}
	k = TableRows(tab);
	k = TableMoveBlanksToBack(tab, 1, k);
	print "! ", (PrintTableName) tab, " (", k, ")^";
	for (row=1:row<=k:row++) {
		for (col=1:col<=tab-->0:col++) {
			tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
			kov = KindAtomic(TC_KOV(tc));
			if (kov == UNKNOWN_TY) kov = NUMBER_TY;
			v = (tab-->col)-->(row+COL_HSIZE);
			if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,row)))
				print "-- ";
			else {
				if (BlkValueWriteToFile(v, kov) == false) print v;
				print " ";
			}
		}
		print "^";
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Read Table from File
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifdef TARGET_GLULX;
[ TableRead tab auxf row maxrow col ch v sgn dg j tc kov;
	for (col=1:col<=tab-->0:col++) {
		j = tab-->col; ! Address of column table
		if (((j-->1) & TB_COLUMN_CANEXCHANGE) == 0)
		    return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
	}
	maxrow = TableRows(tab);
	!print maxrow, " rows available.^";
	for (row=1: row<=maxrow: row++) {
		TableBlankOutRow(tab, row);
	}
	for (row=1: row<=maxrow: row++) {
		!print "Reading row ", row, "^";
		ch = FileIO_GetC(auxf);
		if (ch == '!') {
			while (ch ~= -1 or 10 or 13) ch = FileIO_GetC(auxf);
			while (ch == 10 or 13) ch = FileIO_GetC(auxf);
		}
		for (col=1: col<=tab-->0: col++) {
			if (ch == -1) { row++; jump NoMore; }
			if (ch == 10 or 13) break;
			tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
			kov = KindAtomic(TC_KOV(tc));
			if (kov == UNKNOWN_TY) kov = NUMBER_TY;
			!print "tc = ", tc, " kov = ", kov, "^";
			sgn = 1;
			if (ch == '-') {
				ch = FileIO_GetC(auxf);
				if (ch == -1) jump NotTable;
				if (ch == '-') { ch = FileIO_GetC(auxf); jump EntryDone; }
				sgn = -1;
			}
			if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED)
				ForceTableEntryNonBlank(tab, col, row);
			!print "A";
			v = BlkValueReadFromFile(0, 0, -1, kov);
			if (v) {
				if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED)
					v = BlkValueReadFromFile(TableLookUpEntry(tab, col, row),
						auxf, ch, kov);
				else
					v = BlkValueReadFromFile(0, auxf, ch, kov);
				ch = 32;
			} else {
				dg = ch - '0';
				if ((dg < 0) || (dg > 9)) jump NotTable;
				v = dg;
				for (::) {
					ch = FileIO_GetC(auxf);
					dg = ch - '0';
					if ((dg < 0) || (dg > 9)) break;
					v = 10*v + dg;
				}
				v = v*sgn;
			}
			!print "v=", v, " ";
			if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED == 0)
				TableLookUpEntry(tab, col, row, true, v);
			.EntryDone;
			!print "First nd is ", ch, "^";
			while (ch == 9 or 32) ch = FileIO_GetC(auxf);
		}
		while (ch ~= -1 or 10 or 13) {
			if ((ch ~= '-') && (((ch-'0')<0) || ((ch-'0')>9))) jump NotTable;
			if (ch ~= 9 or 32) jump WontFit;
			ch = FileIO_GetC(auxf);
		}
	}
	.NoMore;
	while (ch == 9 or 32 or 10 or 13) ch = FileIO_GetC(auxf);
	if (ch == -1) return;
	.WontFit;
	return RunTimeProblem(RTP_TABLE_WONTFIT, tab);
	.NotTable;
	return RunTimeProblem(RTP_TABLE_BADFILE, tab);
];
#ENDIF; ! TARGET_GLULX


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Print Rank
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintRank i j v;
#ifdef RANKING_TABLE;
	ANNOUNCE_SCORE_RM('B');
	j = TableRows(RANKING_TABLE);
	for (i=j:i>=1:i--)
		if (score >= TableLookUpEntry(RANKING_TABLE, 1, i)) {
		    v = TableLookUpEntry(RANKING_TABLE, 2, i);
		    TEXT_TY_Say(v);
		    ".";
		}
#endif;
	".";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tables.i6t: Debugging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TableColumnDebug tab col k i v tc kov;
	if (col >= 100) col=TableFindCol(tab, col, false);
	k = TableRows(tab);
	tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
	kov = TC_KOV(tc);
	for (i=1:i<=k:i++) {
		if (i>1) print ", ";
		v = (tab-->col)-->(i+COL_HSIZE);
		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
			print "--";
		else {
			PrintKindValuePair(kov, v);
		}
	}
	say__p = 1;
];

[ TableRowDebug tab i col k v tc kov;
	k = TableRows(tab);
	if ((i<1) || (i>k)) "No such row";
	print "(row ", i, ")  |";
	for (col=1: col<=tab-->0: col++) {
		print " ";
		tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
		kov = TC_KOV(tc);
		v = (tab-->col)-->(i+COL_HSIZE);
		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
			print "-- ";
		else {
			PrintKindValuePair(kov, v);
			print " |";
		}
	}
	say__p = 1;
];

[ TableDebug tab i k;
	PrintTableName(tab); print "^";
	k = TableRows(tab);
	for (i=1:i<=k:i++) { TableRowDebug(tab, i); print "^"; }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: The Core Tree
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ HolderOf o;
	if (InitialSituation-->DONE_INIS == false) return thedark;
	if (o && (o.component_parent)) return o.component_parent;
	if (o && (parent(o))) return parent(o);
	return nothing;
];

[ ParentOf o;
	if (o) o = parent(o);
	return o;
];

[ CoreOf o;
	while (o && (o provides component_parent) && (o.component_parent)) o = o.component_parent;
	return o;
];

[ CoreOfParentOfCoreOf o;
	while (o && (o provides component_parent) && (o.component_parent)) o = o.component_parent;
	if (o) o = parent(o);
	while (o && (o provides component_parent) && (o.component_parent)) o = o.component_parent;
	return o;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Climbing the Core Tree
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LocationOf o;
	if (~~(o ofclass K1_room or K2_thing)) return nothing;
	if (o ofclass K4_door) {
		if (parent(o) == real_location) return real_location;
		return FrontSideOfDoor(o);
	}
	if (o ofclass K7_backdrop) {
		! print "(deciding ", (the) O, " is at ", (the) BackdropLocation(o), ") ";
		return BackdropLocation(o);
	}
	while (o) {
		if (o ofclass K1_room) return o;
		o = CoreOfParentOfCoreOf(o);
	}
	return nothing;
];

[ CommonAncestor o1 o2 i j;
	o1 = CoreOf(o1);
	o2 = CoreOf(o2);
	
	for (i=o1: i: i = CoreOfParentOfCoreOf(i))
		for (j=o2: j: j = CoreOfParentOfCoreOf(j))
			if (j == i) return j;

	return nothing;
];

[ IndirectlyContains o1 o2;
	if ((o1 == nothing) || (o2 == nothing)) rfalse;
	if ((o1 ofclass K1_room) && (o2 ofclass K4_door)) {
		if (o1 == FrontSideOfDoor(o2)) rtrue;
		if (o1 == BackSideOfDoor(o2)) rtrue;
		rfalse;
	}
	if (o2 ofclass K7_backdrop) rfalse;
	for (o2 = HolderOf(o2) : o2 && o2 ~= thedark : o2 = HolderOf(o2)) if (o2 == o1) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: To Decide Whether In
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WhetherIn obj;
	if (obj has enterable) {
		if (IndirectlyContains(obj, player)) rtrue;
		rfalse;
	}
	if (obj ofclass K9_region) return TestRegionalContainment(real_location, obj);
	if (obj ofclass K1_room) {
		if (obj == real_location) rtrue;
		rfalse;
	}
	RunTimeProblem(RTP_NOTINAROOM, obj);
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Containment Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ContainerOf A p;
	if (A ofclass K1_room) return A.map_region;
	p = parent(A);
	if (p == nothing) return nothing;
	if (p ofclass K5_container) return p;
	if (p ofclass K1_room) return p;
	if (p ofclass K9_region) return p;
	return nothing;
];

[ TestContainmentRange obj e f;
	if (obj ofclass K9_region) {
		objectloop (f ofclass K1_room && f.map_region == obj)
			if (f > e) return f;
		return nothing;
	}
	if (obj ofclass K5_container or K1_room) {
		if (e == nothing) return child(obj);
		return sibling(e);
	}
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Support Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SupporterOf obj p;
	p = parent(obj);
	if (p == nothing) return nothing;
	if (p ofclass K6_supporter) return p;
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Carrying Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CarrierOf obj p;
	p = parent(obj);
	if (p && (p ofclass K8_person) && (obj hasnt worn)) return p;
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Wearing Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WearerOf obj p;
	p = parent(obj);
	if (p && (p ofclass K8_person) && (obj has worn)) return p;
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Having Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ OwnerOf obj p;
	p = parent(obj);
	if (p && (p ofclass K8_person)) return p;
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Making Parts
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MakePart P Of First;
	if (P == player) return RunTimeProblem(RTP_CANTMAKEPART, Of);
	if (parent(P)) remove P; give P ~worn;
	if (Of == nothing) { DetachPart(P); return; }
	if (P.component_parent) DetachPart(P);
	P.component_parent = Of;
	First = Of.component_child;
	Of.component_child = P; P.component_sibling = First;
];

[ DetachPart P From Daddy O;
	Daddy = P.component_parent; P.component_parent = nothing;
	if (Daddy == nothing) { P.component_sibling = nothing; return; }
	if (Daddy.component_child == P) {
		Daddy.component_child = P.component_sibling;
		P.component_sibling = nothing; return;
	}
	for (O = Daddy.component_child: O: O = O.component_sibling)
		if (O.component_sibling == P) {
			O.component_sibling = P.component_sibling;
			P.component_sibling = nothing; return;
		}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Movements
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MoveObject F T opt going_mode was L;
	if (F == nothing) return RunTimeProblem(RTP_CANTMOVENOTHING);
	if (F ofclass K7_backdrop) {
		if (T ofclass K9_region) {
			give F ~absent; F.found_in = T.regional_found_in;
			if (TestRegionalContainment(LocationOf(player), T)) move F to LocationOf(player);
			else remove F;
			return; }
		if (T == FoundEverywhere) {
			give F ~absent; F.found_in = FoundEverywhere;
			return;
		}
		return RunTimeProblem(RTP_BACKDROP, F, T);
	}
	if (T ofclass K9_region) return RunTimeProblem(RTP_NOTBACKDROP, F, T);
	if (T == FoundEverywhere) return RunTimeProblem(RTP_BACKDROPONLY, F);
	if (~~(F ofclass K2_thing)) return RunTimeProblem(RTP_NOTTHING, F, T);
	if (F has worn) {
		give F ~worn;
		if (F in T) return;
	}
	DetachPart(F);
	if (going_mode == false) {
		if (F == player) { PlayerTo(T, opt); return; }
		if (IndirectlyContains(F, player)) {
			L = LocationOf(T);
			if (L == nothing) return RunTimeProblem(RTP_CANTBEOFFSTAGE);
			if (LocationOf(player) ~= L) {
				was = parent(player);
				move player to real_location;
				move F to T;
				PlayerTo(was, true);
				return;
			}
		}
	}
	move F to T;
];

[ RemoveFromPlay F;
	if (F == nothing) return RunTimeProblem(RTP_CANTREMOVENOTHING);
	if (F == player) return RunTimeProblem(RTP_CANTREMOVEPLAYER);
	if (F ofclass K4_door) return RunTimeProblem(RTP_CANTREMOVEDOORS);
	if (IndirectlyContains(F, player)) return RunTimeProblem(RTP_CANTBEOFFSTAGE);
	give F ~worn; DetachPart(F);
	if (F ofclass K7_backdrop) give F absent;
	remove F;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: On Stage
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ OnStage O set x;
	if (O ofclass K1_room) rfalse;
	if (set < 0) {
		while (metaclass(O) == Object) {
			if (O ofclass K1_room) rtrue;
			if (O ofclass K9_region) rfalse;
			if (O ofclass K4_door) rtrue;
			if (O ofclass K7_backdrop) { if (O has absent) rfalse; rtrue; }
			x = O.component_parent; if (x) { O = x; continue; }
			x = parent(O); if (x) { O = x; continue; }
			rfalse;
		}
	}
	x = OnStage(O, -1);
	if ((x) && (set == false)) RemoveFromPlay(O);
	if ((x == false) && (set)) MoveObject(O, real_location);
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Moving the Player
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PlayerTo newplace flag L;
    L = LocationOf(newplace);
   	if (L == nothing) return RunTimeProblem(RTP_CANTBEOFFSTAGE);
	@push actor; actor = player;
    move player to newplace;
    location = L;
    real_location = location;
    MoveFloatingObjects();
    SilentlyConsiderLight();
    DivideParagraphPoint();
    if (flag == 0) <Look>;
    if (flag == 1) give location visited;
    if (flag == 2) AbbreviatedRoomDescription();
    @pull actor;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Move During Going
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MoveDuringGoing F T;
	MoveObject(F, T, 0, true);
	if (actor == player) {
		location = LocationOf(player);
		real_location = location;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Being Everywhere
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FoundEverywhere; rtrue; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Testing Everywhere
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BackdropEverywhere O;
	if (O ofclass K7_backdrop) {
		if (O has absent) rfalse;
		if (O.found_in == FoundEverywhere) rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Changing the Player
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ChangePlayer obj flag;
	if (~~(obj ofclass K8_person)) return RunTimeProblem(RTP_CANTCHANGE, obj);
	if (~~(OnStage(obj, -1))) return RunTimeProblem(RTP_CANTCHANGEOFFSTAGE, obj);
	if (obj.component_parent) return RunTimeProblem(RTP_CANTMAKEPART, obj);
	if (obj == player) return;

    give player ~concealed;
    if (player has remove_proper) give player ~proper;
    if (player == selfobj) {
    	player.saved_short_name = player.short_name;
    	player.short_name = PRINT_PROTAGONIST_INTERNAL_RM('c');
    }
    player = obj;
    if (player == selfobj) {
    	player.short_name = player.saved_short_name;
    }
    if (player hasnt proper) give player remove_proper; ! when changing out again
    give player concealed proper;

    location = LocationOf(player); real_location = location;
    MoveFloatingObjects();
    SilentlyConsiderLight();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Floating Objects
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MoveFloatingObjects toroom i k l m address flag;
	if (toroom == nothing) toroom = real_location;
    if (toroom == nothing) return;
    objectloop (i) {
        address = i.&found_in;
        if (address ~= 0 && i hasnt absent) {
            if (ZRegion(address-->0) == 2) {
                m = address-->0;
                .TestPropositionally;
                if (m.call(toroom) ~= 0) move i to toroom;
                else { if (i in toroom) remove i; }
            } else {
                k = i.#found_in;
                for (l=0 : l<k/WORDSIZE : l++) {
                    m = address-->l;
                    if (ZRegion(m) == 2) jump TestPropositionally;
                    if (m == toroom || m in toroom) {
                        if (i notin toroom) move i to toroom;
                        flag = true;
                    }
                }
                if (flag == false) { if (i in toroom) remove i; }
            }
            if ((i ofclass K4_door) && (parent(i) == nothing)) {
            	move i to ((i.door_to).call());
            }
        }
    }
];

[ MoveBackdrop bd D x address;
	if (~~(bd ofclass K7_backdrop)) return RunTimeProblem(RTP_BACKDROPONLY, bd);
	if (bd.#found_in > WORDSIZE) {
		address = bd.&found_in;
		address-->0 = D;
	} else bd.found_in = D;
	give bd ~absent;
	MoveFloatingObjects();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Backdrop Location
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BackdropLocation O target address m x i k l r sl;
	if (O has absent) return nothing;
	if ((target == nothing or real_location) && (parent(O) == real_location))
		return real_location;
	address = O.&found_in;
	if (address ~= 0) {
		k = O.#found_in;
		for (l=0 : l<k/WORDSIZE : l++) {
			m = address-->l;
			if (ZRegion(m) == 2) {
				sl = location;
				if (target) {
					location = target;
					r = m.call();
					if (r ~= 0) { location = sl; return target; }
				} else {
					objectloop (x ofclass K1_room) {
						location = x;
						r = m.call();
						if (r ~= 0) { location = sl; return x; }
					}
				}
				location = sl;
			} else {
				if (m ofclass K9_region) {
					objectloop (x ofclass K1_room)
						if (TestRegionalContainment(x, m))
							if (target == nothing or x)
								return x;
				} else {
					if (target == nothing or m) return m;
				}
			}
		}
	}
	return nothing;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Wearing Clothes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WearObject X P opt;
	if (X == false) rfalse;
	if (X notin P) MoveObject(X, P, opt);
	give X worn;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Map Connections
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ MapConnection from_room dir
	in_direction through_door;
	if ((from_room ofclass K1_room) && (dir ofclass K3_direction)) {
		in_direction = Map_Storage-->
			((from_room.IK1_Count)*No_Directions + dir.IK3_Count);
		if (in_direction ofclass K1_room) return in_direction;
		if (in_direction ofclass K4_door) {
			@push location;
			location = from_room;
			through_door = in_direction.door_to();
			@pull location;
			if (through_door ofclass K1_room) return through_door;
		}
	}
	return nothing;
];

[ DoorFrom obj dir rv;
	rv = RoomOrDoorFrom(obj, dir);
	if (rv ofclass K4_door) return rv;
	return nothing;
];

[ RoomOrDoorFrom obj dir use_doors in_direction sl through_door;
	if ((obj ofclass K1_room) && (dir ofclass K3_direction)) {
		in_direction = Map_Storage-->
			((obj.IK1_Count)*No_Directions + dir.IK3_Count);
		if (in_direction ofclass K1_room or K4_door) return in_direction;	
	}
	return nothing;
];

[ AssertMapConnection r1 dir r2 in_direction;
	SignalMapChange();
	in_direction = Map_Storage-->
		((r1.IK1_Count)*No_Directions + dir.IK3_Count);
	if ((in_direction == 0) || (in_direction ofclass K1_room)) {
		Map_Storage-->((r1.IK1_Count)*No_Directions + dir.IK3_Count) = r2;
		return;
	}
	if (in_direction ofclass K4_door) {
		RunTimeProblem(RTP_EXITDOOR, r1, dir);
		return;
	}
	RunTimeProblem(RTP_NOEXIT, r1, dir);
];

[ AssertMapUnconnection r1 dir r2 in_direction;
	SignalMapChange();
	in_direction = Map_Storage-->
		((r1.IK1_Count)*No_Directions + dir.IK3_Count);
	if (r1 ofclass K4_door) {
		RunTimeProblem(RTP_EXITDOOR, r1, dir);
		return;
	}
	if (in_direction == r2)
		Map_Storage-->((r1.IK1_Count)*No_Directions + dir.IK3_Count) = 0;
	return;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Adjacency Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestAdjacency R1 R2 i row;
	if (R1 ofclass K9_region) RunTimeProblem(RTP_REGIONSNOTADJACENT, R1);
	else if (R2 ofclass K9_region) RunTimeProblem(RTP_REGIONSNOTADJACENT, R2);
	row = (R1.IK1_Count)*No_Directions;
	for (i=0: i<No_Directions: i++, row++)
		if (Map_Storage-->row == R2) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Regional Containment Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestRegionalContainment obj region o;
	if ((obj == nothing) || (region == nothing)) rfalse;
	if (obj ofclass K7_backdrop or K4_door) {
		if (obj has absent) rfalse;
		objectloop (o ofclass K1_room)
			if (TestRegionalContainment(o, region))
				if (BackdropLocation(obj, o))
					rtrue;
		rfalse;
	}
	if (~~(obj ofclass K1_room)) obj = LocationOf(obj);
	if (obj == nothing) rfalse;
	o = obj.map_region;
	while (o) {
		if (o == region) rtrue;
		o = parent(o);
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Doors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FrontSideOfDoor D; if (~~(D ofclass K4_door)) rfalse;
	if (D provides found_in) return (D.&found_in)-->0; ! Two-sided
	return parent(D); ! One-sided
];

[ BackSideOfDoor D; if (~~(D ofclass K4_door)) rfalse;
	if (D provides found_in) return (D.&found_in)-->1; ! Two-sided
	return nothing; ! One-sided
];

[ OtherSideOfDoor D from_room rv;
	if (D ofclass K4_door) {
		@push location;
		location = LocationOf(from_room);
		rv = D.door_to();
		@pull location;
	}
	return rv;
];

[ DirectionDoorLeadsIn D from_room rv dir;
	if (D ofclass K4_door) {
		@push location;
		location = LocationOf(from_room);
		rv = D.door_dir();
		@pull location;
	}
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Visibility Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestVisibility A B;
	if (~~OffersLight(parent(CoreOf(A)))) rfalse;
	if (suppress_scope_loops) rtrue;
	return TestScope(B, A);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Touchability Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestTouchability A B rv;
	if (A ofclass K4_door or K7_backdrop) MoveFloatingObjects(LocationOf(B));
	if (B ofclass K4_door or K7_backdrop) MoveFloatingObjects(LocationOf(A));
	if (TestScope(B,A) == false) rv = true;
	else rv = ObjectIsUntouchable(B, true, A);
	if (A ofclass K4_door or K7_backdrop) MoveFloatingObjects();
	if (rv) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! WorldModel.i6t: Concealment Relation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TestConcealment A B;
	if (A ofclass K2_thing && B ofclass K2_thing) {
		particular_possession = B;
		if (CarryOutActivity(DECIDING_CONCEALED_POSSESS_ACT, A)) rtrue;
	}
	rfalse;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Parsing Tokens
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


[ Cond_Token_202 ;
    if (((((Global_Vars-->11) ofclass K2_thing)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_188 ;
    if (((((Adj_123_t1_v10(real_location)))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_189 ;
    if ((((((Adj_123_t1_v10(real_location))))) && (((~~(((Adj_55_t1_v10(real_location))))))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];




! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Number.i6t: Understanding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DECIMAL_TOKEN wnc wna r n wa wl sign base digit digit_count original_wn group_wn;
	wnc = wn; original_wn = wn; group_wn = wn;

	wn = wnc;
	r = ParseTokenStopped(ELEMENTARY_TT, NUMBER_TOKEN);
	if ((r == GPR_NUMBER) && (parsed_number ~= 10000)) return r;
	wn = wnc;
	wa = WordAddress(wn);
	wl = WordLength(wn);
	sign = 1; base = 10; digit_count = 0;
	if (wa->0 ~= '-' or '$' or '0' or '1' or '2' or '3' or '4'
		or '5' or '6' or '7' or '8' or '9')
		return GPR_FAIL;
	if (wa->0 == '-') { sign = -1; wl--; wa++; }
	if (wl == 0) return GPR_FAIL;
	n = 0;
	while (wl > 0) {
		if (wa->0 >= 'a') digit = wa->0 - 'a' + 10;
		else digit = wa->0 - '0';
		digit_count++;
		switch (base) {
			2:  if (digit_count == 17) return GPR_FAIL;
			10:
				#Iftrue (WORDSIZE == 2);
				if (digit_count == 6) return GPR_FAIL;
				if (digit_count == 5) {
					if (n > 3276) return GPR_FAIL;
					if (n == 3276) {
						if (sign == 1 && digit > 7) return GPR_FAIL;
						if (sign == -1 && digit > 8) return GPR_FAIL;
					}
				}
				#Ifnot; ! i.e., if (WORDSIZE == 4)
				if (digit_count == 11) return GPR_FAIL;
				if (digit_count == 10) {
					if (n > 214748364) return GPR_FAIL;
					if (n == 214748364) {
						if (sign == 1 && digit > 7) return GPR_FAIL;
						if (sign == -1 && digit > 8) return GPR_FAIL;
					}
				}
				#Endif; 
			16: if (digit_count == 5) return GPR_FAIL;
		}
		if (digit >= 0 && digit < base) n = base*n + digit;
		else return GPR_FAIL;
		wl--; wa++;
	}
	parsed_number = n*sign; wn++;
	return GPR_NUMBER;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Number.i6t: Truth states
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TRUTH_STATE_TOKEN original_wn wd;
	original_wn = wn;

	wn = original_wn;
	wd = NextWordStopped();
	if (wd == 'true') { parsed_number = 1; return GPR_NUMBER; }
	if (wd == 'false') { parsed_number = 0; return GPR_NUMBER; }
	wn = original_wn;
	return GPR_FAIL;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Number.i6t: Absolute value
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NUMBER_TY_Abs x; if (x<0) return -x; return x; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RealNumber.i6t: Printing reals
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Ifdef TARGET_GLULX;

[ REAL_NUMBER_TY_Say fp;
	print (Float) fp;
];

[ REAL_NUMBER_TY_Compare r1 r2;
	@jflt r1 r2 ?less;
	@jfeq r1 r2 0 ?same;
	return 1;
	.same; return 0;
	.less; return -1;
];

[ NUMBER_TY_to_REAL_NUMBER_TY int real; @numtof int real; return real; ];
[ REAL_NUMBER_TY_to_NUMBER_TY real int; @ftonumn real int; return int; ];

[ REAL_NUMBER_TY_Sin in out; @sin in out; return out; ];
[ REAL_NUMBER_TY_Cos in out; @cos in out; return out; ];
[ REAL_NUMBER_TY_Tan in out; @tan in out; return out; ];
[ REAL_NUMBER_TY_Arcsin in out; @asin in out; return out; ];
[ REAL_NUMBER_TY_Arccos in out; @acos in out; return out; ];
[ REAL_NUMBER_TY_Arctan in out; @atan in out; return out; ];

[ REAL_NUMBER_TY_Sinh in tmp out;
	@exp in tmp;
	@fsub M_0 in in;
	@exp in out;
	@fadd tmp out out;
	@fmul out M_HALF out;
	return out;
];

[ REAL_NUMBER_TY_Cosh in tmp out;
	@exp in tmp;
	@fsub M_0 in in;
	@exp in out;
	@fsub tmp out out;
	@fmul out M_HALF out;
	return out;
];

[ REAL_NUMBER_TY_Tanh in tmp out;
	tmp = REAL_NUMBER_TY_Sinh(in);
	in = REAL_NUMBER_TY_Cosh(in);
	@fdiv tmp in out;
	return out;
];

[ REAL_NUMBER_TY_Reciprocal in out; @fdiv M_1 in out; return out; ];
[ REAL_NUMBER_TY_Negate in out; @fsub M_0 in out; return out; ];
[ REAL_NUMBER_TY_Plus x y out; @fadd x y out; return out; ];
[ REAL_NUMBER_TY_Minus x y out; @fsub x y out; return out; ];
[ REAL_NUMBER_TY_Times x y out; @fmul x y out; return out; ];
[ REAL_NUMBER_TY_Divide x y out; @fdiv x y out; return out; ];
[ REAL_NUMBER_TY_Remainder x y r q; @fmod x y r q; return r; ];
[ REAL_NUMBER_TY_Approximate x y quotient out;
	@fdiv x y quotient;
	@fadd quotient M_HALF quotient;
	@floor quotient quotient;
	@fmul quotient y out;
	return out;
];
[ REAL_NUMBER_TY_Root x out; @sqrt x out; return out; ];
[ REAL_NUMBER_TY_Cube_Root x out; @pow x M_THIRD out; return out; ];
[ REAL_NUMBER_TY_Pow x y out; @pow x y out; return out; ];
[ REAL_NUMBER_TY_Exp x out; @exp x out; return out; ];
[ REAL_NUMBER_TY_Log x out; @log x out; return out; ];
[ REAL_NUMBER_TY_BLog x n d out;
	@log x out;
	if (n == 10) d = M_LOG10;
	else {
		@numtof n d;
		@log d d;
	}
	@fdiv out d out;
	return out;
];
[ REAL_NUMBER_TY_Floor x out; @floor x out; return out; ];
[ REAL_NUMBER_TY_Ceiling x out; @ceil x out; return out; ];
[ REAL_NUMBER_TY_Abs x; return x & $7fffffff; ];
[ REAL_NUMBER_TY_Nan x; @jisnan x ?Nan; rfalse; .Nan; rtrue; ];

Constant M_0    = $0;
Constant M_1    = $3F800000;
Constant M_HALF = $3F000000; ! 1/3
Constant M_THIRD = $3EAAAAAB; ! 1/3
Constant M_LOG10 = $40135D8E; ! log(10)
Constant M_N1   = $BF800000; ! -1
Constant M_PI   = $40490FDB;
Constant M_NPI  = $C0490FDB;
Constant M_2PI  = $40C90FDB; ! 2*pi
Constant M_PI2  = $3FC90FDB; ! pi/2
Constant M_NPI2 = $BFC90FDB; 
Constant M_E    = $402DF854;
Constant M_E2   = $40EC7326; ! e^2
Constant M_N0   = $80000000; ! negative zero
Constant M_INF  = $7F800000; ! infinity
Constant M_NINF = $FF800000; ! negative infinity
Constant M_NAN  = $7F800001; ! one of many NaN values
Constant M_NNAN = $FF800001; ! another, with a sign bit

! Floating-point parsing routines.

! Parse a float from a text buffer. Returns a float value, or FLOAT_NAN if
! no value was understood.
!
! The recognized format, if you'll pardon a slightly bastardized regexp
! syntax, is "S?D*(PD*)?(ES?D+)?" where S is a sign character "+" or "-",
! D is a decimal digit "0" to "9", P is a decimal point ".",
! and E is the exponential modifier "E" or "e".
!
! For flexibility, the string "M10^" is also accepted for E, where M is
! "X", "x", "*", or the multiplication sign @{D7}. Optional spaces are
! allowed before and after the M sign. (But only for the "10^" form of
! the exponent, not the "e" form.)
!
! This routine does not try to recognize special names for infinity or NaN,
! but it can return FLOAT_INFINITY or FLOAT_NINFINITY if the exponent is too
! large.
!
! This routine relies on floating-point math. Therefore, the same string
! may parse to slightly different float values on different interpreters!
! Be warned.
!
! If useall is true, this insists on using all len characters from the buffer.
! (It returns FLOAT_NAN if any unrecognized characters are left over.)
! Contrariwise, if useall is false, unused characters at the end of the buffer
! are fine. (But not at the beginning; the float must start at the beginning
! of the buffer.)
! 
[ FloatParse buf len useall
	res ix val ch ten negative intpart fracpart fracdiv
	expon expnegative count;
	
!	print "FloatParse <";
!	for (ix=0: ix<len: ix++) print (char) buf->ix;
!	print ">^";

	if (len == 0)
		return FLOAT_NAN;
		
	ix = 0;
	negative = false;
	intpart = 0;
	fracpart = 0;
	@numtof 10 ten;

	! Sign character (optional)
	ch = buf->ix;
	if (ch == '-') {
		negative = true;
		ix++;
	}
	else if (ch == '+') {
		ix++;
	}

	! Some digits (optional)
	for (count=0 : ix<len : ix++, count++) {
		ch = buf->ix;
		if (ch < '0' || ch > '9')
			break;
		val = (ch - '0');
		@numtof val val;
		@fmul intpart ten intpart;
		@fadd intpart val intpart;
	}

	! Decimal point and more digits (optional)
	if (ix<len && buf->ix == '.') {
		ix++;
		@numtof 1 fracdiv;
		for ( : ix<len : ix++, count++) {
			ch = buf->ix;
			if (ch < '0' || ch > '9')
				break;
			val = (ch - '0');
			@numtof	val val;
			@fmul fracpart ten fracpart;
			@fadd fracpart val fracpart;
			@fmul fracdiv ten fracdiv;
		}
		@fdiv fracpart fracdiv fracpart;
	}

	! If there are no digits before *or* after the decimal point, fail.
	if (count == 0)
		return FLOAT_NAN;

	! Combine the integer and fractional parts.
	@fadd intpart fracpart res;

	! Exponent (optional)
	if (ix<len && buf->ix == 'e' or 'E' or ' ' or '*' or 'x' or 'X' or $D7) {
		if (buf->ix == 'e' or 'E') {
			! no spaces, just the 'e'
			ix++;
			if (ix == len)
				return FLOAT_NAN;
		}
		else {
			! any number of spaces, "*", any number of spaces more, "10^"
			while (ix < len && buf->ix == ' ')
				ix++;
			if (ix == len)
				return FLOAT_NAN;
			if (buf->ix ~= '*' or 'x' or 'X' or $D7)
				return FLOAT_NAN;
			ix++;
			while (ix < len && buf->ix == ' ')
				ix++;
			if (ix == len)
				return FLOAT_NAN;
			if (buf->ix ~= '1')
				return FLOAT_NAN;
			ix++;
			if (buf->ix ~= '0')
				return FLOAT_NAN;
			ix++;
			if (buf->ix ~= $5E)
				return FLOAT_NAN;
			ix++;
		}

		! Sign character (optional)
		expnegative = false;
		ch = buf->ix;
		if (ch == '-') {
			expnegative = true;
			ix++;
		}
		else if (ch == '+') {
			ix++;
		}

		expon = 0;
		! Some digits (mandatory)
		for (count=0 : ix<len : ix++, count++) {
			ch = buf->ix;
			if (ch < '0' || ch > '9')
				break;
			expon = 10*expon + (ch - '0');
		}

		if (count == 0)
			return FLOAT_NAN;

		if (expnegative)
			expon = -expon;

		if (expon) {
			@numtof expon expon;
			@pow ten expon val;
			@fmul res val res;
		}
	}

	if (negative) {
		! set the value's sign bit
		res = $80000000 | res;
	}

	if (useall && ix ~= len)
		return FLOAT_NAN;
	return res;
];

! An I6 grammar routine (GPR) for floats. On success, this returns
! GPR_NUMBER and stores a value in the global parsed_number.
!
! This is quite a nuisance, actually, because "." is a word separator.
! Also, we want to accept command sequences like "type 4. look"! So we
! need to collect a set of words made up of digits, signs, periods, and
! the letter "e", but without any intervening whitespace, and excluding
! a trailing period.
!
! (This will fail to correctly parse "type 4.e", but I think that is a
! small flaw. A player would more likely try "type 4. e" or, really,
! not concatenate commands at all. It will also parse "type 4. on keyboard"
! as two commands, even though "4." is a legitimate float literal.
! Contrariwise, "type 4. x me" will be taken as one command. (Because the "x"
! *could* be a continuation of the float, and I don't back up when it turns
! out not to be.) I don't plan to worry about these cases.)

[ FLOAT_TOKEN buf bufend ix ch firstwd newstart newlen lastchar lastwasdot;
	if (wn > num_words)
		return GPR_FAIL;

	! We're going to collect a set of words. Start with zero words.
	firstwd = wn;
	buf = WordAddress(wn);
	bufend = buf;
	lastchar = 0;

	while (wn <= num_words) {
		newstart = WordAddress(wn);
		if (newstart ~= bufend) {
			! There's whitespace between the previous word and this one.
			! Whitespace is okay around an asterisk...
			if ((lastchar ~= '*' or 'x' or 'X' or $D7)
				&& (newstart->0 ~= '*' or 'x' or 'X' or $D7)) {
				! But around any other character, it's not.
				! Don't include the new word.
				break;
			}
		}
		newlen = WordLength(wn);
		for (ix=0 : ix<newlen : ix++) {
			ch = newstart->ix;
			if (~~((ch >= '0' && ch <= '9')
				|| (ch == '-' or '+' or 'E' or 'e' or '.' or 'x' or 'X' or '*' or $D7 or $5E)))
				break;
		}
		if (ix < newlen) {
			! This word contains an invalid character.
			! Don't include the new word.
			break;
		}
		! Okay, include it.
		bufend = newstart + newlen;
		wn++;
		lastchar = (bufend-1)->0;
		lastwasdot = (newlen == 1 && lastchar == '.');
	}

	if (wn > firstwd && lastwasdot) {
		! Exclude a trailing period.
		wn--;
		bufend--;
	}

	if (wn == firstwd) {
		! No words accepted.
		return GPR_FAIL;
	}

	parsed_number = FloatParse(buf, bufend-buf, true);
	if (parsed_number == FLOAT_NAN)
		return GPR_FAIL;
	return GPR_NUMBER;
];

! Floating-point printing routines. (These are based on code in
! Glulxercise.inf, but modified.)
  
! Print a float. This uses exponential notation ("[-]N.NNNe[+-]NN") if
! the exponent is not between 6 and -4. If it is (that is, if the
! absolute value is near 1.0) then it uses decimal notation ("[-]NNN.NNNNN").
! The precision is the number of digits after the decimal point
! (at least one, no more than eight). The default is five, because
! beyond that rounding errors creep in, and even exactly-represented
! float values are printed with trailing fudgy digits.
! Trailing zeroes are trimmed.
[ Float val prec   pval;
	pval = val & $7FFFFFFF;

	@jz pval ?UseFloatDec;
	@jfge pval $49742400 ?UseFloatExp; ! 1000000.0
	@jflt pval $38D1B717 ?UseFloatExp; ! 0.0001

	.UseFloatDec;
	return FloatDec(val, prec);
	.UseFloatExp;
	return FloatExp(val, prec);
];

Array PowersOfTen --> 1 10 100 1000 10000 100000 1000000 10000000 100000000 1000000000;

! Print a float in exponential notation: "[-]N.NNNe[+-]NN".
! The precision is the number of digits after the decimal point
! (at least one, no more than eight). The default is five, because
! beyond that rounding errors creep in, and even exactly-represented
! float values are printed with trailing fudgy digits.
! Trailing zeroes are trimmed.
[ FloatExp val prec   log10val expo fexpo idig ix pow10;
	if (prec == 0)
		prec = 5;
	if (prec > 8)
		prec = 8;
	pow10 = PowersOfTen --> prec;

	! Knock off the sign bit first.
	if (val & $80000000) {
		@streamchar '-';
		val = val & $7FFFFFFF;
	}
	
	@jisnan val ?IsNan;
	@jisinf val ?IsInf;

	if (val == $0) {
		expo = 0;
		idig = 0;
		jump DoPrint;
	}

	! Take as an example val=123.5, with precision=6. The desired
	! result is "1.23000e+02".
	
	@log val sp;
	@fdiv sp $40135D8E log10val; ! $40135D8E is log(10)
	@floor log10val fexpo;
	@ftonumn fexpo expo;
	! expo is now the exponent (as an integer). For our example, expo=2.

	@fsub log10val fexpo sp;
	@numtof prec sp;
	@fadd sp sp sp;
	@fmul sp $40135D8E sp;
	@exp sp sp;
	! The stack value is now exp((log10val - fexpo + prec) * log(10)).
	! We've shifted the decimal point left by expo digits (so that
	! it's after the first nonzero digit), and then right by prec
	! digits. In our example, that would be 1235000.0.
	@ftonumn sp idig;
	! Round to an integer, and we have 1235000. Notice that this is
	! exactly the digits we want to print (if we stick a decimal point
	! after the first).

	.DoPrint;
	
	if (idig >= 10*pow10) {
		! Rounding errors have left us outside the decimal range of
		! [1.0, 10.0) where we should be. Adjust to the next higher
		! exponent.
		expo++;
		@div idig 10 idig;
	}
	
	! Trim off trailing zeroes, as long as there's at least one digit
	! after the decimal point. (Delete this stanza if you want to
	! keep the trailing zeroes.)
	while (prec > 1) {
		@mod idig 10 sp;
		@jnz sp ?DoneTrimming;
		@div pow10 10 pow10;
		@div idig 10 idig;
		prec--;
	}
	.DoneTrimming;
	
	for (ix=0 : ix<=prec : ix++) {
		@div idig pow10 sp;
		@mod sp 10 sp;
		@streamnum sp;
		if (ix == 0)
			@streamchar '.';
		@div pow10 10 pow10;
	}

	! Print the exponent. There are two conventions coded here: the
	! programmatic ("1.0e+00") and the literary ("1.0 x 10^0").
	#ifndef FLOAT_PROGRAMMING_EXPONENTS;
		PrintMultiplicationSign();
		@streamstr "10";
		@streamchar $5E;
		@streamnum expo;
	#ifnot;
		! Convention is to use at least two digits.
		@streamchar 'e';
		if (expo < 0) {
			@streamchar '-';
			@neg expo expo;
		}
		else {
			@streamchar '+';
		}
		if (expo < 10)
			@streamchar '0';
		@streamnum expo;
	#endif; ! FLOAT_PROGRAMMING_EXPONENTS
	
	rtrue;

	.IsNan;
	PrintNan();
	rtrue;

	.IsInf;
	PrintInfinity();
	rtrue;
];

! Print a float in decimal notation: "[-]NNN.NNNNN".
! The precision is the number of digits after the decimal point
! (at least one, no more than eight). The default is five, because
! beyond that rounding errors creep in, and even exactly-represented
! float values are printed with trailing fudgy digits.
! Trailing zeroes are trimmed.
[ FloatDec val prec   log10val int fint extra0 frac idig ix pow10;
	if (prec == 0)
		prec = 5;
	if (prec > 8)
		prec = 8;
	pow10 = PowersOfTen --> prec;
	
	! Knock off the sign bit first.
	if (val & $80000000) {
		@streamchar '-';
		val = val & $7FFFFFFF;
	}
	
	@jisnan val ?IsNan;
	@jisinf val ?IsInf;

	! Take as an example val=123.5, with precision=6. The desired result
	! is "123.50000".
	
	extra0 = 0;
	@fmod val $3F800000 frac fint; ! $3F800000 is 1.0.
	@ftonumz fint int;
	! This converts the integer part of the value to an integer value;
	! in our example, 123.
	
	if (int == $7FFFFFFF) {
		! Looks like the integer part of the value is bigger than
		! we can store in an int variable. (It could be as large
		! as 3e+38.) We're going to have to use a log function to
		! reduce it by some number of factors of 10, and then pad
		! with zeroes.
		@log fint sp;
		@fdiv sp $40135D8E log10val; ! $40135D8E is log(10)
		@ftonumz log10val extra0;
		@sub extra0 8 extra0;
		! extra0 is the number of zeroes we'll be padding with.
		@numtof extra0 sp;
		@fsub log10val sp sp;
		@fmul sp $40135D8E sp;
		@exp sp sp;
		! The stack value is now exp((log10val - extra0) * log(10)).
		! We've shifted the decimal point far enough left to leave
		! about eight digits, which is all we can print as an integer.
		@ftonumz sp int;
	}

	! Print the integer part.
	@streamnum int;
	for (ix=0 : ix<extra0 : ix++)
		@streamchar '0';

	@streamchar '.';

	! Now we need to print the frac part, which is .5.
	
	@log frac sp;
	@fdiv sp $40135D8E log10val; ! $40135D8E is log(10)
	@numtof prec sp;
	@fadd log10val sp sp;
	@fmul sp $40135D8E sp;
	@exp sp sp;
	! The stack value is now exp((frac + prec) * log(10)).
	! We've shifted the decimal point right by prec
	! digits. In our example, that would be 50000.0.
	@ftonumn sp idig;
	! Round to an integer, and we have 50000. Notice that this is
	! exactly the (post-decimal-point) digits we want to print.

	.DoPrint;
	
	if (idig >= pow10) {
		! Rounding errors have left us outside the decimal range of
		! [0.0, 1.0) where we should be. I'm not sure this is possible,
		! actually, but we'll just adjust downward.
		idig = pow10 - 1;
	}

	! Trim off trailing zeroes, as long as there's at least one digit
	! after the decimal point. (Delete this stanza if you want to
	! keep the trailing zeroes.)
	while (prec > 1) {
		@mod idig 10 sp;
		@jnz sp ?DoneTrimming;
		@div pow10 10 pow10;
		@div idig 10 idig;
		prec--;
	}
	.DoneTrimming;
	
	@div pow10 10 pow10;
	for (ix=0 : ix<prec : ix++) {
		@div idig pow10 sp;
		@mod sp 10 sp;
		@streamnum sp;
		@div pow10 10 pow10;
	}
	rtrue;

	.IsNan;
	PrintNan();
	rtrue;

	.IsInf;
	PrintInfinity();
	rtrue;
];

[ PrintInfinity;
	@streamunichar $221E;
	! @streamstr "Inf";
];

[ PrintNan;
	@streamunichar $26a0;
	! @streamstr "NaN";
];

[ PrintMultiplicationSign;
	print " ";
	@streamunichar $D7;
	print " ";
	! @streamstr " x ";
];

#Ifnot; ! TARGET_GLULX

[ REAL_NUMBER_TY_Say real; print real; ]; ! Needs to exist, but likely never used

[ REAL_NUMBER_TY_Compare r1 r2; return UnsignedCompare(r1, r2); ];

#Endif; ! TARGET_GLULX


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Rounding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RoundOffTime t1 t2;
	if (t1 >= 0) return ((t1+t2/2)/t2)*t2;
	return -((-t1+t2/2)/t2)*t2;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Conversion To Number
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ NUMBER_TY_to_TIME_TY n;
	n = n%1440;
	if (n < 0) return n + 1440;
	return n;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Square Root
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SquareRoot num
    op res one n x;
    if (num < 0) { RunTimeProblem(RTP_NEGATIVEROOT); return 1; }

    ! Use floating-point ops if available.
    #ifdef TARGET_GLULX;
    @gestalt 11 0 n;
    if (n) {
        @numtof num x;
        @sqrt x x;
        @ftonumz x num;
        return num;
    }
   #endif;
	op = num;
	if (num < 0) { RunTimeProblem(RTP_NEGATIVEROOT); return 1; }
	! "one" starts at the highest power of four <= the argument.
	for (one = WORD_NEXTTOHIGHBIT: one > op: one = one/4) ;

	while (one ~= 0) {
		! print "Round: op = ", op, " res = ", res, ", res**2 = ", res*res, " one = ", one, " nthb = ", WORD_NEXTTOHIGHBIT, "^";
		if (op >= res + one) {
			op = op - res - one;
			res = res/2 + one;
		} else {
			res = res/2;
		}
		one = one/4;
	}
	! print "Res is ", res, "^";
	return res;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Cube Root
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CubeRoot num neg x y n;
    ! Use floating-point ops if available.
    #ifdef TARGET_GLULX;
    @gestalt 11 0 n;
    if (n) {
        if (num < 0) {
            neg = true;
            num = -num;
        }
        @numtof num x;
        @pow x 1051372203 x; ! pow(x, 0.3333)
        @ftonumz x num;
        if (neg)
            return -num;
        else
            return num;
    }
    #endif;
	if (num < 0) x = -SquareRoot(-num); else x = SquareRoot(num);
	for (n=0: (y ~= x) && (n++ < 100): y = x, x = (2*x + num/x/x)/3) ;
	return x;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Digital Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintTimeOfDay t h aop;
	if (t<0) { print "<no time>"; return; }
	if (t >= TWELVE_HOURS) { aop = "pm"; t = t - TWELVE_HOURS; } else aop = "am";
	h = t/ONE_HOUR; if (h==0) h=12;
	print h, ":";
	if (t%ONE_HOUR < 10) print "0"; print t%ONE_HOUR, " ", (string) aop;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Analogue Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PrintTimeOfDayEnglish t h m dir aop;
	h = (t/ONE_HOUR) % 12; m = t%ONE_HOUR; if (h==0) h=12;
	if (m==0) { print (number) h, " o'clock"; return; }
	dir = "past";
	if (m > HALF_HOUR) { m = ONE_HOUR-m; h = (h+1)%12; if (h==0) h=12; dir = "to"; }
	switch(m) {
		QUARTER_HOUR: print "quarter"; HALF_HOUR: print "half";
		default: print (number) m;
		    if (m%5 ~= 0) {
				if (m == 1) print " minute"; else print " minutes";
		    }
	}
	print " ", (string) dir, " ", (number) h;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Understanding
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TIME_TOKEN first_word second_word at length flag
	illegal_char offhour hr mn i original_wn;
	original_wn = wn;

	wn = original_wn;
	first_word = NextWordStopped();
	switch (first_word) {
		'midnight': parsed_number = 0; return GPR_NUMBER;
		'midday', 'noon': parsed_number = TWELVE_HOURS;
		return GPR_NUMBER;
	}
	! Next try the format 12:02
	at = WordAddress(wn-1); length = WordLength(wn-1);
	for (i=0: i<length: i++) {
		switch (at->i) {
			':': if (flag == false && i>0 && i<length-1) flag = true;
			else illegal_char = true;
			'0', '1', '2', '3', '4', '5', '6', '7', '8', '9': ;
			default: illegal_char = true;
		}
	}
	if (length < 3 || length > 5 || illegal_char) flag = false;
	if (flag) {
		for (i=0: at->i~=':': i++, hr=hr*10) hr = hr + at->i - '0';
		hr = hr/10;
		for (i++: i<length: i++, mn=mn*10) mn = mn + at->i - '0';
		mn = mn/10;
		second_word = NextWordStopped();
		parsed_number = HoursMinsWordToTime(hr, mn, second_word);
		if (parsed_number == -1) return GPR_FAIL;
		if (second_word ~= 'pm' or 'am') wn--;
		return GPR_NUMBER;
	}
	! Lastly the wordy format
	offhour = -1;
	if (first_word == 'half') offhour = HALF_HOUR;
	if (first_word == 'quarter') offhour = QUARTER_HOUR;
	if (offhour < 0) offhour = TryNumber(wn-1);
	if (offhour < 0 || offhour >= ONE_HOUR) return GPR_FAIL;
	second_word = NextWordStopped();
	switch (second_word) {
		! "six o'clock", "six"
		'o^clock', 'am', 'pm', -1:
			hr = offhour; if (hr > 12) return GPR_FAIL;
		! "quarter to six", "twenty past midnight"
		'to', 'past':
			mn = offhour; hr = TryNumber(wn);
			if (hr <= 0) {
				switch (NextWordStopped()) {
					'noon', 'midday': hr = 12;
					'midnight': hr = 0;
					default: return GPR_FAIL;
				}
			}
			if (hr >= 13) return GPR_FAIL;
			if (second_word == 'to') {
				mn = ONE_HOUR-mn; hr--; if (hr<0) hr=23;
			}
			wn++; second_word = NextWordStopped();
		! "six thirty"
		default:
			hr = offhour; mn = TryNumber(--wn);
			if (mn < 0 || mn >= ONE_HOUR) return GPR_FAIL;
			wn++; second_word = NextWordStopped();
	}
	parsed_number = HoursMinsWordToTime(hr, mn, second_word);
	if (parsed_number < 0) return GPR_FAIL;
	if (second_word ~= 'pm' or 'am' or 'o^clock') wn--;
	return GPR_NUMBER;
];

[ HoursMinsWordToTime hour minute word x;
	if (hour >= 24) return -1;
	if (minute >= ONE_HOUR) return -1;
	x = hour*ONE_HOUR + minute; if (hour >= 13) return x;
	x = x % TWELVE_HOURS; if (word == 'pm') x = x + TWELVE_HOURS;
	if (word ~= 'am' or 'pm' && hour == 12) x = x + TWELVE_HOURS;
	return x;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Relative Time Token
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATIVE_TIME_TOKEN first_word second_word offhour mult mn original_wn;
	original_wn = wn;
	wn = original_wn;
	
	first_word = NextWordStopped(); wn--;
	if (first_word == 'an' or 'a//') mn=1; else mn=TryNumber(wn);
	
    if (mn == -1000) {
		first_word = NextWordStopped();
		if (first_word == 'half') offhour = HALF_HOUR;
		if (first_word == 'quarter') offhour = QUARTER_HOUR;
		if (offhour > 0) {
			second_word = NextWordStopped();
			if (second_word == 'of') second_word = NextWordStopped();
			if (second_word == 'an') second_word = NextWordStopped();
			if (second_word == 'hour') {
				parsed_number = offhour;
				return GPR_NUMBER;
			}
		}
		return GPR_FAIL;
    }
	wn++;
	
	first_word = NextWordStopped();
	switch (first_word) {
		'minutes', 'minute': mult = 1;
		'hours', 'hour': mult = 60;
		default: return GPR_FAIL;
	}
	parsed_number = mn*mult;
	if (mult == 60) {
		mn=TryNumber(wn);
		if (mn ~= -1000) {
			wn++;
			first_word = NextWordStopped();
			if (first_word == 'minutes' or 'minute')
				parsed_number = parsed_number + mn;
			else wn = wn - 2;
		}
	}
	return GPR_NUMBER;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: During Scene Matching
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DuringSceneMatching prop sc;
	for (sc=0: sc<NUMBER_SCENES_CREATED: sc++)
		if ((scene_status-->sc == 1) && (prop(sc+1))) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Time.i6t: Scene Questions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SceneUtility sc task;
	if (sc <= 0) return 0;
	if (task == 1 or 2) {
		if (scene_endings-->(sc-1) == 0) return RunTimeProblem(RTP_SCENEHASNTSTARTED, sc);
	} else {
		if (scene_endings-->(sc-1) <= 1) return RunTimeProblem(RTP_SCENEHASNTENDED, sc);
	}
	switch (task) {
		1: return (the_time - scene_started-->(sc-1))%(TWENTY_FOUR_HOURS);
		2: return scene_started-->(sc-1);
		3: return (the_time - scene_ended-->(sc-1))%(TWENTY_FOUR_HOURS);
		4: return scene_ended-->(sc-1);
	}
];




! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Text generation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant CV_POS = -1;
Constant CV_NEG = -2;
Constant CV_MODAL = -3;
Constant CV_MEANING = -4;
[ ConjugateVerb_0 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "be";
        2: print "been";
        3: print "being";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "am";
                    2: print "are";
                    3: print "is";
                    4: print "are";
                    5: print "are";
                    6: print "are";
                }
                2: switch (vp) {
                    1: print "was";
                    2: print "were";
                    3: print "was";
                    4: print "were";
                    5: print "were";
                    6: print "were";
                }
                3: if (vp == 3) { print "has been"; } else { print "have been"; }
                4: print "had been";
                5: print "will be";
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "am not";
                    2: print "are not";
                    3: print "is not";
                    4: print "are not";
                    5: print "are not";
                    6: print "are not";
                }
                2: switch (vp) {
                    1: print "was not";
                    2: print "were not";
                    3: print "was not";
                    4: print "were not";
                    5: print "were not";
                    6: print "were not";
                }
                3: if (vp == 3) { print "has not been"; } else { print "have not been"; }
                4: print "had not been";
                5: print "will not be";
            }
    }
];
[ ConjugateVerb_1 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "auxiliary-have";
        2: print "had";
        3: print "having";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "has"; } else { print "have"; }
                2: print "had";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "has not"; } else { print "have not"; }
                2: print "had not";
            }
    }
];
[ ConjugateVerb_2 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "have";
        2: print "had";
        3: print "having";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_27;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "has"; } else { print "have"; }
                2: print "had";
                3: if (vp == 3) { print "has had"; } else { print "have had"; }
                4: print "had had";
                5: print "will have";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not have"; } else { print "do not have"; }
                2: print "did not have";
                3: if (vp == 3) { print "has not had"; } else { print "have not had"; }
                4: print "had not had";
                5: print "will not have";
            }
    }
];
[ ConjugateVerb_3 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "do";
        2: print "done";
        3: print "doing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "does"; } else { print "do"; }
                2: print "did";
                3: if (vp == 3) { print "has done"; } else { print "have done"; }
                4: print "had done";
                5: print "will do";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not"; } else { print "do not"; }
                2: print "did not";
                3: if (vp == 3) { print "has not done"; } else { print "have not done"; }
                4: print "had not done";
                5: print "will not do";
            }
    }
];
[ ConjugateVerb_4 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "relate";
        2: print "related";
        3: print "relating";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_3;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "relates"; } else { print "relate"; }
                2: print "related";
                3: if (vp == 3) { print "has related"; } else { print "have related"; }
                4: print "had related";
                5: print "will relate";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not relate"; } else { print "do not relate"; }
                2: print "did not relate";
                3: if (vp == 3) { print "has not related"; } else { print "have not related"; }
                4: print "had not related";
                5: print "will not relate";
            }
    }
];
[ ConjugateVerb_5 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "mean";
        2: print "meant";
        3: print "meaning";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_5;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "means"; } else { print "mean"; }
                2: print "meant";
                3: if (vp == 3) { print "has meant"; } else { print "have meant"; }
                4: print "had meant";
                5: print "will mean";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not mean"; } else { print "do not mean"; }
                2: print "did not mean";
                3: if (vp == 3) { print "has not meant"; } else { print "have not meant"; }
                4: print "had not meant";
                5: print "will not mean";
            }
    }
];
[ ConjugateVerb_6 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "provide";
        2: print "provided";
        3: print "providing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_1;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "provides"; } else { print "provide"; }
                2: print "provided";
                3: if (vp == 3) { print "has provided"; } else { print "have provided"; }
                4: print "had provided";
                5: print "will provide";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not provide"; } else { print "do not provide"; }
                2: print "did not provide";
                3: if (vp == 3) { print "has not provided"; } else { print "have not provided"; }
                4: print "had not provided";
                5: print "will not provide";
            }
    }
];
[ ConjugateVerb_7 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "contain";
        2: print "contained";
        3: print "containing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_15;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "contains"; } else { print "contain"; }
                2: print "contained";
                3: if (vp == 3) { print "has contained"; } else { print "have contained"; }
                4: print "had contained";
                5: print "will contain";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not contain"; } else { print "do not contain"; }
                2: print "did not contain";
                3: if (vp == 3) { print "has not contained"; } else { print "have not contained"; }
                4: print "had not contained";
                5: print "will not contain";
            }
    }
];
[ ConjugateVerb_8 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "support";
        2: print "supported";
        3: print "supporting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_17;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "supports"; } else { print "support"; }
                2: print "supported";
                3: if (vp == 3) { print "has supported"; } else { print "have supported"; }
                4: print "had supported";
                5: print "will support";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not support"; } else { print "do not support"; }
                2: print "did not support";
                3: if (vp == 3) { print "has not supported"; } else { print "have not supported"; }
                4: print "had not supported";
                5: print "will not support";
            }
    }
];
[ ConjugateVerb_9 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "incorporate";
        2: print "incorporated";
        3: print "incorporating";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_19;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "incorporates"; } else { print "incorporate"; }
                2: print "incorporated";
                3: if (vp == 3) { print "has incorporated"; } else { print "have incorporated"; }
                4: print "had incorporated";
                5: print "will incorporate";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not incorporate"; } else { print "do not incorporate"; }
                2: print "did not incorporate";
                3: if (vp == 3) { print "has not incorporated"; } else { print "have not incorporated"; }
                4: print "had not incorporated";
                5: print "will not incorporate";
            }
    }
];
[ ConjugateVerb_10 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "enclose";
        2: print "enclosed";
        3: print "enclosing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_37;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "encloses"; } else { print "enclose"; }
                2: print "enclosed";
                3: if (vp == 3) { print "has enclosed"; } else { print "have enclosed"; }
                4: print "had enclosed";
                5: print "will enclose";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not enclose"; } else { print "do not enclose"; }
                2: print "did not enclose";
                3: if (vp == 3) { print "has not enclosed"; } else { print "have not enclosed"; }
                4: print "had not enclosed";
                5: print "will not enclose";
            }
    }
];
[ ConjugateVerb_11 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "carry";
        2: print "carried";
        3: print "carrying";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_21;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "carries"; } else { print "carry"; }
                2: print "carried";
                3: if (vp == 3) { print "has carried"; } else { print "have carried"; }
                4: print "had carried";
                5: print "will carry";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not carry"; } else { print "do not carry"; }
                2: print "did not carry";
                3: if (vp == 3) { print "has not carried"; } else { print "have not carried"; }
                4: print "had not carried";
                5: print "will not carry";
            }
    }
];
[ ConjugateVerb_12 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "hold";
        2: print "held";
        3: print "holding";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_23;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "holds"; } else { print "hold"; }
                2: print "held";
                3: if (vp == 3) { print "has held"; } else { print "have held"; }
                4: print "had held";
                5: print "will hold";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not hold"; } else { print "do not hold"; }
                2: print "did not hold";
                3: if (vp == 3) { print "has not held"; } else { print "have not held"; }
                4: print "had not held";
                5: print "will not hold";
            }
    }
];
[ ConjugateVerb_13 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "wear";
        2: print "worn";
        3: print "wearing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_25;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "wears"; } else { print "wear"; }
                2: print "wore";
                3: if (vp == 3) { print "has worn"; } else { print "have worn"; }
                4: print "had worn";
                5: print "will wear";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not wear"; } else { print "do not wear"; }
                2: print "did not wear";
                3: if (vp == 3) { print "has not worn"; } else { print "have not worn"; }
                4: print "had not worn";
                5: print "will not wear";
            }
    }
];
[ ConjugateVerb_14 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "be able to see";
        2: print "been able to see";
        3: print "being able to see";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_31;
        CV_POS:
            switch (t) {
                1: print "can see";
                2: print "could see";
                3: if (vp == 3) { print "has been able to see"; } else { print "have been able to see"; }
                4: print "had been able to see";
                5: print "will be able to see";
                6: print "see";
                7: print "see";
            }
        CV_NEG:
            switch (t) {
                1: print "cannot see";
                2: print "could not see";
                3: if (vp == 3) { print "has not been able to see"; } else { print "have not been able to see"; }
                4: print "had not been able to see";
                5: print "will not be able to see";
                6: print "see";
                7: print "see";
            }
    }
];
[ ConjugateVerb_15 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "be able to";
        2: print "been able to";
        3: print "being able to";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "can"; if (modal_to) { print " "; modal_to(1); }
                    2: print "can"; if (modal_to) { print " "; modal_to(1); }
                    3: print "can"; if (modal_to) { print " "; modal_to(1); }
                    4: print "can"; if (modal_to) { print " "; modal_to(1); }
                    5: print "can"; if (modal_to) { print " "; modal_to(1); }
                    6: print "can"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "could"; if (modal_to) { print " "; modal_to(1); }
                    2: print "could"; if (modal_to) { print " "; modal_to(1); }
                    3: print "could"; if (modal_to) { print " "; modal_to(1); }
                    4: print "could"; if (modal_to) { print " "; modal_to(1); }
                    5: print "could"; if (modal_to) { print " "; modal_to(1); }
                    6: print "could"; if (modal_to) { print " "; modal_to(1); }
                }
                3: switch (vp) {
                    1: print "have been able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "have been able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "has been able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "have been able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "have been able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "have been able to"; if (modal_to) { print " "; modal_to(1); }
                }
                4: switch (vp) {
                    1: print "had been able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "had been able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "had been able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "had been able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "had been able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "had been able to"; if (modal_to) { print " "; modal_to(1); }
                }
                5: switch (vp) {
                    1: print "will be able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "will be able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "will be able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "will be able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "will be able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "will be able to"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "cannot"; if (modal_to) { print " "; modal_to(1); }
                    2: print "cannot"; if (modal_to) { print " "; modal_to(1); }
                    3: print "cannot"; if (modal_to) { print " "; modal_to(1); }
                    4: print "cannot"; if (modal_to) { print " "; modal_to(1); }
                    5: print "cannot"; if (modal_to) { print " "; modal_to(1); }
                    6: print "cannot"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "could not"; if (modal_to) { print " "; modal_to(1); }
                }
                3: switch (vp) {
                    1: print "have not been able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "have not been able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "has not been able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "have not been able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "have not been able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "have not been able to"; if (modal_to) { print " "; modal_to(1); }
                }
                4: switch (vp) {
                    1: print "had not been able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "had not been able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "had not been able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "had not been able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "had not been able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "had not been able to"; if (modal_to) { print " "; modal_to(1); }
                }
                5: switch (vp) {
                    1: print "will not be able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "will not be able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "will not be able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "will not be able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "will not be able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "will not be able to"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_16 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "see";
        2: print "seen";
        3: print "seeing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "sees"; } else { print "see"; }
                2: print "saw";
                3: if (vp == 3) { print "has seen"; } else { print "have seen"; }
                4: print "had seen";
                5: print "will see";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not see"; } else { print "do not see"; }
                2: print "did not see";
                3: if (vp == 3) { print "has not seen"; } else { print "have not seen"; }
                4: print "had not seen";
                5: print "will not see";
            }
    }
];
[ ConjugateVerb_17 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "be able to touch";
        2: print "been able to touch";
        3: print "being able to touch";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_33;
        CV_POS:
            switch (t) {
                1: print "can touch";
                2: print "could touch";
                3: if (vp == 3) { print "has been able to touch"; } else { print "have been able to touch"; }
                4: print "had been able to touch";
                5: print "will be able to touch";
                6: print "touch";
                7: print "touch";
            }
        CV_NEG:
            switch (t) {
                1: print "cannot touch";
                2: print "could not touch";
                3: if (vp == 3) { print "has not been able to touch"; } else { print "have not been able to touch"; }
                4: print "had not been able to touch";
                5: print "will not be able to touch";
                6: print "touch";
                7: print "touch";
            }
    }
];
[ ConjugateVerb_18 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "touch";
        2: print "touched";
        3: print "touching";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "touches"; } else { print "touch"; }
                2: print "touched";
                3: if (vp == 3) { print "has touched"; } else { print "have touched"; }
                4: print "had touched";
                5: print "will touch";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not touch"; } else { print "do not touch"; }
                2: print "did not touch";
                3: if (vp == 3) { print "has not touched"; } else { print "have not touched"; }
                4: print "had not touched";
                5: print "will not touch";
            }
    }
];
[ ConjugateVerb_19 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "conceal";
        2: print "concealed";
        3: print "concealing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_35;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "conceals"; } else { print "conceal"; }
                2: print "concealed";
                3: if (vp == 3) { print "has concealed"; } else { print "have concealed"; }
                4: print "had concealed";
                5: print "will conceal";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not conceal"; } else { print "do not conceal"; }
                2: print "did not conceal";
                3: if (vp == 3) { print "has not concealed"; } else { print "have not concealed"; }
                4: print "had not concealed";
                5: print "will not conceal";
            }
    }
];
[ ConjugateVerb_20 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "unlock";
        2: print "unlocked";
        3: print "unlocking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_69;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "unlocks"; } else { print "unlock"; }
                2: print "unlocked";
                3: if (vp == 3) { print "has unlocked"; } else { print "have unlocked"; }
                4: print "had unlocked";
                5: print "will unlock";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not unlock"; } else { print "do not unlock"; }
                2: print "did not unlock";
                3: if (vp == 3) { print "has not unlocked"; } else { print "have not unlocked"; }
                4: print "had not unlocked";
                5: print "will not unlock";
            }
    }
];
[ ConjugateVerb_21 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "achieve";
        2: print "achieved";
        3: print "achieving";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "achieves"; } else { print "achieve"; }
                2: print "achieved";
                3: if (vp == 3) { print "has achieved"; } else { print "have achieved"; }
                4: print "had achieved";
                5: print "will achieve";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not achieve"; } else { print "do not achieve"; }
                2: print "did not achieve";
                3: if (vp == 3) { print "has not achieved"; } else { print "have not achieved"; }
                4: print "had not achieved";
                5: print "will not achieve";
            }
    }
];
[ ConjugateVerb_22 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "appreciate";
        2: print "appreciated";
        3: print "appreciating";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "appreciates"; } else { print "appreciate"; }
                2: print "appreciated";
                3: if (vp == 3) { print "has appreciated"; } else { print "have appreciated"; }
                4: print "had appreciated";
                5: print "will appreciate";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not appreciate"; } else { print "do not appreciate"; }
                2: print "did not appreciate";
                3: if (vp == 3) { print "has not appreciated"; } else { print "have not appreciated"; }
                4: print "had not appreciated";
                5: print "will not appreciate";
            }
    }
];
[ ConjugateVerb_23 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "arrive";
        2: print "arrived";
        3: print "arriving";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "arrives"; } else { print "arrive"; }
                2: print "arrived";
                3: if (vp == 3) { print "has arrived"; } else { print "have arrived"; }
                4: print "had arrived";
                5: print "will arrive";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not arrive"; } else { print "do not arrive"; }
                2: print "did not arrive";
                3: if (vp == 3) { print "has not arrived"; } else { print "have not arrived"; }
                4: print "had not arrived";
                5: print "will not arrive";
            }
    }
];
[ ConjugateVerb_24 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "care";
        2: print "cared";
        3: print "caring";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "cares"; } else { print "care"; }
                2: print "cared";
                3: if (vp == 3) { print "has cared"; } else { print "have cared"; }
                4: print "had cared";
                5: print "will care";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not care"; } else { print "do not care"; }
                2: print "did not care";
                3: if (vp == 3) { print "has not cared"; } else { print "have not cared"; }
                4: print "had not cared";
                5: print "will not care";
            }
    }
];
[ ConjugateVerb_25 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "close";
        2: print "closed";
        3: print "closing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "closes"; } else { print "close"; }
                2: print "closed";
                3: if (vp == 3) { print "has closed"; } else { print "have closed"; }
                4: print "had closed";
                5: print "will close";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not close"; } else { print "do not close"; }
                2: print "did not close";
                3: if (vp == 3) { print "has not closed"; } else { print "have not closed"; }
                4: print "had not closed";
                5: print "will not close";
            }
    }
];
[ ConjugateVerb_26 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "die";
        2: print "died";
        3: print "dying";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "dies"; } else { print "die"; }
                2: print "died";
                3: if (vp == 3) { print "has died"; } else { print "have died"; }
                4: print "had died";
                5: print "will die";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not die"; } else { print "do not die"; }
                2: print "did not die";
                3: if (vp == 3) { print "has not died"; } else { print "have not died"; }
                4: print "had not died";
                5: print "will not die";
            }
    }
];
[ ConjugateVerb_27 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "discover";
        2: print "discovered";
        3: print "discovering";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "discovers"; } else { print "discover"; }
                2: print "discovered";
                3: if (vp == 3) { print "has discovered"; } else { print "have discovered"; }
                4: print "had discovered";
                5: print "will discover";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not discover"; } else { print "do not discover"; }
                2: print "did not discover";
                3: if (vp == 3) { print "has not discovered"; } else { print "have not discovered"; }
                4: print "had not discovered";
                5: print "will not discover";
            }
    }
];
[ ConjugateVerb_28 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "drop";
        2: print "dropped";
        3: print "dropping";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "drops"; } else { print "drop"; }
                2: print "dropped";
                3: if (vp == 3) { print "has dropped"; } else { print "have dropped"; }
                4: print "had dropped";
                5: print "will drop";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not drop"; } else { print "do not drop"; }
                2: print "did not drop";
                3: if (vp == 3) { print "has not dropped"; } else { print "have not dropped"; }
                4: print "had not dropped";
                5: print "will not drop";
            }
    }
];
[ ConjugateVerb_29 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "eat";
        2: print "eaten";
        3: print "eating";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "eats"; } else { print "eat"; }
                2: print "ate";
                3: if (vp == 3) { print "has eaten"; } else { print "have eaten"; }
                4: print "had eaten";
                5: print "will eat";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not eat"; } else { print "do not eat"; }
                2: print "did not eat";
                3: if (vp == 3) { print "has not eaten"; } else { print "have not eaten"; }
                4: print "had not eaten";
                5: print "will not eat";
            }
    }
];
[ ConjugateVerb_30 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "feel";
        2: print "felt";
        3: print "feeling";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "feels"; } else { print "feel"; }
                2: print "felt";
                3: if (vp == 3) { print "has felt"; } else { print "have felt"; }
                4: print "had felt";
                5: print "will feel";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not feel"; } else { print "do not feel"; }
                2: print "did not feel";
                3: if (vp == 3) { print "has not felt"; } else { print "have not felt"; }
                4: print "had not felt";
                5: print "will not feel";
            }
    }
];
[ ConjugateVerb_31 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "find";
        2: print "found";
        3: print "finding";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "finds"; } else { print "find"; }
                2: print "found";
                3: if (vp == 3) { print "has found"; } else { print "have found"; }
                4: print "had found";
                5: print "will find";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not find"; } else { print "do not find"; }
                2: print "did not find";
                3: if (vp == 3) { print "has not found"; } else { print "have not found"; }
                4: print "had not found";
                5: print "will not find";
            }
    }
];
[ ConjugateVerb_32 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "get";
        2: print "got";
        3: print "getting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "gets"; } else { print "get"; }
                2: print "got";
                3: if (vp == 3) { print "has got"; } else { print "have got"; }
                4: print "had got";
                5: print "will get";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not get"; } else { print "do not get"; }
                2: print "did not get";
                3: if (vp == 3) { print "has not got"; } else { print "have not got"; }
                4: print "had not got";
                5: print "will not get";
            }
    }
];
[ ConjugateVerb_33 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "give";
        2: print "given";
        3: print "giving";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "gives"; } else { print "give"; }
                2: print "gave";
                3: if (vp == 3) { print "has given"; } else { print "have given"; }
                4: print "had given";
                5: print "will give";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not give"; } else { print "do not give"; }
                2: print "did not give";
                3: if (vp == 3) { print "has not given"; } else { print "have not given"; }
                4: print "had not given";
                5: print "will not give";
            }
    }
];
[ ConjugateVerb_34 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "go";
        2: print "gone";
        3: print "going";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "goes"; } else { print "go"; }
                2: print "went";
                3: if (vp == 3) { print "has gone"; } else { print "have gone"; }
                4: print "had gone";
                5: print "will go";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not go"; } else { print "do not go"; }
                2: print "did not go";
                3: if (vp == 3) { print "has not gone"; } else { print "have not gone"; }
                4: print "had not gone";
                5: print "will not go";
            }
    }
];
[ ConjugateVerb_35 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "happen";
        2: print "happened";
        3: print "happening";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "happens"; } else { print "happen"; }
                2: print "happened";
                3: if (vp == 3) { print "has happened"; } else { print "have happened"; }
                4: print "had happened";
                5: print "will happen";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not happen"; } else { print "do not happen"; }
                2: print "did not happen";
                3: if (vp == 3) { print "has not happened"; } else { print "have not happened"; }
                4: print "had not happened";
                5: print "will not happen";
            }
    }
];
[ ConjugateVerb_36 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "hear";
        2: print "heard";
        3: print "hearing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "hears"; } else { print "hear"; }
                2: print "heard";
                3: if (vp == 3) { print "has heard"; } else { print "have heard"; }
                4: print "had heard";
                5: print "will hear";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not hear"; } else { print "do not hear"; }
                2: print "did not hear";
                3: if (vp == 3) { print "has not heard"; } else { print "have not heard"; }
                4: print "had not heard";
                5: print "will not hear";
            }
    }
];
[ ConjugateVerb_37 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "jump";
        2: print "jumped";
        3: print "jumping";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "jumps"; } else { print "jump"; }
                2: print "jumped";
                3: if (vp == 3) { print "has jumped"; } else { print "have jumped"; }
                4: print "had jumped";
                5: print "will jump";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not jump"; } else { print "do not jump"; }
                2: print "did not jump";
                3: if (vp == 3) { print "has not jumped"; } else { print "have not jumped"; }
                4: print "had not jumped";
                5: print "will not jump";
            }
    }
];
[ ConjugateVerb_38 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "lack";
        2: print "lacked";
        3: print "lacking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "lacks"; } else { print "lack"; }
                2: print "lacked";
                3: if (vp == 3) { print "has lacked"; } else { print "have lacked"; }
                4: print "had lacked";
                5: print "will lack";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not lack"; } else { print "do not lack"; }
                2: print "did not lack";
                3: if (vp == 3) { print "has not lacked"; } else { print "have not lacked"; }
                4: print "had not lacked";
                5: print "will not lack";
            }
    }
];
[ ConjugateVerb_39 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "lead";
        2: print "led";
        3: print "leading";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "leads"; } else { print "lead"; }
                2: print "led";
                3: if (vp == 3) { print "has led"; } else { print "have led"; }
                4: print "had led";
                5: print "will lead";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not lead"; } else { print "do not lead"; }
                2: print "did not lead";
                3: if (vp == 3) { print "has not led"; } else { print "have not led"; }
                4: print "had not led";
                5: print "will not lead";
            }
    }
];
[ ConjugateVerb_40 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "like";
        2: print "liked";
        3: print "liking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "likes"; } else { print "like"; }
                2: print "liked";
                3: if (vp == 3) { print "has liked"; } else { print "have liked"; }
                4: print "had liked";
                5: print "will like";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not like"; } else { print "do not like"; }
                2: print "did not like";
                3: if (vp == 3) { print "has not liked"; } else { print "have not liked"; }
                4: print "had not liked";
                5: print "will not like";
            }
    }
];
[ ConjugateVerb_41 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "listen";
        2: print "listened";
        3: print "listening";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "listens"; } else { print "listen"; }
                2: print "listened";
                3: if (vp == 3) { print "has listened"; } else { print "have listened"; }
                4: print "had listened";
                5: print "will listen";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not listen"; } else { print "do not listen"; }
                2: print "did not listen";
                3: if (vp == 3) { print "has not listened"; } else { print "have not listened"; }
                4: print "had not listened";
                5: print "will not listen";
            }
    }
];
[ ConjugateVerb_42 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "lock";
        2: print "locked";
        3: print "locking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "locks"; } else { print "lock"; }
                2: print "locked";
                3: if (vp == 3) { print "has locked"; } else { print "have locked"; }
                4: print "had locked";
                5: print "will lock";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not lock"; } else { print "do not lock"; }
                2: print "did not lock";
                3: if (vp == 3) { print "has not locked"; } else { print "have not locked"; }
                4: print "had not locked";
                5: print "will not lock";
            }
    }
];
[ ConjugateVerb_43 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "look";
        2: print "looked";
        3: print "looking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "looks"; } else { print "look"; }
                2: print "looked";
                3: if (vp == 3) { print "has looked"; } else { print "have looked"; }
                4: print "had looked";
                5: print "will look";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not look"; } else { print "do not look"; }
                2: print "did not look";
                3: if (vp == 3) { print "has not looked"; } else { print "have not looked"; }
                4: print "had not looked";
                5: print "will not look";
            }
    }
];
[ ConjugateVerb_44 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "need";
        2: print "needed";
        3: print "needing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "needs"; } else { print "need"; }
                2: print "needed";
                3: if (vp == 3) { print "has needed"; } else { print "have needed"; }
                4: print "had needed";
                5: print "will need";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not need"; } else { print "do not need"; }
                2: print "did not need";
                3: if (vp == 3) { print "has not needed"; } else { print "have not needed"; }
                4: print "had not needed";
                5: print "will not need";
            }
    }
];
[ ConjugateVerb_45 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "open";
        2: print "opened";
        3: print "opening";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "opens"; } else { print "open"; }
                2: print "opened";
                3: if (vp == 3) { print "has opened"; } else { print "have opened"; }
                4: print "had opened";
                5: print "will open";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not open"; } else { print "do not open"; }
                2: print "did not open";
                3: if (vp == 3) { print "has not opened"; } else { print "have not opened"; }
                4: print "had not opened";
                5: print "will not open";
            }
    }
];
[ ConjugateVerb_46 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "pass";
        2: print "passed";
        3: print "passing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "passes"; } else { print "pass"; }
                2: print "passed";
                3: if (vp == 3) { print "has passed"; } else { print "have passed"; }
                4: print "had passed";
                5: print "will pass";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not pass"; } else { print "do not pass"; }
                2: print "did not pass";
                3: if (vp == 3) { print "has not passed"; } else { print "have not passed"; }
                4: print "had not passed";
                5: print "will not pass";
            }
    }
];
[ ConjugateVerb_47 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "pick";
        2: print "picked";
        3: print "picking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "picks"; } else { print "pick"; }
                2: print "picked";
                3: if (vp == 3) { print "has picked"; } else { print "have picked"; }
                4: print "had picked";
                5: print "will pick";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not pick"; } else { print "do not pick"; }
                2: print "did not pick";
                3: if (vp == 3) { print "has not picked"; } else { print "have not picked"; }
                4: print "had not picked";
                5: print "will not pick";
            }
    }
];
[ ConjugateVerb_48 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "provoke";
        2: print "provoked";
        3: print "provoking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "provokes"; } else { print "provoke"; }
                2: print "provoked";
                3: if (vp == 3) { print "has provoked"; } else { print "have provoked"; }
                4: print "had provoked";
                5: print "will provoke";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not provoke"; } else { print "do not provoke"; }
                2: print "did not provoke";
                3: if (vp == 3) { print "has not provoked"; } else { print "have not provoked"; }
                4: print "had not provoked";
                5: print "will not provoke";
            }
    }
];
[ ConjugateVerb_49 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "pull";
        2: print "pulled";
        3: print "pulling";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "pulls"; } else { print "pull"; }
                2: print "pulled";
                3: if (vp == 3) { print "has pulled"; } else { print "have pulled"; }
                4: print "had pulled";
                5: print "will pull";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not pull"; } else { print "do not pull"; }
                2: print "did not pull";
                3: if (vp == 3) { print "has not pulled"; } else { print "have not pulled"; }
                4: print "had not pulled";
                5: print "will not pull";
            }
    }
];
[ ConjugateVerb_50 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "push";
        2: print "pushed";
        3: print "pushing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "pushes"; } else { print "push"; }
                2: print "pushed";
                3: if (vp == 3) { print "has pushed"; } else { print "have pushed"; }
                4: print "had pushed";
                5: print "will push";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not push"; } else { print "do not push"; }
                2: print "did not push";
                3: if (vp == 3) { print "has not pushed"; } else { print "have not pushed"; }
                4: print "had not pushed";
                5: print "will not push";
            }
    }
];
[ ConjugateVerb_51 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "put";
        2: print "put";
        3: print "putting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "puts"; } else { print "put"; }
                2: print "put";
                3: if (vp == 3) { print "has put"; } else { print "have put"; }
                4: print "had put";
                5: print "will put";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not put"; } else { print "do not put"; }
                2: print "did not put";
                3: if (vp == 3) { print "has not put"; } else { print "have not put"; }
                4: print "had not put";
                5: print "will not put";
            }
    }
];
[ ConjugateVerb_52 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "rub";
        2: print "rubbed";
        3: print "rubbing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "rubs"; } else { print "rub"; }
                2: print "rubbed";
                3: if (vp == 3) { print "has rubbed"; } else { print "have rubbed"; }
                4: print "had rubbed";
                5: print "will rub";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not rub"; } else { print "do not rub"; }
                2: print "did not rub";
                3: if (vp == 3) { print "has not rubbed"; } else { print "have not rubbed"; }
                4: print "had not rubbed";
                5: print "will not rub";
            }
    }
];
[ ConjugateVerb_53 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "say";
        2: print "said";
        3: print "saying";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "says"; } else { print "say"; }
                2: print "said";
                3: if (vp == 3) { print "has said"; } else { print "have said"; }
                4: print "had said";
                5: print "will say";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not say"; } else { print "do not say"; }
                2: print "did not say";
                3: if (vp == 3) { print "has not said"; } else { print "have not said"; }
                4: print "had not said";
                5: print "will not say";
            }
    }
];
[ ConjugateVerb_54 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "search";
        2: print "searched";
        3: print "searching";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "searches"; } else { print "search"; }
                2: print "searched";
                3: if (vp == 3) { print "has searched"; } else { print "have searched"; }
                4: print "had searched";
                5: print "will search";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not search"; } else { print "do not search"; }
                2: print "did not search";
                3: if (vp == 3) { print "has not searched"; } else { print "have not searched"; }
                4: print "had not searched";
                5: print "will not search";
            }
    }
];
[ ConjugateVerb_55 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "seem";
        2: print "seemed";
        3: print "seeming";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "seems"; } else { print "seem"; }
                2: print "seemed";
                3: if (vp == 3) { print "has seemed"; } else { print "have seemed"; }
                4: print "had seemed";
                5: print "will seem";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not seem"; } else { print "do not seem"; }
                2: print "did not seem";
                3: if (vp == 3) { print "has not seemed"; } else { print "have not seemed"; }
                4: print "had not seemed";
                5: print "will not seem";
            }
    }
];
[ ConjugateVerb_56 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "set";
        2: print "set";
        3: print "setting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "sets"; } else { print "set"; }
                2: print "set";
                3: if (vp == 3) { print "has set"; } else { print "have set"; }
                4: print "had set";
                5: print "will set";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not set"; } else { print "do not set"; }
                2: print "did not set";
                3: if (vp == 3) { print "has not set"; } else { print "have not set"; }
                4: print "had not set";
                5: print "will not set";
            }
    }
];
[ ConjugateVerb_57 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "smell";
        2: print "smelled";
        3: print "smelling";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "smells"; } else { print "smell"; }
                2: print "smelled";
                3: if (vp == 3) { print "has smelled"; } else { print "have smelled"; }
                4: print "had smelled";
                5: print "will smell";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not smell"; } else { print "do not smell"; }
                2: print "did not smell";
                3: if (vp == 3) { print "has not smelled"; } else { print "have not smelled"; }
                4: print "had not smelled";
                5: print "will not smell";
            }
    }
];
[ ConjugateVerb_58 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "sniff";
        2: print "sniffed";
        3: print "sniffing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "sniffs"; } else { print "sniff"; }
                2: print "sniffed";
                3: if (vp == 3) { print "has sniffed"; } else { print "have sniffed"; }
                4: print "had sniffed";
                5: print "will sniff";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not sniff"; } else { print "do not sniff"; }
                2: print "did not sniff";
                3: if (vp == 3) { print "has not sniffed"; } else { print "have not sniffed"; }
                4: print "had not sniffed";
                5: print "will not sniff";
            }
    }
];
[ ConjugateVerb_59 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "squeeze";
        2: print "squeezed";
        3: print "squeezing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "squeezes"; } else { print "squeeze"; }
                2: print "squeezed";
                3: if (vp == 3) { print "has squeezed"; } else { print "have squeezed"; }
                4: print "had squeezed";
                5: print "will squeeze";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not squeeze"; } else { print "do not squeeze"; }
                2: print "did not squeeze";
                3: if (vp == 3) { print "has not squeezed"; } else { print "have not squeezed"; }
                4: print "had not squeezed";
                5: print "will not squeeze";
            }
    }
];
[ ConjugateVerb_60 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "switch";
        2: print "switched";
        3: print "switching";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "switches"; } else { print "switch"; }
                2: print "switched";
                3: if (vp == 3) { print "has switched"; } else { print "have switched"; }
                4: print "had switched";
                5: print "will switch";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not switch"; } else { print "do not switch"; }
                2: print "did not switch";
                3: if (vp == 3) { print "has not switched"; } else { print "have not switched"; }
                4: print "had not switched";
                5: print "will not switch";
            }
    }
];
[ ConjugateVerb_61 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "take";
        2: print "taken";
        3: print "taking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "takes"; } else { print "take"; }
                2: print "took";
                3: if (vp == 3) { print "has taken"; } else { print "have taken"; }
                4: print "had taken";
                5: print "will take";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not take"; } else { print "do not take"; }
                2: print "did not take";
                3: if (vp == 3) { print "has not taken"; } else { print "have not taken"; }
                4: print "had not taken";
                5: print "will not take";
            }
    }
];
[ ConjugateVerb_62 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "talk";
        2: print "talked";
        3: print "talking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "talks"; } else { print "talk"; }
                2: print "talked";
                3: if (vp == 3) { print "has talked"; } else { print "have talked"; }
                4: print "had talked";
                5: print "will talk";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not talk"; } else { print "do not talk"; }
                2: print "did not talk";
                3: if (vp == 3) { print "has not talked"; } else { print "have not talked"; }
                4: print "had not talked";
                5: print "will not talk";
            }
    }
];
[ ConjugateVerb_63 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "taste";
        2: print "tasted";
        3: print "tasting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "tastes"; } else { print "taste"; }
                2: print "tasted";
                3: if (vp == 3) { print "has tasted"; } else { print "have tasted"; }
                4: print "had tasted";
                5: print "will taste";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not taste"; } else { print "do not taste"; }
                2: print "did not taste";
                3: if (vp == 3) { print "has not tasted"; } else { print "have not tasted"; }
                4: print "had not tasted";
                5: print "will not taste";
            }
    }
];
[ ConjugateVerb_64 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "turn";
        2: print "turned";
        3: print "turning";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "turns"; } else { print "turn"; }
                2: print "turned";
                3: if (vp == 3) { print "has turned"; } else { print "have turned"; }
                4: print "had turned";
                5: print "will turn";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not turn"; } else { print "do not turn"; }
                2: print "did not turn";
                3: if (vp == 3) { print "has not turned"; } else { print "have not turned"; }
                4: print "had not turned";
                5: print "will not turn";
            }
    }
];
[ ConjugateVerb_65 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "wait";
        2: print "waited";
        3: print "waiting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "waits"; } else { print "wait"; }
                2: print "waited";
                3: if (vp == 3) { print "has waited"; } else { print "have waited"; }
                4: print "had waited";
                5: print "will wait";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not wait"; } else { print "do not wait"; }
                2: print "did not wait";
                3: if (vp == 3) { print "has not waited"; } else { print "have not waited"; }
                4: print "had not waited";
                5: print "will not wait";
            }
    }
];
[ ConjugateVerb_66 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "wave";
        2: print "waved";
        3: print "waving";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "waves"; } else { print "wave"; }
                2: print "waved";
                3: if (vp == 3) { print "has waved"; } else { print "have waved"; }
                4: print "had waved";
                5: print "will wave";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not wave"; } else { print "do not wave"; }
                2: print "did not wave";
                3: if (vp == 3) { print "has not waved"; } else { print "have not waved"; }
                4: print "had not waved";
                5: print "will not wave";
            }
    }
];
[ ConjugateVerb_67 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "win";
        2: print "won";
        3: print "winning";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "wins"; } else { print "win"; }
                2: print "won";
                3: if (vp == 3) { print "has won"; } else { print "have won"; }
                4: print "had won";
                5: print "will win";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not win"; } else { print "do not win"; }
                2: print "did not win";
                3: if (vp == 3) { print "has not won"; } else { print "have not won"; }
                4: print "had not won";
                5: print "will not win";
            }
    }
];
[ ConjugateVerb_68 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "could";
        2: print "coulded";
        3: print "coulding";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "could"; if (modal_to) { print " "; modal_to(1); }
                    2: print "could"; if (modal_to) { print " "; modal_to(1); }
                    3: print "could"; if (modal_to) { print " "; modal_to(1); }
                    4: print "could"; if (modal_to) { print " "; modal_to(1); }
                    5: print "could"; if (modal_to) { print " "; modal_to(1); }
                    6: print "could"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "could have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "could have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "could have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "could have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "could"; if (modal_to) { print " "; modal_to(1); }
                    2: print "could"; if (modal_to) { print " "; modal_to(1); }
                    3: print "could"; if (modal_to) { print " "; modal_to(1); }
                    4: print "could"; if (modal_to) { print " "; modal_to(1); }
                    5: print "could"; if (modal_to) { print " "; modal_to(1); }
                    6: print "could"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "could not"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "could not have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "could not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "could not"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_69 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "may";
        2: print "mayed";
        3: print "maying";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "may"; if (modal_to) { print " "; modal_to(1); }
                    2: print "may"; if (modal_to) { print " "; modal_to(1); }
                    3: print "may"; if (modal_to) { print " "; modal_to(1); }
                    4: print "may"; if (modal_to) { print " "; modal_to(1); }
                    5: print "may"; if (modal_to) { print " "; modal_to(1); }
                    6: print "may"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "may have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "may have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "may have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "may have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "may"; if (modal_to) { print " "; modal_to(1); }
                    2: print "may"; if (modal_to) { print " "; modal_to(1); }
                    3: print "may"; if (modal_to) { print " "; modal_to(1); }
                    4: print "may"; if (modal_to) { print " "; modal_to(1); }
                    5: print "may"; if (modal_to) { print " "; modal_to(1); }
                    6: print "may"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "may not"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "may not have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "may not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "may not"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_70 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "might";
        2: print "mighted";
        3: print "mighting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "might"; if (modal_to) { print " "; modal_to(1); }
                    2: print "might"; if (modal_to) { print " "; modal_to(1); }
                    3: print "might"; if (modal_to) { print " "; modal_to(1); }
                    4: print "might"; if (modal_to) { print " "; modal_to(1); }
                    5: print "might"; if (modal_to) { print " "; modal_to(1); }
                    6: print "might"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "might have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "might have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "might have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "might have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "might"; if (modal_to) { print " "; modal_to(1); }
                    2: print "might"; if (modal_to) { print " "; modal_to(1); }
                    3: print "might"; if (modal_to) { print " "; modal_to(1); }
                    4: print "might"; if (modal_to) { print " "; modal_to(1); }
                    5: print "might"; if (modal_to) { print " "; modal_to(1); }
                    6: print "might"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "might not"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "might not have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "might not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "might not"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_71 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "must";
        2: print "musted";
        3: print "musting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "must"; if (modal_to) { print " "; modal_to(1); }
                    2: print "must"; if (modal_to) { print " "; modal_to(1); }
                    3: print "must"; if (modal_to) { print " "; modal_to(1); }
                    4: print "must"; if (modal_to) { print " "; modal_to(1); }
                    5: print "must"; if (modal_to) { print " "; modal_to(1); }
                    6: print "must"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "must have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "must have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "must have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "must have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "must"; if (modal_to) { print " "; modal_to(1); }
                    2: print "must"; if (modal_to) { print " "; modal_to(1); }
                    3: print "must"; if (modal_to) { print " "; modal_to(1); }
                    4: print "must"; if (modal_to) { print " "; modal_to(1); }
                    5: print "must"; if (modal_to) { print " "; modal_to(1); }
                    6: print "must"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "must not"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "must not have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "must not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "must not"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_72 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "should";
        2: print "shoulded";
        3: print "shoulding";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "should"; if (modal_to) { print " "; modal_to(1); }
                    2: print "should"; if (modal_to) { print " "; modal_to(1); }
                    3: print "should"; if (modal_to) { print " "; modal_to(1); }
                    4: print "should"; if (modal_to) { print " "; modal_to(1); }
                    5: print "should"; if (modal_to) { print " "; modal_to(1); }
                    6: print "should"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "should have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "should have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "should have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "should have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "should"; if (modal_to) { print " "; modal_to(1); }
                    2: print "should"; if (modal_to) { print " "; modal_to(1); }
                    3: print "should"; if (modal_to) { print " "; modal_to(1); }
                    4: print "should"; if (modal_to) { print " "; modal_to(1); }
                    5: print "should"; if (modal_to) { print " "; modal_to(1); }
                    6: print "should"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "should not"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "should not have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "should not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "should not"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_73 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "would";
        2: print "woulded";
        3: print "woulding";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "would"; if (modal_to) { print " "; modal_to(1); }
                    2: print "would"; if (modal_to) { print " "; modal_to(1); }
                    3: print "would"; if (modal_to) { print " "; modal_to(1); }
                    4: print "would"; if (modal_to) { print " "; modal_to(1); }
                    5: print "would"; if (modal_to) { print " "; modal_to(1); }
                    6: print "would"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "would have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "would have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "would have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "would have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "would"; if (modal_to) { print " "; modal_to(1); }
                    2: print "would"; if (modal_to) { print " "; modal_to(1); }
                    3: print "would"; if (modal_to) { print " "; modal_to(1); }
                    4: print "would"; if (modal_to) { print " "; modal_to(1); }
                    5: print "would"; if (modal_to) { print " "; modal_to(1); }
                    6: print "would"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "would not"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "would not have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    2: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    3: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    4: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    5: print "would not"; if (modal_to) { print " "; modal_to(1); }
                    6: print "would not"; if (modal_to) { print " "; modal_to(1); }
                }
            }
    }
];
[ ConjugateVerb_74 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "'re";
        2: print " been";
        3: print " being";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "'m";
                    2: print "'re";
                    3: print "'s";
                    4: print "'re";
                    5: print "'re";
                    6: print "'re";
                }
                2: switch (vp) {
                    1: print " was";
                    2: print " were";
                    3: print " was";
                    4: print " were";
                    5: print " were";
                    6: print " were";
                }
                3: if (vp == 3) { print "'s been"; } else { print "'ve been"; }
                4: print "'d been";
                5: print "'ll be";
            }
        CV_NEG:
            switch (t) {
                1: switch (vp) {
                    1: print "'m not";
                    2: print "'re not";
                    3: print "'s not";
                    4: print "'re not";
                    5: print "'re not";
                    6: print "'re not";
                }
                2: switch (vp) {
                    1: print " wasn't";
                    2: print " weren't";
                    3: print " wasn't";
                    4: print " weren't";
                    5: print " weren't";
                    6: print " weren't";
                }
                3: if (vp == 3) { print "'s not been"; } else { print "'ve not been"; }
                4: print "'d not been";
                5: print "'ll not be";
            }
    }
];
[ ConjugateVerb_75 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "'ve";
        2: print " had";
        3: print " having";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "'s"; } else { print "'ve"; }
                2: print " had";
                3: if (vp == 3) { print "'s had"; } else { print "'ve had"; }
                4: print "'d had";
                5: print "'ll have";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "'s not"; } else { print "'ve not"; }
                2: print " hadn't";
                3: if (vp == 3) { print "'s not had"; } else { print "'ve not had"; }
                4: print "'d not had";
                5: print "'ll not have";
            }
    }
];
[ ConjugateVerb_76 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "aren't";
        2: print "aren'ted";
        3: print "aren'ting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "am not";
                    2: print "aren't";
                    3: print "isn't";
                    4: print "aren't";
                    5: print "aren't";
                    6: print "aren't";
                }
                2: switch (vp) {
                    1: print "wasn't";
                    2: print "weren't";
                    3: print "wasn't";
                    4: print "weren't";
                    5: print "weren't";
                    6: print "weren't";
                }
                3: if (vp == 3) { print "hasn't been"; } else { print "haven't been"; }
                4: print "hadn't been";
                5: print "won't be";
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_77 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "can't";
        2: print "can'ted";
        3: print "can'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "can't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "can't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "can't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "can't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "can't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "can't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                }
                3: switch (vp) {
                    1: print "haven't been able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "haven't been able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "hasn't been able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "haven't been able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "haven't been able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "haven't been able to"; if (modal_to) { print " "; modal_to(1); }
                }
                4: switch (vp) {
                    1: print "hadn't been able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "hadn't been able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "hadn't been able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "hadn't been able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "hadn't been able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "hadn't been able to"; if (modal_to) { print " "; modal_to(1); }
                }
                5: switch (vp) {
                    1: print "won't be able to"; if (modal_to) { print " "; modal_to(1); }
                    2: print "won't be able to"; if (modal_to) { print " "; modal_to(1); }
                    3: print "won't be able to"; if (modal_to) { print " "; modal_to(1); }
                    4: print "won't be able to"; if (modal_to) { print " "; modal_to(1); }
                    5: print "won't be able to"; if (modal_to) { print " "; modal_to(1); }
                    6: print "won't be able to"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_78 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "haven't";
        2: print "haven'ted";
        3: print "haven'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "haven't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "haven't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "hasn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "haven't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "haven't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "haven't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "hadn't"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "won't have"; if (modal_to) { print " "; modal_to(1); }
                    2: print "won't have"; if (modal_to) { print " "; modal_to(1); }
                    3: print "won't have"; if (modal_to) { print " "; modal_to(1); }
                    4: print "won't have"; if (modal_to) { print " "; modal_to(1); }
                    5: print "won't have"; if (modal_to) { print " "; modal_to(1); }
                    6: print "won't have"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_79 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "don't";
        2: print "don'ted";
        3: print "don'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "don't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "don't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "doesn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "don't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "don't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "don't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "didn't"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "won't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_80 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "mustn't";
        2: print "mustn'ted";
        3: print "mustn'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mustn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "mustn't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_81 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "mightn't";
        2: print "mightn'ted";
        3: print "mightn'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mightn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "mightn't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_82 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "mayn't";
        2: print "mayn'ted";
        3: print "mayn'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "mayn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "mayn't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_83 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "wouldn't";
        2: print "wouldn'ted";
        3: print "wouldn'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "wouldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "wouldn't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_84 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "couldn't";
        2: print "couldn'ted";
        3: print "couldn'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "couldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "couldn't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_85 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "shouldn't";
        2: print "shouldn'ted";
        3: print "shouldn'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    2: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    3: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    4: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    5: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                    6: print "shouldn't have"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "shouldn't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_86 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "won't";
        2: print "won'ted";
        3: print "won'ting";
        CV_MODAL: return true;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: switch (vp) {
                    1: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "won't"; if (modal_to) { print " "; modal_to(1); }
                }
                2: switch (vp) {
                    1: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                }
                3: switch (vp) {
                    1: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                }
                4: switch (vp) {
                    1: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    2: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    3: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    4: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    5: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                    6: print "wouldn't"; if (modal_to) { print " "; modal_to(2); }
                }
                5: switch (vp) {
                    1: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    2: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    3: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    4: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    5: print "won't"; if (modal_to) { print " "; modal_to(1); }
                    6: print "won't"; if (modal_to) { print " "; modal_to(1); }
                }
            }
        CV_NEG:
            switch (t) {
            }
    }
];
[ ConjugateVerb_87 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "know";
        2: print "known";
        3: print "knowing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_71;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "knows"; } else { print "know"; }
                2: print "knew";
                3: if (vp == 3) { print "has known"; } else { print "have known"; }
                4: print "had known";
                5: print "will know";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not know"; } else { print "do not know"; }
                2: print "did not know";
                3: if (vp == 3) { print "has not known"; } else { print "have not known"; }
                4: print "had not known";
                5: print "will not know";
            }
    }
];
[ ConjugateVerb_88 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "hang";
        2: print "hung";
        3: print "hanging";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "hangs"; } else { print "hang"; }
                2: print "hung";
                3: if (vp == 3) { print "has hung"; } else { print "have hung"; }
                4: print "had hung";
                5: print "will hang";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not hang"; } else { print "do not hang"; }
                2: print "did not hang";
                3: if (vp == 3) { print "has not hung"; } else { print "have not hung"; }
                4: print "had not hung";
                5: print "will not hang";
            }
    }
];
[ ConjugateVerb_89 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "reach";
        2: print "reached by";
        3: print "reaching";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_79;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "reaches"; } else { print "reach"; }
                2: print "reaches";
                3: if (vp == 3) { print "has reached by"; } else { print "have reached by"; }
                4: print "had reached by";
                5: print "will reach";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not reach"; } else { print "do not reach"; }
                2: print "did not reach";
                3: if (vp == 3) { print "has not reached by"; } else { print "have not reached by"; }
                4: print "had not reached by";
                5: print "will not reach";
            }
    }
];
[ ConjugateVerb_90 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "own";
        2: print "owned";
        3: print "owning";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_81;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "owns"; } else { print "own"; }
                2: print "owned";
                3: if (vp == 3) { print "has owned"; } else { print "have owned"; }
                4: print "had owned";
                5: print "will own";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not own"; } else { print "do not own"; }
                2: print "did not own";
                3: if (vp == 3) { print "has not owned"; } else { print "have not owned"; }
                4: print "had not owned";
                5: print "will not own";
            }
    }
];
[ ConjugateVerb_91 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "belong";
        2: print "belonged";
        3: print "belonging";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "belongs"; } else { print "belong"; }
                2: print "belonged";
                3: if (vp == 3) { print "has belonged"; } else { print "have belonged"; }
                4: print "had belonged";
                5: print "will belong";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not belong"; } else { print "do not belong"; }
                2: print "did not belong";
                3: if (vp == 3) { print "has not belonged"; } else { print "have not belonged"; }
                4: print "had not belonged";
                5: print "will not belong";
            }
    }
];
[ ConjugateVerb_92 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "demonstrate";
        2: print "demonstrated";
        3: print "demonstrating";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_85;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "demonstrates"; } else { print "demonstrate"; }
                2: print "demonstrated";
                3: if (vp == 3) { print "has demonstrated"; } else { print "have demonstrated"; }
                4: print "had demonstrated";
                5: print "will demonstrate";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not demonstrate"; } else { print "do not demonstrate"; }
                2: print "did not demonstrate";
                3: if (vp == 3) { print "has not demonstrated"; } else { print "have not demonstrated"; }
                4: print "had not demonstrated";
                5: print "will not demonstrate";
            }
    }
];
[ ConjugateVerb_93 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "quip-supply";
        2: print "quip-supplied";
        3: print "quip-supplying";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_89;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "quip-supplies"; } else { print "quip-supply"; }
                2: print "quip-supplied";
                3: if (vp == 3) { print "has quip-supplied"; } else { print "have quip-supplied"; }
                4: print "had quip-supplied";
                5: print "will quip-supply";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not quip-supply"; } else { print "do not quip-supply"; }
                2: print "did not quip-supply";
                3: if (vp == 3) { print "has not quip-supplied"; } else { print "have not quip-supplied"; }
                4: print "had not quip-supplied";
                5: print "will not quip-supply";
            }
    }
];
[ ConjugateVerb_94 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "follow";
        2: print "followed";
        3: print "following";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_91;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "follows"; } else { print "follow"; }
                2: print "followed";
                3: if (vp == 3) { print "has followed"; } else { print "have followed"; }
                4: print "had followed";
                5: print "will follow";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not follow"; } else { print "do not follow"; }
                2: print "did not follow";
                3: if (vp == 3) { print "has not followed"; } else { print "have not followed"; }
                4: print "had not followed";
                5: print "will not follow";
            }
    }
];
[ ConjugateVerb_95 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "rule out";
        2: print "ruled out";
        3: print "ruling out";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_93;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "rules out"; } else { print "rule out"; }
                2: print "ruled out";
                3: if (vp == 3) { print "has ruled out"; } else { print "have ruled out"; }
                4: print "had ruled out";
                5: print "will rule out";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not rule out"; } else { print "do not rule out"; }
                2: print "did not rule out";
                3: if (vp == 3) { print "has not ruled out"; } else { print "have not ruled out"; }
                4: print "had not ruled out";
                5: print "will not rule out";
            }
    }
];
[ ConjugateVerb_96 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "mention";
        2: print "mentioned";
        3: print "mentioning";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_95;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "mentions"; } else { print "mention"; }
                2: print "mentioned";
                3: if (vp == 3) { print "has mentioned"; } else { print "have mentioned"; }
                4: print "had mentioned";
                5: print "will mention";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not mention"; } else { print "do not mention"; }
                2: print "did not mention";
                3: if (vp == 3) { print "has not mentioned"; } else { print "have not mentioned"; }
                4: print "had not mentioned";
                5: print "will not mention";
            }
    }
];
[ ConjugateVerb_97 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "stock";
        2: print "stocked";
        3: print "stocking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_97;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "stocks"; } else { print "stock"; }
                2: print "stocked";
                3: if (vp == 3) { print "has stocked"; } else { print "have stocked"; }
                4: print "had stocked";
                5: print "will stock";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not stock"; } else { print "do not stock"; }
                2: print "did not stock";
                3: if (vp == 3) { print "has not stocked"; } else { print "have not stocked"; }
                4: print "had not stocked";
                5: print "will not stock";
            }
    }
];
[ ConjugateVerb_98 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "branch";
        2: print "branched";
        3: print "branching";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "branches"; } else { print "branch"; }
                2: print "branched";
                3: if (vp == 3) { print "has branched"; } else { print "have branched"; }
                4: print "had branched";
                5: print "will branch";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not branch"; } else { print "do not branch"; }
                2: print "did not branch";
                3: if (vp == 3) { print "has not branched"; } else { print "have not branched"; }
                4: print "had not branched";
                5: print "will not branch";
            }
    }
];
[ ConjugateVerb_99 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "shake";
        2: print "shaken";
        3: print "shaking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "shakes"; } else { print "shake"; }
                2: print "shook";
                3: if (vp == 3) { print "has shaken"; } else { print "have shaken"; }
                4: print "had shaken";
                5: print "will shake";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not shake"; } else { print "do not shake"; }
                2: print "did not shake";
                3: if (vp == 3) { print "has not shaken"; } else { print "have not shaken"; }
                4: print "had not shaken";
                5: print "will not shake";
            }
    }
];
[ ConjugateVerb_100 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "make";
        2: print "made";
        3: print "making";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "makes"; } else { print "make"; }
                2: print "made";
                3: if (vp == 3) { print "has made"; } else { print "have made"; }
                4: print "had made";
                5: print "will make";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not make"; } else { print "do not make"; }
                2: print "did not make";
                3: if (vp == 3) { print "has not made"; } else { print "have not made"; }
                4: print "had not made";
                5: print "will not make";
            }
    }
];
[ ConjugateVerb_101 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "remove";
        2: print "removed";
        3: print "removing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "removes"; } else { print "remove"; }
                2: print "removed";
                3: if (vp == 3) { print "has removed"; } else { print "have removed"; }
                4: print "had removed";
                5: print "will remove";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not remove"; } else { print "do not remove"; }
                2: print "did not remove";
                3: if (vp == 3) { print "has not removed"; } else { print "have not removed"; }
                4: print "had not removed";
                5: print "will not remove";
            }
    }
];
[ ConjugateVerb_102 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "survey";
        2: print "surveyed";
        3: print "surveying";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "surveys"; } else { print "survey"; }
                2: print "surveyed";
                3: if (vp == 3) { print "has surveyed"; } else { print "have surveyed"; }
                4: print "had surveyed";
                5: print "will survey";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not survey"; } else { print "do not survey"; }
                2: print "did not survey";
                3: if (vp == 3) { print "has not surveyed"; } else { print "have not surveyed"; }
                4: print "had not surveyed";
                5: print "will not survey";
            }
    }
];
[ ConjugateVerb_103 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "wrinkle";
        2: print "wrinkled";
        3: print "wrinkling";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "wrinkles"; } else { print "wrinkle"; }
                2: print "wrinkled";
                3: if (vp == 3) { print "has wrinkled"; } else { print "have wrinkled"; }
                4: print "had wrinkled";
                5: print "will wrinkle";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not wrinkle"; } else { print "do not wrinkle"; }
                2: print "did not wrinkle";
                3: if (vp == 3) { print "has not wrinkled"; } else { print "have not wrinkled"; }
                4: print "had not wrinkled";
                5: print "will not wrinkle";
            }
    }
];
[ ConjugateVerb_104 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "smile";
        2: print "smiled";
        3: print "smiling";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "smiles"; } else { print "smile"; }
                2: print "smiled";
                3: if (vp == 3) { print "has smiled"; } else { print "have smiled"; }
                4: print "had smiled";
                5: print "will smile";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not smile"; } else { print "do not smile"; }
                2: print "did not smile";
                3: if (vp == 3) { print "has not smiled"; } else { print "have not smiled"; }
                4: print "had not smiled";
                5: print "will not smile";
            }
    }
];
[ ConjugateVerb_105 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "sigh";
        2: print "sighed";
        3: print "sighing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "sighs"; } else { print "sigh"; }
                2: print "sighed";
                3: if (vp == 3) { print "has sighed"; } else { print "have sighed"; }
                4: print "had sighed";
                5: print "will sigh";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not sigh"; } else { print "do not sigh"; }
                2: print "did not sigh";
                3: if (vp == 3) { print "has not sighed"; } else { print "have not sighed"; }
                4: print "had not sighed";
                5: print "will not sigh";
            }
    }
];
[ ConjugateVerb_106 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "peer";
        2: print "peered";
        3: print "peering";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "peers"; } else { print "peer"; }
                2: print "peered";
                3: if (vp == 3) { print "has peered"; } else { print "have peered"; }
                4: print "had peered";
                5: print "will peer";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not peer"; } else { print "do not peer"; }
                2: print "did not peer";
                3: if (vp == 3) { print "has not peered"; } else { print "have not peered"; }
                4: print "had not peered";
                5: print "will not peer";
            }
    }
];
[ ConjugateVerb_107 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "observe";
        2: print "observed";
        3: print "observing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "observes"; } else { print "observe"; }
                2: print "observed";
                3: if (vp == 3) { print "has observed"; } else { print "have observed"; }
                4: print "had observed";
                5: print "will observe";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not observe"; } else { print "do not observe"; }
                2: print "did not observe";
                3: if (vp == 3) { print "has not observed"; } else { print "have not observed"; }
                4: print "had not observed";
                5: print "will not observe";
            }
    }
];
[ ConjugateVerb_108 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "gaze";
        2: print "gazed";
        3: print "gazing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "gazes"; } else { print "gaze"; }
                2: print "gazed";
                3: if (vp == 3) { print "has gazed"; } else { print "have gazed"; }
                4: print "had gazed";
                5: print "will gaze";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not gaze"; } else { print "do not gaze"; }
                2: print "did not gaze";
                3: if (vp == 3) { print "has not gazed"; } else { print "have not gazed"; }
                4: print "had not gazed";
                5: print "will not gaze";
            }
    }
];
[ ConjugateVerb_109 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "trudge";
        2: print "trudged";
        3: print "trudging";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "trudges"; } else { print "trudge"; }
                2: print "trudged";
                3: if (vp == 3) { print "has trudged"; } else { print "have trudged"; }
                4: print "had trudged";
                5: print "will trudge";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not trudge"; } else { print "do not trudge"; }
                2: print "did not trudge";
                3: if (vp == 3) { print "has not trudged"; } else { print "have not trudged"; }
                4: print "had not trudged";
                5: print "will not trudge";
            }
    }
];
[ ConjugateVerb_110 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "walk";
        2: print "walked";
        3: print "walking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "walks"; } else { print "walk"; }
                2: print "walked";
                3: if (vp == 3) { print "has walked"; } else { print "have walked"; }
                4: print "had walked";
                5: print "will walk";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not walk"; } else { print "do not walk"; }
                2: print "did not walk";
                3: if (vp == 3) { print "has not walked"; } else { print "have not walked"; }
                4: print "had not walked";
                5: print "will not walk";
            }
    }
];
[ ConjugateVerb_111 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "step";
        2: print "stepped";
        3: print "stepping";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "steps"; } else { print "step"; }
                2: print "stepped";
                3: if (vp == 3) { print "has stepped"; } else { print "have stepped"; }
                4: print "had stepped";
                5: print "will step";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not step"; } else { print "do not step"; }
                2: print "did not step";
                3: if (vp == 3) { print "has not stepped"; } else { print "have not stepped"; }
                4: print "had not stepped";
                5: print "will not step";
            }
    }
];
[ ConjugateVerb_112 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "enter";
        2: print "entered";
        3: print "entering";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "enters"; } else { print "enter"; }
                2: print "entered";
                3: if (vp == 3) { print "has entered"; } else { print "have entered"; }
                4: print "had entered";
                5: print "will enter";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not enter"; } else { print "do not enter"; }
                2: print "did not enter";
                3: if (vp == 3) { print "has not entered"; } else { print "have not entered"; }
                4: print "had not entered";
                5: print "will not enter";
            }
    }
];
[ ConjugateVerb_113 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "exit";
        2: print "exited";
        3: print "exiting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "exits"; } else { print "exit"; }
                2: print "exited";
                3: if (vp == 3) { print "has exited"; } else { print "have exited"; }
                4: print "had exited";
                5: print "will exit";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not exit"; } else { print "do not exit"; }
                2: print "did not exit";
                3: if (vp == 3) { print "has not exited"; } else { print "have not exited"; }
                4: print "had not exited";
                5: print "will not exit";
            }
    }
];
[ ConjugateVerb_114 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "pause";
        2: print "paused";
        3: print "pausing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "pauses"; } else { print "pause"; }
                2: print "paused";
                3: if (vp == 3) { print "has paused"; } else { print "have paused"; }
                4: print "had paused";
                5: print "will pause";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not pause"; } else { print "do not pause"; }
                2: print "did not pause";
                3: if (vp == 3) { print "has not paused"; } else { print "have not paused"; }
                4: print "had not paused";
                5: print "will not pause";
            }
    }
];
[ ConjugateVerb_115 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "hand";
        2: print "handed";
        3: print "handing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "hands"; } else { print "hand"; }
                2: print "handed";
                3: if (vp == 3) { print "has handed"; } else { print "have handed"; }
                4: print "had handed";
                5: print "will hand";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not hand"; } else { print "do not hand"; }
                2: print "did not hand";
                3: if (vp == 3) { print "has not handed"; } else { print "have not handed"; }
                4: print "had not handed";
                5: print "will not hand";
            }
    }
];
[ ConjugateVerb_116 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "try";
        2: print "tried";
        3: print "trying";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "tries"; } else { print "try"; }
                2: print "tried";
                3: if (vp == 3) { print "has tried"; } else { print "have tried"; }
                4: print "had tried";
                5: print "will try";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not try"; } else { print "do not try"; }
                2: print "did not try";
                3: if (vp == 3) { print "has not tried"; } else { print "have not tried"; }
                4: print "had not tried";
                5: print "will not try";
            }
    }
];
[ ConjugateVerb_117 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "squeal";
        2: print "squealed";
        3: print "squealing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "squeals"; } else { print "squeal"; }
                2: print "squealed";
                3: if (vp == 3) { print "has squealed"; } else { print "have squealed"; }
                4: print "had squealed";
                5: print "will squeal";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not squeal"; } else { print "do not squeal"; }
                2: print "did not squeal";
                3: if (vp == 3) { print "has not squealed"; } else { print "have not squealed"; }
                4: print "had not squealed";
                5: print "will not squeal";
            }
    }
];
[ ConjugateVerb_118 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "tap";
        2: print "tapped";
        3: print "tapping";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "taps"; } else { print "tap"; }
                2: print "tapped";
                3: if (vp == 3) { print "has tapped"; } else { print "have tapped"; }
                4: print "had tapped";
                5: print "will tap";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not tap"; } else { print "do not tap"; }
                2: print "did not tap";
                3: if (vp == 3) { print "has not tapped"; } else { print "have not tapped"; }
                4: print "had not tapped";
                5: print "will not tap";
            }
    }
];
[ ConjugateVerb_119 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "curse";
        2: print "cursed";
        3: print "cursing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "curses"; } else { print "curse"; }
                2: print "cursed";
                3: if (vp == 3) { print "has cursed"; } else { print "have cursed"; }
                4: print "had cursed";
                5: print "will curse";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not curse"; } else { print "do not curse"; }
                2: print "did not curse";
                3: if (vp == 3) { print "has not cursed"; } else { print "have not cursed"; }
                4: print "had not cursed";
                5: print "will not curse";
            }
    }
];
[ ConjugateVerb_120 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "rap";
        2: print "rapped";
        3: print "rapping";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "raps"; } else { print "rap"; }
                2: print "rapped";
                3: if (vp == 3) { print "has rapped"; } else { print "have rapped"; }
                4: print "had rapped";
                5: print "will rap";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not rap"; } else { print "do not rap"; }
                2: print "did not rap";
                3: if (vp == 3) { print "has not rapped"; } else { print "have not rapped"; }
                4: print "had not rapped";
                5: print "will not rap";
            }
    }
];
[ ConjugateVerb_121 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "explain";
        2: print "explained";
        3: print "explaining";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "explains"; } else { print "explain"; }
                2: print "explained";
                3: if (vp == 3) { print "has explained"; } else { print "have explained"; }
                4: print "had explained";
                5: print "will explain";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not explain"; } else { print "do not explain"; }
                2: print "did not explain";
                3: if (vp == 3) { print "has not explained"; } else { print "have not explained"; }
                4: print "had not explained";
                5: print "will not explain";
            }
    }
];
[ ConjugateVerb_122 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "gasp";
        2: print "gasped";
        3: print "gasping";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "gasps"; } else { print "gasp"; }
                2: print "gasped";
                3: if (vp == 3) { print "has gasped"; } else { print "have gasped"; }
                4: print "had gasped";
                5: print "will gasp";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not gasp"; } else { print "do not gasp"; }
                2: print "did not gasp";
                3: if (vp == 3) { print "has not gasped"; } else { print "have not gasped"; }
                4: print "had not gasped";
                5: print "will not gasp";
            }
    }
];
[ ConjugateVerb_123 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "return";
        2: print "returned";
        3: print "returning";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "returns"; } else { print "return"; }
                2: print "returned";
                3: if (vp == 3) { print "has returned"; } else { print "have returned"; }
                4: print "had returned";
                5: print "will return";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not return"; } else { print "do not return"; }
                2: print "did not return";
                3: if (vp == 3) { print "has not returned"; } else { print "have not returned"; }
                4: print "had not returned";
                5: print "will not return";
            }
    }
];
[ ConjugateVerb_124 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "ask";
        2: print "asked";
        3: print "asking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "asks"; } else { print "ask"; }
                2: print "asked";
                3: if (vp == 3) { print "has asked"; } else { print "have asked"; }
                4: print "had asked";
                5: print "will ask";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not ask"; } else { print "do not ask"; }
                2: print "did not ask";
                3: if (vp == 3) { print "has not asked"; } else { print "have not asked"; }
                4: print "had not asked";
                5: print "will not ask";
            }
    }
];
[ ConjugateVerb_125 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "think";
        2: print "thought";
        3: print "thinking";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "thinks"; } else { print "think"; }
                2: print "thought";
                3: if (vp == 3) { print "has thought"; } else { print "have thought"; }
                4: print "had thought";
                5: print "will think";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not think"; } else { print "do not think"; }
                2: print "did not think";
                3: if (vp == 3) { print "has not thought"; } else { print "have not thought"; }
                4: print "had not thought";
                5: print "will not think";
            }
    }
];
[ ConjugateVerb_126 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "scrunch";
        2: print "scrunched";
        3: print "scrunching";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "scrunches"; } else { print "scrunch"; }
                2: print "scrunched";
                3: if (vp == 3) { print "has scrunched"; } else { print "have scrunched"; }
                4: print "had scrunched";
                5: print "will scrunch";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not scrunch"; } else { print "do not scrunch"; }
                2: print "did not scrunch";
                3: if (vp == 3) { print "has not scrunched"; } else { print "have not scrunched"; }
                4: print "had not scrunched";
                5: print "will not scrunch";
            }
    }
];
[ ConjugateVerb_127 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "grimace";
        2: print "grimaced";
        3: print "grimacing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "grimaces"; } else { print "grimace"; }
                2: print "grimaced";
                3: if (vp == 3) { print "has grimaced"; } else { print "have grimaced"; }
                4: print "had grimaced";
                5: print "will grimace";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not grimace"; } else { print "do not grimace"; }
                2: print "did not grimace";
                3: if (vp == 3) { print "has not grimaced"; } else { print "have not grimaced"; }
                4: print "had not grimaced";
                5: print "will not grimace";
            }
    }
];
[ ConjugateVerb_128 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "mutter";
        2: print "muttered";
        3: print "muttering";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "mutters"; } else { print "mutter"; }
                2: print "muttered";
                3: if (vp == 3) { print "has muttered"; } else { print "have muttered"; }
                4: print "had muttered";
                5: print "will mutter";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not mutter"; } else { print "do not mutter"; }
                2: print "did not mutter";
                3: if (vp == 3) { print "has not muttered"; } else { print "have not muttered"; }
                4: print "had not muttered";
                5: print "will not mutter";
            }
    }
];
[ ConjugateVerb_129 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "leave";
        2: print "left";
        3: print "leaving";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "leaves"; } else { print "leave"; }
                2: print "left";
                3: if (vp == 3) { print "has left"; } else { print "have left"; }
                4: print "had left";
                5: print "will leave";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not leave"; } else { print "do not leave"; }
                2: print "did not leave";
                3: if (vp == 3) { print "has not left"; } else { print "have not left"; }
                4: print "had not left";
                5: print "will not leave";
            }
    }
];
[ ConjugateVerb_130 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "stand";
        2: print "stood";
        3: print "standing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "stands"; } else { print "stand"; }
                2: print "stood";
                3: if (vp == 3) { print "has stood"; } else { print "have stood"; }
                4: print "had stood";
                5: print "will stand";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not stand"; } else { print "do not stand"; }
                2: print "did not stand";
                3: if (vp == 3) { print "has not stood"; } else { print "have not stood"; }
                4: print "had not stood";
                5: print "will not stand";
            }
    }
];
[ ConjugateVerb_131 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "mount";
        2: print "mounted";
        3: print "mounting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "mounts"; } else { print "mount"; }
                2: print "mounted";
                3: if (vp == 3) { print "has mounted"; } else { print "have mounted"; }
                4: print "had mounted";
                5: print "will mount";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not mount"; } else { print "do not mount"; }
                2: print "did not mount";
                3: if (vp == 3) { print "has not mounted"; } else { print "have not mounted"; }
                4: print "had not mounted";
                5: print "will not mount";
            }
    }
];
[ ConjugateVerb_132 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "stammer";
        2: print "stammered";
        3: print "stammering";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "stammers"; } else { print "stammer"; }
                2: print "stammered";
                3: if (vp == 3) { print "has stammered"; } else { print "have stammered"; }
                4: print "had stammered";
                5: print "will stammer";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not stammer"; } else { print "do not stammer"; }
                2: print "did not stammer";
                3: if (vp == 3) { print "has not stammered"; } else { print "have not stammered"; }
                4: print "had not stammered";
                5: print "will not stammer";
            }
    }
];
[ ConjugateVerb_133 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "polish";
        2: print "polished";
        3: print "polishing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "polishes"; } else { print "polish"; }
                2: print "polished";
                3: if (vp == 3) { print "has polished"; } else { print "have polished"; }
                4: print "had polished";
                5: print "will polish";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not polish"; } else { print "do not polish"; }
                2: print "did not polish";
                3: if (vp == 3) { print "has not polished"; } else { print "have not polished"; }
                4: print "had not polished";
                5: print "will not polish";
            }
    }
];
[ ConjugateVerb_134 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "interrupt";
        2: print "interrupted";
        3: print "interrupting";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "interrupts"; } else { print "interrupt"; }
                2: print "interrupted";
                3: if (vp == 3) { print "has interrupted"; } else { print "have interrupted"; }
                4: print "had interrupted";
                5: print "will interrupt";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not interrupt"; } else { print "do not interrupt"; }
                2: print "did not interrupt";
                3: if (vp == 3) { print "has not interrupted"; } else { print "have not interrupted"; }
                4: print "had not interrupted";
                5: print "will not interrupt";
            }
    }
];
[ ConjugateVerb_135 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "raise";
        2: print "raised";
        3: print "raising";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "raises"; } else { print "raise"; }
                2: print "raised";
                3: if (vp == 3) { print "has raised"; } else { print "have raised"; }
                4: print "had raised";
                5: print "will raise";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not raise"; } else { print "do not raise"; }
                2: print "did not raise";
                3: if (vp == 3) { print "has not raised"; } else { print "have not raised"; }
                4: print "had not raised";
                5: print "will not raise";
            }
    }
];
[ ConjugateVerb_136 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "chuckle";
        2: print "chuckled";
        3: print "chuckling";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "chuckles"; } else { print "chuckle"; }
                2: print "chuckled";
                3: if (vp == 3) { print "has chuckled"; } else { print "have chuckled"; }
                4: print "had chuckled";
                5: print "will chuckle";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not chuckle"; } else { print "do not chuckle"; }
                2: print "did not chuckle";
                3: if (vp == 3) { print "has not chuckled"; } else { print "have not chuckled"; }
                4: print "had not chuckled";
                5: print "will not chuckle";
            }
    }
];
[ ConjugateVerb_137 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "lean";
        2: print "leaned";
        3: print "leaning";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "leans"; } else { print "lean"; }
                2: print "leaned";
                3: if (vp == 3) { print "has leaned"; } else { print "have leaned"; }
                4: print "had leaned";
                5: print "will lean";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not lean"; } else { print "do not lean"; }
                2: print "did not lean";
                3: if (vp == 3) { print "has not leaned"; } else { print "have not leaned"; }
                4: print "had not leaned";
                5: print "will not lean";
            }
    }
];
[ ConjugateVerb_138 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "consider";
        2: print "considered";
        3: print "considering";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "considers"; } else { print "consider"; }
                2: print "considered";
                3: if (vp == 3) { print "has considered"; } else { print "have considered"; }
                4: print "had considered";
                5: print "will consider";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not consider"; } else { print "do not consider"; }
                2: print "did not consider";
                3: if (vp == 3) { print "has not considered"; } else { print "have not considered"; }
                4: print "had not considered";
                5: print "will not consider";
            }
    }
];
[ ConjugateVerb_139 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "nod";
        2: print "nodded";
        3: print "nodding";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "nods"; } else { print "nod"; }
                2: print "nodded";
                3: if (vp == 3) { print "has nodded"; } else { print "have nodded"; }
                4: print "had nodded";
                5: print "will nod";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not nod"; } else { print "do not nod"; }
                2: print "did not nod";
                3: if (vp == 3) { print "has not nodded"; } else { print "have not nodded"; }
                4: print "had not nodded";
                5: print "will not nod";
            }
    }
];
[ ConjugateVerb_140 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "extricate";
        2: print "extricated";
        3: print "extricating";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "extricates"; } else { print "extricate"; }
                2: print "extricated";
                3: if (vp == 3) { print "has extricated"; } else { print "have extricated"; }
                4: print "had extricated";
                5: print "will extricate";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not extricate"; } else { print "do not extricate"; }
                2: print "did not extricate";
                3: if (vp == 3) { print "has not extricated"; } else { print "have not extricated"; }
                4: print "had not extricated";
                5: print "will not extricate";
            }
    }
];
[ ConjugateVerb_141 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "toss";
        2: print "tossed";
        3: print "tossing";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "tosses"; } else { print "toss"; }
                2: print "tossed";
                3: if (vp == 3) { print "has tossed"; } else { print "have tossed"; }
                4: print "had tossed";
                5: print "will toss";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not toss"; } else { print "do not toss"; }
                2: print "did not toss";
                3: if (vp == 3) { print "has not tossed"; } else { print "have not tossed"; }
                4: print "had not tossed";
                5: print "will not toss";
            }
    }
];
[ ConjugateVerb_142 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "flatten";
        2: print "flattened";
        3: print "flattening";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "flattens"; } else { print "flatten"; }
                2: print "flattened";
                3: if (vp == 3) { print "has flattened"; } else { print "have flattened"; }
                4: print "had flattened";
                5: print "will flatten";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not flatten"; } else { print "do not flatten"; }
                2: print "did not flatten";
                3: if (vp == 3) { print "has not flattened"; } else { print "have not flattened"; }
                4: print "had not flattened";
                5: print "will not flatten";
            }
    }
];
[ ConjugateVerb_143 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "remember";
        2: print "remembered";
        3: print "remembering";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "remembers"; } else { print "remember"; }
                2: print "remembered";
                3: if (vp == 3) { print "has remembered"; } else { print "have remembered"; }
                4: print "had remembered";
                5: print "will remember";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not remember"; } else { print "do not remember"; }
                2: print "did not remember";
                3: if (vp == 3) { print "has not remembered"; } else { print "have not remembered"; }
                4: print "had not remembered";
                5: print "will not remember";
            }
    }
];
[ ConjugateVerb_144 
    fn ! Implied call parameter
    vp ! Implied call parameter
    t ! Implied call parameter
    modal_to ! Implied call parameter
    ;
    switch (fn) {
        1: print "trip";
        2: print "tripped";
        3: print "tripping";
        CV_MODAL: return false;
        CV_MEANING: return Rel_Record_0;
        CV_POS:
            switch (t) {
                1: if (vp == 3) { print "trips"; } else { print "trip"; }
                2: print "tripped";
                3: if (vp == 3) { print "has tripped"; } else { print "have tripped"; }
                4: print "had tripped";
                5: print "will trip";
            }
        CV_NEG:
            switch (t) {
                1: if (vp == 3) { print "does not trip"; } else { print "do not trip"; }
                2: print "did not trip";
                3: if (vp == 3) { print "has not tripped"; } else { print "have not tripped"; }
                4: print "had not tripped";
                5: print "will not trip";
            }
    }
];
Array TableOfVerbs --> ConjugateVerb_0 ConjugateVerb_2 ConjugateVerb_3 ConjugateVerb_4 ConjugateVerb_5 ConjugateVerb_6 ConjugateVerb_7 ConjugateVerb_8 ConjugateVerb_9 ConjugateVerb_10 ConjugateVerb_11 ConjugateVerb_12 ConjugateVerb_13 ConjugateVerb_14 ConjugateVerb_15 ConjugateVerb_16 ConjugateVerb_17 ConjugateVerb_18 ConjugateVerb_19 ConjugateVerb_20 ConjugateVerb_21 ConjugateVerb_22 ConjugateVerb_23 ConjugateVerb_24 ConjugateVerb_25 ConjugateVerb_26 ConjugateVerb_27 ConjugateVerb_28 ConjugateVerb_29 ConjugateVerb_30 ConjugateVerb_31 ConjugateVerb_32 ConjugateVerb_33 ConjugateVerb_34 ConjugateVerb_35 ConjugateVerb_36 ConjugateVerb_37 ConjugateVerb_38 ConjugateVerb_39 ConjugateVerb_40 ConjugateVerb_41 ConjugateVerb_42 ConjugateVerb_43 ConjugateVerb_44 ConjugateVerb_45 ConjugateVerb_46 ConjugateVerb_47 ConjugateVerb_48 ConjugateVerb_49 ConjugateVerb_50 ConjugateVerb_51 ConjugateVerb_52 ConjugateVerb_53 ConjugateVerb_54 ConjugateVerb_55 ConjugateVerb_56 ConjugateVerb_57 ConjugateVerb_58 ConjugateVerb_59 ConjugateVerb_60 ConjugateVerb_61 ConjugateVerb_62 ConjugateVerb_63 ConjugateVerb_64 ConjugateVerb_65 ConjugateVerb_66 ConjugateVerb_67 ConjugateVerb_68 ConjugateVerb_69 ConjugateVerb_70 ConjugateVerb_71 ConjugateVerb_72 ConjugateVerb_73 ConjugateVerb_87 ConjugateVerb_88 ConjugateVerb_89 ConjugateVerb_90 ConjugateVerb_91 ConjugateVerb_92 ConjugateVerb_93 ConjugateVerb_94 ConjugateVerb_95 ConjugateVerb_96 ConjugateVerb_97 ConjugateVerb_98 ConjugateVerb_99 ConjugateVerb_100 ConjugateVerb_101 ConjugateVerb_102 ConjugateVerb_103 ConjugateVerb_104 ConjugateVerb_105 ConjugateVerb_106 ConjugateVerb_107 ConjugateVerb_108 ConjugateVerb_109 ConjugateVerb_110 ConjugateVerb_111 ConjugateVerb_112 ConjugateVerb_113 ConjugateVerb_114 ConjugateVerb_115 ConjugateVerb_116 ConjugateVerb_117 ConjugateVerb_118 ConjugateVerb_119 ConjugateVerb_120 ConjugateVerb_121 ConjugateVerb_122 ConjugateVerb_123 ConjugateVerb_124 ConjugateVerb_125 ConjugateVerb_126 ConjugateVerb_127 ConjugateVerb_128 ConjugateVerb_129 ConjugateVerb_130 ConjugateVerb_131 ConjugateVerb_132 ConjugateVerb_133 ConjugateVerb_134 ConjugateVerb_135 ConjugateVerb_136 ConjugateVerb_137 ConjugateVerb_138 ConjugateVerb_139 ConjugateVerb_140 ConjugateVerb_141 ConjugateVerb_142 ConjugateVerb_143 ConjugateVerb_144 0;




! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Testing commands
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF DEBUG;
Array TestText_0 ->
    "w/x vent/ask for screwdriver/e/n/e/buy screwdriver/ask for screwdriver/w/s/sw/hello/ask for screwdriver/ask about laundromat owner/out/nw||||";
Array TestReq_0 -->
    0 0;
Array TestText_1 ->
    "test screwdriver/w/w/w||||";
Array TestReq_1 -->
    0 0;
Array TestText_2 ->
    "gonear closet/purloin glasses/wear them/knock on door||||";
Array TestReq_2 -->
    0 0;
Array TestText_3 ->
    "x bosh/x sign/department/x pawn shop/x neon/x margaret/x laundromat/x sign/laundromat/x swamp/x wetland/x interstate/x lot/x wash/x car/x hyundai/enter wash/e/x laundromat door/x pawn shop door/open laundromat door/open pawn shop door||||";
Array TestReq_3 -->
    0 0;
Array TestText_4 ->
    "gonear parking lot north||||";
Array TestReq_4 -->
    0 0;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Abstract Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ XAbstractSub;
    if (XTestMove(noun, second)) return;
    move noun to second;
    "[Abstracted.]";
];

[ XTestMove obj dest;
    if (obj <= InformLibrary) "[Can't move ", (name) obj, ": it's a system object.]";
    if (obj.component_parent) "[Can't move ", (name) obj, ": it's part of ",
        (the) obj.component_parent, ".]";
    while (dest) {
        if (dest == obj) "[Can't move ", (name) obj, ": it would contain itself.]";
        dest = CoreOfParentOfCoreOf(dest);
    }
    rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Actions Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ActionsOnSub; trace_actions = 1; say__p = 1; "Actions listing on."; ];
[ ActionsOffSub; trace_actions = 0; say__p = 1; "Actions listing off."; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Gonear Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GonearSub;
	PlayerTo(LocationOf(noun));
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Purloin Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ XPurloinSub;
    if (XTestMove(noun, player)) return;
    move noun to player; give noun moved ~concealed;
    say__p = 1;
    "[Purloined.]";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Random Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PredictableSub;
    VM_Seed_RNG(-100);
    say__p = 1;
    "[Random number generator now predictable.]";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Relations Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ShowRelationsSub;
   IterateRelations(ShowOneRelation);
];

[ ShowOneRelation rel;
	if ((RlnGetF(rel, RR_PERMISSIONS)) & (RELS_SHOW)) {
		(RlnGetF(rel, RR_HANDLER))(rel, RELS_SHOW);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Responses Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global suppress_text_substitution = false;
[ ShowResponsesSub a i j reg wd set_mode;
	if (NO_RESPONSES == 0) "There are no lettered responses.";
	wn = 2;
	if (NextWordStopped() == 'now') set_mode = 1; else wn--;
	if (NextWordStopped() == 'set') set_mode = 2; else wn--;
	wd = NextWordStopped(); wn--;
	if (wd == 'all') reg = 0;
	else {
		reg = -1;
		if (wd ~= -1) reg = TryNumber(wn);
		if (reg < 0) {
			say__p = 1;
   			print ">--> The following sets of responses are available:^";
			print "    RESPONSES ALL^";
		}
	}
	for (a=0, i=1, j=0: ResponseDivisions-->a: a=a+3, i++) {
		if (ResponseDivisions-->a ~= EMPTY_TEXT_PACKED) j++;
		if ((reg == 0) || (reg == j)) {
			if (ResponseDivisions-->a ~= EMPTY_TEXT_PACKED) {
				if (set_mode) {
					print "[", (string) ResponseDivisions-->a, "]^";
				} else {
					print (string) ResponseDivisions-->a, ":^";
				}
			}
			ShowResponsesRange(ResponseDivisions-->(a+1), ResponseDivisions-->(a+2), set_mode);
		}
		if (reg < 0) {
			if (ResponseDivisions-->a ~= EMPTY_TEXT_PACKED) {
				print "    RESPONSES ", j, ": ", (string) ResponseDivisions-->a, "^";
			}
		}
	}
];

[ ShowResponsesRange from to set_mode i;
	say__p = 1;
	for (i=from: i<=to: i++) {
		switch (set_mode) {
			1: print "now ";
			2: ;
			0: print "    ";
		}
		print (PrintResponse) i;
		switch (set_mode) {
			1: print " is ";
			2: print " is ";
			0: print ": ";
		}
		suppress_text_substitution = true;
		CarryOutActivity(PRINTING_RESPONSE_ACT, i);
		suppress_text_substitution = false;
		switch (set_mode) {
			1: print ";";
			2: print ".";
		}
		print "^";
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Rules Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RulesOnSub;
	debug_rules = 1; say__p = 1;
	"Rules tracing now switched on. Type ~rules off~ to switch it off again,
	 or ~rules all~ to include even rules which do not apply.";
];
[ RulesAllSub;
	debug_rules = 2; say__p = 1;
	"Rules tracing now switched to ~all~. Type ~rules off~ to switch it off again.";
];
[ RulesOffSub;
	debug_rules = 0; say__p = 1;
	"Rules tracing now switched off. Type ~rules~ to switch it on again.";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Scenes Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ScenesOnSub;
	debug_scenes = 1;
	ShowSceneStatus(); say__p = 1;
	"(Scene monitoring now switched on. Type ~scenes off~ to switch it off again.)";
];
[ ScenesOffSub;
	debug_scenes = 0; say__p = 1;
	"(Scene monitoring now switched off. Type ~scenes~ to switch it on again.)";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Scope Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global x_scope_count;
[ ScopeSub;
    x_scope_count = 0;
    LoopOverScope(Print_ScL, noun);
    if (x_scope_count == 0) "Nothing is in scope.";
];
[ Print_ScL obj; print_ret ++x_scope_count, ": ", (a) obj, " (", obj, ")"; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Showheap Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ShowHeapSub;
	HeapDebug();
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: ShowMe Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ShowMeSub t_0 na;
	t_0 = noun;
 	if (noun == nothing) noun = real_location;
 	if (ShowMeRecursively(noun, 0, (noun == real_location))) {
 		if (noun == real_location)
			print "* denotes things which are not in scope^";
	}
 	if (t_0 ofclass K2_thing) {
 		print "location:"; ShowRLocation(noun, true); print "^";
 	}
 	if (t_0) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(pluralname)) && (t_0  has pluralname)) { if (na++ > 0) print ", "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (t_0  hasnt pluralname)) { if (na++ > 0) print ", "; print "singular-named"; }
    if ((AllowInShowme(proper)) && (t_0  has proper)) { if (na++ > 0) print ", "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (t_0  hasnt proper)) { if (na++ > 0) print ", "; print "improper-named"; }
    if ((AllowInShowme(ambigpluralname)) && (t_0  has ambigpluralname)) { if (na++ > 0) print ", "; print "ambiguously plural"; }
    if ((AllowInShowme(p127_always_indefinite)) && (t_0 .p127_always_indefinite == true)) { if (na++ > 0) print ", "; print "always-indefinite"; }
    if ((AllowInShowme(p129_marked_for_special_list)) && (t_0 .p129_marked_for_special_list == true)) { if (na++ > 0) print ", "; print "marked for special listing"; }
    if ((AllowInShowme(p129_marked_for_special_list)) && (t_0 .p129_marked_for_special_list == false)) { if (na++ > 0) print ", "; print "unmarked for special listing"; }
}
if (t_0 ofclass K1_room) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(light)) && (t_0  has light)) { if (na++ > 0) print ", "; print "lighted"; }
    if ((AllowInShowme(light)) && (t_0  hasnt light)) { if (na++ > 0) print ", "; print "dark"; }
    if ((AllowInShowme(visited)) && (t_0  has visited)) { if (na++ > 0) print ", "; print "visited"; }
    if ((AllowInShowme(visited)) && (t_0  hasnt visited)) { if (na++ > 0) print ", "; print "unvisited"; }
    if ((AllowInShowme(p100_dimly_lit)) && (t_0  has p100_dimly_lit)) { if (na++ > 0) print ", "; print "dimly lit"; }
    if ((AllowInShowme(p100_dimly_lit)) && (t_0  hasnt p100_dimly_lit)) { if (na++ > 0) print ", "; print "fully lit"; }
    if ((AllowInShowme(p105_outdoor_adjacent)) && (t_0  has p105_outdoor_adjacent)) { if (na++ > 0) print ", "; print "outdoor-adjacent"; }
}
if (t_0 ofclass K2_thing) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(light)) && (t_0  has light)) { if (na++ > 0) print ", "; print "lit"; }
    if ((AllowInShowme(light)) && (t_0  hasnt light)) { if (na++ > 0) print ", "; print "unlit"; }
    if ((AllowInShowme(edible)) && (t_0  has edible)) { if (na++ > 0) print ", "; print "edible"; }
    if ((AllowInShowme(edible)) && (t_0  hasnt edible)) { if (na++ > 0) print ", "; print "inedible"; }
    if ((AllowInShowme(static)) && (t_0  has static)) { if (na++ > 0) print ", "; print "fixed in place"; }
    if ((AllowInShowme(static)) && (t_0  hasnt static)) { if (na++ > 0) print ", "; print "portable"; }
    if ((AllowInShowme(scenery)) && (t_0  has scenery)) { if (na++ > 0) print ", "; print "scenery"; }
    if ((AllowInShowme(clothing)) && (t_0  has clothing)) { if (na++ > 0) print ", "; print "wearable"; }
    if ((AllowInShowme(pushable)) && (t_0  has pushable)) { if (na++ > 0) print ", "; print "pushable between rooms"; }
    if ((AllowInShowme(moved)) && (t_0  has moved)) { if (na++ > 0) print ", "; print "handled"; }
    if ((AllowInShowme(concealed)) && (t_0  hasnt concealed)) { if (na++ > 0) print ", "; print "described"; }
    if ((AllowInShowme(concealed)) && (t_0  has concealed)) { if (na++ > 0) print ", "; print "undescribed"; }
    if ((AllowInShowme(workflag)) && (t_0  has workflag)) { if (na++ > 0) print ", "; print "marked for listing"; }
    if ((AllowInShowme(workflag)) && (t_0  hasnt workflag)) { if (na++ > 0) print ", "; print "unmarked for listing"; }
    if ((AllowInShowme(mentioned)) && (t_0  has mentioned)) { if (na++ > 0) print ", "; print "mentioned"; }
    if ((AllowInShowme(mentioned)) && (t_0  hasnt mentioned)) { if (na++ > 0) print ", "; print "unmentioned"; }
    if ((AllowInShowme(neuter)) && (t_0  has neuter)) { if (na++ > 0) print ", "; print "neuter"; }
    if ((AllowInShowme(male)) && (t_0  has male)) { if (na++ > 0) print ", "; print "male"; }
    if ((AllowInShowme(female)) && (t_0  has female)) { if (na++ > 0) print ", "; print "female"; }
    if ((AllowInShowme(nomale)) && (t_0  has nomale)) { if (na++ > 0) print ", "; print "nomale"; }
    if ((AllowInShowme(p95_seen)) && (t_0  has p95_seen)) { if (na++ > 0) print ", "; print "seen"; }
    if ((AllowInShowme(p95_seen)) && (t_0  hasnt p95_seen)) { if (na++ > 0) print ", "; print "unseen"; }
    if ((AllowInShowme(p97_familiar)) && (t_0  has p97_familiar)) { if (na++ > 0) print ", "; print "familiar"; }
    if ((AllowInShowme(p97_familiar)) && (t_0  hasnt p97_familiar)) { if (na++ > 0) print ", "; print "unfamiliar"; }
    if ((AllowInShowme(p108_audible)) && (t_0  has p108_audible)) { if (na++ > 0) print ", "; print "audible"; }
    if ((AllowInShowme(p109_noisy)) && (t_0  has p109_noisy)) { if (na++ > 0) print ", "; print "noisy"; }
    if ((AllowInShowme(p109_noisy)) && (t_0  hasnt p109_noisy)) { if (na++ > 0) print ", "; print "quiet"; }
    if ((AllowInShowme(p111_insistent)) && (t_0  has p111_insistent)) { if (na++ > 0) print ", "; print "insistent"; }
    if ((AllowInShowme(p111_insistent)) && (t_0  hasnt p111_insistent)) { if (na++ > 0) print ", "; print "background"; }
    if ((AllowInShowme(p169_swipable)) && (t_0 .p169_swipable == true)) { if (na++ > 0) print ", "; print "swipable"; }
}
if (t_0 ofclass K3_direction) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(workflag)) && (t_0  has workflag)) { if (na++ > 0) print ", "; print "marked for listing"; }
    if ((AllowInShowme(workflag)) && (t_0  hasnt workflag)) { if (na++ > 0) print ", "; print "unmarked for listing"; }
    if ((AllowInShowme(p152_hyperspatial)) && (t_0 .p152_hyperspatial == true)) { if (na++ > 0) print ", "; print "hyperspatial"; }
}
if (t_0 ofclass K4_door) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(open)) && (t_0  has open)) { if (na++ > 0) print ", "; print "open"; }
    if ((AllowInShowme(open)) && (t_0  hasnt open)) { if (na++ > 0) print ", "; print "closed"; }
    if ((AllowInShowme(openable)) && (t_0  has openable)) { if (na++ > 0) print ", "; print "openable"; }
    if ((AllowInShowme(openable)) && (t_0  hasnt openable)) { if (na++ > 0) print ", "; print "unopenable"; }
    if ((AllowInShowme(lockable)) && (t_0  has lockable)) { if (na++ > 0) print ", "; print "lockable"; }
    if ((AllowInShowme(locked)) && (t_0  has locked)) { if (na++ > 0) print ", "; print "locked"; }
    if ((AllowInShowme(locked)) && (t_0  hasnt locked)) { if (na++ > 0) print ", "; print "unlocked"; }
}
if (t_0 ofclass K5_container) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(enterable)) && (t_0  has enterable)) { if (na++ > 0) print ", "; print "enterable"; }
    if ((AllowInShowme(transparent)) && (t_0  hasnt transparent)) { if (na++ > 0) print ", "; print "opaque"; }
    if ((AllowInShowme(transparent)) && (t_0  has transparent)) { if (na++ > 0) print ", "; print "transparent"; }
    if ((AllowInShowme(open)) && (t_0  has open)) { if (na++ > 0) print ", "; print "open"; }
    if ((AllowInShowme(open)) && (t_0  hasnt open)) { if (na++ > 0) print ", "; print "closed"; }
    if ((AllowInShowme(openable)) && (t_0  has openable)) { if (na++ > 0) print ", "; print "openable"; }
    if ((AllowInShowme(openable)) && (t_0  hasnt openable)) { if (na++ > 0) print ", "; print "unopenable"; }
    if ((AllowInShowme(lockable)) && (t_0  has lockable)) { if (na++ > 0) print ", "; print "lockable"; }
    if ((AllowInShowme(locked)) && (t_0  has locked)) { if (na++ > 0) print ", "; print "locked"; }
    if ((AllowInShowme(locked)) && (t_0  hasnt locked)) { if (na++ > 0) print ", "; print "unlocked"; }
}
if (t_0 ofclass K6_supporter) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(enterable)) && (t_0  has enterable)) { if (na++ > 0) print ", "; print "enterable"; }
}
if (t_0 ofclass K8_person) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p128_activated)) && (t_0 .p128_activated == true)) { if (na++ > 0) print ", "; print "activated"; }
}
if (t_0 ofclass K9_region) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p99_powered)) && (t_0  has p99_powered)) { if (na++ > 0) print ", "; print "powered"; }
}
if (t_0 ofclass K14_device) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(on)) && (t_0  has on)) { if (na++ > 0) print ", "; print "switched on"; }
    if ((AllowInShowme(on)) && (t_0  hasnt on)) { if (na++ > 0) print ", "; print "switched off"; }
}
if (t_0 ofclass K18_unenterable_room) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(enterable)) && (t_0  has enterable)) { if (na++ > 0) print ", "; print "enterable"; }
}
if (t_0 ofclass K20_phone) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p114_caller_id)) && (t_0  has p114_caller_id)) { if (na++ > 0) print ", "; print "caller id"; }
    if ((AllowInShowme(p115_mobile)) && (t_0  has p115_mobile)) { if (na++ > 0) print ", "; print "mobile"; }
    if ((AllowInShowme(p115_mobile)) && (t_0  hasnt p115_mobile)) { if (na++ > 0) print ", "; print "wired"; }
    if ((AllowInShowme(p117_identifiable)) && (t_0 .p117_identifiable == true)) { if (na++ > 0) print ", "; print "identifiable"; }
    if ((AllowInShowme(p117_identifiable)) && (t_0 .p117_identifiable == false)) { if (na++ > 0) print ", "; print "unidentifiable"; }
}
if (t_0 ofclass K22_money_card) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p123_mc_enabled)) && (t_0 .p123_mc_enabled == true)) { if (na++ > 0) print ", "; print "mc-enabled"; }
    if ((AllowInShowme(p123_mc_enabled)) && (t_0 .p123_mc_enabled == false)) { if (na++ > 0) print ", "; print "mc-disabled"; }
}
if (t_0 ofclass K26_choice) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p136_available)) && (t_0 .p136_available == true)) { if (na++ > 0) print ", "; print "available"; }
    if ((AllowInShowme(p137_exhausted)) && (t_0 .p137_exhausted == true)) { if (na++ > 0) print ", "; print "exhausted"; }
}
if (t_0 ofclass K27_light_source) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p139_fluorescent)) && (t_0 .p139_fluorescent == true)) { if (na++ > 0) print ", "; print "fluorescent"; }
}
if (t_0 ofclass K29_quip) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p137_exhausted)) && (t_0 .p137_exhausted == true)) { if (na++ > 0) print ", "; print "exhausted"; }
    if ((AllowInShowme(p141_one_shot)) && (t_0 .p141_one_shot == true)) { if (na++ > 0) print ", "; print "one-shot"; }
    if ((AllowInShowme(p141_one_shot)) && (t_0 .p141_one_shot == false)) { if (na++ > 0) print ", "; print "repeatable"; }
    if ((AllowInShowme(p145_universal)) && (t_0 .p145_universal == true)) { if (na++ > 0) print ", "; print "universal"; }
    if ((AllowInShowme(p146_always_available)) && (t_0 .p146_always_available == true)) { if (na++ > 0) print ", "; print "always-available"; }
}
if (t_0 ofclass K30_two_sided_door) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p153_front_locked)) && (t_0 .p153_front_locked == true)) { if (na++ > 0) print ", "; print "front-locked"; }
    if ((AllowInShowme(p154_back_locked)) && (t_0 .p154_back_locked == true)) { if (na++ > 0) print ", "; print "back-locked"; }
    if ((AllowInShowme(p155_front_openable)) && (t_0 .p155_front_openable == true)) { if (na++ > 0) print ", "; print "front-openable"; }
    if ((AllowInShowme(p156_back_openable)) && (t_0 .p156_back_openable == true)) { if (na++ > 0) print ", "; print "back-openable"; }
    if ((AllowInShowme(p157_front_closable)) && (t_0 .p157_front_closable == true)) { if (na++ > 0) print ", "; print "front-closable"; }
    if ((AllowInShowme(p158_back_closable)) && (t_0 .p158_back_closable == true)) { if (na++ > 0) print ", "; print "back-closable"; }
    if ((AllowInShowme(p159_front_locks_the_back)) && (t_0 .p159_front_locks_the_back == true)) { if (na++ > 0) print ", "; print "front-locks-the-back"; }
    if ((AllowInShowme(p160_front_locks_the_front)) && (t_0 .p160_front_locks_the_front == true)) { if (na++ > 0) print ", "; print "front-locks-the-front"; }
    if ((AllowInShowme(p161_back_locks_the_back)) && (t_0 .p161_back_locks_the_back == true)) { if (na++ > 0) print ", "; print "back-locks-the-back"; }
    if ((AllowInShowme(p162_back_locks_the_front)) && (t_0 .p162_back_locks_the_front == true)) { if (na++ > 0) print ", "; print "back-locks-the-front"; }
    if ((AllowInShowme(p163_close_lock_the_back)) && (t_0 .p163_close_lock_the_back == true)) { if (na++ > 0) print ", "; print "close-lock-the-back"; }
    if ((AllowInShowme(p164_close_lock_the_front)) && (t_0 .p164_close_lock_the_front == true)) { if (na++ > 0) print ", "; print "close-lock-the-front"; }
    if ((AllowInShowme(p165_autolock_the_back)) && (t_0 .p165_autolock_the_back == true)) { if (na++ > 0) print ", "; print "autolock-the-back"; }
    if ((AllowInShowme(p166_autolock_the_front)) && (t_0 .p166_autolock_the_front == true)) { if (na++ > 0) print ", "; print "autolock-the-front"; }
    if ((AllowInShowme(p167_auto_closable)) && (t_0 .p167_auto_closable == true)) { if (na++ > 0) print ", "; print "auto-closable"; }
    if ((AllowInShowme(p168_time_locked)) && (t_0 .p168_time_locked == true)) { if (na++ > 0) print ", "; print "time-locked"; }
}
if (t_0 ofclass K36_pronoun) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(neuter)) && (t_0  has neuter)) { if (na++ > 0) print ", "; print "neuter"; }
}
if (t_0 == I159_weather) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p103_rainy)) && (t_0  has p103_rainy)) { if (na++ > 0) print ", "; print "rainy"; }
    if ((AllowInShowme(p103_rainy)) && (t_0  hasnt p103_rainy)) { if (na++ > 0) print ", "; print "sunny"; }
}
if (t_0) {if (na > 0) { na = 0; print "^"; }
    print "list grouping key: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, list_together), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, list_together), "~", "^";
    print "printed name: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, short_name), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, short_name), "~", "^";
    print "printed plural name: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, plural), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, plural), "~", "^";
    print "indefinite article: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, article), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, article), "~", "^";
    print "most recent reference: "; print (E105) GProperty(OBJECT_TY, t_0, most_recent_reference), "^";
    if (GProperty(OBJECT_TY, t_0, third_singular_pronoun)) { print "third singular pronoun: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, third_singular_pronoun), "^";
    }
    print "summary: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, p106_summary), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, p106_summary), "~", "^";
}
if (t_0 ofclass K1_room) {if (na > 0) { na = 0; print "^"; }
    print "description: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, description), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, description), "~", "^";
    if (GProperty(OBJECT_TY, t_0, map_region)) { print "map region: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, map_region), "^";
    }
    print "dark description: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, p15_dark_description), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, p15_dark_description), "~", "^";
    print "reception: "; print (DA_TruthState) GProperty(OBJECT_TY, t_0, p18_reception), "^";
    print "preposition: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, p21_preposition), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, p21_preposition), "~", "^";
    print "destination name: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, p24_destination_name), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, p24_destination_name), "~", "^";
    print "room condition: "; print (E74) GProperty(OBJECT_TY, t_0, p102_room_condition), "^";
}
if (t_0 ofclass K2_thing) {if (na > 0) { na = 0; print "^"; }
    print "description: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, description), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, description), "~", "^";
    print "initial appearance: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, initial), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, initial), "~", "^";
    if (GProperty(OBJECT_TY, t_0, with_key)) { print "matching key: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, with_key), "^";
    }
    print "dark description: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, p15_dark_description), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, p15_dark_description), "~", "^";
    print "hearability: "; print (E76) GProperty(OBJECT_TY, t_0, p16_hearability), "^";
    print "volume: "; print (REAL_NUMBER_TY_Say) GProperty(OBJECT_TY, t_0, p17_volume), "^";
    print "price: "; print (E80) GProperty(OBJECT_TY, t_0, p20_price), "^";
    print "behind description: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, p25_behind_description), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, p25_behind_description), "~", "^";
    if (GProperty(OBJECT_TY, t_0, p43_third_plural_pronoun)) { print "third-plural-pronoun: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, p43_third_plural_pronoun), "^";
    }
    print "possessive: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, p48_possessive), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, p48_possessive), "~", "^";
    print "portrait: "; print (PrintFigureName) GProperty(OBJECT_TY, t_0, p49_portrait), "^";
    if (GProperty(OBJECT_TY, t_0, p125_owner)) { print "owner: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, p125_owner), "^";
    }
    if (GProperty(OBJECT_TY, t_0, p126_vendor)) { print "vendor: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, p126_vendor), "^";
    }
}
if (t_0 ofclass K3_direction) {if (na > 0) { na = 0; print "^"; }
    if (GProperty(OBJECT_TY, t_0, p10_opposite)) { print "opposite: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, p10_opposite), "^";
    }
}
if (t_0 ofclass K4_door) {if (na > 0) { na = 0; print "^"; }
    if (GProperty(OBJECT_TY, t_0, door_to)) { print "other side: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, door_to), "^";
    }
}
if (t_0 ofclass K5_container) {if (na > 0) { na = 0; print "^"; }
    print "carrying capacity: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, capacity), "^";
}
if (t_0 ofclass K6_supporter) {if (na > 0) { na = 0; print "^"; }
    print "carrying capacity: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, capacity), "^";
}
if (t_0 ofclass K8_person) {if (na > 0) { na = 0; print "^"; }
    print "carrying capacity: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, capacity), "^";
    print "behavior stack: "; print (LIST_OF_TY_Say) GProperty(OBJECT_TY, t_0, p22_behavior_stack), "^";
    if (GProperty(OBJECT_TY, t_0, p23_target_location)) { print "target location: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, p23_target_location), "^";
    }
    print "remembrances: "; print (LIST_OF_TY_Say) GProperty(OBJECT_TY, t_0, p26_remembrances), "^";
    print "queue: "; print (LIST_OF_TY_Say) GProperty(OBJECT_TY, t_0, p29_queue), "^";
    print "how-are-you-reply: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, p38_how_are_you_reply), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, p38_how_are_you_reply), "~", "^";
    if (GProperty(OBJECT_TY, t_0, p44_first_singular_pronoun)) { print "first-singular-pronoun: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, p44_first_singular_pronoun), "^";
    }
    if (GProperty(OBJECT_TY, t_0, p45_first_plural_pronoun)) { print "first-plural-pronoun: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, p45_first_plural_pronoun), "^";
    }
    if (GProperty(OBJECT_TY, t_0, p46_second_singular_pronoun)) { print "second-singular-pronoun: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, p46_second_singular_pronoun), "^";
    }
    if (GProperty(OBJECT_TY, t_0, p47_second_plural_pronoun)) { print "second-plural-pronoun: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, p47_second_plural_pronoun), "^";
    }
}
if (t_0 ofclass K20_phone) {if (na > 0) { na = 0; print "^"; }
    print "phone condition: "; print (E78) GProperty(OBJECT_TY, t_0, p113_phone_condition), "^";
}
if (t_0 ofclass K22_money_card) {if (na > 0) { na = 0; print "^"; }
    print "balance: "; print (E80) GProperty(OBJECT_TY, t_0, p19_balance), "^";
}
if (t_0 ofclass K29_quip) {if (na > 0) { na = 0; print "^"; }
    print "comment: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, p27_comment), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, p27_comment), "~", "^";
    print "reply: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, p28_reply), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, p28_reply), "~", "^";
    print "quip condition: "; print (E93) GProperty(OBJECT_TY, t_0, p143_quip_condition), "^";
    print "quip condition 2: "; print (E94) GProperty(OBJECT_TY, t_0, p144_quip_condition_2), "^";
}
if (t_0 ofclass K30_two_sided_door) {if (na > 0) { na = 0; print "^"; }
    if (GProperty(OBJECT_TY, t_0, p30_frontside)) { print "frontside: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, p30_frontside), "^";
    }
    print "close delay: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, p31_close_delay), "^";
    print "time lock delay: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, p32_time_lock_delay), "^";
    print "front description: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, p33_front_description), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, p33_front_description), "~", "^";
    print "back description: "; if (TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, p34_back_description), EMPTY_TEXT_VALUE) == 0) print "none^"; else print "~", (TEXT_TY_Say) GProperty(OBJECT_TY, t_0, p34_back_description), "~", "^";
    print "description policy: "; print (E98) GProperty(OBJECT_TY, t_0, p35_description_policy), "^";
    print "lock countdown: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, p36_lock_countdown), "^";
    print "close countdown: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, p37_close_countdown), "^";
}
if (t_0 ofclass K36_pronoun) {if (na > 0) { na = 0; print "^"; }
    print "grammatical-person: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, p40_grammatical_person), "^";
    print "declensions: "; print (LIST_OF_TY_Say) GProperty(OBJECT_TY, t_0, p41_declensions), "^";
}

];

[ ShowRLocation obj top;
	if (obj ofclass K1_room) return;
	print " ";
	if (parent(obj)) {
		if (obj has worn) print "worn by ";
		else {
			if (parent(obj) has animate) print "carried by ";
			if (parent(obj) has container) print "in ";
			if (parent(obj) ofclass K1_room) print "in ";
			if (parent(obj) has supporter) print "on ";
		}
		print (the) parent(obj);
		ShowRLocation(parent(obj));
	} else {
		if (obj.component_parent) {
			if (top == false) print ", which is ";
			print "part of ", (the) obj.component_parent;
			ShowRLocation(obj.component_parent);
		}
		else print "out of play";
	}
];

[ ShowMeRecursively obj depth f c i k;
	spaces(2*depth);
	if (f && (depth > 0) && (TestScope(obj, player) == false)) { print "*"; c = true; }
	print (name) obj;
	if (depth > 0) {
		if (obj.component_parent) print " (part of ", (name) obj.component_parent, ")";
		if (obj has worn) print " (worn)";
	}
	if (obj provides KD_Count) {
		k = KindHierarchy-->((obj.KD_Count)*2);
		if ((k ~= K2_thing) || (depth==0)) {
			print " - ";
			if (k == K4_door or K5_container) {
				if (obj has transparent) print "transparent ";
				if (obj has locked) print "locked ";
				else if (obj has open) print "open ";
				else print "closed ";
			}
			print (I7_Kind_Name) k;
		}
	}
	print "^";
	if (obj.component_child) c = c | ShowMeRecursively(obj.component_child, depth+2, f);
	if ((depth>0) && (obj.component_sibling))
		c = c | ShowMeRecursively(obj.component_sibling, depth, f);
	if (child(obj)) c = c | ShowMeRecursively(child(obj), depth+2, f);
	if ((depth>0) && (sibling(obj))) c = c | ShowMeRecursively(sibling(obj), depth, f);
	return c;
];

[ AllowInShowme pr;
	if (pr == workflag or concealed or mentioned) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Showverb Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ShowVerbSub address lines meta i x;
	wn = 2; x = NextWordStopped();
    if (x == 0 || ((x->#dict_par1) & 1) == 0)
        "Try typing ~showverb~ and then the name of a verb.";
    meta = ((x->#dict_par1) & 2)/2;
    i = DictionaryWordToVerbNum(x);
    address = VM_CommandTableAddress(i);
    lines = address->0;
    address++;
    print "Verb ";
    if (meta) print "meta ";
    VM_PrintCommandWords(i);
    new_line;
    if (lines == 0) print "has no grammar lines.^";
    for (: lines>0 : lines--) {
        address = UnpackGrammarLine(address);
        print "    "; DebugGrammarLine(); new_line;
    }
    ParaContent();
];

[ DebugGrammarLine pcount;
    print " * ";
    for (: line_token-->pcount ~= ENDIT_TOKEN : pcount++) {
        if ((line_token-->pcount)->0 & $10) print "/ ";
        print (DebugToken) line_token-->pcount, " ";
    }
    print "-> ", (DebugAction) action_to_be;
    if (action_reversed) print " reverse";
];

[ DebugToken token;
    AnalyseToken(token);
    switch (found_ttype) {
      ILLEGAL_TT:
        print "<illegal token number ", token, ">";
      ELEMENTARY_TT:
        switch (found_tdata) {
          NOUN_TOKEN:           print "noun";
          HELD_TOKEN:           print "held";
          MULTI_TOKEN:          print "multi";
          MULTIHELD_TOKEN:      print "multiheld";
          MULTIEXCEPT_TOKEN:    print "multiexcept";
          MULTIINSIDE_TOKEN:    print "multiinside";
          CREATURE_TOKEN:       print "creature";
          SPECIAL_TOKEN:        print "special";
          NUMBER_TOKEN:         print "number";
          TOPIC_TOKEN:          print "topic";
          ENDIT_TOKEN:          print "END";
        }
      PREPOSITION_TT:
        print "'", (address) found_tdata, "'";
      ROUTINE_FILTER_TT:
        print "noun=Routine(", found_tdata, ")";
      ATTR_FILTER_TT:
        print (DebugAttribute) found_tdata;
      SCOPE_TT:
        print "scope=Routine(", found_tdata, ")";
      GPR_TT:
        print "Routine(", found_tdata, ")";
    }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Test Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#Iftrue (5 > 0);

[ TestScriptSub;
	switch(special_word) {
'screwdriver//': TestStart(TestText_0, TestReq_0, 137);
'laundry//': TestStart(TestText_1, TestReq_1, 22);
'closet//': TestStart(TestText_2, TestReq_2, 53);
'lotsouth//': TestStart(TestText_3, TestReq_3, 234);
'lotnorth//': TestStart(TestText_4, TestReq_4, 24);

	default:
		print ">--> The following tests are available:^";
print "'test screwdriver'^";
print "'test laundry'^";
print "'test closet'^";
print "'test lotsouth'^";
print "'test lotnorth'^";

	}
];

#ifdef TARGET_GLULX;
Constant TEST_STACK_SIZE = 128;
#ifnot;
Constant TEST_STACK_SIZE = 48;
#endif;

Array test_stack --> TEST_STACK_SIZE;
Global test_sp = 0;
[ TestStart T R l k;
	if (test_sp >= TEST_STACK_SIZE) ">--> Testing too many levels deep";
	test_stack-->test_sp = T;
	test_stack-->(test_sp+1) = 0;
	test_stack-->(test_sp+3) = l;
	test_sp = test_sp + 4;
	if ((R-->0) && (R-->0 ~= real_location)) {
	     print "(first moving to ", (name) R-->0, ")^";
	     PlayerTo(R-->0, 1);
	}
	k=1;
	while (R-->k) {
	    if (R-->k notin player) {
	        print "(first acquiring ", (the) R-->k, ")^";
	        move R-->k to player;
	    }
	    k++;
	}
	print "(Testing.)^"; say__p = 1;
];
[ TestKeyboardPrimitive a_buffer a_table p i j l spaced ch;
	if (test_sp == 0) {
	    test_stack-->2 = 1;
	    return VM_ReadKeyboard(a_buffer, a_table);
	}
	else {
	    p = test_stack-->(test_sp-4);
	    i = test_stack-->(test_sp-3);
	    l = test_stack-->(test_sp-1);
	    print "[";
	    print test_stack-->2;
	    print "] ";
	    test_stack-->2 = test_stack-->2 + 1;
	    style bold;
	    while ((i < l) && (p->i ~= '/')) {
	    	ch = p->i;
	        if (spaced || (ch ~= ' ')) {
	        	if ((p->i == '[') && (p->(i+1) == '/') && (p->(i+2) == ']')) {
	        		ch = '/'; i = i+2;
	        	}
	            a_buffer->(j+WORDSIZE) = ch;
	            print (char) ch;
	            i++; j++;
	            spaced = true;
	        } else i++;
	    }
	    style roman;
	    print "^";
	    #ifdef TARGET_ZCODE;
	    a_buffer->1 = j;
	    #ifnot; ! TARGET_GLULX
	    a_buffer-->0 = j;
	    #endif;
	    VM_Tokenise(a_buffer, a_table);
	    if (p->i == '/') i++;
	    if (i >= l) {
	        test_sp = test_sp - 4;
	    } else test_stack-->(test_sp-3) = i;
	}
];

#IFNOT;

[ TestScriptSub;
	">--> No test scripts exist for this game.";
];

#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Trace Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TraceOnSub; parser_trace=1; say__p = 1; "[Trace on.]"; ];

[ TraceLevelSub;
    parser_trace = parsed_number; say__p = 1;
    print "[Parser tracing set to level ", parser_trace, ".]^";
];

[ TraceOffSub; parser_trace=0; say__p = 1; "Trace off."; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Tree Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ XTreeSub i;
    if (noun == 0) {
        objectloop (i)
            if (i ofclass Object && parent(i) == 0) XObj(i);
    }
    else XObj(noun,1);
];

[ XObj obj f;
    if (parent(obj) == 0) print (name) obj; else print (a) obj;
    print " (", obj, ") ";
    if (f == 1 && parent(obj) ~= 0)
        print "(in ", (name) parent(obj), " ", parent(obj), ")";
    new_line;
    if (child(obj) == 0) rtrue;
    if (obj == Class)
        WriteListFrom(child(obj), NEWLINE_BIT+INDENT_BIT+ALWAYS_BIT+NOARTICLE_BIT, 1);
    else
        WriteListFrom(child(obj), NEWLINE_BIT+INDENT_BIT+ALWAYS_BIT+FULLINV_BIT, 1);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Tests.i6t: Grammar
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ testcommandnoun obj o2;
	switch (scope_stage) {
		1: rtrue; ! allow multiple objects
		2: objectloop (obj)
        	if ((obj ofclass Object) && (obj provides KD_Count))
            	PlaceInScope(obj, true);
        3: print "There seems to be no such object anywhere in the model world.^";
    }
];

Verb meta 'abstract'

    * scope=testcommandnoun 'to' scope=testcommandnoun -> XAbstract;
Verb meta 'actions'

    *                                           -> ActionsOn
    * 'on'                                      -> ActionsOn
    * 'off'                                     -> ActionsOff;
Verb meta 'gonear'

    * scope=testcommandnoun                     -> Gonear;
Verb meta 'purloin'

    * scope=testcommandnoun                     -> XPurloin;
Verb meta 'random'

    *                                           -> Predictable;
Verb meta 'relations'

	*                                           -> ShowRelations;
Verb meta 'responses'

	*                                           -> ShowResponses
	* special                                   -> ShowResponses
	* 'now' special                             -> ShowResponses
	* 'set' special                             -> ShowResponses;
Verb meta 'rules'

	*                                           -> RulesOn
	* 'all'                                     -> RulesAll
	* 'on'                                      -> RulesOn
	* 'off'                                     -> RulesOff;
Verb meta 'scenes'

	*                                           -> ScenesOn
	* 'on'                                      -> ScenesOn
	* 'off'                                     -> ScenesOff;
Verb meta 'scope'

    *                                           -> Scope
    * scope=testcommandnoun                     -> Scope;
Verb meta 'showheap'

	*                                           -> ShowHeap;
Verb meta 'showme'

	*                                           -> ShowMe
	* scope=testcommandnoun                     -> ShowMe;
Verb meta 'showverb'

    * special                                   -> Showverb;
Verb meta 'test'

	*                                           -> TestScript
	* special                                   -> TestScript;
Verb meta 'trace'

    *                                           -> TraceOn
    * number                                    -> TraceLevel
    * 'on'                                      -> TraceOn
    * 'off'                                     -> TraceOff;
Verb meta 'tree'

    *                                           -> XTree
    * scope=testcommandnoun                     -> XTree;

[ InternalTestCases ;
    ];

#ENDIF; ! DEBUG


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: I6 Inclusions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! "Include (- ... -)" inclusions with no specified position appear here.


	[ CheckDPMR result sinp1 sinp2 rv;
		sinp1 = inp1; sinp2 = inp2; inp1 = noun; inp2 = second;
		rv = FollowRulebook( 25 );
		inp1 = sinp1; inp2 = sinp2;
		if ((rv) && RulebookSucceeded()) {
			result = ResultOfRule();
			if (result == RBNO_6 ) return 4;
			if (result == RBNO_7 ) return 3;
			if (result == RBNO_8 ) return 2;
			if (result == RBNO_9 ) return 1;
			if (result == RBNO_10 ) return 0;
		}
		return 2;
	];

[ LITTLE_USED_DO_NOTHING_R; rfalse; ];


! Wait for a safe non navigating key. The user might press Down/PgDn or use the mouse scroll wheel to scroll a page of text, so we will stop those key codes from continuing.
[ KeyPause key; 
	while ( 1 )
	{
		key = VM_KeyChar();
		#Ifdef TARGET_ZCODE;
		if ( key == 63 or 129 or 130 or 132 )
		{
			continue;
		}
		#Ifnot; ! TARGET_GLULX
		if ( key == -4 or -5 or -10 or -11 or -12 or -13 )
		{
			continue;
		}
		#Endif; ! TARGET_
		rfalse;
	}
];

[ SPACEPause i;
	while (i ~= 13 or 31 or 32)
	{
		i = VM_KeyChar();	
	}
];

! No longer used but included just in case
[ GetKey;
	return VM_KeyChar(); 
];



[ CenterPrint str depth i j len;
	font off;
	i = VM_ScreenWidth();
	len = TEXT_TY_CharacterLength(str);
	if (len > 63) len = 63;
	j = (i-len)/2 - 1;
	VM_MoveCursorInStatusLine(depth, j);
	print (I7_string) str; 
	font on;
];

[ CenterPrintComplex str i j len;
	font off;
	print "^"; 
	i = VM_ScreenWidth();
	len = TEXT_TY_CharacterLength(str);
	if (len > 63) len = 63;
	j = (i-len)/2 - 1;
	spaces j;
	print (I7_string) str; 
	font on;
];



[ I7ScreenHeight i screen_height;
	i = 0->32;
	if (screen_height == 0 or 255) screen_height = 18;
	screen_height = screen_height - 7;
	return screen_height;
];

 

[ DeepStatus depth i screen_width;
    VM_StatusLineHeight(depth);
    screen_width = VM_ScreenWidth();
    #ifdef TARGET_GLULX;
        VM_ClearScreen(1);
    #ifnot;
        style reverse;
        for (i=1:i<depth+1:i++)
        {
             @set_cursor i 1;
             spaces(screen_width);
        } 
    #endif;
]; 

[ I7VM_MoveCursorInStatusLine depth;
	VM_MoveCursorInStatusLine(depth, 1);
];

[ RightAlign depth screen_width o n;
	screen_width = VM_ScreenWidth(); 
	n = (Global_Vars-->15);
	o = screen_width - n;
	VM_MoveCursorInStatusLine(depth, o);
];

 

[ Detitler i j buffer_length flag; 

#ifdef TARGET_ZCODE;
	buffer_length = buffer->1+(WORDSIZE-1);
#endif;
#ifdef TARGET_GLULX;
	buffer_length = (buffer-->0)+(WORDSIZE-1);
#endif; 
	for (i = WORDSIZE : i <= buffer_length: i++)
	{ 
		if ((buffer->i) == '.' && (i > WORDSIZE + 1)) 
		{ 
			! flag if the period follows Mr, Mrs, Dr, prof, rev, or st
			!
			! This is hackish, but our hearts are pure
			
			if ((buffer->(i-1)=='r') && (buffer->(i-2)=='m') && ((buffer->(i-3)==' ') || ((i-3) < WORDSIZE))) flag = 1;
			if ((buffer->(i-1)=='r') && (buffer->(i-2)=='d') && ((buffer->(i-3)==' ') || ((i-3) < WORDSIZE))) flag = 1;
			if ((buffer->(i-1)=='t') && (buffer->(i-2)=='s') && ((buffer->(i-3)==' ') || ((i-3) < WORDSIZE))) flag = 1;
			if ((buffer->(i-1)=='s') && (buffer->(i-2)=='r') && (buffer->(i-3)=='m') && ((buffer->(i-4)==' ') || ((i-4) < WORDSIZE))) flag = 1;
			if ((buffer->(i-1)=='v') && (buffer->(i-2)=='e') && (buffer->(i-3)=='r') && ((buffer->(i-4)==' ') || ((i-4) < WORDSIZE))) flag = 1;
			if ((buffer->(i-1)=='f') && (buffer->(i-2)=='o') && (buffer->(i-3)=='r') && (buffer->(i-4)=='p') && ((buffer->(i-5)==' ') || ((i-5) < WORDSIZE))) flag = 1;
			if (flag) buffer->i = ' ';   
		}
	}
	VM_Tokenise(buffer, parse);
]; 



[ BufferOut i;   
	for (i = WORDSIZE : i <= (buffer-->0)+(WORDSIZE-1) : i++)
	{  
		print (char) (buffer->i);
	} 
];

[ PunctuationStripping i;
	for (i = WORDSIZE : i <= (buffer-->0)+(WORDSIZE-1) : i++)
	{ 
		if ((buffer->i) == '"' or '?' or '!') 
		{	buffer->i = ' ';  
		}
	}
	VM_Tokenise(buffer, parse);
];



[ SingleQuoteStripping i;
	for (i = WORDSIZE : i <= (buffer-->0)+(WORDSIZE-1) : i++)	{ 
		if ((buffer->i) == 39) 
		{	buffer->i = ' ';  
		}
	}
	VM_Tokenise(buffer, parse);
];

[ QuoteStripping i;
	for (i = WORDSIZE : i <= (buffer-->0)+(WORDSIZE-1) : i++)	{ 
		if ((buffer->i) == '"') 
		{	buffer->i = ' ';  
		}
	}
	VM_Tokenise(buffer, parse);
];



[ Questionstripping i;
	for (i = WORDSIZE : i <= (buffer-->0)+(WORDSIZE-1) : i++)
	{ 
		if ((buffer->i) == '?') 
		{	buffer->i = ' ';  
		}
	}
	VM_Tokenise(buffer, parse);
];



[ ExclamationStripping i;
	for (i = WORDSIZE : i <= (buffer-->0)+(WORDSIZE-1) : i++)
	{ 
		if ((buffer->i) == '!') 
		{	buffer->i = ' ';  
		}
	}
	VM_Tokenise(buffer, parse);
];



[ PeriodStripping i j;
	for (i = WORDSIZE : i <= (buffer-->0)+(WORDSIZE-1) : i++)
	{ 
		if ((buffer->i) == '.') 
		{	buffer->i = ' ';  
		}
	}
	VM_Tokenise(buffer, parse);
];


[ GTE_SetStylehint wintype style hint N i;
	if ( style == I132_all_styles )
	{
		for ( i = 0: i < style_NUMSTYLES : i++ )
		{
			glk_stylehint_set( wintype, i, hint, N );
		}
	}
	else
	{
		glk_stylehint_set( wintype, style - 2, hint, N );
	}
];

[ GTE_ConvertColour txt p1 cp1 dsize i ch progress;
	! Transmute the text
	cp1 = txt-->0;
	p1 = TEXT_TY_Temporarily_Transmute( txt );
	dsize = BlkValueLBCapacity( txt );
	for ( i = 0 : i < dsize : i++ )
	{
		! Decode the hex characters
		ch = BlkValueRead( txt, i );
		if ( ch == 0 )
		{
			break;
		}
		else if ( ch > 47 && ch < 58 )
		{
			progress = progress * 16 + ch - 48;
		}
		else if ( ch > 64 && ch < 71 )
		{
			progress = progress * 16 + ch - 55;
		}
		else if ( ch > 96 && ch < 103 )
		{
			progress = progress * 16 + ch - 87;
		}
	}
	! Clean up and return
	TEXT_TY_Untransmute( txt, p1, cp1 );
	return progress;
];

Global capture_active = 0;
Global capture_p = 0;
Global capture_pc = 0;

Array captured_text --> CAPTURE_BUFFER_LEN + 1;
Global text_capture_old_stream = 0;
Global text_capture_new_stream = 0;
[ StartCapture i;   
	if (capture_active == 1)
		return;
	capture_active = 1;
	! New: need to clear out the paragraphing flags
	capture_p = say__p;
	capture_pc = say__pc;
	ClearParagraphing();
	text_capture_old_stream = glk_stream_get_current();
	text_capture_new_stream = glk_stream_open_memory_uni(captured_text + WORDSIZE, CAPTURE_BUFFER_LEN, 1, 0);
	glk_stream_set_current(text_capture_new_stream);
];

[ EndCapture len;
	if ( capture_active == 0 )
		return;
	capture_active = 0;
	glk_stream_set_current(text_capture_old_stream);
	len = say__p; ! save temporarily
	! restore from before
	say__p = capture_p;
	say__pc = capture_pc;
	capture_p = len; ! save for when we print
	@copy $ffffffff sp;
	@copy text_capture_new_stream sp;
	@glk $0044 2 0; ! stream_close
	@copy sp len;
	@copy sp 0;
	captured_text-->0 = len;
	if (len > CAPTURE_BUFFER_LEN)
	{
		captured_text-->0 = CAPTURE_BUFFER_LEN;
	}
];

[ PrintCapture flag len i;
	len = captured_text-->0;
	i = 1;
	@push say__pc;
	say__pc = say__pc | PARA_NORULEBOOKBREAKS;
	while(i <= len){
		if(captured_text-->i == ESCAPE_CODE){
			i++;
			if(~~flag){
				FollowRulebook(383, captured_text-->i);
			}
		}else{
			glk_put_char_uni(captured_text-->i);
		}
		i++;
	}
	@pull say__pc;
	say__p = capture_p; ! if our captured text ended with a pending paragraph break, impose it here
	! This specifically has to clobber the current value of say__p or else we get an extra line break
];


[ RockSwitchingSGW;
	switch( (Global_Vars-->51) )
	{
		GG_PICWIN_ROCK: gg_picwin = (Global_Vars-->52);
		GG_HIDEWIN_ROCK: gg_hidewin = (Global_Vars-->52);
	}
];

  

[ FindHeight  result graph_height;
	if (gg_picwin)
	{	result = glk_window_get_size(gg_picwin, gg_arguments, gg_arguments+WORDSIZE);
			 		graph_height  = gg_arguments-->1;
	} 
	return graph_height;
];

[ FindWidth  result graph_width;
	if (gg_picwin)
	{	result = glk_window_get_size(gg_picwin, gg_arguments, gg_arguments+WORDSIZE);
			 		graph_width  = gg_arguments-->0;
	} 
	return graph_width;
];

 [ MyRedrawGraphicsWindows cur_pic_1 cur_pic_2 cur_pic_3 cur_pic_4 cur_pic_5 result graph_width graph_height pic_count
		img_width img_height w_offset h_offset w_total h_total;

	FollowRulebook(548);
	pic_count = latest_rule_result-->2;
	if (pic_count > 0) { 	cur_pic_1 = ResourceIDsOfFigures-->(Global_Vars-->61); }   
	if (pic_count > 1) { 	cur_pic_2 = ResourceIDsOfFigures-->(Global_Vars-->62); }   
	if (pic_count > 2) { 	cur_pic_3 = ResourceIDsOfFigures-->(Global_Vars-->63); }   
	if (pic_count > 3) { 	cur_pic_4 = ResourceIDsOfFigures-->(Global_Vars-->64); }   
	if (pic_count > 4) { 	cur_pic_5 = ResourceIDsOfFigures-->(Global_Vars-->65); }   

	  if (gg_picwin) {  

	result = glk_window_get_size(gg_picwin, gg_arguments, gg_arguments+WORDSIZE);
			 	graph_width  = gg_arguments-->0;
			 	graph_height = gg_arguments-->1;

	result = glk_image_get_info( cur_pic_1, gg_arguments,  gg_arguments+WORDSIZE);
	img_width  = gg_arguments-->0;
	img_height = gg_arguments-->1;

	w_total = img_width;
	h_total = img_height;

	if (graph_height - h_total < 0) !	if the image won't fit, find the scaling factor
	{
		w_total = (graph_height * w_total)/h_total;
		h_total = graph_height;

	}

	if (graph_width - w_total < 0)
	{
		h_total = (graph_width * h_total)/w_total;
		w_total = graph_width;
	}

	w_offset = (graph_width - w_total)/2; if (w_offset < 0) w_offset = 0;
	h_offset = 0; ! h_offset = (graph_height - h_total)/2; if (h_offset < 0) h_offset = 0;
 
	if (pic_count > 0) {
		glk_image_draw_scaled(gg_picwin, cur_pic_1, w_offset, h_offset, w_total, h_total); 	
	}
	if (pic_count > 1) {
		glk_image_draw_scaled(gg_picwin, cur_pic_2, w_offset, h_offset + w_total, w_total, h_total); 
	}
	if (pic_count > 2) {
		glk_image_draw_scaled(gg_picwin, cur_pic_3, w_offset, h_offset + 2 * w_total, w_total, h_total); 
	}
	if (pic_count > 3) {
		glk_image_draw_scaled(gg_picwin, cur_pic_4, w_offset, h_offset + 3 * w_total, w_total, h_total); 
	}
	if (pic_count > 4) {
		glk_image_draw_scaled(gg_picwin, cur_pic_5, w_offset, h_offset + 4 * w_total, w_total, h_total); 
	}
	}
 ]; 

[ BlankWindowToColor color result graph_width graph_height;
  

	  if (gg_picwin) {  

	result = glk_window_get_size(gg_picwin, gg_arguments, gg_arguments+WORDSIZE);
			 	graph_width  = gg_arguments-->0;
			 	graph_height = gg_arguments-->1; 

	glk_window_fill_rect(gg_picwin, color , 0, 0, graph_width, graph_height);
	}
];

 [ TileFillGraphicsWindows cur_pic result graph_width graph_height 
		img_width img_height w_total h_total;

	if (FollowRulebook( 548 ) ) { cur_pic = ResourceIDsOfFigures-->(Global_Vars-->61); }   
	if (cur_pic == 0) rtrue;

	  if (gg_picwin) {  

	result = glk_window_get_size(gg_picwin, gg_arguments, gg_arguments+WORDSIZE);
			 	graph_width  = gg_arguments-->0;
			 	graph_height = gg_arguments-->1;

	result = glk_image_get_info( cur_pic, gg_arguments,  gg_arguments+WORDSIZE);
	img_width  = gg_arguments-->0;
	img_height = gg_arguments-->1;   

	while (w_total < graph_width)
	{
		while (h_total < graph_height)
		{
			glk_image_draw(gg_picwin, cur_pic, w_total, h_total); 
			h_total = h_total + img_height;
		}
		h_total = 0;
		w_total = w_total + img_width;
	}
	}
 ]; 

[ TotalFillGraphicsWindows cur_pic result graph_width graph_height 
		img_width img_height;

	if (FollowRulebook( 548 ) ) { cur_pic =  ResourceIDsOfFigures-->(Global_Vars-->61); }   
	if (cur_pic == 0) rtrue;

	  if (gg_picwin) {  

	result = glk_window_get_size(gg_picwin, gg_arguments, gg_arguments+WORDSIZE);
			 	graph_width  = gg_arguments-->0;
			 	graph_height = gg_arguments-->1;

	glk_image_draw_scaled(gg_picwin, cur_pic, 0, 0, graph_width, graph_height); 
	}
 ]; 

!Array gg_arguments --> 0 0;

[ MakeGraphicsWindow depth prop pos;
	if (gg_picwin) rtrue;
	depth = (Global_Vars-->66);
	prop = (Global_Vars-->67);
	pos = (Global_Vars-->69);
	switch(pos)
	{
		I275_g_null: pos = winmethod_Above;
		I276_g_above: pos = winmethod_Above;
		I277_g_below: pos = winmethod_Below;
		I278_g_left: pos = winmethod_Left;
		I279_g_right: pos = winmethod_Right;
	} 
	if (prop > 0 && prop < 100)
	{	
		gg_picwin = glk_window_open(gg_mainwin, (pos+winmethod_Proportional), prop, wintype_Graphics, GG_PICWIN_ROCK);
	}
	else
	{
		if (depth == 0) depth = 240;
		gg_picwin = glk_window_open(gg_mainwin, (pos+winmethod_Fixed), depth, wintype_Graphics, GG_PICWIN_ROCK);
	}
];

[ MakeGraphicsWindowHidewin depth prop pos;
	if (gg_hidewin) rtrue;
	depth = 0;
	prop = 0;
	pos = I275_g_null;
	switch(pos)
	{
		I275_g_null: pos = winmethod_Above;
		I276_g_above: pos = winmethod_Above;
		I277_g_below: pos = winmethod_Below;
		I278_g_left: pos = winmethod_Left;
		I279_g_right: pos = winmethod_Right;
	} 
	gg_hidewin = glk_window_open(gg_mainwin, (pos+winmethod_Fixed), depth, wintype_Graphics, GG_HIDEWIN_ROCK);
	
];

[ ResizeGraphicsWindow o2 widthptr picwidth prop id winwidth;
	if (gg_picwin) {
		o2 = glk_window_get_parent(gg_picwin);
		
	      id=gg_hidewin;
	      glk_window_get_size(id, gg_arguments, 0);
	      picwidth = gg_arguments-->0;
		prop = (Global_Vars-->67);
		winwidth = picwidth * prop / 100;
		if (picwidth * prop / 100  < 120) {
			winwidth = 120;
			glk_window_set_arrangement(o2, winmethod_Left | winmethod_Fixed, winwidth, gg_picwin);
		}
		else if (picwidth * prop / 100  > 240) {
			winwidth = 240;
			glk_window_set_arrangement(o2, winmethod_Left | winmethod_Fixed, winwidth, gg_picwin);
		}
		else {
			glk_window_set_arrangement(o2, winmethod_Left | winmethod_Fixed, winwidth, gg_picwin);
		}
	}
];

[ DrawSpeechBubble speech_bubble_pic w_offset h_offset w_total h_total graph_width;
	if (gg_picwin) {
		speech_bubble_pic = I510_figure_speech_bubble + 1;

		glk_window_get_size(gg_picwin, gg_arguments, gg_arguments+WORDSIZE);
		graph_width  = gg_arguments-->0;
		
		w_offset = 3 * graph_width / 4 - 5;
		h_offset = 5 + graph_width * ((Global_Vars-->83) - 1);
	
		w_total = graph_width / 4;
		h_total = w_total;		

		glk_image_draw_scaled(gg_picwin, speech_bubble_pic, w_offset, h_offset, w_total, h_total); 	
	}
];

[ DrawPhoneHandset phone_handset_pic w_offset h_offset w_total h_total graph_width;
	if (gg_picwin) {
		phone_handset_pic = I511_figure_phone_handset + 1;

		glk_window_get_size(gg_picwin, gg_arguments, gg_arguments+WORDSIZE);
		graph_width  = gg_arguments-->0;
		
		w_offset = 5;
		h_offset = 5 + graph_width * ((Global_Vars-->82) - 1);
	
		w_total = graph_width / 4;
		h_total = w_total;		

		glk_image_draw_scaled(gg_picwin, phone_handset_pic, w_offset, h_offset, w_total, h_total); 	
	}
];

[ SubstituteForComparison to txt ;
    @push say__comp;
    say__comp = 1;
    TEXT_TY_SubstitutedForm(to, txt); 
    @pull say__comp;
    return to;
];

! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Entries in constant lists
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


Array LIST_CONST_87571 --> (85721088) LIST_OF_TY MAX_POSITIVE_NUMBER 10 1 (I190_doing_nothing) ;
Array LIST_CONST_91633 --> (85721088) LIST_OF_TY MAX_POSITIVE_NUMBER NUMBER_TY 3 (7) (8) (9) ;
Array LIST_CONST_91656 --> (85721088) LIST_OF_TY MAX_POSITIVE_NUMBER NUMBER_TY 3 (3) (4) (-2) ;
Array LIST_CONST_93225 --> (85721088) LIST_OF_TY MAX_POSITIVE_NUMBER NUMBER_TY 3 (0) (0) (0) ;
Array LIST_CONST_101244 --> (102498304) LIST_OF_TY MAX_POSITIVE_NUMBER TEXT_TY 5 (BC_3026) (BC_3027) (BC_3028) (BC_3029) (BC_3030) ;
Array LIST_CONST_101278 --> (102498304) LIST_OF_TY MAX_POSITIVE_NUMBER TEXT_TY 5 (BC_3031) (BC_3032) (BC_3033) (BC_3034) (BC_3035) ;
Array LIST_CONST_101312 --> (102498304) LIST_OF_TY MAX_POSITIVE_NUMBER TEXT_TY 5 (BC_3036) (BC_3037) (BC_3038) (BC_3039) (BC_3040) ;
Array LIST_CONST_101342 --> (102498304) LIST_OF_TY MAX_POSITIVE_NUMBER TEXT_TY 5 (BC_3041) (BC_3042) (BC_3043) (BC_3044) (BC_3045) ;
Array LIST_CONST_101372 --> (102498304) LIST_OF_TY MAX_POSITIVE_NUMBER TEXT_TY 5 (BC_3046) (BC_3047) (BC_3048) (BC_3049) (BC_3050) ;
Array LIST_CONST_101402 --> (102498304) LIST_OF_TY MAX_POSITIVE_NUMBER TEXT_TY 5 (BC_3051) (BC_3052) (BC_3053) (BC_3054) (BC_3055) ;
Array LIST_CONST_101436 --> (102498304) LIST_OF_TY MAX_POSITIVE_NUMBER TEXT_TY 5 (BC_3056) (BC_3057) (BC_3058) (BC_3059) (BC_3060) ;
Array LIST_CONST_101470 --> (102498304) LIST_OF_TY MAX_POSITIVE_NUMBER TEXT_TY 5 (BC_3061) (BC_3062) (BC_3063) (BC_3064) (BC_3065) ;
Array LIST_CONST_101504 --> (102498304) LIST_OF_TY MAX_POSITIVE_NUMBER TEXT_TY 5 (BC_3066) (BC_3067) (BC_3068) (BC_3069) (BC_3070) ;



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: To Phrases
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! From "Glulx Entry Points" by Emily Short
! Request 0: phrase nothing -> number
! To decide what number is the value returned by glk event handling ( this is the handle glk event rule ):
[ PHR_1291_r0  ;
    ! [2: now glulx replacement command is ~~]
    BlkValueCopy((Global_Vars-->53), EMPTY_TEXT_VALUE);
    ! [3: follow the glulx input handling rules for the current glk event]
    FollowRulebook(543, evGlobal-->0, true);
    ! [4: if the outcome of the rulebook is the replace player input outcome]
    if ((((ResultOfRule()) == RBNO_28)))
    {! [5: decide on input replacement]
        return 2;
        }
    ! [6: if the outcome of the rulebook is the require input to continue outcome]
    if ((((ResultOfRule()) == RBNO_29)))
    {! [7: decide on input continuation]
        return 1;
        }
    ! [8: follow the command-counting rules]
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(544));
    ! [9: if the rule succeeded]
    if (((RulebookSucceeded())))
    {! [10: follow the input-cancelling rules]
        FollowRulebook(RULEBOOK_TY_to_RULE_TY(545));
        ! [11: follow the command-showing rules]
        FollowRulebook(RULEBOOK_TY_to_RULE_TY(546));
        ! [12: follow the command-pasting rules]
        FollowRulebook(RULEBOOK_TY_to_RULE_TY(547));
        ! [13: if the rule succeeded]
        if (((RulebookSucceeded())))
        {! [14: decide on input replacement]
            return 2;
            }
            }
            return 0;
];
! From "Conversation Framework" by Eric Eve
! Request 1: phrase nothing -> nothing
! To reset the interlocutor:
[ PHR_830_r1  ;
    ! [2: now the current interlocutor is nothing]
    (Global_Vars-->11) = nothing;
    rfalse;
];
! From "Formatting Capture" by Daniel Stelzer
! Request 2: phrase nothing -> nothing
! To say bold type -- running on ( documented at phs_bold ):
[ PHR_352_r2  ;
    ! [2: if text capturing is active]
    if (((capture_active > 0)))
    {! [3: say ~[escape code]b~]
        say__p=1;! [4: escape code]
        ParaContent(); print (char) ESCAPE_CODE;! [5: ~b~]
        ParaContent(); print "b"; .L_Say546; .L_SayX539;} else {
        ! [6: say internal bold type]
        say__p=1;! [7: internal bold type]
        ParaContent(); style bold; .L_Say547; .L_SayX540;}
        rfalse;
];
! From "Formatting Capture" by Daniel Stelzer
! Request 3: phrase nothing -> nothing
! To say roman type -- running on ( documented at phs_roman ):
[ PHR_354_r3  ;
    ! [2: if text capturing is active]
    if (((capture_active > 0)))
    {! [3: say ~[escape code]r~]
        say__p=1;! [4: escape code]
        ParaContent(); print (char) ESCAPE_CODE;! [5: ~r~]
        ParaContent(); print "r"; .L_Say548; .L_SayX541;} else {
        ! [6: say internal roman type]
        say__p=1;! [7: internal roman type]
        ParaContent(); style roman; .L_Say549; .L_SayX542;}
        rfalse;
];
! Request 4: phrase nothing -> nothing
! To init player:
[ PHR_1441_r4  ;
    ! [2: now the player carries the green smartphone]
    MoveObject(I445_green_smartphone,player);
    ! [3: now the player carries the bureau credit card]
    MoveObject(I437_bureau_credit_card,player);
    ! [4: now the player knows klimp's phone number]
    (RGuard_MT_2(player,I421_klimp_s_mobile_phone_nu));
    ! [5: now the player owns the bureau credit card]
    (RGuard_MT_7(player,I437_bureau_credit_card));
    ! [6: now the player knows biff's mobile number]
    (RGuard_MT_2(player,I422_biff_s_mobile_number));
    ! [7: now the player owns the green smartphone]
    (RGuard_MT_7(player,I445_green_smartphone));
    rfalse;
];
! Request 5: phrase nothing -> nothing
! To init office:
[ PHR_1485_r5  ;
    ! [2: if player is not ezra gaunt]
    if (((~~((player == I404_ezra_gaunt)))))
    {! [3: move movie poster to room of stuff]
        MoveObject(I440_movie_poster, I357_room_of_stuff, 0, false);
        ! [4: move trivia competition award to room of stuff]
        MoveObject(I441_trivia_competition_awar, I357_room_of_stuff, 0, false);
        }
    ! [5: if player is not petula goldberg]
    if (((~~((player == I405_petula_goldberg)))))
    {! [6: move photo of pluto to room of stuff]
        MoveObject(I438_photo_of_pluto, I357_room_of_stuff, 0, false);
        ! [7: move green pheasant to room of stuff]
        MoveObject(I442_green_pheasant, I357_room_of_stuff, 0, false);
        }
    ! [8: if player is not larch faraji]
    if (((~~((player == I406_larch_faraji)))))
    {! [9: move drawing of the pitfall snake to room of stuff]
        MoveObject(I443_drawing_of_the_pitfall_, I357_room_of_stuff, 0, false);
        ! [10: move photo of softball team to room of stuff]
        MoveObject(I444_photo_of_softball_team, I357_room_of_stuff, 0, false);
        }
        rfalse;
];
! Request 6: phrase nothing -> nothing
! To set possessives:
[ PHR_1442_r6  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(6);
    BlkValueCreateOnStack(4, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_69();
    BlkValueFreeOnStack(4);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_69 
    tmp_0 ! Let/loop value, e.g., 'P': text
    ;
    ! [2: let p be the substituted form of ~[Player's surname] s~]
    tmp_0 = I7SFRAME; 
    		BlkValueCopy(tmp_0, TEXT_TY_SubstitutedForm((I7SFRAME+WORDSIZE*2), ((LocalParking-->0=tmp_0),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*4),TX_S_578))));
    ! [3: now the possessive of biff's door is p]
    BlkValueCopy(GProperty(10, I451_biff_s_door,p48_possessive), tmp_0);
    ! [4: now the possessive of the green smartphone is p]
    BlkValueCopy(GProperty(10, I445_green_smartphone,p48_possessive), tmp_0);
    ! [5: now the possessive of biff's computer is p]
    BlkValueCopy(GProperty(10, I362_biff_s_computer,p48_possessive), tmp_0);
    ! [6: now the possessive of car 1 is p]
    BlkValueCopy(GProperty(10, I299_car_1,p48_possessive), tmp_0);
    rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 7: phrase nothing -> nothing
! To say We:
[ PHR_764_r7  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_70();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_70 ;
    ! [2: if last person referenced is not the player]
    if (((~~(((Global_Vars-->10) == player)))))
    {! [3: say ~[player]~]
        say__p=1;! [4: player]
        ParaContent(); PrintShortName(player); .L_Say550; .L_SayX543;} else {
        ! [5: now the prior named object is the player]
        prior_named_noun = player;
        ! [6: now the most recent reference of the prior named object is pronominal]
        WriteGProperty(OBJECT_TY, prior_named_noun,most_recent_reference,I392_pronominal);
        ! [7: if the story viewpoint is]
        switch (story_viewpoint) 
        {I118_first_person_singular:
            ! [8: say ~I~]
            say__p=1;! [9: ~I~]
            ParaContent(); print "I"; .L_Say551; .L_SayX544;;
            I119_second_person_singular:
            ! [10: say ~You~]
            say__p=1;! [11: ~You~]
            ParaContent(); print "You"; .L_Say552; .L_SayX545;;
            I120_third_person_singular:
            ! [12: if printing gender for the player is]
            switch ((PHR_1436_r206 (player))) 
            {I66_masculine_gender:
                ! [13: say ~He~]
                say__p=1;! [14: ~He~]
                ParaContent(); print "He"; .L_Say553; .L_SayX546;;
                I67_feminine_gender:
                ! [15: say ~She~]
                say__p=1;! [16: ~She~]
                ParaContent(); print "She"; .L_Say554; .L_SayX547;;
                I65_neuter_gender:
                ! [17: say ~It~]
                say__p=1;! [18: ~It~]
                ParaContent(); print "It"; .L_Say555; .L_SayX548;;
                I68_neitherine_gender:
                ! [19: say ~[entry 1 in the declensions of the third singular pronoun of the player in title case]~]
                say__p=1;! [20: entry 1 in the declensions of the third singular pronoun of the player in title case]
                ParaContent(); print (TEXT_TY_Say) TEXT_TY_CharactersToCase(I7SFRAME, LIST_OF_TY_GetItem(GProperty(10, GProperty(10, player,third_singular_pronoun),p41_declensions),1), 2); .L_Say556; .L_SayX549;}
                ;
                I121_first_person_plural:
            ! [21: say ~We~]
            say__p=1;! [22: ~We~]
            ParaContent(); print "We"; .L_Say557; .L_SayX550;;
            I122_second_person_plural:
            ! [23: say ~You~]
            say__p=1;! [24: ~You~]
            ParaContent(); print "You"; .L_Say558; .L_SayX551;;
            I123_third_person_plural:
            ! [25: say ~They~]
            say__p=1;! [26: ~They~]
            ParaContent(); print "They"; .L_Say559; .L_SayX552;}
            }
            rfalse;
];
! From "Phones" by Philip Riley
! Request 8: phrase person -> nothing
! To break connection of ( P - a person ):
[ PHR_996_r8  
    t_0 ! Call parameter 'P': person
    tmp_0 ! Let/loop value, e.g., 'callee': thing
    ;
    ! [2: let callee be a random person talking with p]

    		tmp_0 = (Prop_106(t_0));
    ! [3: now p is not talking with anyone]
    Prop_107(t_0);
    ! [4: now p is not calling anything]
    Prop_108(t_0);
    ! [5: now p is not talking on anything]
    Prop_109(t_0);
    ! [6: now callee is not talking with anyone]
    Prop_110(tmp_0);
    ! [7: now callee is not calling anything]
    Prop_111(tmp_0);
    ! [8: now callee is not talking on anything]
    Prop_112(tmp_0);
    ! [9: if p is player or callee is player]
    if ((((t_0 == player))) || (((tmp_0 == player))))
    {! [10: say ~Your call abruptly ends. You must have lost reception.~]
        say__p=1;! [11: ~Your call abruptly ends. You must have lost reception.~]
        ParaContent(); print "Your call abruptly ends. You must have lost reception."; new_line; .L_Say560; .L_SayX553;}
        rfalse;
];
! From "Formatting Capture" by Daniel Stelzer
! Request 9: phrase nothing -> nothing
! To say italic type -- running on ( documented at phs_italic ):
[ PHR_353_r9  ;
    ! [2: if text capturing is active]
    if (((capture_active > 0)))
    {! [3: say ~[escape code]i~]
        say__p=1;! [4: escape code]
        ParaContent(); print (char) ESCAPE_CODE;! [5: ~i~]
        ParaContent(); print "i"; .L_Say561; .L_SayX554;} else {
        ! [6: say internal italic type]
        say__p=1;! [7: internal italic type]
        ParaContent(); style underline; .L_Say562; .L_SayX555;}
        rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! Request 10: phrase two-sided door -> nothing
! To autolock ( TSD - a two-sided door ):
[ PHR_1373_r10  
    t_0 ! Call parameter 'TSD': two-sided door
    tmp_0 ! Let/loop value, e.g., 'lock-happened': truth state
    ;
    ! [2: let lock-happened be false]

    		tmp_0 = 0;
    ! [3: if tsd is autolock-the-front]
    if ((((Adj_173_t1_v10(t_0)))))
    {! [4: if tsd is not front-locked]
        if (((~~(((Adj_160_t1_v10(t_0)))))))
        {! [5: now lock-happened is true]
            tmp_0 = 1;
            }
        ! [6: lock tsd in the front]
        (PHR_1371_r194 (t_0));
        }
    ! [7: if tsd is autolock-the-back]
    if ((((Adj_172_t1_v10(t_0)))))
    {! [8: if tsd is not back-locked]
        if (((~~(((Adj_161_t1_v10(t_0)))))))
        {! [9: now lock-happened is true]
            tmp_0 = 1;
            }
        ! [10: lock tsd in the back]
        (PHR_1372_r195 (t_0));
        }
    ! [11: if lock-happened is true and ( the location is the frontside of tsd or the location is the backside of tsd )]
    if (((((tmp_0 && true) == (1 && true)))) && ((((real_location == GProperty(10, t_0,p30_frontside)))) || (((real_location == (PHR_1345_r44 (t_0)))))))
    {! [12: say ~[The TSD] locks with a click.~]
        say__p=1;! [13: the tsd]
        ParaContent(); print (The) t_0;! [14: ~ locks with a click.~]
        ParaContent(); print " locks with a click."; new_line; .L_Say563; .L_SayX556;}
        rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! Request 11: phrase two-sided door -> nothing
! To autoclose ( TSD - a two-sided door ):
[ PHR_1376_r11  
    t_0 ! Call parameter 'TSD': two-sided door
    ;
    ! [2: close tsd]
    (PHR_1375_r196 (t_0));
    ! [3: if the location of the player is the frontside of tsd or the location of the player is the backside of tsd]
    if ((((LocationOf(player) == GProperty(10, t_0,p30_frontside)))) || (((LocationOf(player) == (PHR_1345_r44 (t_0))))))
    {! [4: say ~[The TSD] closes.~]
        say__p=1;! [5: the tsd]
        ParaContent(); print (The) t_0;! [6: ~ closes.~]
        ParaContent(); print " closes."; new_line; .L_Say564; .L_SayX557;}
        rfalse;
];
! From "Conversation Framework" by Eric Eve
! Request 12: phrase thing -> nothing
! To implicitly greet ( character - a thing ):
[ PHR_819_r12  
    t_0 ! Call parameter 'character': thing
    ;
    ! [2: now the greeting type is implicit]
    (Global_Vars-->12) = I129_implicit;
    ! [3: try saying hello to the character]
    TryAction(0, player, ##A74_saying_hello_to, t_0, 0);
    rfalse;
];
! Request 13: phrase nothing -> nothing
! To say agent:
[ PHR_1445_r13  ;
    ! [2: say ~Agent [player's surname]~]
    say__p=1;! [3: ~Agent ~]
    ParaContent(); print "Agent ";! [4: player's surname]
    ParaContent(); print (TEXT_TY_Say) (Global_Vars-->20); .L_Say565; .L_SayX558;rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 14: phrase nothing -> nothing
! To say Our:
[ PHR_770_r14  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_71();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_71 ;
    ! [2: if the last person referenced is not the player]
    if (((~~(((Global_Vars-->10) == player)))))
    {! [3: say ~[player]'s~]
        say__p=1;! [4: player]
        ParaContent(); PrintShortName(player);! [5: ~'s~]
        ParaContent(); print "'s"; .L_Say566; .L_SayX559;} else {
        ! [6: now the prior named object is the player]
        prior_named_noun = player;
        ! [7: if the story viewpoint is]
        switch (story_viewpoint) 
        {I118_first_person_singular:
            ! [8: say ~My~]
            say__p=1;! [9: ~My~]
            ParaContent(); print "My"; .L_Say567; .L_SayX560;;
            I119_second_person_singular:
            ! [10: say ~Your~]
            say__p=1;! [11: ~Your~]
            ParaContent(); print "Your"; .L_Say568; .L_SayX561;;
            I120_third_person_singular:
            ! [12: if printing gender for the player is]
            switch ((PHR_1436_r206 (player))) 
            {I66_masculine_gender:
                ! [13: say ~His~]
                say__p=1;! [14: ~His~]
                ParaContent(); print "His"; .L_Say569; .L_SayX562;;
                I67_feminine_gender:
                ! [15: say ~Her~]
                say__p=1;! [16: ~Her~]
                ParaContent(); print "Her"; .L_Say570; .L_SayX563;;
                I65_neuter_gender:
                ! [17: say ~Its~]
                say__p=1;! [18: ~Its~]
                ParaContent(); print "Its"; .L_Say571; .L_SayX564;;
                I68_neitherine_gender:
                ! [19: say ~[entry 5 in the declensions of the third singular pronoun of the player in title case]~]
                say__p=1;! [20: entry 5 in the declensions of the third singular pronoun of the player in title case]
                ParaContent(); print (TEXT_TY_Say) TEXT_TY_CharactersToCase(I7SFRAME, LIST_OF_TY_GetItem(GProperty(10, GProperty(10, player,third_singular_pronoun),p41_declensions),5), 2); .L_Say572; .L_SayX565;}
                ;
                I121_first_person_plural:
            ! [21: say ~Our~]
            say__p=1;! [22: ~Our~]
            ParaContent(); print "Our"; .L_Say573; .L_SayX566;;
            I122_second_person_plural:
            ! [23: say ~Your~]
            say__p=1;! [24: ~Your~]
            ParaContent(); print "Your"; .L_Say574; .L_SayX567;;
            I123_third_person_plural:
            ! [25: say ~Their~]
            say__p=1;! [26: ~Their~]
            ParaContent(); print "Their"; .L_Say575; .L_SayX568;}
            }
            rfalse;
];
! Request 15: phrase (person, person) -> truth state
! To decide whether ( actor - a person ) is busy with respect to ( actor2 - a person ):
[ PHR_1461_r15  
    t_0 ! Call parameter 'actor': person
    t_1 ! Call parameter 'actor2': person
    ;
    ! [2: decide on whether or not actor is phoning and actor is not talking with actor2]
    return ((((((Adj_49_t1_v10(t_0))))) && (((~~(((RGuard_T_4(t_0,t_1)))))))));
    return false;
];
! From "Gender Options" by Nathanael Nerode
! Request 16: phrase nothing -> nothing
! To say we:
[ PHR_757_r16  ;
    ! [2: if the last person referenced is not the player]
    if (((~~(((Global_Vars-->10) == player)))))
    {! [3: say ~[player]~]
        say__p=1;! [4: player]
        ParaContent(); PrintShortName(player); .L_Say576; .L_SayX569;} else {
        ! [5: now the prior named object is the player]
        prior_named_noun = player;
        ! [6: now the most recent reference of the prior named object is pronominal]
        WriteGProperty(OBJECT_TY, prior_named_noun,most_recent_reference,I392_pronominal);
        ! [7: if the story viewpoint is]
        switch (story_viewpoint) 
        {I118_first_person_singular:
            ! [8: say ~I~]
            say__p=1;! [9: ~I~]
            ParaContent(); print "I"; .L_Say577; .L_SayX570;;
            I119_second_person_singular:
            ! [10: say ~you~]
            say__p=1;! [11: ~you~]
            ParaContent(); print "you"; .L_Say578; .L_SayX571;;
            I120_third_person_singular:
            ! [12: if printing gender for the player is]
            switch ((PHR_1436_r206 (player))) 
            {I66_masculine_gender:
                ! [13: say ~he~]
                say__p=1;! [14: ~he~]
                ParaContent(); print "he"; .L_Say579; .L_SayX572;;
                I67_feminine_gender:
                ! [15: say ~she~]
                say__p=1;! [16: ~she~]
                ParaContent(); print "she"; .L_Say580; .L_SayX573;;
                I65_neuter_gender:
                ! [17: say ~it~]
                say__p=1;! [18: ~it~]
                ParaContent(); print "it"; .L_Say581; .L_SayX574;;
                I68_neitherine_gender:
                ! [19: say entry 1 in the declensions of the third singular pronoun of the player]
                say__p=1;! [20: entry 1 in the declensions of the third singular pronoun of the player]
                ParaContent(); print (TEXT_TY_Say) LIST_OF_TY_GetItem(GProperty(10, GProperty(10, player,third_singular_pronoun),p41_declensions),1); .L_Say582; .L_SayX575;}
                ;
                I121_first_person_plural:
            ! [21: say ~we~]
            say__p=1;! [22: ~we~]
            ParaContent(); print "we"; .L_Say583; .L_SayX576;;
            I122_second_person_plural:
            ! [23: say ~you~]
            say__p=1;! [24: ~you~]
            ParaContent(); print "you"; .L_Say584; .L_SayX577;;
            I123_third_person_plural:
            ! [25: say ~they~]
            say__p=1;! [26: ~they~]
            ParaContent(); print "they"; .L_Say585; .L_SayX578;}
            }
            rfalse;
];
! From "Memories" by Philip Riley
! Request 17: phrase (memory, person) -> nothing
! To remember ( M - a memory ) for ( P - a person ):
[ PHR_1188_r17  
    t_0 ! Call parameter 'M': memory
    t_1 ! Call parameter 'P': person
    ;
    ! [2: if m is not listed in the remembrances of p]
    if (((LIST_OF_TY_FindItem(GProperty(10, t_1,p26_remembrances), t_0) == false)))
    {! [3: add m to the remembrances of p]
        LIST_OF_TY_InsertItem(GProperty(10, t_1,p26_remembrances), t_0, 0, 0, 0);
        ! [4: queue m]
        (PHR_1189_r187 (t_0));
        }
        rfalse;
];
! From "Simple Conversation" by Philip Riley
! Request 18: phrase (person, quip) -> nothing
! To queue ( P - a person ) with ( Q - a quip ):
[ PHR_1209_r18  
    t_0 ! Call parameter 'P': person
    t_1 ! Call parameter 'Q': quip
    ;
    ! [2: if q is not listed in the queue of p]
    if (((LIST_OF_TY_FindItem(GProperty(10, t_0,p29_queue), t_1) == false)))
    {! [3: add q to the queue of p]
        LIST_OF_TY_InsertItem(GProperty(10, t_0,p29_queue), t_1, 0, 0, 0);
        }
        rfalse;
];
! From "Hyperspace" by Philip Riley
! Request 19: phrase list of numbers -> nothing
! To say symbols for ( L - a list of numbers ):
[ PHR_1249_r19  
    t_0 ! Call parameter 'L': list of numbers
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value: number
    ;
    ! [2: say ~[fixed letter spacing]~]
    say__p=1;! [3: fixed letter spacing]
    ParaContent(); (PHR_355_r53 ()); .L_Say586; .L_SayX579;! [4: repeat with digit running through l]
    for (tmp_2=t_0, tmp_1=1, tmp_0=LIST_OF_TY_GetItem(tmp_2, tmp_1, true): tmp_1<=LIST_OF_TY_GetLength(tmp_2): tmp_1++, tmp_0=LIST_OF_TY_GetItem(tmp_2, tmp_1, true))
    {! [5: say ~[symbol for digit]~]
        say__p=1;! [6: symbol for digit]
        ParaContent(); (PHR_1255_r190 (tmp_0)); .L_Say587; .L_SayX580;}
    ! [7: say ~[variable letter spacing]~]
    say__p=1;! [8: variable letter spacing]
    ParaContent(); (PHR_356_r54 ()); .L_Say588; .L_SayX581;rfalse;
];
! From "Hyperspace" by Philip Riley
! Request 20: phrase number -> list of numbers
! To decide what list of numbers is convert ( N - a number ) to base five:
[ PHR_1251_r20  I7RBLK 
    t_0 ! Call parameter 'N': number
;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(1, KD9_list_of_numbers);
    BlkValueCreateOnStack(0, KD9_list_of_numbers);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_72(t_0));
    BlkValueFreeOnStack(1);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! list of numbers
];
[ KERNEL_72 
    t_0 ! Call parameter 'N': number
    tmp_0 ! Let/loop value, e.g., 'K': number
    tmp_1 ! Let/loop value, e.g., 'L': list of numbers
    tmp_2 ! Let/loop value, e.g., 'negative': truth state
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    tmp_4 ! Let/loop value (deallocated by end of phrase)
    tmp_5 ! Let/loop value: number
    ;
    ! [2: let k be n]

    		tmp_0 = t_0;
    ! [3: let l be a list of numbers]
    tmp_1 = I7SFRAME; 
    		
    ! [4: while k is not 0]
    while (((~~((tmp_0 == 0)))))
    {! [5: let r be the remainder after dividing k by 5]

        		tmp_2 = (IntegerRemainder(tmp_0, 5));
        ! [6: add r to l]
        LIST_OF_TY_InsertItem(tmp_1, tmp_2, 0, 0, 0);
        ! [7: now k is k divided by 5]
        tmp_0 = (IntegerDivide(tmp_0, 5));
        }
    ! [8: if l is empty]
    if ((((Adj_17_t1_v34(tmp_1)))))
    {! [9: add 0 to l]
        LIST_OF_TY_InsertItem(tmp_1, 0, 0, 0, 0);
        }
    ! [10: let negative be false]

    		tmp_2 = 0;
    ! [11: reverse l]
    LIST_OF_TY_Reverse(tmp_1);
    ! [12: repeat with x running through l]
    for (tmp_5=tmp_1, tmp_4=1, tmp_3=LIST_OF_TY_GetItem(tmp_5, tmp_4, true): tmp_4<=LIST_OF_TY_GetLength(tmp_5): tmp_4++, tmp_3=LIST_OF_TY_GetItem(tmp_5, tmp_4, true))
    {! [13: if x < 0]
        if (((tmp_3 < 0)))
        {! [14: now negative is true]
            tmp_2 = 1;
            }
            }
    ! [15: if negative is true]
    if ((((tmp_2 && true) == (1 && true))))
    {! [16: let length be the number of entries in l]

        		tmp_3 = LIST_OF_TY_GetLength(tmp_1);
        ! [17: repeat with x running from 1 to length]
        for (tmp_4=1: tmp_4<=tmp_3: tmp_4++)
        {! [18: now entry x of l is -1 times entry x of l]
            WriteLIST_OF_TY_GetItem(tmp_1,tmp_4,(-1 * LIST_OF_TY_GetItem(tmp_1,tmp_4)));
            }
        ! [19: add -1 to l]
        LIST_OF_TY_InsertItem(tmp_1, -1, 0, 0, 0);
        }
    ! [20: decide on l]
    return BlkValueCopy((I7SFRAME+WORDSIZE), tmp_1);
    return BC_3071;
];
! From "Floors" by Philip Riley
! Request 21: phrase room -> text
! To decide what text is the floor touch description for ( R - a room ):
[ PHR_1080_r21  I7RBLK 
    t_0 ! Call parameter 'R': room
;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_73(t_0));
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! text
];
[ KERNEL_73 
    t_0 ! Call parameter 'R': room
    ;
    ! [2: decide on the text produced by the floor touch description rules for r]
    return BlkValueCopy(I7SFRAME, ResultOfRule(RULEBOOK_TY_to_RULE_TY(460), t_0, true, TEXT_TY));
    return BC_3072;
];
! From "Ceilings" by Philip Riley
! Request 22: phrase room -> text
! To decide what text is the ceiling touch description for ( R - a room ):
[ PHR_1095_r22  I7RBLK 
    t_0 ! Call parameter 'R': room
;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_74(t_0));
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! text
];
[ KERNEL_74 
    t_0 ! Call parameter 'R': room
    ;
    ! [2: decide on the text produced by the ceiling touch description rules for r]
    return BlkValueCopy(I7SFRAME, ResultOfRule(RULEBOOK_TY_to_RULE_TY(462), t_0, true, TEXT_TY));
    return BC_3073;
];
! From "Margaret" by Philip Riley
! Request 23: phrase nothing -> nothing
! To initiate Margaret's box routine:
[ PHR_1430_r23  ;
    ! [2: say ~[Margaret] says, 'Hey, what are you doing with those boxes, [Agent]? You don't have to worry about that -- I'll get them.' [regarding Margaret][They] takes the flattened boxes from [us] and hustles off.~]
    say__p=1;! [3: margaret]
    ParaContent(); PrintShortName(I358_margaret_chao);! [4: ~ says, 'Hey, what are you doing with those boxes, ~]
    ParaContent(); print " says, ~Hey, what are you doing with those boxes, ";! [5: agent]
    ParaContent(); (PHR_1445_r13 ());! [6: ~? You don't have to worry about that -- I'll get them.' ~]
    ParaContent(); print "? You don't have to worry about that -- I'll get them.~ ";! [7: regarding margaret]
    ParaContent(); RegardingSingleObject(I358_margaret_chao);! [8: they]
    ParaContent(); (PHR_776_r43 ());! [9: ~ takes the flattened boxes from ~]
    ParaContent(); print " takes the flattened boxes from ";! [10: us]
    ParaContent(); (PHR_760_r49 ());! [11: ~ and hustles off.~]
    ParaContent(); print " and hustles off."; new_line; .L_Say589; .L_SayX582;! [12: now margaret carries the margaret-flattened-boxes]
    MoveObject(I468_margaret_flattened_boxe,I358_margaret_chao);
    ! [13: now the biff-flattened-boxes are in the room of stuff]
    MoveObject(I467_biff_flattened_boxes,I357_room_of_stuff);
    ! [14: now the current interlocutor is nothing]
    (Global_Vars-->11) = nothing;
    ! [15: add behavior throw out boxes to margaret]
    (PHR_1050_r73 (I368_throw_out_boxes,I358_margaret_chao));
    rfalse;
];
! From "Can't Go That Way" by Philip Riley
! Request 24: phrase (room, direction) -> text
! To decide which text is the excuse for ( source - a room ) to ( dir - a direction ):
[ PHR_1105_r24  I7RBLK 
    t_0 ! Call parameter 'source': room
    t_1 ! Call parameter 'dir': direction
;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_75(t_0, t_1));
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! text
];
[ KERNEL_75 
    t_0 ! Call parameter 'source': room
    t_1 ! Call parameter 'dir': direction
    ;
    ! [2: now the room you tried to leave is source]
    (Global_Vars-->21) = t_0;
    ! [3: decide on the text produced by the excuse text rules for dir]
    return BlkValueCopy(I7SFRAME, ResultOfRule(RULEBOOK_TY_to_RULE_TY(463), t_1, true, TEXT_TY));
    return BC_3074;
];
! From "Gender Options" by Nathanael Nerode
! Request 25: phrase nothing -> nothing
! To say ourselves:
[ PHR_762_r25  ;
    ! [2: now the prior named object is the player]
    prior_named_noun = player;
    ! [3: if the story viewpoint is]
    switch (story_viewpoint) 
    {I118_first_person_singular:
        ! [4: say ~myself~]
        say__p=1;! [5: ~myself~]
        ParaContent(); print "myself"; .L_Say590; .L_SayX583;;
        I119_second_person_singular:
        ! [6: say ~yourself~]
        say__p=1;! [7: ~yourself~]
        ParaContent(); print "yourself"; .L_Say591; .L_SayX584;;
        I120_third_person_singular:
        ! [8: if printing gender for the player is]
        switch ((PHR_1436_r206 (player))) 
        {I66_masculine_gender:
            ! [9: say ~himself~]
            say__p=1;! [10: ~himself~]
            ParaContent(); print "himself"; .L_Say592; .L_SayX585;;
            I67_feminine_gender:
            ! [11: say ~herself~]
            say__p=1;! [12: ~herself~]
            ParaContent(); print "herself"; .L_Say593; .L_SayX586;;
            I65_neuter_gender:
            ! [13: say ~itself~]
            say__p=1;! [14: ~itself~]
            ParaContent(); print "itself"; .L_Say594; .L_SayX587;;
            I68_neitherine_gender:
            ! [15: say entry 4 in the declensions of the third singular pronoun of the player]
            say__p=1;! [16: entry 4 in the declensions of the third singular pronoun of the player]
            ParaContent(); print (TEXT_TY_Say) LIST_OF_TY_GetItem(GProperty(10, GProperty(10, player,third_singular_pronoun),p41_declensions),4); .L_Say595; .L_SayX588;}
            ;
            I121_first_person_plural:
        ! [17: say ~ourselves~]
        say__p=1;! [18: ~ourselves~]
        ParaContent(); print "ourselves"; .L_Say596; .L_SayX589;;
        I122_second_person_plural:
        ! [19: say ~yourselves~]
        say__p=1;! [20: ~yourselves~]
        ParaContent(); print "yourselves"; .L_Say597; .L_SayX590;;
        I123_third_person_plural:
        ! [21: say ~themselves~]
        say__p=1;! [22: ~themselves~]
        ParaContent(); print "themselves"; .L_Say598; .L_SayX591;}
        rfalse;
];
! Request 26: phrase (room, room) -> text
! To decide which text is the transition for ( source - a room ) to ( target - a room ):
[ PHR_1502_r26  I7RBLK 
    t_0 ! Call parameter 'source': room
    t_1 ! Call parameter 'target': room
;
    @push I7SFRAME;
    StackFrameCreate(6);
    BlkValueCreateOnStack(4, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_76(t_0, t_1));
    BlkValueFreeOnStack(4);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! text
];
[ KERNEL_76 
    t_0 ! Call parameter 'source': room
    t_1 ! Call parameter 'target': room
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: repeat through the table of transitions]
    @push ct_0; @push ct_1;
    		for (tmp_0=T19_transitions, tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [3: if ( source room entry is source ) and ( target room entry is target )]
        if ((((TableLookUpEntry(ct_0,132,ct_1) == t_0))) && (((TableLookUpEntry(ct_0,147,ct_1) == t_1))))
        {! [4: if there is a used entry and used entry is false]
            if ((((ExistsTableLookUpEntry(ct_0,149,ct_1)))) && ((((TableLookUpEntry(ct_0,149,ct_1) && true) == (0 && true)))))
            {! [5: decide on transition text entry]
                return BlkValueCopy(I7SFRAME, TableLookUpEntry(ct_0,148,ct_1));
                }
            ! [6: if there is no used entry]
            if (((ExistsTableLookUpEntry(ct_0,149,ct_1) == false)))
            {! [7: decide on transition text entry]
                return BlkValueCopy((I7SFRAME+WORDSIZE*2), TableLookUpEntry(ct_0,148,ct_1));
                }
                }
                }
                @pull ct_1; @pull ct_0;! [8: decide on ~none~]
    return BlkValueCopy((I7SFRAME+WORDSIZE*4), TX_L_478);
    return BC_3075;
];
! Request 27: phrase (room, room) -> nothing
! To mark transition from ( source - a room ) to ( target - a room ) as used:
[ PHR_1503_r27  
    t_0 ! Call parameter 'source': room
    t_1 ! Call parameter 'target': room
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: repeat through the table of transitions]
    @push ct_0; @push ct_1;
    		for (tmp_0=T19_transitions, tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [3: if ( source room entry is source ) and ( target room entry is target )]
        if ((((TableLookUpEntry(ct_0,132,ct_1) == t_0))) && (((TableLookUpEntry(ct_0,147,ct_1) == t_1))))
        {! [4: now used entry is true]
            TableLookUpEntry(ct_0,149,ct_1,1,1);
            }
            }
            @pull ct_1; @pull ct_0;rfalse;
];
! Request 28: phrase action -> nothing
! To postpone ( act - an action ):
[ PHR_1456_r28  
    t_0 ! Call parameter 'act': action
    ;
    ! [2: now the postponed action is act]
    BlkValueCopy((Global_Vars-->79), t_0);
    rfalse;
];
! From "Exit Lister" by Eric Eve
! Request 29: phrase nothing -> nothing
! To say to-preposition:
[ PHR_1157_r29  ;
    ! [2: say ~to~]
    say__p=1;! [3: ~to~]
    ParaContent(); print "to"; .L_Say599; .L_SayX592;rfalse;
];
! From "Exit Lister" by Eric Eve
! Request 30: phrase room -> nothing
! To say destname ( place - a room ):
[ PHR_1159_r30  
    t_0 ! Call parameter 'place': room
I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(4);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_77(t_0);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_77 
    t_0 ! Call parameter 'place': room
    ;
    ! [2: if the destination name of place is ~~]
    if ((( BlkValueCompare(GProperty(10, t_0,p24_destination_name), EMPTY_TEXT_VALUE) == 0)))
    {! [3: say ~[the place]~ in lower case]
        say__p=1;! [4: ~[the place]~ in lower case]
        ParaContent(); print (TEXT_TY_Say) TEXT_TY_CharactersToCase(I7SFRAME, ((LocalParking-->0=t_0),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*2),TX_S_579)), 0); .L_Say600; .L_SayX593;} else {
        ! [5: say ~[destination name of place]~]
        say__p=1;! [6: destination name of place]
        ParaContent(); @push self; print (TEXT_TY_Say) GProperty(10, self=t_0,p24_destination_name);@pull self;  .L_Say601; .L_SayX594;}
        rfalse;
];
! From the Standard Rules
! Request 31: phrase (object, number) -> nothing
! To set the/-- locale priority of ( O - an object ) to ( N - a number ):
[ PHR_80_r31  
    t_0 ! Call parameter 'O': object
    t_1 ! Call parameter 'N': number
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: if o is a thing]
    if (((t_0 ofclass K2_thing)))
    {! [3: if n <= 0]
        if (((t_1 <= 0)))
        {! [4: now o is mentioned]
            (Adj_96_t2_v10(t_0));
            }
        ! [5: if there is a notable-object of o in the table of locale priorities]
        if (((ExistsTableLookUpCorr(T1_locale_priorities,105,105,t_0))))
        {! [6: choose row with a notable-object of o in the table of locale priorities]
            ct_0 = T1_locale_priorities; ct_1 = TableRowCorr(ct_0, 105, t_0);
            ! [7: if n <= 0]
            if (((t_1 <= 0)))
            {! [8: blank out the whole row]
                TableBlankOutRow(ct_0, ct_1);
                } else {
                ! [9: now the locale description priority entry is n]
                TableLookUpEntry(ct_0,106,ct_1,1,t_1);
                }
                } else {
            ! [10: if n is greater than 0]
            if (((t_1 > 0)))
            {! [11: choose a blank row in the table of locale priorities]
                ct_0 = T1_locale_priorities; ct_1 = TableBlankRow(ct_0);
                ! [12: now the notable-object entry is o]
                TableLookUpEntry(ct_0,105,ct_1,1,t_0);
                ! [13: now the locale description priority entry is n]
                TableLookUpEntry(ct_0,106,ct_1,1,t_1);
                }
                }
                }
                rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 32: phrase nothing -> nothing
! To say our:
[ PHR_763_r32  ;
    ! [2: if the last person referenced is not the player]
    if (((~~(((Global_Vars-->10) == player)))))
    {! [3: say ~[player]'s~]
        say__p=1;! [4: player]
        ParaContent(); PrintShortName(player);! [5: ~'s~]
        ParaContent(); print "'s"; .L_Say602; .L_SayX595;} else {
        ! [6: now the prior named object is the player]
        prior_named_noun = player;
        ! [7: if the story viewpoint is]
        switch (story_viewpoint) 
        {I118_first_person_singular:
            ! [8: say ~my~]
            say__p=1;! [9: ~my~]
            ParaContent(); print "my"; .L_Say603; .L_SayX596;;
            I119_second_person_singular:
            ! [10: say ~your~]
            say__p=1;! [11: ~your~]
            ParaContent(); print "your"; .L_Say604; .L_SayX597;;
            I120_third_person_singular:
            ! [12: if printing gender for the player is]
            switch ((PHR_1436_r206 (player))) 
            {I66_masculine_gender:
                ! [13: say ~his~]
                say__p=1;! [14: ~his~]
                ParaContent(); print "his"; .L_Say605; .L_SayX598;;
                I67_feminine_gender:
                ! [15: say ~her~]
                say__p=1;! [16: ~her~]
                ParaContent(); print "her"; .L_Say606; .L_SayX599;;
                I65_neuter_gender:
                ! [17: say ~its~]
                say__p=1;! [18: ~its~]
                ParaContent(); print "its"; .L_Say607; .L_SayX600;;
                I68_neitherine_gender:
                ! [19: say entry 5 in the declensions of the third singular pronoun of the player]
                say__p=1;! [20: entry 5 in the declensions of the third singular pronoun of the player]
                ParaContent(); print (TEXT_TY_Say) LIST_OF_TY_GetItem(GProperty(10, GProperty(10, player,third_singular_pronoun),p41_declensions),5); .L_Say608; .L_SayX601;}
                ;
                I121_first_person_plural:
            ! [21: say ~our~]
            say__p=1;! [22: ~our~]
            ParaContent(); print "our"; .L_Say609; .L_SayX602;;
            I122_second_person_plural:
            ! [23: say ~your~]
            say__p=1;! [24: ~your~]
            ParaContent(); print "your"; .L_Say610; .L_SayX603;;
            I123_third_person_plural:
            ! [25: say ~their~]
            say__p=1;! [26: ~their~]
            ParaContent(); print "their"; .L_Say611; .L_SayX604;}
            }
            rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 33: phrase nothing -> nothing
! To say their:
[ PHR_777_r33  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~their~]
        say__p=1;! [5: ~their~]
        ParaContent(); print "their"; .L_Say612; .L_SayX605;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[our]~]
            say__p=1;! [8: our]
            ParaContent(); (PHR_763_r32 ()); .L_Say613; .L_SayX606;} else {
            ! [9: if printing gender for the item is]
            switch ((PHR_1436_r206 (tmp_0))) 
            {I66_masculine_gender:
                ! [10: say ~his~]
                say__p=1;! [11: ~his~]
                ParaContent(); print "his"; .L_Say614; .L_SayX607;;
                I67_feminine_gender:
                ! [12: say ~her~]
                say__p=1;! [13: ~her~]
                ParaContent(); print "her"; .L_Say615; .L_SayX608;;
                I65_neuter_gender:
                ! [14: say ~its~]
                say__p=1;! [15: ~its~]
                ParaContent(); print "its"; .L_Say616; .L_SayX609;;
                I68_neitherine_gender:
                ! [16: say entry 5 in the declensions of the third singular pronoun of the item]
                say__p=1;! [17: entry 5 in the declensions of the third singular pronoun of the item]
                ParaContent(); print (TEXT_TY_Say) LIST_OF_TY_GetItem(GProperty(10, GProperty(OBJECT_TY, tmp_0,third_singular_pronoun),p41_declensions),5); .L_Say617; .L_SayX610;}
                }
                }
                rfalse;
];
! Request 34: phrase nothing -> nothing
! To lb:
[ PHR_1437_r34  ;
    ! [2: say line break]
    say__p=1;! [3: line break]
    ParaContent(); new_line; .L_Say618; .L_SayX611;rfalse;
];
! From "Basic Screen Effects" by Emily Short
! Request 35: phrase table name -> nothing
! To fill the/-- status bar/line with ( selected table - a table-name ):
[ PHR_906_r35  
    t_0 ! Call parameter 'selected table': table name
I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_78(t_0);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_78 
    t_0 ! Call parameter 'selected table': table name
    tmp_0 ! Let/loop value, e.g., '__n': number
    tmp_1 ! Let/loop value, e.g., '__index': number
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: let __n be the number of rows in the selected table]

    		tmp_0 = TableRows(t_0);
    ! [3: deepen status line to __n rows]
    DeepStatus(tmp_0);
    ! [4: let __index be 1]

    		tmp_1 = 1;
    ! [5: repeat through selected table]
    @push ct_0; @push ct_1;
    		for (tmp_2=t_0, tmp_3=1, ct_0=tmp_2, ct_1=tmp_3:
    			tmp_3<=TableRows(tmp_2):
    			tmp_3++, ct_0=tmp_2, ct_1=tmp_3)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [6: move cursor to __index]
        I7VM_MoveCursorInStatusLine(tmp_1);
        ! [7: if there is left entry]
        if (((ExistsTableLookUpEntry(ct_0,107,ct_1))))
        {! [8: say ~[left entry]~]
            say__p=1;! [9: left entry]
            ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,107,ct_1); .L_Say619; .L_SayX612;}
        ! [10: if there is central entry]
        if (((ExistsTableLookUpEntry(ct_0,108,ct_1))))
        {! [11: center central entry at row __index]
            CenterPrint(BlkValueCopy(I7SFRAME, TableLookUpEntry(ct_0,108,ct_1)), tmp_1);
            }
        ! [12: if there is right entry]
        if (((ExistsTableLookUpEntry(ct_0,109,ct_1))))
        {! [13: right align cursor to __index]
            RightAlign(tmp_1);
            ! [14: say ~[right entry]~]
            say__p=1;! [15: right entry]
            ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,109,ct_1); .L_Say620; .L_SayX613;}
        ! [16: increase __index by 1]
        tmp_1 = tmp_1 + 1;;
        }
        @pull ct_1; @pull ct_0;rfalse;
];
! Request 36: phrase nothing -> nothing
! To continue:
[ PHR_1444_r36  ;
    ! [2: say ~[bracket]continue[close bracket][paragraph break]~]
    say__p=1;! [3: bracket]
    ParaContent(); print "[";! [4: ~continue~]
    ParaContent(); print "continue";! [5: close bracket]
    ParaContent(); print "]";! [6: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say621; .L_SayX614;! [7: wait for any key]
    KeyPause();
    rfalse;
];
! From "Hyperspace" by Philip Riley
! Request 37: phrase nothing -> text
! To decide which text is the dirstring:
[ PHR_1252_r37  I7RBLK ;
    @push I7SFRAME;
    StackFrameCreate(28);
    BlkValueCreateOnStack(26, TEXT_TY);
    BlkValueCreateOnStack(24, TEXT_TY);
    BlkValueCreateOnStack(22, TEXT_TY);
    BlkValueCreateOnStack(20, TEXT_TY);
    BlkValueCreateOnStack(18, TEXT_TY);
    BlkValueCreateOnStack(16, TEXT_TY);
    BlkValueCreateOnStack(14, TEXT_TY);
    BlkValueCreateOnStack(12, TEXT_TY);
    BlkValueCreateOnStack(10, TEXT_TY);
    BlkValueCreateOnStack(8, TEXT_TY);
    BlkValueCreateOnStack(6, TEXT_TY);
    BlkValueCreateOnStack(4, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_79());
    BlkValueFreeOnStack(26);
    BlkValueFreeOnStack(24);
    BlkValueFreeOnStack(22);
    BlkValueFreeOnStack(20);
    BlkValueFreeOnStack(18);
    BlkValueFreeOnStack(16);
    BlkValueFreeOnStack(14);
    BlkValueFreeOnStack(12);
    BlkValueFreeOnStack(10);
    BlkValueFreeOnStack(8);
    BlkValueFreeOnStack(6);
    BlkValueFreeOnStack(4);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! text
];
[ KERNEL_79 
    tmp_0 ! Let/loop value, e.g., 'nsdiff': real number
    tmp_1 ! Let/loop value, e.g., 'wediff': real number
    tmp_2 ! Let/loop value, e.g., 'fbdiff': real number
    tmp_3 ! Let/loop value, e.g., 'nsdir': text
    tmp_4 ! Let/loop value, e.g., 'wedir': text
    tmp_5 ! Let/loop value, e.g., 'fbdir': text
    tmp_6 ! Let/loop value, e.g., 'nsdivwe': real number
    tmp_7 ! Let/loop value, e.g., 'nsdivfb': real number
    tmp_8 ! Let/loop value, e.g., 'wedivfb': real number
    tmp_9 ! Let/loop value, e.g., 'nsscore': real number
    tmp_10 ! Let/loop value, e.g., 'wescore': real number
    tmp_11 ! Let/loop value, e.g., 'fbscore': real number
    tmp_12 ! Let/loop value, e.g., 'dir': text
    tmp_13 ! Let/loop value, e.g., 'count': number
    tmp_14 ! Let/loop value (deallocated by end of phrase)
    ;
    ! [2: let nsdiff be entry 1 of coordinates of pillar minus entry 1 of hyperplane coords + 0.1]

    		tmp_0 = (REAL_NUMBER_TY_Plus(NUMBER_TY_to_REAL_NUMBER_TY((LIST_OF_TY_GetItem(BC_3076,1) - LIST_OF_TY_GetItem((Global_Vars-->45),1))), 1036831949));
    ! [3: let wediff be entry 2 of coordinates of pillar minus entry 2 of hyperplane coords + 0.1]

    		tmp_1 = (REAL_NUMBER_TY_Plus(NUMBER_TY_to_REAL_NUMBER_TY((LIST_OF_TY_GetItem(BC_3077,2) - LIST_OF_TY_GetItem((Global_Vars-->45),2))), 1036831949));
    ! [4: let fbdiff be entry 3 of coordinates of pillar minus entry 3 of hyperplane coords + 0.1]

    		tmp_2 = (REAL_NUMBER_TY_Plus(NUMBER_TY_to_REAL_NUMBER_TY((LIST_OF_TY_GetItem(BC_3078,3) - LIST_OF_TY_GetItem((Global_Vars-->45),3))), 1036831949));
    ! [5: let nsdir be ~~]
    tmp_3 = I7SFRAME; 
    		BlkValueCopy(tmp_3, EMPTY_TEXT_VALUE);
    ! [6: let wedir be ~~]
    tmp_4 = (I7SFRAME+WORDSIZE*2); 
    		BlkValueCopy(tmp_4, EMPTY_TEXT_VALUE);
    ! [7: let fbdir be ~~]
    tmp_5 = (I7SFRAME+WORDSIZE*4); 
    		BlkValueCopy(tmp_5, EMPTY_TEXT_VALUE);
    ! [8: if nsdiff >= 0]
    if (((REAL_NUMBER_TY_Compare(tmp_0, NUMBER_TY_to_REAL_NUMBER_TY(0)) >= 0)))
    {! [9: let nsdir be ~north~]
        BlkValueCopy(tmp_3, TX_L_43);
        } else {
        ! [10: let nsdir be ~south~]
        BlkValueCopy(tmp_3, TX_L_47);
        }
    ! [11: if wediff >= 0]
    if (((REAL_NUMBER_TY_Compare(tmp_1, NUMBER_TY_to_REAL_NUMBER_TY(0)) >= 0)))
    {! [12: let wedir be ~west~]
        BlkValueCopy(tmp_4, TX_L_51);
        } else {
        ! [13: let wedir be ~east~]
        BlkValueCopy(tmp_4, TX_L_50);
        }
    ! [14: if fbdiff >= 0]
    if (((REAL_NUMBER_TY_Compare(tmp_2, NUMBER_TY_to_REAL_NUMBER_TY(0)) >= 0)))
    {! [15: let fbdir be ~forth~]
        BlkValueCopy(tmp_5, TX_L_106);
        } else {
        ! [16: let fbdir be ~back~]
        BlkValueCopy(tmp_5, TX_L_104);
        }
    ! [17: let nsdivwe be nsdiff / wediff]

    		tmp_6 = (REAL_NUMBER_TY_Divide(tmp_0, tmp_1));
    ! [18: now nsdivwe is absolute value of nsdivwe]
    tmp_6 = REAL_NUMBER_TY_Abs(tmp_6);
    ! [19: let nsdivfb be nsdiff / fbdiff]

    		tmp_7 = (REAL_NUMBER_TY_Divide(tmp_0, tmp_2));
    ! [20: now nsdivfb is absolute value of nsdivfb]
    tmp_7 = REAL_NUMBER_TY_Abs(tmp_7);
    ! [21: let wedivfb be wediff / fbdiff]

    		tmp_8 = (REAL_NUMBER_TY_Divide(tmp_1, tmp_2));
    ! [22: now wedivfb is absolute value of wedivfb]
    tmp_8 = REAL_NUMBER_TY_Abs(tmp_8);
    ! [23: let nsscore be nsdivwe + nsdivfb]

    		tmp_9 = (REAL_NUMBER_TY_Plus(tmp_6, tmp_7));
    ! [24: let wescore be 1 / nsdivwe + wedivfb]

    		tmp_10 = (REAL_NUMBER_TY_Plus((REAL_NUMBER_TY_Divide(NUMBER_TY_to_REAL_NUMBER_TY(1), tmp_6)), tmp_8));
    ! [25: let fbscore be 1 / wedivfb + 1 / nsdivfb]

    		tmp_11 = (REAL_NUMBER_TY_Plus((REAL_NUMBER_TY_Divide(NUMBER_TY_to_REAL_NUMBER_TY(1), tmp_8)), (REAL_NUMBER_TY_Divide(NUMBER_TY_to_REAL_NUMBER_TY(1), tmp_7))));
    ! [26: let dir be ~~]
    tmp_12 = (I7SFRAME+WORDSIZE*6); 
    		BlkValueCopy(tmp_12, EMPTY_TEXT_VALUE);
    ! [27: let count be 1]

    		tmp_13 = 1;
    ! [28: if fbscore >= wescore and fbscore >= nsscore]
    if ((((REAL_NUMBER_TY_Compare(tmp_11, tmp_10) >= 0))) && (((REAL_NUMBER_TY_Compare(tmp_11, tmp_9) >= 0))))
    {! [29: now dir is fbdir]
        BlkValueCopy(tmp_12, tmp_5);
        ! [30: let x be 2 * nsscore]

        		tmp_14 = (REAL_NUMBER_TY_Times(NUMBER_TY_to_REAL_NUMBER_TY(2), tmp_9));
        ! [31: if fbscore < x]
        if (((REAL_NUMBER_TY_Compare(tmp_11, tmp_14) < 0)))
        {! [32: increment count]
            tmp_13 = tmp_13 + 1;;
            ! [33: now dir is ~[dir][nsdir]~]
            BlkValueCopy(tmp_12, ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=tmp_4),(LocalParking-->5=tmp_5),(LocalParking-->6=tmp_6),(LocalParking-->7=tmp_7),(LocalParking-->8=tmp_8),(LocalParking-->9=tmp_9),(LocalParking-->10=tmp_10),(LocalParking-->11=tmp_11),(LocalParking-->12=tmp_12),(LocalParking-->13=tmp_13),(LocalParking-->14=tmp_14),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*8),TX_S_580)));
            }
        ! [34: now x is 2 * wescore]
        tmp_14 = (REAL_NUMBER_TY_Times(NUMBER_TY_to_REAL_NUMBER_TY(2), tmp_10));
        ! [35: if fbscore < x and count < 2]
        if ((((REAL_NUMBER_TY_Compare(tmp_11, tmp_14) < 0))) && (((tmp_13 < 2))))
        {! [36: now dir is ~[dir][wedir]~]
            BlkValueCopy(tmp_12, ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=tmp_4),(LocalParking-->5=tmp_5),(LocalParking-->6=tmp_6),(LocalParking-->7=tmp_7),(LocalParking-->8=tmp_8),(LocalParking-->9=tmp_9),(LocalParking-->10=tmp_10),(LocalParking-->11=tmp_11),(LocalParking-->12=tmp_12),(LocalParking-->13=tmp_13),(LocalParking-->14=tmp_14),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*10),TX_S_581)));
            }
        ! [37: decide on dir]
        return BlkValueCopy((I7SFRAME+WORDSIZE*12), tmp_12);
        }
    ! [38: if nsscore >= wescore and nsscore >= fbscore]
    if ((((REAL_NUMBER_TY_Compare(tmp_9, tmp_10) >= 0))) && (((REAL_NUMBER_TY_Compare(tmp_9, tmp_11) >= 0))))
    {! [39: now dir is nsdir]
        BlkValueCopy(tmp_12, tmp_3);
        ! [40: if nsscore < 2 * wescore]
        if (((REAL_NUMBER_TY_Compare(tmp_9, (REAL_NUMBER_TY_Times(NUMBER_TY_to_REAL_NUMBER_TY(2), tmp_10))) < 0)))
        {! [41: increment count]
            tmp_13 = tmp_13 + 1;;
            ! [42: now dir is ~[dir][wedir]~]
            BlkValueCopy(tmp_12, ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=tmp_4),(LocalParking-->5=tmp_5),(LocalParking-->6=tmp_6),(LocalParking-->7=tmp_7),(LocalParking-->8=tmp_8),(LocalParking-->9=tmp_9),(LocalParking-->10=tmp_10),(LocalParking-->11=tmp_11),(LocalParking-->12=tmp_12),(LocalParking-->13=tmp_13),(LocalParking-->14=tmp_14),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*14),TX_S_582)));
            }
        ! [43: if nsscore < 2 * fbscore and count < 2]
        if ((((REAL_NUMBER_TY_Compare(tmp_9, (REAL_NUMBER_TY_Times(NUMBER_TY_to_REAL_NUMBER_TY(2), tmp_11))) < 0))) && (((tmp_13 < 2))))
        {! [44: now dir is ~[fbdir][dir]~]
            BlkValueCopy(tmp_12, ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=tmp_4),(LocalParking-->5=tmp_5),(LocalParking-->6=tmp_6),(LocalParking-->7=tmp_7),(LocalParking-->8=tmp_8),(LocalParking-->9=tmp_9),(LocalParking-->10=tmp_10),(LocalParking-->11=tmp_11),(LocalParking-->12=tmp_12),(LocalParking-->13=tmp_13),(LocalParking-->14=tmp_14),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*16),TX_S_583)));
            }
        ! [45: decide on dir]
        return BlkValueCopy((I7SFRAME+WORDSIZE*18), tmp_12);
        }
    ! [46: if wescore >= nsscore and wescore >= fbscore]
    if ((((REAL_NUMBER_TY_Compare(tmp_10, tmp_9) >= 0))) && (((REAL_NUMBER_TY_Compare(tmp_10, tmp_11) >= 0))))
    {! [47: now dir is wedir]
        BlkValueCopy(tmp_12, tmp_4);
        ! [48: let x be 2 * nsscore]

        		tmp_14 = (REAL_NUMBER_TY_Times(NUMBER_TY_to_REAL_NUMBER_TY(2), tmp_9));
        ! [49: if wescore < 2 * nsscore]
        if (((REAL_NUMBER_TY_Compare(tmp_10, (REAL_NUMBER_TY_Times(NUMBER_TY_to_REAL_NUMBER_TY(2), tmp_9))) < 0)))
        {! [50: increment count]
            tmp_13 = tmp_13 + 1;;
            ! [51: now dir is ~[nsdir][dir]~]
            BlkValueCopy(tmp_12, ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=tmp_4),(LocalParking-->5=tmp_5),(LocalParking-->6=tmp_6),(LocalParking-->7=tmp_7),(LocalParking-->8=tmp_8),(LocalParking-->9=tmp_9),(LocalParking-->10=tmp_10),(LocalParking-->11=tmp_11),(LocalParking-->12=tmp_12),(LocalParking-->13=tmp_13),(LocalParking-->14=tmp_14),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*20),TX_S_584)));
            }
        ! [52: if wescore < 2 * fbscore and count < 2]
        if ((((REAL_NUMBER_TY_Compare(tmp_10, (REAL_NUMBER_TY_Times(NUMBER_TY_to_REAL_NUMBER_TY(2), tmp_11))) < 0))) && (((tmp_13 < 2))))
        {! [53: now dir is ~[fbdir][dir]~]
            BlkValueCopy(tmp_12, ((LocalParking-->0=tmp_0),(LocalParking-->1=tmp_1),(LocalParking-->2=tmp_2),(LocalParking-->3=tmp_3),(LocalParking-->4=tmp_4),(LocalParking-->5=tmp_5),(LocalParking-->6=tmp_6),(LocalParking-->7=tmp_7),(LocalParking-->8=tmp_8),(LocalParking-->9=tmp_9),(LocalParking-->10=tmp_10),(LocalParking-->11=tmp_11),(LocalParking-->12=tmp_12),(LocalParking-->13=tmp_13),(LocalParking-->14=tmp_14),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*22),TX_S_585)));
            }
        ! [54: decide on dir]
        return BlkValueCopy((I7SFRAME+WORDSIZE*24), tmp_12);
        }
    ! [55: decide on dir]
    return BlkValueCopy((I7SFRAME+WORDSIZE*26), tmp_12);
    return BC_3079;
];
! From "Hyperspace" by Philip Riley
! Request 38: phrase nothing -> real number
! To decide which real number is the distance:
[ PHR_1256_r38  
    tmp_0 ! Let/loop value, e.g., 'nsdiff': real number
    tmp_1 ! Let/loop value, e.g., 'wediff': real number
    tmp_2 ! Let/loop value, e.g., 'fbdiff': real number
    tmp_3 ! Let/loop value, e.g., 'dsq': real number
    ;
    ! [2: let nsdiff be entry 1 of coordinates of pillar minus entry 1 of hyperplane coords + 0.1]

    		tmp_0 = (REAL_NUMBER_TY_Plus(NUMBER_TY_to_REAL_NUMBER_TY((LIST_OF_TY_GetItem(BC_3080,1) - LIST_OF_TY_GetItem((Global_Vars-->45),1))), 1036831949));
    ! [3: let wediff be entry 2 of coordinates of pillar minus entry 2 of hyperplane coords + 0.1]

    		tmp_1 = (REAL_NUMBER_TY_Plus(NUMBER_TY_to_REAL_NUMBER_TY((LIST_OF_TY_GetItem(BC_3081,2) - LIST_OF_TY_GetItem((Global_Vars-->45),2))), 1036831949));
    ! [4: let fbdiff be entry 3 of coordinates of pillar minus entry 3 of hyperplane coords + 0.1]

    		tmp_2 = (REAL_NUMBER_TY_Plus(NUMBER_TY_to_REAL_NUMBER_TY((LIST_OF_TY_GetItem(BC_3082,3) - LIST_OF_TY_GetItem((Global_Vars-->45),3))), 1036831949));
    ! [5: now nsdiff is the absolute value of nsdiff]
    tmp_0 = REAL_NUMBER_TY_Abs(tmp_0);
    ! [6: now wediff is the absolute value of wediff]
    tmp_1 = REAL_NUMBER_TY_Abs(tmp_1);
    ! [7: now fbdiff is the absolute value of fbdiff]
    tmp_2 = REAL_NUMBER_TY_Abs(tmp_2);
    ! [8: let dsq be ( nsdiff * nsdiff ) + ( wediff * wediff ) + ( fbdiff * fbdiff )]

    		tmp_3 = (REAL_NUMBER_TY_Plus((REAL_NUMBER_TY_Times(tmp_0, tmp_0)), (REAL_NUMBER_TY_Plus((REAL_NUMBER_TY_Times(tmp_1, tmp_1)), (REAL_NUMBER_TY_Times(tmp_2, tmp_2))))));
    ! [9: decide on the real square root of dsq]
    return REAL_NUMBER_TY_Root(tmp_3);
    return 0;
];
! From "Gender Options" by Nathanael Nerode
! Request 39: phrase nothing -> nothing
! To say Those:
[ PHR_772_r39  ;
    ! [2: say those in the nominative]
    say__p=1;! [3: those in the nominative]
    ParaContent(); (PHR_774_r93 (I125_nominative)); .L_Say622; .L_SayX615;rfalse;
];
! From the Standard Rules
! Request 40: phrase response -> nothing
! To say text of ( R - response ) ( documented at phs_response ):
[ PHR_380_r40  
    t_0 ! Call parameter 'R': response
    ;
    ! [2: carry out the issuing the response text activity with r]
    CarryOutActivity(V33_issuing_the_response_tex, t_0);
    rfalse;
];
! From "Essentials" by Philip Riley
! Request 41: phrase (person, text) -> nothing
! To print to ( P - a person ) that ( T - a text ):
[ PHR_963_r41  
    t_0 ! Call parameter 'P': person
    t_1 ! Call parameter 'T': text
    ;
    ! [2: if p is the player]
    if (((t_0 == player)))
    {! [3: say t]
        say__p=1;! [4: t]
        ParaContent(); print (TEXT_TY_Say) t_1; .L_Say623; .L_SayX616;}
        rfalse;
];
! From the Standard Rules
! Request 42: phrase object -> nothing
! To describe locale for ( O - object ):
[ PHR_79_r42  
    t_0 ! Call parameter 'O': object
    ;
    ! [2: carry out the printing the locale description activity with o]
    CarryOutActivity(V30_printing_the_locale_desc, t_0);
    rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 43: phrase nothing -> nothing
! To say They:
[ PHR_776_r43  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_80();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_80 
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~They~]
        say__p=1;! [5: ~They~]
        ParaContent(); print "They"; .L_Say624; .L_SayX617;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[We]~]
            say__p=1;! [8: we]
            ParaContent(); (PHR_764_r7 ()); .L_Say625; .L_SayX618;} else {
            ! [9: if printing gender for the item is]
            switch ((PHR_1436_r206 (tmp_0))) 
            {I66_masculine_gender:
                ! [10: say ~He~]
                say__p=1;! [11: ~He~]
                ParaContent(); print "He"; .L_Say626; .L_SayX619;;
                I67_feminine_gender:
                ! [12: say ~She~]
                say__p=1;! [13: ~She~]
                ParaContent(); print "She"; .L_Say627; .L_SayX620;;
                I65_neuter_gender:
                ! [14: say ~It~]
                say__p=1;! [15: ~It~]
                ParaContent(); print "It"; .L_Say628; .L_SayX621;;
                I68_neitherine_gender:
                ! [16: say ~[entry 1 in the declensions of the third singular pronoun of the item in title case]~]
                say__p=1;! [17: entry 1 in the declensions of the third singular pronoun of the item in title case]
                ParaContent(); print (TEXT_TY_Say) TEXT_TY_CharactersToCase(I7SFRAME, LIST_OF_TY_GetItem(GProperty(10, GProperty(OBJECT_TY, tmp_0,third_singular_pronoun),p41_declensions),1), 2); .L_Say629; .L_SayX622;}
                }
                }
                rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! Request 44: phrase door -> room
! To decide which room is the backside of ( D - a door ):
[ PHR_1345_r44  
    t_0 ! Call parameter 'D': door
    ;
    ! [2: decide on the other side of d from the frontside of d]
    return CheckKindReturned(OtherSideOfDoor(t_0,GProperty(10, t_0,p30_frontside)), K1_room);
    return I154_room_of_subjects;
];
! From "Two-Sided Doors" by Philip Riley
! Request 45: phrase (two-sided door, thing) -> truth state
! To decide whether ( D - a two-sided door ) is locked for ( actor - a thing ):
[ PHR_1347_r45  
    t_0 ! Call parameter 'D': two-sided door
    t_1 ! Call parameter 'actor': thing
    ;
    ! [2: decide on whether or not ( the location of the actor is the frontside of d and d is front-locked ) or ( the location of the actor is the backside of d and d is back-locked )]
    return ((((((LocationOf(t_1) == GProperty(10, t_0,p30_frontside)))) && ((((Adj_160_t1_v10(t_0)))))) || ((((LocationOf(t_1) == (PHR_1345_r44 (t_0))))) && ((((Adj_161_t1_v10(t_0))))))));
    return false;
];
! From "Two-Sided Doors" by Philip Riley
! Request 46: phrase two-sided door -> text
! To decide what text is can't unlock without a lock description for ( TSD - a two-sided door ):
[ PHR_1357_r46  I7RBLK 
    t_0 ! Call parameter 'TSD': two-sided door
;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_81(t_0));
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! text
];
[ KERNEL_81 
    t_0 ! Call parameter 'TSD': two-sided door
    ;
    ! [2: decide on the text produced by the can't unlock without a lock description rules for tsd]
    return BlkValueCopy(I7SFRAME, ResultOfRule(RULEBOOK_TY_to_RULE_TY(550), t_0, true, TEXT_TY));
    return BC_3083;
];
! From "Two-Sided Doors" by Philip Riley
! Request 47: phrase two-sided door -> text
! To decide what text is can't unlock already unlocked description for ( TSD - a two-sided door ):
[ PHR_1359_r47  I7RBLK 
    t_0 ! Call parameter 'TSD': two-sided door
;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_82(t_0));
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! text
];
[ KERNEL_82 
    t_0 ! Call parameter 'TSD': two-sided door
    ;
    ! [2: decide on the text produced by the can't unlock already unlocked description rules for tsd]
    return BlkValueCopy(I7SFRAME, ResultOfRule(RULEBOOK_TY_to_RULE_TY(551), t_0, true, TEXT_TY));
    return BC_3084;
];
! From "Two-Sided Doors" by Philip Riley
! Request 48: phrase (door, thing) -> side
! To decide what side is the closest side of ( D - a door ) to ( actor - a thing ):
[ PHR_1348_r48  
    t_0 ! Call parameter 'D': door
    t_1 ! Call parameter 'actor': thing
    ;
    ! [2: if location of the actor is backside of d]
    if (((LocationOf(t_1) == (PHR_1345_r44 (t_0)))))
    {! [3: decide on xback]
        return I287_xback;
        }
    ! [4: decide on front]
    return I286_front;
    return I286_front;
];
! From "Gender Options" by Nathanael Nerode
! Request 49: phrase nothing -> nothing
! To say us:
[ PHR_760_r49  ;
    ! [2: if the last person referenced is not the player]
    if (((~~(((Global_Vars-->10) == player)))))
    {! [3: say ~[player]~]
        say__p=1;! [4: player]
        ParaContent(); PrintShortName(player); .L_Say630; .L_SayX623;} else {
        ! [5: now the prior named object is the player]
        prior_named_noun = player;
        ! [6: if the story viewpoint is]
        switch (story_viewpoint) 
        {I118_first_person_singular:
            ! [7: say ~me~]
            say__p=1;! [8: ~me~]
            ParaContent(); print "me"; .L_Say631; .L_SayX624;;
            I119_second_person_singular:
            ! [9: say ~you~]
            say__p=1;! [10: ~you~]
            ParaContent(); print "you"; .L_Say632; .L_SayX625;;
            I120_third_person_singular:
            ! [11: if printing gender for the player is]
            switch ((PHR_1436_r206 (player))) 
            {I66_masculine_gender:
                ! [12: say ~him~]
                say__p=1;! [13: ~him~]
                ParaContent(); print "him"; .L_Say633; .L_SayX626;;
                I67_feminine_gender:
                ! [14: say ~her~]
                say__p=1;! [15: ~her~]
                ParaContent(); print "her"; .L_Say634; .L_SayX627;;
                I65_neuter_gender:
                ! [16: say ~it~]
                say__p=1;! [17: ~it~]
                ParaContent(); print "it"; .L_Say635; .L_SayX628;;
                I68_neitherine_gender:
                ! [18: say entry 2 in the declensions of the third singular pronoun of the player]
                say__p=1;! [19: entry 2 in the declensions of the third singular pronoun of the player]
                ParaContent(); print (TEXT_TY_Say) LIST_OF_TY_GetItem(GProperty(10, GProperty(10, player,third_singular_pronoun),p41_declensions),2); .L_Say636; .L_SayX629;}
                ;
                I121_first_person_plural:
            ! [20: say ~us~]
            say__p=1;! [21: ~us~]
            ParaContent(); print "us"; .L_Say637; .L_SayX630;;
            I122_second_person_plural:
            ! [22: say ~you~]
            say__p=1;! [23: ~you~]
            ParaContent(); print "you"; .L_Say638; .L_SayX631;;
            I123_third_person_plural:
            ! [24: say ~them~]
            say__p=1;! [25: ~them~]
            ParaContent(); print "them"; .L_Say639; .L_SayX632;}
            }
            rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 50: phrase nothing -> nothing
! To say There's:
[ PHR_792_r50  ;
    ! [2: say ~[regarding nothing]There['re]~]
    say__p=1;! [3: regarding nothing]
    ParaContent(); RegardingSingleObject(nothing);! [4: ~There~]
    ParaContent(); print "There";! [5: 're]
    ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say640; .L_SayX633;rfalse;
];
! From the Standard Rules
! Request 51: phrase nothing -> nothing
! To say here ( documented at phs_here ):
[ PHR_517_r51  ;
    ! [2: say ~[if story tense is present tense]here[otherwise]there~]
    say__p=1;! [3: if story tense is present tense]

    	if (~~((((story_tense == I112_present_tense))))) jump L_Say641;! [4: ~here~]
    ParaContent(); print "here";! [5: otherwise]

    	jump L_SayX634; .L_Say641;! [6: ~there~]
    ParaContent(); print "there"; .L_Say642; .L_SayX634;rfalse;
];
! From "Conversation Responses" by Eric Eve
! Request 52: phrase object -> truth state
! To decide whether asked about ( obj - an object ):
[ PHR_849_r52  
    t_0 ! Call parameter 'obj': object
    ;
    ! [2: if quizzing someone about something]
    if ((((action ==##A66_quizzing_it_about) &&  (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing)))))
    {! [3: decide on whether or not the obj is the second noun]
        return ((((t_0 == second))));
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Formatting Capture" by Daniel Stelzer
! Request 53: phrase nothing -> nothing
! To say fixed letter spacing -- running on ( documented at phs_fixedspacing ):
[ PHR_355_r53  ;
    ! [2: if text capturing is active]
    if (((capture_active > 0)))
    {! [3: say ~[escape code]f~]
        say__p=1;! [4: escape code]
        ParaContent(); print (char) ESCAPE_CODE;! [5: ~f~]
        ParaContent(); print "f"; .L_Say643; .L_SayX635;} else {
        ! [6: say internal fixed letter spacing]
        say__p=1;! [7: internal fixed letter spacing]
        ParaContent(); font off; .L_Say644; .L_SayX636;}
        rfalse;
];
! From "Formatting Capture" by Daniel Stelzer
! Request 54: phrase nothing -> nothing
! To say variable letter spacing -- running on ( documented at phs_varspacing ):
[ PHR_356_r54  ;
    ! [2: if text capturing is active]
    if (((capture_active > 0)))
    {! [3: say ~[escape code]v~]
        say__p=1;! [4: escape code]
        ParaContent(); print (char) ESCAPE_CODE;! [5: ~v~]
        ParaContent(); print "v"; .L_Say645; .L_SayX637;} else {
        ! [6: say internal variable letter spacing]
        say__p=1;! [7: internal variable letter spacing]
        ParaContent(); font on; .L_Say646; .L_SayX638;}
        rfalse;
];
! From "Hearing" by Philip Riley
! Request 55: phrase person -> nothing
! To say generic description of ( P - a person ):
[ PHR_988_r55  
    t_0 ! Call parameter 'P': person
    ;
    ! [2: say ~Someone~]
    say__p=1;! [3: ~Someone~]
    ParaContent(); print "Someone"; .L_Say647; .L_SayX639;rfalse;
];
! From "Phones" by Philip Riley
! Request 56: phrase phone -> nothing
! To say generic description of ( T - a phone ):
[ PHR_999_r56  
    t_0 ! Call parameter 'T': phone
    ;
    ! [2: say ~A phone~]
    say__p=1;! [3: ~A phone~]
    ParaContent(); print "A phone"; .L_Say648; .L_SayX640;rfalse;
];
! From "Hearing" by Philip Riley
! Request 57: phrase thing -> nothing
! To say generic description of ( T - a thing ):
[ PHR_987_r57  
    t_0 ! Call parameter 'T': thing
    ;
    ! [2: say ~Something~]
    say__p=1;! [3: ~Something~]
    ParaContent(); print "Something"; .L_Say649; .L_SayX641;rfalse;
];
! From "Hearing" by Philip Riley
! Request 58: phrase thing -> nothing
! To say sound of ( T - a thing ):
[ PHR_989_r58  
    t_0 ! Call parameter 'T': thing
    ;
    ! [2: carry out the printing the sound action activity with t]
    CarryOutActivity(V39_printing_the_sound_actio, t_0);
    rfalse;
];
! From "Essentials" by Philip Riley
! Request 59: phrase (person, text) -> nothing
! To print near ( P - a person ) that ( T - a text ):
[ PHR_964_r59  
    t_0 ! Call parameter 'P': person
    t_1 ! Call parameter 'T': text
    ;
    ! [2: if p is colocated with the player]
    if (((PHR_957_r60 (t_0,player))))
    {! [3: say t]
        say__p=1;! [4: t]
        ParaContent(); print (TEXT_TY_Say) t_1; .L_Say650; .L_SayX642;}
        rfalse;
];
! From "Essentials" by Philip Riley
! Request 60: phrase (thing, thing) -> truth state
! To decide whether ( t1 - a thing ) is colocated with ( t2 - a thing ):
[ PHR_957_r60  
    t_0 ! Call parameter 't1': thing
    t_1 ! Call parameter 't2': thing
    ;
    ! [2: if the location of t1 is the location of t2]
    if (((LocationOf(t_0) == LocationOf(t_1))))
    {! [3: decide yes]
        rtrue;
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Essentials" by Philip Riley
! Request 61: phrase (person, text, person) -> nothing
! To print to ( P - a person ) that ( T - a text ) as ( speaker - a person ):
[ PHR_965_r61  
    t_0 ! Call parameter 'P': person
    t_1 ! Call parameter 'T': text
    t_2 ! Call parameter 'speaker': person
I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_83(t_0, t_1, t_2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_83 
    t_0 ! Call parameter 'P': person
    t_1 ! Call parameter 'T': text
    t_2 ! Call parameter 'speaker': person
    ;
    ! [2: print to p that t]
    (PHR_963_r41 (t_0,BlkValueCopy(I7SFRAME, t_1)));
    ! [3: if p is not player]
    if (((~~((t_0 == player)))))
    {! [4: say t]
        say__p=1;! [5: t]
        ParaContent(); print (TEXT_TY_Say) t_1; .L_Say651; .L_SayX643;}
        rfalse;
];
! From "Real People" by Philip Riley
! Request 62: phrase person -> behavior
! To decide which behavior is the current behavior of ( P - a person ):
[ PHR_1053_r62  
    t_0 ! Call parameter 'P': person
    ;
    ! [2: if the behavior stack of p is empty]
    if ((((Adj_17_t1_v34(GProperty(10, t_0,p22_behavior_stack))))))
    {! [3: decide on doing nothing]
        return I190_doing_nothing;
        }
    ! [4: decide on entry 1 of the behavior stack of p]
    return LIST_OF_TY_GetItem(GProperty(10, t_0,p22_behavior_stack),1);
    return I190_doing_nothing;
];
! From "Real People" by Philip Riley
! Request 63: phrase person -> nothing
! To remove behavior from ( P - a person ):
[ PHR_1051_r63  
    t_0 ! Call parameter 'P': person
    ;
    ! [2: follow the termination rules for p]
    FollowRulebook(450, t_0, true);
    ! [3: remove entry 1 from behavior stack of p]
    LIST_OF_TY_RemoveItemRange(GProperty(10, t_0,p22_behavior_stack), 1, 1, 0);
    rfalse;
];
! From "Real People" by Philip Riley
! Request 64: phrase person -> nothing
! To clear behavior of ( P - a person ):
[ PHR_1049_r64  
    t_0 ! Call parameter 'P': person
    ;
    ! [2: now the behavior stack of p is { doing nothing }]
    BlkValueCopy(GProperty(10, t_0,p22_behavior_stack), BC_3085);
    rfalse;
];
! From "Exit Lister" by Eric Eve
! Request 65: phrase nothing -> nothing
! To list the exits:
[ PHR_1151_r65  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_84();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_84 
    tmp_0 ! Let/loop value, e.g., 'exits count': number
    tmp_1 ! Let/loop value, e.g., 'farplace': object
    tmp_2 ! Let/loop value, e.g., 'i': number
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    tmp_4 ! Let/loop value (deallocated by end of phrase)
    ;
    ! [2: let exits count be 0]

    		tmp_0 = 0;
    ! [3: let farplace be location]

    		tmp_1 = real_location;
    ! [4: repeat with way running through directions]
    for (tmp_2=Prop_113(0), tmp_3=Prop_113(tmp_2): tmp_2: tmp_2=tmp_3, tmp_3=Prop_113(tmp_3))
    {! [5: let farplace be the room way from the location]
        tmp_1 = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par1 ofclass K1_room) && (formal_par1 ofclass K1_room))))) && ((
                        formal_rv = MapConnection(formal_par1,formal_par0)) | 1)
                        )|| (ArgumentTypeFailed(176, 43))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = real_location) +
                    (formal_par0 = tmp_2)
                    ))
            )

        ! Resolution complete
        ;
        ! [6: now direction-object is the room-or-door way from the location]
        (Global_Vars-->35) = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par1 ofclass K1_room) && (formal_par1 ofclass K1_room))))) && ((
                        formal_rv = RoomOrDoorFrom(formal_par1,formal_par0)) | 1)
                        )|| (ArgumentTypeFailed(177, 43))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = real_location) +
                    (formal_par0 = tmp_2)
                    ))
            )

        ! Resolution complete
        ;
        ! [7: if the direction-object is apparent and farplace is not darkness-occluded]
        if (((((Adj_58_t1_v10((Global_Vars-->35)))))) && (((~~(((Adj_60_t1_v10(tmp_1))))))))
        {! [8: increase exits count by 1]
            tmp_0 = tmp_0 + 1;;
            }
            }
    ! [9: if exits count is 0]
    if (((tmp_0 == 0)))
    {! [10: say ~[no-obvious-exits]~]
        say__p=1;! [11: no-obvious-exits]
        ParaContent(); (PHR_1153_r176 ()); .L_Say652; .L_SayX644;! [12: rule fails]
        RulebookFails(); rtrue;
        }
    ! [13: let i be exits count]

    		tmp_2 = tmp_0;
    ! [14: if exits count is 1]
    if (((tmp_0 == 1)))
    {! [15: say ~[only-obvious-exit] ~]
        say__p=1;! [16: only-obvious-exit]
        ParaContent(); (PHR_1154_r177 ());! [17: ~ ~]
        ParaContent(); print " "; .L_Say653; .L_SayX645;} else {
        ! [18: say ~[obvious-exits] ~]
        say__p=1;! [19: obvious-exits]
        ParaContent(); (PHR_1155_r178 ());! [20: ~ ~]
        ParaContent(); print " "; .L_Say654; .L_SayX646;}
    ! [21: repeat with way running through directions]
    for (tmp_3=Prop_114(0), tmp_4=Prop_114(tmp_3): tmp_3: tmp_3=tmp_4, tmp_4=Prop_114(tmp_4))
    {! [22: let farplace be the room way from the location]
        tmp_1 = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par1 ofclass K1_room) && (formal_par1 ofclass K1_room))))) && ((
                        formal_rv = MapConnection(formal_par1,formal_par0)) | 1)
                        )|| (ArgumentTypeFailed(190, 43))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = real_location) +
                    (formal_par0 = tmp_3)
                    ))
            )

        ! Resolution complete
        ;
        ! [23: now direction-object is the room-or-door way from the location]
        (Global_Vars-->35) = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par1 ofclass K1_room) && (formal_par1 ofclass K1_room))))) && ((
                        formal_rv = RoomOrDoorFrom(formal_par1,formal_par0)) | 1)
                        )|| (ArgumentTypeFailed(191, 43))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = real_location) +
                    (formal_par0 = tmp_3)
                    ))
            )

        ! Resolution complete
        ;
        ! [24: if direction-object is apparent and farplace is not darkness-occluded]
        if (((((Adj_58_t1_v10((Global_Vars-->35)))))) && (((~~(((Adj_60_t1_v10(tmp_1))))))))
        {! [25: say ~[way]~]
            say__p=1;! [26: way]
            ParaContent(); PrintShortName(tmp_3); .L_Say655; .L_SayX647;! [27: if farplace is visited]
            if ((((Adj_80_t1_v10(tmp_1)))))
            {! [28: say ~ ([to-preposition] [destname farplace])~]
                say__p=1;! [29: ~ (~]
                ParaContent(); print " (";! [30: to-preposition]
                ParaContent(); (PHR_1157_r29 ());! [31: ~ ~]
                ParaContent(); print " ";! [32: destname farplace]
                ParaContent(); 
                ! Resolution of run-time phrase ambiguity (to phrase):
                    formal_par0 = tmp_1;
                    if (((((formal_par0 ofclass K1_room) && (formal_par0 ofclass K1_room))))) { (PHR_1159_r30 (formal_par0)); }
                    else ArgumentTypeFailed(1);

                ! Resolution complete
                ! [33: ~)~]
                ParaContent(); print ")"; .L_Say656; .L_SayX648;}
            ! [34: decrease i by 1]
            tmp_2 = tmp_2 - 1;;
            ! [35: if i is 0]
            if (((tmp_2 == 0)))
            {! [36: say ~.~]
                say__p=1;! [37: ~.~]
                ParaContent(); print "."; new_line; .L_Say657; .L_SayX649;}
            ! [38: if i is 1]
            if (((tmp_2 == 1)))
            {! [39: say ~ [and-conjunction] ~]
                say__p=1;! [40: ~ ~]
                ParaContent(); print " ";! [41: and-conjunction]
                ParaContent(); (PHR_1156_r179 ());! [42: ~ ~]
                ParaContent(); print " "; .L_Say658; .L_SayX650;}
            ! [43: if i > 1]
            if (((tmp_2 > 1)))
            {! [44: say ~, ~]
                say__p=1;! [45: ~, ~]
                ParaContent(); print ", "; .L_Say659; .L_SayX651;}
                }
                }
                rfalse;
];
! From "Choices" by Philip Riley
! Request 66: phrase nothing -> list of objects
! To decide what list of objects is the total choices:
[ PHR_1175_r66  I7RBLK ;
    @push I7SFRAME;
    StackFrameCreate(8);
    BlkValueCreateOnStack(7, KD11_list_of_objects);
    BlkValueCreateOnStack(6, KD11_list_of_objects);
    BlkValueCreateOnStack(5, KD11_list_of_objects);
    BlkValueCreateOnStack(4, KD12_list_of_choices);
    BlkValueCreateOnStack(3, KD12_list_of_choices);
    BlkValueCreateOnStack(2, KD12_list_of_choices);
    BlkValueCreateOnStack(1, KD12_list_of_choices);
    BlkValueCreateOnStack(0, KD11_list_of_objects);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_85());
    BlkValueFreeOnStack(7);
    BlkValueFreeOnStack(6);
    BlkValueFreeOnStack(5);
    BlkValueFreeOnStack(4);
    BlkValueFreeOnStack(3);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(1);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! list of objects
];
[ KERNEL_85 
    tmp_0 ! Let/loop value, e.g., 'Q': list of objects
    tmp_1 ! Let/loop value, e.g., 'X': list of choices
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    tmp_4 ! Let/loop value (deallocated by end of phrase)
    ;
    ! [2: let q be a list of objects]
    tmp_0 = I7SFRAME; 
    		
    ! [3: let x be the list of available choices]
    tmp_1 = (I7SFRAME+WORDSIZE); 
    		BlkValueCopy(tmp_1, (Prop_115((I7SFRAME+WORDSIZE*2),10)));
    ! [4: add x to q]
    LIST_OF_TY_AppendList(tmp_0, tmp_1, 0, 0, 0);
    ! [5: repeat with t running through the things in the location]
    for (tmp_2=Prop_116(0), tmp_3=Prop_116(tmp_2): tmp_2: tmp_2=tmp_3, tmp_3=Prop_116(tmp_3))
    {! [6: let demos be the list of things that demonstrate t]
        tmp_4 = (I7SFRAME+WORDSIZE*3); 
        		BlkValueCopy(tmp_4, (Prop_117(tmp_2,(I7SFRAME+WORDSIZE*4),10)));
        ! [7: add demos to q]
        LIST_OF_TY_AppendList(tmp_0, tmp_4, 0, 0, 0);
        }
    ! [8: now q is filter to unexhausted choices of q]
    BlkValueCopy(tmp_0, (PHR_571_r217 ((I7SFRAME+WORDSIZE*5),Prop_118,BlkValueCopy((I7SFRAME+WORDSIZE*6), tmp_0))));
    ! [9: decide on q]
    return BlkValueCopy((I7SFRAME+WORDSIZE*7), tmp_0);
    return BC_3086;
];
! From "Simple Conversation" by Philip Riley
! Request 67: phrase list of objects -> nothing
! To prepare a/the/-- list of ( selection - list of objects ):
[ PHR_1228_r67  
    t_0 ! Call parameter 'selection': list of objects
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value: number
    ;
    ! [2: now every thing is unmarked for special listing]
    Prop_119();
    ! [3: now every direction is unmarked for special listing]
    Prop_120();
    ! [4: now every room is unmarked for special listing]
    Prop_121();
    ! [5: now every region is unmarked for special listing]
    Prop_122();
    ! [6: repeat with item running through selection]
    for (tmp_2=t_0, tmp_1=1, tmp_0=LIST_OF_TY_GetItem(tmp_2, tmp_1, true): tmp_1<=LIST_OF_TY_GetLength(tmp_2): tmp_1++, tmp_0=LIST_OF_TY_GetItem(tmp_2, tmp_1, true))
    {! [7: now the item is marked for special listing]
        (Adj_145_t2_v10(tmp_0));
        }
    ! [8: register things marked for listing]
    (PHR_1114_r154 ());
    rfalse;
];
! From "Complex Listing" by Emily Short
! Request 68: phrase list style -> nothing
! To say the prepared list delimited in ( chosen style - a list style ) style:
[ PHR_1124_r68  
    t_0 ! Call parameter 'chosen style': list style
    ;
    ! [2: now current articulation style is definite]
    (Global_Vars-->22) = I197_definite;
    ! [3: now current list style is the chosen style]
    (Global_Vars-->26) = t_0;
    ! [4: say prepared list]
    say__p=1;! [5: prepared list]
    ParaContent(); (PHR_1121_r161 ()); .L_Say660; .L_SayX652;rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 69: phrase nothing -> nothing
! To say them:
[ PHR_779_r69  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~them~]
        say__p=1;! [5: ~them~]
        ParaContent(); print "them"; .L_Say661; .L_SayX653;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[us]~]
            say__p=1;! [8: us]
            ParaContent(); (PHR_760_r49 ()); .L_Say662; .L_SayX654;} else {
            ! [9: if printing gender for the item is]
            switch ((PHR_1436_r206 (tmp_0))) 
            {I66_masculine_gender:
                ! [10: say ~him~]
                say__p=1;! [11: ~him~]
                ParaContent(); print "him"; .L_Say663; .L_SayX655;;
                I67_feminine_gender:
                ! [12: say ~her~]
                say__p=1;! [13: ~her~]
                ParaContent(); print "her"; .L_Say664; .L_SayX656;;
                I65_neuter_gender:
                ! [14: say ~it~]
                say__p=1;! [15: ~it~]
                ParaContent(); print "it"; .L_Say665; .L_SayX657;;
                I68_neitherine_gender:
                ! [16: say entry 2 in the declensions of the third singular pronoun of the item]
                say__p=1;! [17: entry 2 in the declensions of the third singular pronoun of the item]
                ParaContent(); print (TEXT_TY_Say) LIST_OF_TY_GetItem(GProperty(10, GProperty(OBJECT_TY, tmp_0,third_singular_pronoun),p41_declensions),2); .L_Say666; .L_SayX658;}
                }
                }
                rfalse;
];
! From "Glulx Entry Points" by Emily Short
! Request 70: phrase nothing -> number
! To decide what number is the glulx input handling rules for an arrange event:
[ PHR_1303_r70  
    tmp_0 ! Let/loop value, e.g., 'final return value': number
    ;
    ! [2: let final return value be a number]

    		tmp_0 = 0; 
    ! [3: now arranging now in gep is true]
    (Global_Vars-->55) = 1;
    ! [4: now final return value is the value returned by glk event handling]
    tmp_0 = (PHR_1291_r0 ());
    ! [5: now arranging now in gep is false]
    (Global_Vars-->55) = 0;
    ! [6: decide on final return value]
    return tmp_0;
    return 0;
];
! Request 71: phrase nothing -> figure name
! To decide which figure name is the picture of the location:
[ PHR_1507_r71  
    tmp_0 ! Let/loop value, e.g., 'result': figure name
    ;
    ! [2: let result be figure null]

    		tmp_0 = I500_figure_null;
    ! [3: if location is parking lot south or location is parking lot north]
    if ((((real_location == I294_strip_mall_parking_lot_))) || (((real_location == I312_strip_mall_parking_lot_))))
    {! [4: now result is figure parking lot]
        tmp_0 = I514_figure_parking_lot;
        }
    ! [5: if location is dave's pawn shop]
    if (((real_location == I309_dave_s_pawn_shop)))
    {! [6: now result is figure pawn shop]
        tmp_0 = I515_figure_pawn_shop;
        }
    ! [7: if location is in bosh hq]
    if (((TestRegionalContainment(real_location,I428_bosh_hq))))
    {! [8: now result is figure bosh]
        tmp_0 = I516_figure_bosh;
        }
    ! [9: if location is li'l nectarine convenience store]
    if (((real_location == I340_li_l_nectarine_convenie)))
    {! [10: now result is figure store]
        tmp_0 = I517_figure_store;
        }
    ! [11: if location is in laundromat-region]
    if (((TestRegionalContainment(real_location,I327_laundromat_region))))
    {! [12: now result is figure laundromat]
        tmp_0 = I518_figure_laundromat;
        }
    ! [13: if location is astral-tunnel-1 or location is astral-tunnel-2 or location is astral-tunnel-3]
    if ((((real_location == I324_astral_tunnel_1))) || ((((real_location == I326_astral_tunnel_2))) || (((real_location == I339_astral_tunnel_3)))))
    {! [14: now result is figure white tunnel]
        tmp_0 = I519_figure_white_tunnel;
        }
    ! [15: if location is featureless hyperplane]
    if (((real_location == I244_featureless_hyperplane)))
    {! [16: now result is figure hyperspace]
        tmp_0 = I521_figure_hyperspace;
        }
    ! [17: if location is in elr]
    if (((TestRegionalContainment(real_location,I369_elr))))
    {! [18: now result is figure enigma lake]
        tmp_0 = I522_figure_enigma_lake;
        }
    ! [19: if location is enigma park]
    if (((real_location == I371_enigma_park)))
    {! [20: now result is figure enigma park]
        tmp_0 = I523_figure_enigma_park;
        }
    ! [21: if location is lake shore north of the park or location is lake shore west]
    if ((((real_location == I381_lake_shore_north_of_the))) || (((real_location == I382_lake_shore_west))))
    {! [22: now result is figure engima shore]
        tmp_0 = I524_figure_engima_shore;
        }
    ! [23: if location is in field office area]
    if (((TestRegionalContainment(real_location,I247_field_office_area))))
    {! [24: now result is figure field office]
        tmp_0 = I525_figure_field_office;
        }
    ! [25: decide on result]
    return tmp_0;
    return I83_figure_of_cover;
];
! From "Hyperspace" by Philip Riley
! Request 72: phrase nothing -> truth state
! To decide if could see hypertunnels:
[ PHR_1242_r72  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_86();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! truth state
];
[ KERNEL_86 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    ! [2: if the location is not in hyperspace]
    if (((~~((TestRegionalContainment(real_location,I232_hyperspace))))))
    {! [3: repeat with d running through hyperspatial directions]
        for (tmp_0=Prop_123(0), tmp_1=Prop_123(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_123(tmp_1))
        {! [4: if the room d from the location is somewhere]
            if (((LocationOf(
            ! Resolution of run-time phrase ambiguity (deciding a value):
                (
                    ! This value evaluates third (i.e., last)
                    formal_rv
                +
                    0*(
                        ! The following condition evaluates second
                        ((
                            ((((((formal_par1 ofclass K1_room) && (formal_par1 ofclass K1_room))))) && ((
                            formal_rv = MapConnection(formal_par1,formal_par0)) | 1)
                            )|| (ArgumentTypeFailed(67, 27))

                        ))
                    +
                        ! The following assignments evaluate first
                        ((formal_par1 = real_location) +
                        (formal_par0 = tmp_0)
                        ))
                )

            ! Resolution complete
            ) ofclass K1_room)))
            {! [5: decide yes]
                rtrue;
                }
                }
                }
    ! [6: decide no]
    rfalse;
    return false;
];
! From "Real People" by Philip Riley
! Request 73: phrase (behavior, person) -> nothing
! To add behavior ( b - a behavior ) to ( P - a person ):
[ PHR_1050_r73  
    t_0 ! Call parameter 'b': behavior
    t_1 ! Call parameter 'P': person
    ;
    ! [2: add b at entry 1 in the behavior stack of p]
    LIST_OF_TY_InsertItem(GProperty(10, t_1,p22_behavior_stack), t_0, 1, 1, 0);
    rfalse;
];
! From "Image Strip" by Philip Riley
! Request 74: phrase text -> nothing
! To blank the/-- graphics/-- window to ( bc - some text ):
[ PHR_1337_r74  
    t_0 ! Call parameter 'bc': text
I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_87(t_0);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_87 
    t_0 ! Call parameter 'bc': text
    ;
    ! [2: blank the graphics window to the color number of bc]
    BlankWindowToColor(GTE_ConvertColour( BlkValueCopy(I7SFRAME, t_0) ));
    rfalse;
];
! From the Standard Rules
! Request 75: phrase nothing -> nothing
! To say no line break -- running on ( documented at phs_nolinebreak ):
[ PHR_334_r75  ;
    ! [2: do nothing]
    ;
    rfalse;
];
! From the Standard Rules
! Request 76: phrase real number -> real number
! To decide which real number is the real square of ( R - a real number ) ( this is the rsqr function inverse to root ):
[ PHR_414_r76  
    t_0 ! Call parameter 'R': real number
    tmp_0 ! Let/loop value, e.g., 'x': real number
    ;
    ! [2: let x be given by x = r@@94@{32} where x is a real number]

    		! Solving Q0_german for '$w'
    (tmp_0 = (REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2))));
    ;
    ! [3: decide on x]
    return tmp_0;
    return 0;
];
! From the Standard Rules
! Request 77: phrase real number -> real number
! To decide which real number is the hyperbolic arcsine of ( R - a real number ) ( documented at ph_hyperbolicarcsine ) ( this is the arcsinh function inverse to sinh ):
[ PHR_432_r77  
    t_0 ! Call parameter 'R': real number
    tmp_0 ! Let/loop value, e.g., 'x': real number
    ;
    ! [2: let x be given by x = log ( r + root ( r@@94@{32} + 1 ) ) where x is a real number]

    		! Solving Q1_german for '$w'
    (tmp_0 = (REAL_NUMBER_TY_Log((REAL_NUMBER_TY_Plus(t_0, (REAL_NUMBER_TY_Root((REAL_NUMBER_TY_Plus((REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2))), NUMBER_TY_to_REAL_NUMBER_TY(1))))))))));
    ;
    ! [3: decide on x]
    return tmp_0;
    return 0;
];
! From the Standard Rules
! Request 78: phrase real number -> real number
! To decide which real number is the hyperbolic arccosine of ( R - a real number ) ( documented at ph_hyperbolicarccosine ) ( this is the arccosh function inverse to cosh ):
[ PHR_433_r78  
    t_0 ! Call parameter 'R': real number
    tmp_0 ! Let/loop value, e.g., 'x': real number
    ;
    ! [2: let x be given by x = log ( r + root ( r@@94@{32} - 1 ) ) where x is a real number]

    		! Solving Q2_german for '$w'
    (tmp_0 = (REAL_NUMBER_TY_Log((REAL_NUMBER_TY_Plus(t_0, (REAL_NUMBER_TY_Root((REAL_NUMBER_TY_Minus((REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2))), NUMBER_TY_to_REAL_NUMBER_TY(1))))))))));
    ;
    ! [3: decide on x]
    return tmp_0;
    return 0;
];
! From the Standard Rules
! Request 79: phrase real number -> real number
! To decide which real number is the hyperbolic arctangent of ( R - a real number ) ( documented at ph_hyperbolicarctangent ) ( this is the arctanh function inverse to tanh ):
[ PHR_434_r79  
    t_0 ! Call parameter 'R': real number
    tmp_0 ! Let/loop value, e.g., 'x': real number
    ;
    ! [2: let x be given by x = 0.5* ( log ( 1+r ) - log ( 1-r ) ) where x is a real number]

    		! Solving Q3_german for '$w'
    (tmp_0 = (REAL_NUMBER_TY_Times(1056964608, (REAL_NUMBER_TY_Minus((REAL_NUMBER_TY_Log((REAL_NUMBER_TY_Plus(NUMBER_TY_to_REAL_NUMBER_TY(1), t_0)))), (REAL_NUMBER_TY_Log((REAL_NUMBER_TY_Minus(NUMBER_TY_to_REAL_NUMBER_TY(1), t_0)))))))));
    ;
    ! [3: decide on x]
    return tmp_0;
    return 0;
];
! From the Standard Rules
! Request 80: phrase nothing -> nothing
! To say now ( documented at phs_now ):
[ PHR_518_r80  ;
    ! [2: say ~[if story tense is present tense]now[otherwise]then~]
    say__p=1;! [3: if story tense is present tense]

    	if (~~((((story_tense == I112_present_tense))))) jump L_Say667;! [4: ~now~]
    ParaContent(); print "now";! [5: otherwise]

    	jump L_SayX659; .L_Say667;! [6: ~then~]
    ParaContent(); print "then"; .L_Say668; .L_SayX659;rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 81: phrase nothing -> nothing
! To say reset LPR:
[ PHR_755_r81  ;
    ! [2: if not expanding text for comparison purposes]
    if ((~~(((say__comp)))))
    {! [3: now last person referenced is nothing]
        (Global_Vars-->10) = nothing;
        }
        rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 82: phrase person -> nothing
! To say force pronoun for ( P - a person ):
[ PHR_756_r82  
    t_0 ! Call parameter 'P': person
    ;
    ! [2: if not expanding text for comparison purposes]
    if ((~~(((say__comp)))))
    {! [3: now last person referenced is p]
        (Global_Vars-->10) = t_0;
        }
        rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 83: phrase nothing -> nothing
! To say we're:
[ PHR_758_r83  ;
    ! [2: if the last person referenced is not the player]
    if (((~~(((Global_Vars-->10) == player)))))
    {! [3: say ~[player]'s~]
        say__p=1;! [4: player]
        ParaContent(); PrintShortName(player);! [5: ~'s~]
        ParaContent(); print "'s"; .L_Say669; .L_SayX660;} else {
        ! [6: now the prior named object is the player]
        prior_named_noun = player;
        ! [7: now the most recent reference of the prior named object is pronominal]
        WriteGProperty(OBJECT_TY, prior_named_noun,most_recent_reference,I392_pronominal);
        ! [8: if the story viewpoint is]
        switch (story_viewpoint) 
        {I118_first_person_singular:
            ! [9: say ~I'm~]
            say__p=1;! [10: ~I'm~]
            ParaContent(); print "I'm"; .L_Say670; .L_SayX661;;
            I119_second_person_singular:
            ! [11: say ~you're~]
            say__p=1;! [12: ~you're~]
            ParaContent(); print "you're"; .L_Say671; .L_SayX662;;
            I120_third_person_singular:
            ! [13: if printing gender for the player is]
            switch ((PHR_1436_r206 (player))) 
            {I66_masculine_gender:
                ! [14: say ~he's~]
                say__p=1;! [15: ~he's~]
                ParaContent(); print "he's"; .L_Say672; .L_SayX663;;
                I67_feminine_gender:
                ! [16: say ~she's~]
                say__p=1;! [17: ~she's~]
                ParaContent(); print "she's"; .L_Say673; .L_SayX664;;
                I65_neuter_gender:
                ! [18: say ~it's~]
                say__p=1;! [19: ~it's~]
                ParaContent(); print "it's"; .L_Say674; .L_SayX665;;
                I68_neitherine_gender:
                ! [20: say ~[entry 1 in the declensions of the third singular pronoun of the player][']re~]
                say__p=1;! [21: entry 1 in the declensions of the third singular pronoun of the player]
                ParaContent(); print (TEXT_TY_Say) LIST_OF_TY_GetItem(GProperty(10, GProperty(10, player,third_singular_pronoun),p41_declensions),1);! [22: ']
                ParaContent(); print "'";! [23: ~re~]
                ParaContent(); print "re"; .L_Say675; .L_SayX666;}
                ;
                I121_first_person_plural:
            ! [24: say ~we're~]
            say__p=1;! [25: ~we're~]
            ParaContent(); print "we're"; .L_Say676; .L_SayX667;;
            I122_second_person_plural:
            ! [26: say ~you're~]
            say__p=1;! [27: ~you're~]
            ParaContent(); print "you're"; .L_Say677; .L_SayX668;;
            I123_third_person_plural:
            ! [28: say ~they're~]
            say__p=1;! [29: ~they're~]
            ParaContent(); print "they're"; .L_Say678; .L_SayX669;}
            }
            rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 84: phrase nothing -> nothing
! To say we've:
[ PHR_759_r84  ;
    ! [2: if last person referenced is not the player]
    if (((~~(((Global_Vars-->10) == player)))))
    {! [3: say ~[player]'s~]
        say__p=1;! [4: player]
        ParaContent(); PrintShortName(player);! [5: ~'s~]
        ParaContent(); print "'s"; .L_Say679; .L_SayX670;} else {
        ! [6: now the prior named object is the player]
        prior_named_noun = player;
        ! [7: now the most recent reference of the prior named object is pronominal]
        WriteGProperty(OBJECT_TY, prior_named_noun,most_recent_reference,I392_pronominal);
        ! [8: if the story viewpoint is]
        switch (story_viewpoint) 
        {I118_first_person_singular:
            ! [9: say ~I've~]
            say__p=1;! [10: ~I've~]
            ParaContent(); print "I've"; .L_Say680; .L_SayX671;;
            I119_second_person_singular:
            ! [11: say ~you've~]
            say__p=1;! [12: ~you've~]
            ParaContent(); print "you've"; .L_Say681; .L_SayX672;;
            I120_third_person_singular:
            ! [13: if printing gender for the player is]
            switch ((PHR_1436_r206 (player))) 
            {I66_masculine_gender:
                ! [14: say ~he's~]
                say__p=1;! [15: ~he's~]
                ParaContent(); print "he's"; .L_Say682; .L_SayX673;;
                I67_feminine_gender:
                ! [16: say ~she's~]
                say__p=1;! [17: ~she's~]
                ParaContent(); print "she's"; .L_Say683; .L_SayX674;;
                I65_neuter_gender:
                ! [18: say ~it's~]
                say__p=1;! [19: ~it's~]
                ParaContent(); print "it's"; .L_Say684; .L_SayX675;;
                I68_neitherine_gender:
                ! [20: say ~[entry 1 in the declensions of the third singular pronoun of the player]'ve~]
                say__p=1;! [21: entry 1 in the declensions of the third singular pronoun of the player]
                ParaContent(); print (TEXT_TY_Say) LIST_OF_TY_GetItem(GProperty(10, GProperty(10, player,third_singular_pronoun),p41_declensions),1);! [22: ~'ve~]
                ParaContent(); print "~ve"; .L_Say685; .L_SayX676;}
                ;
                I121_first_person_plural:
            ! [23: say ~we've~]
            say__p=1;! [24: ~we've~]
            ParaContent(); print "we've"; .L_Say686; .L_SayX677;;
            I122_second_person_plural:
            ! [25: say ~you've~]
            say__p=1;! [26: ~you've~]
            ParaContent(); print "you've"; .L_Say687; .L_SayX678;;
            I123_third_person_plural:
            ! [27: say ~they've~]
            say__p=1;! [28: ~they've~]
            ParaContent(); print "they've"; .L_Say688; .L_SayX679;}
            }
            rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 85: phrase nothing -> nothing
! To say ours:
[ PHR_761_r85  ;
    ! [2: if the last person referenced is not the player]
    if (((~~(((Global_Vars-->10) == player)))))
    {! [3: say ~[player]'s~]
        say__p=1;! [4: player]
        ParaContent(); PrintShortName(player);! [5: ~'s~]
        ParaContent(); print "'s"; .L_Say689; .L_SayX680;} else {
        ! [6: now the prior named object is the player]
        prior_named_noun = player;
        ! [7: if the story viewpoint is]
        switch (story_viewpoint) 
        {I118_first_person_singular:
            ! [8: say ~mine~]
            say__p=1;! [9: ~mine~]
            ParaContent(); print "mine"; .L_Say690; .L_SayX681;;
            I119_second_person_singular:
            ! [10: say ~yours~]
            say__p=1;! [11: ~yours~]
            ParaContent(); print "yours"; .L_Say691; .L_SayX682;;
            I120_third_person_singular:
            ! [12: if printing gender for the player is]
            switch ((PHR_1436_r206 (player))) 
            {I66_masculine_gender:
                ! [13: say ~his~]
                say__p=1;! [14: ~his~]
                ParaContent(); print "his"; .L_Say692; .L_SayX683;;
                I67_feminine_gender:
                ! [15: say ~hers~]
                say__p=1;! [16: ~hers~]
                ParaContent(); print "hers"; .L_Say693; .L_SayX684;;
                I65_neuter_gender:
                ! [17: say ~its~]
                say__p=1;! [18: ~its~]
                ParaContent(); print "its"; .L_Say694; .L_SayX685;;
                I68_neitherine_gender:
                ! [19: say entry 3 in the declensions of the third singular pronoun of the player]
                say__p=1;! [20: entry 3 in the declensions of the third singular pronoun of the player]
                ParaContent(); print (TEXT_TY_Say) LIST_OF_TY_GetItem(GProperty(10, GProperty(10, player,third_singular_pronoun),p41_declensions),3); .L_Say695; .L_SayX686;}
                ;
                I121_first_person_plural:
            ! [21: say ~ours~]
            say__p=1;! [22: ~ours~]
            ParaContent(); print "ours"; .L_Say696; .L_SayX687;;
            I122_second_person_plural:
            ! [23: say ~yours~]
            say__p=1;! [24: ~yours~]
            ParaContent(); print "yours"; .L_Say697; .L_SayX688;;
            I123_third_person_plural:
            ! [25: say ~theirs~]
            say__p=1;! [26: ~theirs~]
            ParaContent(); print "theirs"; .L_Say698; .L_SayX689;}
            }
            rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 86: phrase nothing -> nothing
! To say We're:
[ PHR_765_r86  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_88();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_88 ;
    ! [2: if last person referenced is not the player]
    if (((~~(((Global_Vars-->10) == player)))))
    {! [3: say ~[player]'s~]
        say__p=1;! [4: player]
        ParaContent(); PrintShortName(player);! [5: ~'s~]
        ParaContent(); print "'s"; .L_Say699; .L_SayX690;} else {
        ! [6: now the prior named object is the player]
        prior_named_noun = player;
        ! [7: now the most recent reference of the prior named object is pronominal]
        WriteGProperty(OBJECT_TY, prior_named_noun,most_recent_reference,I392_pronominal);
        ! [8: if the story viewpoint is]
        switch (story_viewpoint) 
        {I118_first_person_singular:
            ! [9: say ~I'm~]
            say__p=1;! [10: ~I'm~]
            ParaContent(); print "I'm"; .L_Say700; .L_SayX691;;
            I119_second_person_singular:
            ! [11: say ~You're~]
            say__p=1;! [12: ~You're~]
            ParaContent(); print "You're"; .L_Say701; .L_SayX692;;
            I120_third_person_singular:
            ! [13: if printing gender for the player is]
            switch ((PHR_1436_r206 (player))) 
            {I66_masculine_gender:
                ! [14: say ~He's~]
                say__p=1;! [15: ~He's~]
                ParaContent(); print "He's"; .L_Say702; .L_SayX693;;
                I67_feminine_gender:
                ! [16: say ~She's~]
                say__p=1;! [17: ~She's~]
                ParaContent(); print "She's"; .L_Say703; .L_SayX694;;
                I65_neuter_gender:
                ! [18: say ~It's~]
                say__p=1;! [19: ~It's~]
                ParaContent(); print "It's"; .L_Say704; .L_SayX695;;
                I68_neitherine_gender:
                ! [20: say ~[entry 1 in the declensions of the third singular pronoun of the player in title case]'re~]
                say__p=1;! [21: entry 1 in the declensions of the third singular pronoun of the player in title case]
                ParaContent(); print (TEXT_TY_Say) TEXT_TY_CharactersToCase(I7SFRAME, LIST_OF_TY_GetItem(GProperty(10, GProperty(10, player,third_singular_pronoun),p41_declensions),1), 2);! [22: ~'re~]
                ParaContent(); print "~re"; .L_Say705; .L_SayX696;}
                ;
                I121_first_person_plural:
            ! [23: say ~We're~]
            say__p=1;! [24: ~We're~]
            ParaContent(); print "We're"; .L_Say706; .L_SayX697;;
            I122_second_person_plural:
            ! [25: say ~You're~]
            say__p=1;! [26: ~You're~]
            ParaContent(); print "You're"; .L_Say707; .L_SayX698;;
            I123_third_person_plural:
            ! [27: say ~They're~]
            say__p=1;! [28: ~They're~]
            ParaContent(); print "They're"; .L_Say708; .L_SayX699;}
            }
            rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 87: phrase nothing -> nothing
! To say We've:
[ PHR_766_r87  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_89();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_89 ;
    ! [2: if last person referenced is not the player]
    if (((~~(((Global_Vars-->10) == player)))))
    {! [3: say ~[player]'s~]
        say__p=1;! [4: player]
        ParaContent(); PrintShortName(player);! [5: ~'s~]
        ParaContent(); print "'s"; .L_Say709; .L_SayX700;} else {
        ! [6: now the prior named object is the player]
        prior_named_noun = player;
        ! [7: now the most recent reference of the prior named object is pronominal]
        WriteGProperty(OBJECT_TY, prior_named_noun,most_recent_reference,I392_pronominal);
        ! [8: if the story viewpoint is]
        switch (story_viewpoint) 
        {I118_first_person_singular:
            ! [9: say ~I've~]
            say__p=1;! [10: ~I've~]
            ParaContent(); print "I've"; .L_Say710; .L_SayX701;;
            I119_second_person_singular:
            ! [11: say ~You've~]
            say__p=1;! [12: ~You've~]
            ParaContent(); print "You've"; .L_Say711; .L_SayX702;;
            I120_third_person_singular:
            ! [13: if printing gender for the player is]
            switch ((PHR_1436_r206 (player))) 
            {I66_masculine_gender:
                ! [14: say ~He's~]
                say__p=1;! [15: ~He's~]
                ParaContent(); print "He's"; .L_Say712; .L_SayX703;;
                I67_feminine_gender:
                ! [16: say ~She's~]
                say__p=1;! [17: ~She's~]
                ParaContent(); print "She's"; .L_Say713; .L_SayX704;;
                I65_neuter_gender:
                ! [18: say ~It's~]
                say__p=1;! [19: ~It's~]
                ParaContent(); print "It's"; .L_Say714; .L_SayX705;;
                I68_neitherine_gender:
                ! [20: say ~[entry 1 in the declensions of the third singular pronoun of the player in title case]'ve~]
                say__p=1;! [21: entry 1 in the declensions of the third singular pronoun of the player in title case]
                ParaContent(); print (TEXT_TY_Say) TEXT_TY_CharactersToCase(I7SFRAME, LIST_OF_TY_GetItem(GProperty(10, GProperty(10, player,third_singular_pronoun),p41_declensions),1), 2);! [22: ~'ve~]
                ParaContent(); print "~ve"; .L_Say715; .L_SayX706;}
                ;
                I121_first_person_plural:
            ! [23: say ~We've~]
            say__p=1;! [24: ~We've~]
            ParaContent(); print "We've"; .L_Say716; .L_SayX707;;
            I122_second_person_plural:
            ! [25: say ~You've~]
            say__p=1;! [26: ~You've~]
            ParaContent(); print "You've"; .L_Say717; .L_SayX708;;
            I123_third_person_plural:
            ! [27: say ~They've~]
            say__p=1;! [28: ~They've~]
            ParaContent(); print "They've"; .L_Say718; .L_SayX709;}
            }
            rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 88: phrase nothing -> nothing
! To say Us:
[ PHR_767_r88  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_90();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_90 ;
    ! [2: if the last person referenced is not the player]
    if (((~~(((Global_Vars-->10) == player)))))
    {! [3: say ~[player]~]
        say__p=1;! [4: player]
        ParaContent(); PrintShortName(player); .L_Say719; .L_SayX710;} else {
        ! [5: now the prior named object is the player]
        prior_named_noun = player;
        ! [6: if the story viewpoint is]
        switch (story_viewpoint) 
        {I118_first_person_singular:
            ! [7: say ~Me~]
            say__p=1;! [8: ~Me~]
            ParaContent(); print "Me"; .L_Say720; .L_SayX711;;
            I119_second_person_singular:
            ! [9: say ~You~]
            say__p=1;! [10: ~You~]
            ParaContent(); print "You"; .L_Say721; .L_SayX712;;
            I120_third_person_singular:
            ! [11: if printing gender for the player is]
            switch ((PHR_1436_r206 (player))) 
            {I66_masculine_gender:
                ! [12: say ~Him~]
                say__p=1;! [13: ~Him~]
                ParaContent(); print "Him"; .L_Say722; .L_SayX713;;
                I67_feminine_gender:
                ! [14: say ~Her~]
                say__p=1;! [15: ~Her~]
                ParaContent(); print "Her"; .L_Say723; .L_SayX714;;
                I65_neuter_gender:
                ! [16: say ~It~]
                say__p=1;! [17: ~It~]
                ParaContent(); print "It"; .L_Say724; .L_SayX715;;
                I68_neitherine_gender:
                ! [18: say ~[entry 2 in the declensions of the third singular pronoun of the player in title case]~]
                say__p=1;! [19: entry 2 in the declensions of the third singular pronoun of the player in title case]
                ParaContent(); print (TEXT_TY_Say) TEXT_TY_CharactersToCase(I7SFRAME, LIST_OF_TY_GetItem(GProperty(10, GProperty(10, player,third_singular_pronoun),p41_declensions),2), 2); .L_Say725; .L_SayX716;}
                ;
                I121_first_person_plural:
            ! [20: say ~Us~]
            say__p=1;! [21: ~Us~]
            ParaContent(); print "Us"; .L_Say726; .L_SayX717;;
            I122_second_person_plural:
            ! [22: say ~You~]
            say__p=1;! [23: ~You~]
            ParaContent(); print "You"; .L_Say727; .L_SayX718;;
            I123_third_person_plural:
            ! [24: say ~Them~]
            say__p=1;! [25: ~Them~]
            ParaContent(); print "Them"; .L_Say728; .L_SayX719;}
            }
            rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 89: phrase nothing -> nothing
! To say Ours:
[ PHR_768_r89  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_91();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_91 ;
    ! [2: if the last person referenced is not the player]
    if (((~~(((Global_Vars-->10) == player)))))
    {! [3: say ~[player]'s~]
        say__p=1;! [4: player]
        ParaContent(); PrintShortName(player);! [5: ~'s~]
        ParaContent(); print "'s"; .L_Say729; .L_SayX720;} else {
        ! [6: now the prior named object is the player]
        prior_named_noun = player;
        ! [7: if the story viewpoint is]
        switch (story_viewpoint) 
        {I118_first_person_singular:
            ! [8: say ~Mine~]
            say__p=1;! [9: ~Mine~]
            ParaContent(); print "Mine"; .L_Say730; .L_SayX721;;
            I119_second_person_singular:
            ! [10: say ~Yours~]
            say__p=1;! [11: ~Yours~]
            ParaContent(); print "Yours"; .L_Say731; .L_SayX722;;
            I120_third_person_singular:
            ! [12: if printing gender for the player is]
            switch ((PHR_1436_r206 (player))) 
            {I66_masculine_gender:
                ! [13: say ~His~]
                say__p=1;! [14: ~His~]
                ParaContent(); print "His"; .L_Say732; .L_SayX723;;
                I67_feminine_gender:
                ! [15: say ~Hers~]
                say__p=1;! [16: ~Hers~]
                ParaContent(); print "Hers"; .L_Say733; .L_SayX724;;
                I65_neuter_gender:
                ! [17: say ~Its~]
                say__p=1;! [18: ~Its~]
                ParaContent(); print "Its"; .L_Say734; .L_SayX725;;
                I68_neitherine_gender:
                ! [19: say ~[entry 3 in the declensions of the third singular pronoun of the player in title case]~]
                say__p=1;! [20: entry 3 in the declensions of the third singular pronoun of the player in title case]
                ParaContent(); print (TEXT_TY_Say) TEXT_TY_CharactersToCase(I7SFRAME, LIST_OF_TY_GetItem(GProperty(10, GProperty(10, player,third_singular_pronoun),p41_declensions),3), 2); .L_Say735; .L_SayX726;}
                ;
                I121_first_person_plural:
            ! [21: say ~Ours~]
            say__p=1;! [22: ~Ours~]
            ParaContent(); print "Ours"; .L_Say736; .L_SayX727;;
            I122_second_person_plural:
            ! [23: say ~Yours~]
            say__p=1;! [24: ~Yours~]
            ParaContent(); print "Yours"; .L_Say737; .L_SayX728;;
            I123_third_person_plural:
            ! [25: say ~Theirs~]
            say__p=1;! [26: ~Theirs~]
            ParaContent(); print "Theirs"; .L_Say738; .L_SayX729;}
            }
            rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 90: phrase nothing -> nothing
! To say Ourselves:
[ PHR_769_r90  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_92();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_92 ;
    ! [2: now the prior named object is the player]
    prior_named_noun = player;
    ! [3: if the story viewpoint is]
    switch (story_viewpoint) 
    {I118_first_person_singular:
        ! [4: say ~Myself~]
        say__p=1;! [5: ~Myself~]
        ParaContent(); print "Myself"; .L_Say739; .L_SayX730;;
        I119_second_person_singular:
        ! [6: say ~Yourself~]
        say__p=1;! [7: ~Yourself~]
        ParaContent(); print "Yourself"; .L_Say740; .L_SayX731;;
        I120_third_person_singular:
        ! [8: if printing gender for the player is]
        switch ((PHR_1436_r206 (player))) 
        {I66_masculine_gender:
            ! [9: say ~Himself~]
            say__p=1;! [10: ~Himself~]
            ParaContent(); print "Himself"; .L_Say741; .L_SayX732;;
            I67_feminine_gender:
            ! [11: say ~Herself~]
            say__p=1;! [12: ~Herself~]
            ParaContent(); print "Herself"; .L_Say742; .L_SayX733;;
            I65_neuter_gender:
            ! [13: say ~Itself~]
            say__p=1;! [14: ~Itself~]
            ParaContent(); print "Itself"; .L_Say743; .L_SayX734;;
            I68_neitherine_gender:
            ! [15: say ~[entry 4 in the declensions of the third singular pronoun of the player in title case]~]
            say__p=1;! [16: entry 4 in the declensions of the third singular pronoun of the player in title case]
            ParaContent(); print (TEXT_TY_Say) TEXT_TY_CharactersToCase(I7SFRAME, LIST_OF_TY_GetItem(GProperty(10, GProperty(10, player,third_singular_pronoun),p41_declensions),4), 2); .L_Say744; .L_SayX735;}
            ;
            I121_first_person_plural:
        ! [17: say ~Ourselves~]
        say__p=1;! [18: ~Ourselves~]
        ParaContent(); print "Ourselves"; .L_Say745; .L_SayX736;;
        I122_second_person_plural:
        ! [19: say ~Yourselves~]
        say__p=1;! [20: ~Yourselves~]
        ParaContent(); print "Yourselves"; .L_Say746; .L_SayX737;;
        I123_third_person_plural:
        ! [21: say ~Themselves~]
        say__p=1;! [22: ~Themselves~]
        ParaContent(); print "Themselves"; .L_Say747; .L_SayX738;}
        rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 91: phrase nothing -> nothing
! To say those:
[ PHR_771_r91  ;
    ! [2: say those in the accusative]
    say__p=1;! [3: those in the accusative]
    ParaContent(); (PHR_773_r92 (I126_accusative)); .L_Say748; .L_SayX739;rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 92: phrase grammatical case -> nothing
! To say those in ( case - grammatical case ):
[ PHR_773_r92  
    t_0 ! Call parameter 'case': grammatical case
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    ;
    ! [2: if the case is nominative]
    if (((t_0 == I125_nominative)))
    {! [3: let the item be the prior named object]

        		tmp_0 = prior_named_noun;
        ! [4: if the prior naming context is plural]
        if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
        {! [5: say ~those~]
            say__p=1;! [6: ~those~]
            ParaContent(); print "those"; .L_Say749; .L_SayX740;} else {
            ! [7: if the item is the player]
            if (((tmp_0 == player)))
            {! [8: say ~[we]~]
                say__p=1;! [9: we]
                ParaContent(); (PHR_757_r16 ()); .L_Say750; .L_SayX741;} else {
                ! [10: if printing gender for the item is]
                switch ((PHR_1436_r206 (tmp_0))) 
                {I66_masculine_gender:
                    ! [11: say ~he~]
                    say__p=1;! [12: ~he~]
                    ParaContent(); print "he"; .L_Say751; .L_SayX742;;
                    I67_feminine_gender:
                    ! [13: say ~she~]
                    say__p=1;! [14: ~she~]
                    ParaContent(); print "she"; .L_Say752; .L_SayX743;;
                    I65_neuter_gender:
                    ! [15: say ~that~]
                    say__p=1;! [16: ~that~]
                    ParaContent(); print "that"; .L_Say753; .L_SayX744;;
                    I68_neitherine_gender:
                    ! [17: say entry 1 in the declensions of the third singular pronoun of the player]
                    say__p=1;! [18: entry 1 in the declensions of the third singular pronoun of the player]
                    ParaContent(); print (TEXT_TY_Say) LIST_OF_TY_GetItem(GProperty(10, GProperty(10, player,third_singular_pronoun),p41_declensions),1); .L_Say754; .L_SayX745;}
                    }
                    }
                    } else {
        ! [19: let the item be the prior named object]

        		tmp_0 = prior_named_noun;
        ! [20: if the prior naming context is plural]
        if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
        {! [21: say ~those~]
            say__p=1;! [22: ~those~]
            ParaContent(); print "those"; .L_Say755; .L_SayX746;} else {
            ! [23: if the item is the player]
            if (((tmp_0 == player)))
            {! [24: say ~[we]~]
                say__p=1;! [25: we]
                ParaContent(); (PHR_757_r16 ()); .L_Say756; .L_SayX747;} else {
                ! [26: if printing gender for the item is]
                switch ((PHR_1436_r206 (tmp_0))) 
                {I66_masculine_gender:
                    ! [27: say ~him~]
                    say__p=1;! [28: ~him~]
                    ParaContent(); print "him"; .L_Say757; .L_SayX748;;
                    I67_feminine_gender:
                    ! [29: say ~her~]
                    say__p=1;! [30: ~her~]
                    ParaContent(); print "her"; .L_Say758; .L_SayX749;;
                    I65_neuter_gender:
                    ! [31: say ~that~]
                    say__p=1;! [32: ~that~]
                    ParaContent(); print "that"; .L_Say759; .L_SayX750;;
                    I68_neitherine_gender:
                    ! [33: say entry 2 in the declensions of the third singular pronoun of the player]
                    say__p=1;! [34: entry 2 in the declensions of the third singular pronoun of the player]
                    ParaContent(); print (TEXT_TY_Say) LIST_OF_TY_GetItem(GProperty(10, GProperty(10, player,third_singular_pronoun),p41_declensions),2); .L_Say760; .L_SayX751;}
                    }
                    }
                    }
                    rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 93: phrase grammatical case -> nothing
! To say Those in ( case - grammatical case ):
[ PHR_774_r93  
    t_0 ! Call parameter 'case': grammatical case
I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(4);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_93(t_0);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_93 
    t_0 ! Call parameter 'case': grammatical case
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    ;
    ! [2: if the case is nominative]
    if (((t_0 == I125_nominative)))
    {! [3: let the item be the prior named object]

        		tmp_0 = prior_named_noun;
        ! [4: if the prior naming context is plural]
        if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
        {! [5: say ~Those~]
            say__p=1;! [6: ~Those~]
            ParaContent(); print "Those"; .L_Say761; .L_SayX752;} else {
            ! [7: if the item is the player]
            if (((tmp_0 == player)))
            {! [8: say ~[We]~]
                say__p=1;! [9: we]
                ParaContent(); (PHR_764_r7 ()); .L_Say762; .L_SayX753;} else {
                ! [10: if printing gender for the item is]
                switch ((PHR_1436_r206 (tmp_0))) 
                {I66_masculine_gender:
                    ! [11: say ~He~]
                    say__p=1;! [12: ~He~]
                    ParaContent(); print "He"; .L_Say763; .L_SayX754;;
                    I67_feminine_gender:
                    ! [13: say ~She~]
                    say__p=1;! [14: ~She~]
                    ParaContent(); print "She"; .L_Say764; .L_SayX755;;
                    I65_neuter_gender:
                    ! [15: say ~That~]
                    say__p=1;! [16: ~That~]
                    ParaContent(); print "That"; .L_Say765; .L_SayX756;;
                    I68_neitherine_gender:
                    ! [17: say ~[entry 1 in the declensions of the third singular pronoun of the item in title case]~]
                    say__p=1;! [18: ~~]
                    ParaContent(); print "";! [19: entry 1 in the declensions of the third singular pronoun of the item in title case]
                    ParaContent(); print (TEXT_TY_Say) TEXT_TY_CharactersToCase(I7SFRAME, LIST_OF_TY_GetItem(GProperty(10, GProperty(OBJECT_TY, tmp_0,third_singular_pronoun),p41_declensions),1), 2); .L_Say766; .L_SayX757;}
                    }
                    }
                    } else {
        ! [20: let the item be the prior named object]

        		tmp_0 = prior_named_noun;
        ! [21: if the prior naming context is plural]
        if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
        {! [22: say ~Those~]
            say__p=1;! [23: ~Those~]
            ParaContent(); print "Those"; .L_Say767; .L_SayX758;} else {
            ! [24: if the item is the player]
            if (((tmp_0 == player)))
            {! [25: say ~[We]~]
                say__p=1;! [26: we]
                ParaContent(); (PHR_764_r7 ()); .L_Say768; .L_SayX759;} else {
                ! [27: if printing gender for the item is]
                switch ((PHR_1436_r206 (tmp_0))) 
                {I66_masculine_gender:
                    ! [28: say ~Him~]
                    say__p=1;! [29: ~Him~]
                    ParaContent(); print "Him"; .L_Say769; .L_SayX760;;
                    I67_feminine_gender:
                    ! [30: say ~Her~]
                    say__p=1;! [31: ~Her~]
                    ParaContent(); print "Her"; .L_Say770; .L_SayX761;;
                    I65_neuter_gender:
                    ! [32: say ~That~]
                    say__p=1;! [33: ~That~]
                    ParaContent(); print "That"; .L_Say771; .L_SayX762;;
                    I68_neitherine_gender:
                    ! [34: say ~[entry 2 in the declensions of the third singular pronoun of the item in title case]~]
                    say__p=1;! [35: entry 2 in the declensions of the third singular pronoun of the item in title case]
                    ParaContent(); print (TEXT_TY_Say) TEXT_TY_CharactersToCase((I7SFRAME+WORDSIZE*2), LIST_OF_TY_GetItem(GProperty(10, GProperty(OBJECT_TY, tmp_0,third_singular_pronoun),p41_declensions),2), 2); .L_Say772; .L_SayX763;}
                    }
                    }
                    }
                    rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 94: phrase nothing -> nothing
! To say they:
[ PHR_775_r94  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~they~]
        say__p=1;! [5: ~they~]
        ParaContent(); print "they"; .L_Say773; .L_SayX764;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[we]~]
            say__p=1;! [8: we]
            ParaContent(); (PHR_757_r16 ()); .L_Say774; .L_SayX765;} else {
            ! [9: if printing gender for the item is]
            switch ((PHR_1436_r206 (tmp_0))) 
            {I66_masculine_gender:
                ! [10: say ~he~]
                say__p=1;! [11: ~he~]
                ParaContent(); print "he"; .L_Say775; .L_SayX766;;
                I67_feminine_gender:
                ! [12: say ~she~]
                say__p=1;! [13: ~she~]
                ParaContent(); print "she"; .L_Say776; .L_SayX767;;
                I65_neuter_gender:
                ! [14: say ~it~]
                say__p=1;! [15: ~it~]
                ParaContent(); print "it"; .L_Say777; .L_SayX768;;
                I68_neitherine_gender:
                ! [16: say entry 1 in the declensions of the third singular pronoun of the item]
                say__p=1;! [17: entry 1 in the declensions of the third singular pronoun of the item]
                ParaContent(); print (TEXT_TY_Say) LIST_OF_TY_GetItem(GProperty(10, GProperty(OBJECT_TY, tmp_0,third_singular_pronoun),p41_declensions),1); .L_Say778; .L_SayX769;}
                }
                }
                rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 95: phrase nothing -> nothing
! To say Their:
[ PHR_778_r95  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_94();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_94 
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~Their~]
        say__p=1;! [5: ~Their~]
        ParaContent(); print "Their"; .L_Say779; .L_SayX770;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[Our]~]
            say__p=1;! [8: our]
            ParaContent(); (PHR_770_r14 ()); .L_Say780; .L_SayX771;} else {
            ! [9: if printing gender for the item is]
            switch ((PHR_1436_r206 (tmp_0))) 
            {I66_masculine_gender:
                ! [10: say ~His~]
                say__p=1;! [11: ~His~]
                ParaContent(); print "His"; .L_Say781; .L_SayX772;;
                I67_feminine_gender:
                ! [12: say ~Her~]
                say__p=1;! [13: ~Her~]
                ParaContent(); print "Her"; .L_Say782; .L_SayX773;;
                I65_neuter_gender:
                ! [14: say ~Its~]
                say__p=1;! [15: ~Its~]
                ParaContent(); print "Its"; .L_Say783; .L_SayX774;;
                I68_neitherine_gender:
                ! [16: say ~[entry 5 in the declensions of the third singular pronoun of the item in title case]~]
                say__p=1;! [17: entry 5 in the declensions of the third singular pronoun of the item in title case]
                ParaContent(); print (TEXT_TY_Say) TEXT_TY_CharactersToCase(I7SFRAME, LIST_OF_TY_GetItem(GProperty(10, GProperty(OBJECT_TY, tmp_0,third_singular_pronoun),p41_declensions),5), 2); .L_Say784; .L_SayX775;}
                }
                }
                rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 96: phrase nothing -> nothing
! To say Them:
[ PHR_780_r96  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_95();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_95 
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~Them~]
        say__p=1;! [5: ~Them~]
        ParaContent(); print "Them"; .L_Say785; .L_SayX776;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[Us]~]
            say__p=1;! [8: us]
            ParaContent(); (PHR_767_r88 ()); .L_Say786; .L_SayX777;} else {
            ! [9: if printing gender for the item is]
            switch ((PHR_1436_r206 (tmp_0))) 
            {I66_masculine_gender:
                ! [10: say ~Him~]
                say__p=1;! [11: ~Him~]
                ParaContent(); print "Him"; .L_Say787; .L_SayX778;;
                I67_feminine_gender:
                ! [12: say ~Her~]
                say__p=1;! [13: ~Her~]
                ParaContent(); print "Her"; .L_Say788; .L_SayX779;;
                I65_neuter_gender:
                ! [14: say ~It~]
                say__p=1;! [15: ~It~]
                ParaContent(); print "It"; .L_Say789; .L_SayX780;;
                I68_neitherine_gender:
                ! [16: say ~[entry 2 in the declensions of the third singular pronoun of the item in title case]~]
                say__p=1;! [17: entry 2 in the declensions of the third singular pronoun of the item in title case]
                ParaContent(); print (TEXT_TY_Say) TEXT_TY_CharactersToCase(I7SFRAME, LIST_OF_TY_GetItem(GProperty(10, GProperty(OBJECT_TY, tmp_0,third_singular_pronoun),p41_declensions),2), 2); .L_Say790; .L_SayX781;}
                }
                }
                rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 97: phrase nothing -> nothing
! To say theirs:
[ PHR_781_r97  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~theirs~]
        say__p=1;! [5: ~theirs~]
        ParaContent(); print "theirs"; .L_Say791; .L_SayX782;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[ours]~]
            say__p=1;! [8: ours]
            ParaContent(); (PHR_761_r85 ()); .L_Say792; .L_SayX783;} else {
            ! [9: if printing gender for the item is]
            switch ((PHR_1436_r206 (tmp_0))) 
            {I66_masculine_gender:
                ! [10: say ~his~]
                say__p=1;! [11: ~his~]
                ParaContent(); print "his"; .L_Say793; .L_SayX784;;
                I67_feminine_gender:
                ! [12: say ~hers~]
                say__p=1;! [13: ~hers~]
                ParaContent(); print "hers"; .L_Say794; .L_SayX785;;
                I65_neuter_gender:
                ! [14: say ~its~]
                say__p=1;! [15: ~its~]
                ParaContent(); print "its"; .L_Say795; .L_SayX786;;
                I68_neitherine_gender:
                ! [16: say entry 3 in the declensions of the third singular pronoun of the item]
                say__p=1;! [17: entry 3 in the declensions of the third singular pronoun of the item]
                ParaContent(); print (TEXT_TY_Say) LIST_OF_TY_GetItem(GProperty(10, GProperty(OBJECT_TY, tmp_0,third_singular_pronoun),p41_declensions),3); .L_Say796; .L_SayX787;}
                }
                }
                rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 98: phrase nothing -> nothing
! To say Theirs:
[ PHR_782_r98  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_96();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_96 
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~Theirs~]
        say__p=1;! [5: ~Theirs~]
        ParaContent(); print "Theirs"; .L_Say797; .L_SayX788;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[Ours]~]
            say__p=1;! [8: ours]
            ParaContent(); (PHR_768_r89 ()); .L_Say798; .L_SayX789;} else {
            ! [9: if printing gender for the item is]
            switch ((PHR_1436_r206 (tmp_0))) 
            {I66_masculine_gender:
                ! [10: say ~His~]
                say__p=1;! [11: ~His~]
                ParaContent(); print "His"; .L_Say799; .L_SayX790;;
                I67_feminine_gender:
                ! [12: say ~Hers~]
                say__p=1;! [13: ~Hers~]
                ParaContent(); print "Hers"; .L_Say800; .L_SayX791;;
                I65_neuter_gender:
                ! [14: say ~Its~]
                say__p=1;! [15: ~Its~]
                ParaContent(); print "Its"; .L_Say801; .L_SayX792;;
                I68_neitherine_gender:
                ! [16: say ~[entry 2 in the declensions of the third singular pronoun of the item in title case]~]
                say__p=1;! [17: entry 2 in the declensions of the third singular pronoun of the item in title case]
                ParaContent(); print (TEXT_TY_Say) TEXT_TY_CharactersToCase(I7SFRAME, LIST_OF_TY_GetItem(GProperty(10, GProperty(OBJECT_TY, tmp_0,third_singular_pronoun),p41_declensions),2), 2); .L_Say802; .L_SayX793;}
                }
                }
                rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 99: phrase nothing -> nothing
! To say themselves:
[ PHR_783_r99  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~themselves~]
        say__p=1;! [5: ~themselves~]
        ParaContent(); print "themselves"; .L_Say803; .L_SayX794;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[ourselves]~]
            say__p=1;! [8: ourselves]
            ParaContent(); (PHR_762_r25 ()); .L_Say804; .L_SayX795;} else {
            ! [9: if printing gender for the item is]
            switch ((PHR_1436_r206 (tmp_0))) 
            {I66_masculine_gender:
                ! [10: say ~himself~]
                say__p=1;! [11: ~himself~]
                ParaContent(); print "himself"; .L_Say805; .L_SayX796;;
                I67_feminine_gender:
                ! [12: say ~herself~]
                say__p=1;! [13: ~herself~]
                ParaContent(); print "herself"; .L_Say806; .L_SayX797;;
                I65_neuter_gender:
                ! [14: say ~itself~]
                say__p=1;! [15: ~itself~]
                ParaContent(); print "itself"; .L_Say807; .L_SayX798;;
                I68_neitherine_gender:
                ! [16: say entry 4 in the declensions of the third singular pronoun of the item]
                say__p=1;! [17: entry 4 in the declensions of the third singular pronoun of the item]
                ParaContent(); print (TEXT_TY_Say) LIST_OF_TY_GetItem(GProperty(10, GProperty(OBJECT_TY, tmp_0,third_singular_pronoun),p41_declensions),4); .L_Say808; .L_SayX799;}
                }
                }
                rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 100: phrase nothing -> nothing
! To say Themselves:
[ PHR_784_r100  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_97();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_97 
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~Themselves~]
        say__p=1;! [5: ~Themselves~]
        ParaContent(); print "Themselves"; .L_Say809; .L_SayX800;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[Ourselves]~]
            say__p=1;! [8: ourselves]
            ParaContent(); (PHR_769_r90 ()); .L_Say810; .L_SayX801;} else {
            ! [9: if printing gender for the item is]
            switch ((PHR_1436_r206 (tmp_0))) 
            {I66_masculine_gender:
                ! [10: say ~Himself~]
                say__p=1;! [11: ~Himself~]
                ParaContent(); print "Himself"; .L_Say811; .L_SayX802;;
                I67_feminine_gender:
                ! [12: say ~Herself~]
                say__p=1;! [13: ~Herself~]
                ParaContent(); print "Herself"; .L_Say812; .L_SayX803;;
                I65_neuter_gender:
                ! [14: say ~Itself~]
                say__p=1;! [15: ~Itself~]
                ParaContent(); print "Itself"; .L_Say813; .L_SayX804;;
                I68_neitherine_gender:
                ! [16: say ~[entry 24 in the declensions of the third singular pronoun of the item in title case]~]
                say__p=1;! [17: entry 24 in the declensions of the third singular pronoun of the item in title case]
                ParaContent(); print (TEXT_TY_Say) TEXT_TY_CharactersToCase(I7SFRAME, LIST_OF_TY_GetItem(GProperty(10, GProperty(OBJECT_TY, tmp_0,third_singular_pronoun),p41_declensions),24), 2); .L_Say814; .L_SayX805;}
                }
                }
                rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 101: phrase nothing -> nothing
! To say they're:
[ PHR_785_r101  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~they~]
        say__p=1;! [5: ~they~]
        ParaContent(); print "they"; .L_Say815; .L_SayX806;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[we]~]
            say__p=1;! [8: we]
            ParaContent(); (PHR_757_r16 ()); .L_Say816; .L_SayX807;} else {
            ! [9: if printing gender for the item is]
            switch ((PHR_1436_r206 (tmp_0))) 
            {I66_masculine_gender:
                ! [10: say ~he~]
                say__p=1;! [11: ~he~]
                ParaContent(); print "he"; .L_Say817; .L_SayX808;;
                I67_feminine_gender:
                ! [12: say ~she~]
                say__p=1;! [13: ~she~]
                ParaContent(); print "she"; .L_Say818; .L_SayX809;;
                I65_neuter_gender:
                ! [14: say ~that~]
                say__p=1;! [15: ~that~]
                ParaContent(); print "that"; .L_Say819; .L_SayX810;;
                I68_neitherine_gender:
                ! [16: say entry 1 in the declensions of the third singular pronoun of the item]
                say__p=1;! [17: entry 1 in the declensions of the third singular pronoun of the item]
                ParaContent(); print (TEXT_TY_Say) LIST_OF_TY_GetItem(GProperty(10, GProperty(OBJECT_TY, tmp_0,third_singular_pronoun),p41_declensions),1); .L_Say820; .L_SayX811;}
                }
                }
    ! [18: say ~['re]~]
    say__p=1;! [19: 're]
    ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say821; .L_SayX812;rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 102: phrase nothing -> nothing
! To say They're:
[ PHR_786_r102  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_98();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_98 
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the prior naming context is plural]
    if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
    {! [4: say ~They~]
        say__p=1;! [5: ~They~]
        ParaContent(); print "They"; .L_Say822; .L_SayX813;} else {
        ! [6: if the item is the player]
        if (((tmp_0 == player)))
        {! [7: say ~[We]~]
            say__p=1;! [8: we]
            ParaContent(); (PHR_764_r7 ()); .L_Say823; .L_SayX814;} else {
            ! [9: if printing gender for the item is]
            switch ((PHR_1436_r206 (tmp_0))) 
            {I66_masculine_gender:
                ! [10: say ~He~]
                say__p=1;! [11: ~He~]
                ParaContent(); print "He"; .L_Say824; .L_SayX815;;
                I67_feminine_gender:
                ! [12: say ~She~]
                say__p=1;! [13: ~She~]
                ParaContent(); print "She"; .L_Say825; .L_SayX816;;
                I65_neuter_gender:
                ! [14: say ~That~]
                say__p=1;! [15: ~That~]
                ParaContent(); print "That"; .L_Say826; .L_SayX817;;
                I68_neitherine_gender:
                ! [16: say ~[entry 1 in the declensions of the third singular pronoun of the item in title case]~]
                say__p=1;! [17: entry 1 in the declensions of the third singular pronoun of the item in title case]
                ParaContent(); print (TEXT_TY_Say) TEXT_TY_CharactersToCase(I7SFRAME, LIST_OF_TY_GetItem(GProperty(10, GProperty(OBJECT_TY, tmp_0,third_singular_pronoun),p41_declensions),1), 2); .L_Say827; .L_SayX818;}
                }
                }
    ! [18: say ~['re]~]
    say__p=1;! [19: 're]
    ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say828; .L_SayX819;rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 103: phrase nothing -> nothing
! To say It:
[ PHR_787_r103  ;
    ! [2: say ~[regarding nothing]It~]
    say__p=1;! [3: regarding nothing]
    ParaContent(); RegardingSingleObject(nothing);! [4: ~It~]
    ParaContent(); print "It"; .L_Say829; .L_SayX820;rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 104: phrase nothing -> nothing
! To say There:
[ PHR_788_r104  ;
    ! [2: say ~[regarding nothing]There~]
    say__p=1;! [3: regarding nothing]
    ParaContent(); RegardingSingleObject(nothing);! [4: ~There~]
    ParaContent(); print "There"; .L_Say830; .L_SayX821;rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 105: phrase nothing -> nothing
! To say it:
[ PHR_789_r105  ;
    ! [2: say ~[regarding nothing]it~]
    say__p=1;! [3: regarding nothing]
    ParaContent(); RegardingSingleObject(nothing);! [4: ~it~]
    ParaContent(); print "it"; .L_Say831; .L_SayX822;rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 106: phrase nothing -> nothing
! To say there:
[ PHR_790_r106  ;
    ! [2: say ~[regarding nothing]there~]
    say__p=1;! [3: regarding nothing]
    ParaContent(); RegardingSingleObject(nothing);! [4: ~there~]
    ParaContent(); print "there"; .L_Say832; .L_SayX823;rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 107: phrase nothing -> nothing
! To say It's:
[ PHR_791_r107  ;
    ! [2: say ~[regarding nothing]It['re]~]
    say__p=1;! [3: regarding nothing]
    ParaContent(); RegardingSingleObject(nothing);! [4: ~It~]
    ParaContent(); print "It";! [5: 're]
    ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say833; .L_SayX824;rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 108: phrase nothing -> nothing
! To say it's:
[ PHR_793_r108  ;
    ! [2: say ~[regarding nothing]it['re]~]
    say__p=1;! [3: regarding nothing]
    ParaContent(); RegardingSingleObject(nothing);! [4: ~it~]
    ParaContent(); print "it";! [5: 're]
    ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say834; .L_SayX825;rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 109: phrase nothing -> nothing
! To say there's:
[ PHR_794_r109  ;
    ! [2: say ~[regarding nothing]there['re]~]
    say__p=1;! [3: regarding nothing]
    ParaContent(); RegardingSingleObject(nothing);! [4: ~there~]
    ParaContent(); print "there";! [5: 're]
    ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say835; .L_SayX826;rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 110: phrase nothing -> nothing
! To say possessive:
[ PHR_795_r110  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the item is the player]
    if (((tmp_0 == player)))
    {! [4: say ~[our]~]
        say__p=1;! [5: our]
        ParaContent(); (PHR_763_r32 ()); .L_Say836; .L_SayX827;} else {
        ! [6: if the prior naming context is plural]
        if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
        {! [7: say ~[the item][apostrophe]~]
            say__p=1;! [8: the item]
            ParaContent(); print (the) tmp_0;! [9: apostrophe]
            ParaContent(); print "'"; .L_Say837; .L_SayX828;} else {
            ! [10: say ~[the item][apostrophe]s~]
            say__p=1;! [11: the item]
            ParaContent(); print (the) tmp_0;! [12: apostrophe]
            ParaContent(); print "'";! [13: ~s~]
            ParaContent(); print "s"; .L_Say838; .L_SayX829;}
            }
            rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 111: phrase nothing -> nothing
! To say Possessive:
[ PHR_796_r111  
    tmp_0 ! Let/loop value, e.g., 'item': object
    ;
    ! [2: let the item be the prior named object]

    		tmp_0 = prior_named_noun;
    ! [3: if the item is the player]
    if (((tmp_0 == player)))
    {! [4: say ~[Our]~]
        say__p=1;! [5: our]
        ParaContent(); (PHR_770_r14 ()); .L_Say839; .L_SayX830;} else {
        ! [6: if the prior naming context is plural]
        if ((((prior_named_list >= 2) || (prior_named_noun && prior_named_noun has pluralname))))
        {! [7: say ~[The item][apostrophe]~]
            say__p=1;! [8: the item]
            ParaContent(); print (The) tmp_0;! [9: apostrophe]
            ParaContent(); print "'"; .L_Say840; .L_SayX831;} else {
            ! [10: say ~[The item][apostrophe]s~]
            say__p=1;! [11: the item]
            ParaContent(); print (The) tmp_0;! [12: apostrophe]
            ParaContent(); print "'";! [13: ~s~]
            ParaContent(); print "s"; .L_Say841; .L_SayX832;}
            }
            rfalse;
];
! From "Conversation Framework" by Eric Eve
! Request 112: phrase thing -> nothing
! To say make ( obj - a thing ) known/familiar:
[ PHR_848_r112  
    t_0 ! Call parameter 'obj': thing
    ;
    ! [2: now obj is familiar]
    (Adj_118_t2_v10(t_0));
    rfalse;
];
! From "Conversation Responses" by Eric Eve
! Request 113: phrase description of objects -> truth state
! To decide whether asked about ( objs - a description of objects ):
[ PHR_850_r113  
    t_0 ! Call parameter 'objs': description of objects
    ;
    ! [2: if quizzing someone about something]
    if ((((action ==##A66_quizzing_it_about) &&  (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing)))))
    {! [3: decide on whether or not the second noun is a member of objs]
        return ((((t_0)(second))));
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Conversation Responses" by Eric Eve
! Request 114: phrase topic -> truth state
! To decide whether asked about ( atopic - a topic ):
[ PHR_851_r114  
    t_0 ! Call parameter 'atopic': topic
    ;
    ! [2: if asking someone about something]
    if ((((action ==##Ask) &&  (actor==player) && ((noun ofclass K8_person)) && (true))))
    {! [3: decide on whether or not the topic understood matches atopic]
        return ((((SnippetMatches(parsed_number, t_0)))));
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Conversation Responses" by Eric Eve
! Request 115: phrase object -> truth state
! To decide whether asked-or-told about ( obj - an object ):
[ PHR_852_r115  
    t_0 ! Call parameter 'obj': object
    ;
    ! [2: if quizzing someone about something or informing someone about something]
    if (((((action ==##A66_quizzing_it_about) &&  (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))))) || ((((action ==##A67_informing_it_about) &&  (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))))))
    {! [3: decide on whether or not the obj is the second noun]
        return ((((t_0 == second))));
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Conversation Responses" by Eric Eve
! Request 116: phrase description of objects -> truth state
! To decide whether asked or told about ( objs - a description of objects ):
[ PHR_853_r116  
    t_0 ! Call parameter 'objs': description of objects
    ;
    ! [2: if quizzing someone about something or informing someone about something]
    if (((((action ==##A66_quizzing_it_about) &&  (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))))) || ((((action ==##A67_informing_it_about) &&  (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))))))
    {! [3: decide on whether or not the second noun is a member of objs]
        return ((((t_0)(second))));
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Conversation Responses" by Eric Eve
! Request 117: phrase topic -> truth state
! To decide whether asked-or-told about ( atopic - a topic ):
[ PHR_854_r117  
    t_0 ! Call parameter 'atopic': topic
    ;
    ! [2: if asking someone about something or telling someone about something]
    if (((((action ==##Ask) &&  (actor==player) && ((noun ofclass K8_person)) && (true)))) || ((((action ==##Tell) &&  (actor==player) && ((noun ofclass K8_person)) && (true)))))
    {! [3: decide on whether or not the topic understood matches atopic]
        return ((((SnippetMatches(parsed_number, t_0)))));
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Conversation Responses" by Eric Eve
! Request 118: phrase object -> truth state
! To decide whether told about ( obj - an object ):
[ PHR_855_r118  
    t_0 ! Call parameter 'obj': object
    ;
    ! [2: if informing someone about something]
    if ((((action ==##A67_informing_it_about) &&  (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing)))))
    {! [3: decide on whether or not obj is the second noun]
        return ((((t_0 == second))));
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Conversation Responses" by Eric Eve
! Request 119: phrase description of objects -> truth state
! To decide whether told about ( objs - a description of objects ):
[ PHR_856_r119  
    t_0 ! Call parameter 'objs': description of objects
    ;
    ! [2: if informing someone about something]
    if ((((action ==##A67_informing_it_about) &&  (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing)))))
    {! [3: decide on whether or not the second noun is a member of objs]
        return ((((t_0)(second))));
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Conversation Responses" by Eric Eve
! Request 120: phrase topic -> truth state
! To decide whether told about ( atopic - a topic ):
[ PHR_857_r120  
    t_0 ! Call parameter 'atopic': topic
    ;
    ! [2: if telling someone about something]
    if ((((action ==##Tell) &&  (actor==player) && ((noun ofclass K8_person)) && (true))))
    {! [3: decide on whether or not the topic understood matches atopic]
        return ((((SnippetMatches(parsed_number, t_0)))));
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Conversation Responses" by Eric Eve
! Request 121: phrase topic -> truth state
! To decide whether answered that ( atopic - a topic ):
[ PHR_858_r121  
    t_0 ! Call parameter 'atopic': topic
    ;
    ! [2: if answering someone that something]
    if ((((action ==##Answer) &&  (actor==player) && ((noun ofclass K8_person)) && (true))))
    {! [3: decide on whether or not the topic understood matches atopic]
        return ((((SnippetMatches(parsed_number, t_0)))));
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Conversation Responses" by Eric Eve
! Request 122: phrase object -> truth state
! To decide whether asked for ( obj - an object ):
[ PHR_859_r122  
    t_0 ! Call parameter 'obj': object
    ;
    ! [2: if requesting someone for something]
    if ((((action ==##A64_requesting_it_for) &&  (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing)))))
    {! [3: decide on whether or not the obj is the second noun]
        return ((((t_0 == second))));
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Conversation Responses" by Eric Eve
! Request 123: phrase topic -> truth state
! To decide whether asked for ( atopic - a topic ):
[ PHR_860_r123  
    t_0 ! Call parameter 'atopic': topic
    ;
    ! [2: if imploring someone for something]
    if ((((action ==##A65_imploring_it_for) &&  (actor==player) && ((noun ofclass K8_person)) && (true))))
    {! [3: decide on whether or not the topic understood matches atopic]
        return ((((SnippetMatches(parsed_number, t_0)))));
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Conversation Responses" by Eric Eve
! Request 124: phrase description of objects -> truth state
! To decide whether asked for ( objs - a description of objects ):
[ PHR_861_r124  
    t_0 ! Call parameter 'objs': description of objects
    ;
    ! [2: if requesting someone for something]
    if ((((action ==##A64_requesting_it_for) &&  (actor==player) && ((noun ofclass K8_person)) && ((second ofclass K2_thing)))))
    {! [3: decide on whether or not the second noun is a member of objs]
        return ((((t_0)(second))));
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Conversation Responses" by Eric Eve
! Request 125: phrase object -> truth state
! To decide whether shown ( obj - an object ):
[ PHR_862_r125  
    t_0 ! Call parameter 'obj': object
    ;
    ! [2: if showing something to someone]
    if ((((action ==##Show) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person)))))
    {! [3: decide on whether or not obj is the noun]
        return ((((t_0 == noun))));
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Conversation Responses" by Eric Eve
! Request 126: phrase description of objects -> truth state
! To decide whether shown ( objs - a description of objects ):
[ PHR_863_r126  
    t_0 ! Call parameter 'objs': description of objects
    ;
    ! [2: if showing something to someone]
    if ((((action ==##Show) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person)))))
    {! [3: decide on whether or not the noun is a member of objs]
        return ((((t_0)(noun))));
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Conversation Responses" by Eric Eve
! Request 127: phrase object -> truth state
! To decide whether given ( obj - an object ):
[ PHR_864_r127  
    t_0 ! Call parameter 'obj': object
    ;
    ! [2: if giving something to someone]
    if ((((action ==##Give) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person)))))
    {! [3: decide on whether or not obj is the noun]
        return ((((t_0 == noun))));
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Conversation Responses" by Eric Eve
! Request 128: phrase description of objects -> truth state
! To decide whether given ( objs - a description of objects ):
[ PHR_865_r128  
    t_0 ! Call parameter 'objs': description of objects
    ;
    ! [2: if giving something to someone]
    if ((((action ==##Give) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person)))))
    {! [3: decide on whether or not the noun is a member of objs]
        return ((((t_0)(noun))));
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Conversation Responses" by Eric Eve
! Request 129: phrase object -> truth state
! To decide whether given-or-shown ( obj - an object ):
[ PHR_866_r129  
    t_0 ! Call parameter 'obj': object
    ;
    ! [2: if giving something to someone or showing something to someone]
    if (((((action ==##Give) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person))))) || ((((action ==##Show) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person))))))
    {! [3: decide on whether or not obj is the noun]
        return ((((t_0 == noun))));
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Conversation Responses" by Eric Eve
! Request 130: phrase description of objects -> truth state
! To decide whether given-or-shown ( objs - a description of objects ):
[ PHR_867_r130  
    t_0 ! Call parameter 'objs': description of objects
    ;
    ! [2: if giving something to someone or showing something to someone]
    if (((((action ==##Give) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person))))) || ((((action ==##Show) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person))))))
    {! [3: decide on whether or not the noun is a member of objs]
        return ((((t_0)(noun))));
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Basic Screen Effects" by Emily Short
! Request 131: phrase nothing -> nothing
! To pause the/-- game:
[ PHR_894_r131  ;
    ! [2: carry out the pausing the game activity]
    CarryOutActivity(V34_pausing_the_game);
    rfalse;
];
! From "Essentials" by Philip Riley
! Request 132: phrase text -> nothing
! To dbg ( t - a text ):
[ PHR_948_r132  
    t_0 ! Call parameter 't': text
    ;
    ! [2: if debug is true]
    if (((((Global_Vars-->16) && true) == (1 && true))))
    {! [3: say ~*** [t][line break]~]
        say__p=1;! [4: ~*** ~]
        ParaContent(); print "*** ";! [5: t]
        ParaContent(); print (TEXT_TY_Say) t_0;! [6: line break]
        ParaContent(); new_line; .L_Say842; .L_SayX833;}
        rfalse;
];
! From "Essentials" by Philip Riley
! Request 133: phrase thing -> truth state
! To decide whether ( T - a thing ) is here:
[ PHR_952_r133  
    t_0 ! Call parameter 'T': thing
    ;
    ! [2: decide on whether or not t is available]
    return (((((Adj_46_t1_v10(t_0))))));
    return false;
];
! From "Essentials" by Philip Riley
! Request 134: phrase (scene, number) -> time
! To decide what time is ( s - a scene ) plus ( n - a number ):
[ PHR_954_r134  
    t_0 ! Call parameter 's': scene
    t_1 ! Call parameter 'n': number
    ;
    ! [2: decide on n minutes after time when s began]
    return (((SceneUtility(t_0, 2))+((t_1)%(TWENTY_FOUR_HOURS))+TWENTY_FOUR_HOURS)%(TWENTY_FOUR_HOURS));
    return 540;
];
! From "Essentials" by Philip Riley
! Request 135: phrase (scene, number) -> truth state
! To decide whether at ( s - a scene ) plus ( n - a number ):
[ PHR_955_r135  
    t_0 ! Call parameter 's': scene
    t_1 ! Call parameter 'n': number
    ;
    ! [2: if time of day is s plus n]
    if (((the_time == (PHR_959_r137 (t_0,t_1)))))
    {! [3: decide yes]
        rtrue;
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Essentials" by Philip Riley
! Request 136: phrase thing -> room
! To decide what room is the holding room of ( T - a thing ):
[ PHR_956_r136  
    t_0 ! Call parameter 'T': thing
    ;
    ! [2: decide on nothing]
    return CheckKindReturned(nothing, K1_room);
    return I154_room_of_subjects;
];
! From "Essentials" by Philip Riley
! Request 137: phrase (scene, number) -> time
! To decide what time is ( s - a scene ) plus ( n - a number ):
[ PHR_959_r137  
    t_0 ! Call parameter 's': scene
    t_1 ! Call parameter 'n': number
    ;
    ! [2: decide on n minutes after time when s began]
    return (((SceneUtility(t_0, 2))+((t_1)%(TWENTY_FOUR_HOURS))+TWENTY_FOUR_HOURS)%(TWENTY_FOUR_HOURS));
    return 540;
];
! From "Essentials" by Philip Riley
! Request 138: phrase (scene, number) -> truth state
! To decide whether at ( s - a scene ) plus ( n - a number ):
[ PHR_960_r138  
    t_0 ! Call parameter 's': scene
    t_1 ! Call parameter 'n': number
    ;
    ! [2: if time of day is s plus n]
    if (((the_time == (PHR_959_r137 (t_0,t_1)))))
    {! [3: decide yes]
        rtrue;
        }
    ! [4: decide no]
    rfalse;
    return false;
];
! From "Essentials" by Philip Riley
! Request 139: phrase (room, text) -> nothing
! To print in ( R - a room ) that ( T - a text ):
[ PHR_966_r139  
    t_0 ! Call parameter 'R': room
    t_1 ! Call parameter 'T': text
    ;
    ! [2: if location is r]
    if (((real_location == t_0)))
    {! [3: say t]
        say__p=1;! [4: t]
        ParaContent(); print (TEXT_TY_Say) t_1; .L_Say843; .L_SayX834;}
        rfalse;
];
! From "Facts" by Philip Riley
! Request 140: phrase fact -> nothing
! To say forget ( target - a fact ):
[ PHR_976_r140  
    t_0 ! Call parameter 'target': fact
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    ! [2: repeat with listener running through people who can see the person asked]
    for (tmp_0=Prop_124(0), tmp_1=Prop_124(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_124(tmp_1))
    {! [3: now the listener does not know the target]
        (RGuard_MF_2(tmp_0,t_0));
        }
        rfalse;
];
! From "Door Utils" by Philip Riley
! Request 141: phrase door -> nothing
! To say state of ( D - a door ):
[ PHR_1044_r141  
    t_0 ! Call parameter 'D': door
    ;
    ! [2: say ~It is ~]
    say__p=1;! [3: ~It is ~]
    ParaContent(); print "It is "; .L_Say844; .L_SayX835;! [4: if d is closed]
    if ((((Adj_102_t1_v10(t_0)))))
    {! [5: say ~closed~]
        say__p=1;! [6: ~closed~]
        ParaContent(); print "closed"; .L_Say845; .L_SayX836;! [7: if d is locked]
        if ((((Adj_106_t1_v10(t_0)))))
        {! [8: say ~ and locked~]
            say__p=1;! [9: ~ and locked~]
            ParaContent(); print " and locked"; .L_Say846; .L_SayX837;}
        ! [10: say ~.[line break]~]
        say__p=1;! [11: ~.~]
        ParaContent(); print ".";! [12: line break]
        ParaContent(); new_line; .L_Say847; .L_SayX838;} else {
        ! [13: say ~open.~]
        say__p=1;! [14: ~open.~]
        ParaContent(); print "open."; new_line; .L_Say848; .L_SayX839;}
        rfalse;
];
! From "Real People" by Philip Riley
! Request 142: phrase (person, behavior) -> truth state
! To decide whether ( P - a person ) stashed ( b - a behavior ):
[ PHR_1047_r142  
    t_0 ! Call parameter 'P': person
    t_1 ! Call parameter 'b': behavior
    ;
    ! [2: if b is listed in the behavior stack of p and entry 1 of behavior stack of p is not b]
    if ((((LIST_OF_TY_FindItem(GProperty(10, t_0,p22_behavior_stack), t_1)))) && (((~~((LIST_OF_TY_GetItem(GProperty(10, t_0,p22_behavior_stack),1) == t_1))))))
    {! [3: decide on true]
        return 1;
        }
    ! [4: decide on false]
    return 0;
    return false;
];
! From "Real People" by Philip Riley
! Request 143: phrase (behavior, person) -> nothing
! To resume ( b - a behavior ) for ( P - a person ):
[ PHR_1048_r143  
    t_0 ! Call parameter 'b': behavior
    t_1 ! Call parameter 'P': person
    ;
    ! [2: while entry 1 of the behavior stack of p is not b]
    while (((~~((LIST_OF_TY_GetItem(GProperty(10, t_1,p22_behavior_stack),1) == t_0)))))
    {! [3: follow the termination rules for p]
        FollowRulebook(450, t_1, true);
        ! [4: remove entry 1 from behavior stack of p]
        LIST_OF_TY_RemoveItemRange(GProperty(10, t_1,p22_behavior_stack), 1, 1, 0);
        }
        rfalse;
];
! From "Real People" by Philip Riley
! Request 144: phrase (person, behavior) -> truth state
! To decide whether ( P - a person ) acts like ( b - a behavior ):
[ PHR_1052_r144  
    t_0 ! Call parameter 'P': person
    t_1 ! Call parameter 'b': behavior
    ;
    ! [2: decide on whether or not the current behavior of p is b]
    return (((((PHR_1053_r62 (t_0)) == t_1))));
    return false;
];
! From "PBR Common" by Philip Riley
! Request 145: phrase text -> text
! To decide what text is the real sentence case of ( T - a text ):
[ PHR_1059_r145  I7RBLK 
    t_0 ! Call parameter 'T': text
;
    @push I7SFRAME;
    StackFrameCreate(10);
    BlkValueCreateOnStack(8, TEXT_TY);
    BlkValueCreateOnStack(6, TEXT_TY);
    BlkValueCreateOnStack(4, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_99(t_0));
    BlkValueFreeOnStack(8);
    BlkValueFreeOnStack(6);
    BlkValueFreeOnStack(4);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! text
];
[ KERNEL_99 
    t_0 ! Call parameter 'T': text
    tmp_0 ! Let/loop value, e.g., 'X': text
    tmp_1 ! Let/loop value, e.g., 'T2': text
    ;
    ! [2: let x be ( character number 1 in t ) in upper case]
    tmp_0 = I7SFRAME; 
    		BlkValueCopy(tmp_0, TEXT_TY_CharactersToCase((I7SFRAME+WORDSIZE*2), TEXT_TY_GetBlob((I7SFRAME+WORDSIZE*4), t_0, 1, CHR_BLOB), 1));
    ! [3: let t2 be t]
    tmp_1 = (I7SFRAME+WORDSIZE*6); 
    		BlkValueCopy(tmp_1, t_0);
    ! [4: replace character number 1 in t2 with x]
    TEXT_TY_ReplaceBlob(CHR_BLOB, tmp_1, 1, tmp_0);
    ! [5: decide on t2]
    return BlkValueCopy((I7SFRAME+WORDSIZE*8), tmp_1);
    return BC_3087;
];
! From "Walls" by Philip Riley
! Request 146: phrase room -> text
! To decide what text is the wall description for ( R - a room ):
[ PHR_1063_r146  I7RBLK 
    t_0 ! Call parameter 'R': room
;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_100(t_0));
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! text
];
[ KERNEL_100 
    t_0 ! Call parameter 'R': room
    ;
    ! [2: decide on the text produced by the wall description rules for r]
    return BlkValueCopy(I7SFRAME, ResultOfRule(RULEBOOK_TY_to_RULE_TY(457), t_0, true, TEXT_TY));
    return BC_3088;
];
! From "Walls" by Philip Riley
! Request 147: phrase room -> text
! To decide what text is the wall touch description for ( R - a room ):
[ PHR_1066_r147  I7RBLK 
    t_0 ! Call parameter 'R': room
;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_101(t_0));
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! text
];
[ KERNEL_101 
    t_0 ! Call parameter 'R': room
    ;
    ! [2: decide on the text produced by the wall touch description rules for r]
    return BlkValueCopy(I7SFRAME, ResultOfRule(RULEBOOK_TY_to_RULE_TY(458), t_0, true, TEXT_TY));
    return BC_3089;
];
! From "Floors" by Philip Riley
! Request 148: phrase room -> text
! To decide what text is the floor description for ( R - a room ):
[ PHR_1077_r148  I7RBLK 
    t_0 ! Call parameter 'R': room
;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_102(t_0));
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! text
];
[ KERNEL_102 
    t_0 ! Call parameter 'R': room
    ;
    ! [2: decide on the text produced by the floor description rules for r]
    return BlkValueCopy(I7SFRAME, ResultOfRule(RULEBOOK_TY_to_RULE_TY(459), t_0, true, TEXT_TY));
    return BC_3090;
];
! From "Ceilings" by Philip Riley
! Request 149: phrase room -> text
! To decide what text is the ceiling description for ( R - a room ):
[ PHR_1092_r149  I7RBLK 
    t_0 ! Call parameter 'R': room
;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_103(t_0));
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! text
];
[ KERNEL_103 
    t_0 ! Call parameter 'R': room
    ;
    ! [2: decide on the text produced by the ceiling description rules for r]
    return BlkValueCopy(I7SFRAME, ResultOfRule(RULEBOOK_TY_to_RULE_TY(461), t_0, true, TEXT_TY));
    return BC_3091;
];
! From "Can't Take That" by Philip Riley
! Request 150: phrase thing -> text
! To decide what text is the can't take message of ( T - a thing ):
[ PHR_1109_r150  I7RBLK 
    t_0 ! Call parameter 'T': thing
;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_104(t_0));
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! text
];
[ KERNEL_104 
    t_0 ! Call parameter 'T': thing
    ;
    ! [2: decide on the text produced by the can't take that rules for t]
    return BlkValueCopy(I7SFRAME, ResultOfRule(RULEBOOK_TY_to_RULE_TY(464), t_0, true, TEXT_TY));
    return BC_3092;
];
! From "Can't Take That" by Philip Riley
! Request 151: phrase thing -> text
! To decide what text is the can't move message of ( T - a thing ):
[ PHR_1111_r151  I7RBLK 
    t_0 ! Call parameter 'T': thing
;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_105(t_0));
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! text
];
[ KERNEL_105 
    t_0 ! Call parameter 'T': thing
    ;
    ! [2: decide on the text produced by the can't move that rules for t]
    return BlkValueCopy(I7SFRAME, ResultOfRule(RULEBOOK_TY_to_RULE_TY(465), t_0, true, TEXT_TY));
    return BC_3093;
];
! From "Complex Listing" by Emily Short
! Request 152: phrase table name -> nothing
! To empty out ( selected table - a table-name ):
[ PHR_1112_r152  
    t_0 ! Call parameter 'selected table': table name
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    ! [2: repeat through selected table]
    @push ct_0; @push ct_1;
    		for (tmp_0=t_0, tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [3: blank out the whole row]
        TableBlankOutRow(ct_0, ct_1);
        }
        @pull ct_1; @pull ct_0;rfalse;
];
! From "Complex Listing" by Emily Short
! Request 153: phrase description of objects -> nothing
! To prepare a/the/-- list of ( selection - description of objects ):
[ PHR_1113_r153  
    t_0 ! Call parameter 'selection': description of objects
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    ! [2: now every thing is unmarked for special listing]
    Prop_125();
    ! [3: now every direction is unmarked for special listing]
    Prop_126();
    ! [4: now every room is unmarked for special listing]
    Prop_127();
    ! [5: now every region is unmarked for special listing]
    Prop_128();
    ! [6: repeat with item running through members of the selection]
    for (tmp_0=(t_0)(-2,0), tmp_1=(t_0)(-2,tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=(t_0)(-2,tmp_1))
    {! [7: now the item is marked for special listing]
        (Adj_145_t2_v10(tmp_0));
        }
    ! [8: register things marked for listing]
    (PHR_1114_r154 ());
    rfalse;
];
! From "Complex Listing" by Emily Short
! Request 154: phrase nothing -> nothing
! To register the/-- things marked for listing:
[ PHR_1114_r154  
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: empty out the table of scored listing]
    (PHR_1112_r152 (T10_scored_listing));
    ! [3: repeat with item running through directions which are marked for special listing]
    for (tmp_0=Prop_129(0), tmp_1=Prop_129(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_129(tmp_1))
    {! [4: choose a blank row in the table of scored listing]
        ct_0 = T10_scored_listing; ct_1 = TableBlankRow(ct_0);
        ! [5: now output entry is the item]
        TableLookUpEntry(ct_0,138,ct_1,1,tmp_0);
        ! [6: now item is unmarked for special listing]
        (Adj_146_t2_v10(tmp_0));
        }
    ! [7: repeat with item running through rooms which are marked for special listing]
    for (tmp_0=Prop_130(0), tmp_1=Prop_130(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_130(tmp_1))
    {! [8: choose a blank row in the table of scored listing]
        ct_0 = T10_scored_listing; ct_1 = TableBlankRow(ct_0);
        ! [9: now output entry is the item]
        TableLookUpEntry(ct_0,138,ct_1,1,tmp_0);
        ! [10: now item is unmarked for special listing]
        (Adj_146_t2_v10(tmp_0));
        }
    ! [11: repeat with item running through things which are marked for special listing]
    for (tmp_0=Prop_131(0), tmp_1=Prop_131(tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_131(tmp_1))
    {! [12: choose a blank row in the table of scored listing]
        ct_0 = T10_scored_listing; ct_1 = TableBlankRow(ct_0);
        ! [13: now output entry is the item]
        TableLookUpEntry(ct_0,138,ct_1,1,tmp_0);
        ! [14: now item is unmarked for special listing]
        (Adj_146_t2_v10(tmp_0));
        }
        rfalse;
];
! From "Complex Listing" by Emily Short
! Request 155: phrase nothing -> nothing
! To say is-are the prepared list:
[ PHR_1115_r155  ;
    ! [2: now current articulation style is definite]
    (Global_Vars-->22) = I197_definite;
    ! [3: say tabled verb]
    say__p=1;! [4: tabled verb]
    ParaContent(); (PHR_1118_r158 ()); .L_Say849; .L_SayX840;! [5: say prepared list]
    say__p=1;! [6: prepared list]
    ParaContent(); (PHR_1121_r161 ()); .L_Say850; .L_SayX841;rfalse;
];
! From "Complex Listing" by Emily Short
! Request 156: phrase nothing -> nothing
! To say is-are a prepared list:
[ PHR_1116_r156  ;
    ! [2: now current articulation style is indefinite]
    (Global_Vars-->22) = I198_indefinite;
    ! [3: say tabled verb]
    say__p=1;! [4: tabled verb]
    ParaContent(); (PHR_1118_r158 ()); .L_Say851; .L_SayX842;! [5: say prepared list]
    say__p=1;! [6: prepared list]
    ParaContent(); (PHR_1121_r161 ()); .L_Say852; .L_SayX843;rfalse;
];
! From "Complex Listing" by Emily Short
! Request 157: phrase nothing -> nothing
! To say is-are prepared list:
[ PHR_1117_r157  ;
    ! [2: now current articulation style is bare]
    (Global_Vars-->22) = I196_bare;
    ! [3: say tabled verb]
    say__p=1;! [4: tabled verb]
    ParaContent(); (PHR_1118_r158 ()); .L_Say853; .L_SayX844;! [5: say prepared list]
    say__p=1;! [6: prepared list]
    ParaContent(); (PHR_1121_r161 ()); .L_Say854; .L_SayX845;rfalse;
];
! From "Complex Listing" by Emily Short
! Request 158: phrase nothing -> nothing
! To say tabled verb:
[ PHR_1118_r158  ;
    ! [2: if the number of filled rows in the table of scored listing is greater than 1]
    if (((TableFilledRows(T10_scored_listing) > 1)))
    {! [3: say ~are ~]
        say__p=1;! [4: ~are ~]
        ParaContent(); print "are "; .L_Say855; .L_SayX846;} else {
        ! [5: say ~is ~]
        say__p=1;! [6: ~is ~]
        ParaContent(); print "is "; .L_Say856; .L_SayX847;}
        rfalse;
];
! From "Complex Listing" by Emily Short
! Request 159: phrase nothing -> nothing
! To say the prepared list:
[ PHR_1119_r159  ;
    ! [2: now current articulation style is definite]
    (Global_Vars-->22) = I197_definite;
    ! [3: say prepared list]
    say__p=1;! [4: prepared list]
    ParaContent(); (PHR_1121_r161 ()); .L_Say857; .L_SayX848;rfalse;
];
! From "Complex Listing" by Emily Short
! Request 160: phrase nothing -> nothing
! To say a prepared list:
[ PHR_1120_r160  ;
    ! [2: now current articulation style is indefinite]
    (Global_Vars-->22) = I198_indefinite;
    ! [3: say prepared list]
    say__p=1;! [4: prepared list]
    ParaContent(); (PHR_1121_r161 ()); .L_Say858; .L_SayX849;rfalse;
];
! From "Complex Listing" by Emily Short
! Request 161: phrase nothing -> nothing
! To say prepared list:
[ PHR_1121_r161  ;
    ! [2: if the number of filled rows in the table of scored listing is 0]
    if (((TableFilledRows(T10_scored_listing) == 0)))
    {! [3: say ~nothing~]
        say__p=1;! [4: ~nothing~]
        ParaContent(); print "nothing"; .L_Say859; .L_SayX850;! [5: rule fails]
        RulebookFails(); rtrue;
        }
    ! [6: dump list]
    (PHR_1128_r167 ());
    ! [7: now current articulation style is bare]
    (Global_Vars-->22) = I196_bare;
    rfalse;
];
! From "Complex Listing" by Emily Short
! Request 162: phrase list style -> nothing
! To say prepared list delimited in ( chosen style - a list style ) style:
[ PHR_1122_r162  
    t_0 ! Call parameter 'chosen style': list style
    ;
    ! [2: now current articulation style is indefinite]
    (Global_Vars-->22) = I198_indefinite;
    ! [3: now current list style is the chosen style]
    (Global_Vars-->26) = t_0;
    ! [4: say prepared list]
    say__p=1;! [5: prepared list]
    ParaContent(); (PHR_1121_r161 ()); .L_Say860; .L_SayX851;rfalse;
];
! From "Complex Listing" by Emily Short
! Request 163: phrase list style -> nothing
! To say a prepared list delimited in ( chosen style - a list style ) style:
[ PHR_1123_r163  
    t_0 ! Call parameter 'chosen style': list style
    ;
    ! [2: now current articulation style is indefinite]
    (Global_Vars-->22) = I198_indefinite;
    ! [3: now current list style is the chosen style]
    (Global_Vars-->26) = t_0;
    ! [4: say prepared list]
    say__p=1;! [5: prepared list]
    ParaContent(); (PHR_1121_r161 ()); .L_Say861; .L_SayX852;rfalse;
];
! From "Complex Listing" by Emily Short
! Request 164: phrase list style -> nothing
! To say is-are prepared list delimited in ( chosen style - a list style ) style:
[ PHR_1125_r164  
    t_0 ! Call parameter 'chosen style': list style
    ;
    ! [2: now current articulation style is indefinite]
    (Global_Vars-->22) = I198_indefinite;
    ! [3: now current list style is the chosen style]
    (Global_Vars-->26) = t_0;
    ! [4: say tabled verb]
    say__p=1;! [5: tabled verb]
    ParaContent(); (PHR_1118_r158 ()); .L_Say862; .L_SayX853;! [6: say prepared list]
    say__p=1;! [7: prepared list]
    ParaContent(); (PHR_1121_r161 ()); .L_Say863; .L_SayX854;rfalse;
];
! From "Complex Listing" by Emily Short
! Request 165: phrase list style -> nothing
! To say is-are a prepared list delimited in ( chosen style - a list style ) style:
[ PHR_1126_r165  
    t_0 ! Call parameter 'chosen style': list style
    ;
    ! [2: now current articulation style is indefinite]
    (Global_Vars-->22) = I198_indefinite;
    ! [3: now current list style is the chosen style]
    (Global_Vars-->26) = t_0;
    ! [4: say tabled verb]
    say__p=1;! [5: tabled verb]
    ParaContent(); (PHR_1118_r158 ()); .L_Say864; .L_SayX855;! [6: say prepared list]
    say__p=1;! [7: prepared list]
    ParaContent(); (PHR_1121_r161 ()); .L_Say865; .L_SayX856;rfalse;
];
! From "Complex Listing" by Emily Short
! Request 166: phrase list style -> nothing
! To say is-are the prepared list delimited in ( chosen style - a list style ) style:
[ PHR_1127_r166  
    t_0 ! Call parameter 'chosen style': list style
    ;
    ! [2: now current articulation style is definite]
    (Global_Vars-->22) = I197_definite;
    ! [3: now current list style is the chosen style]
    (Global_Vars-->26) = t_0;
    ! [4: say tabled verb]
    say__p=1;! [5: tabled verb]
    ParaContent(); (PHR_1118_r158 ()); .L_Say866; .L_SayX857;! [6: say prepared list]
    say__p=1;! [7: prepared list]
    ParaContent(); (PHR_1121_r161 ()); .L_Say867; .L_SayX858;rfalse;
];
! From "Complex Listing" by Emily Short
! Request 167: phrase nothing -> nothing
! To dump list:
[ PHR_1128_r167  ;
    ! [2: carry out the list arranging activity]
    CarryOutActivity(V43_list_arranging);
    ! [3: say list of the table of scored listing]
    say__p=1;! [4: list of the table of scored listing]
    ParaContent(); (PHR_1133_r171 (T10_scored_listing)); .L_Say868; .L_SayX859;! [5: now current list style is sequential]
    (Global_Vars-->26) = I200_sequential;
    ! [6: empty out table of scored listing]
    (PHR_1112_r152 (T10_scored_listing));
    rfalse;
];
! From "Complex Listing" by Emily Short
! Request 168: phrase nothing -> nothing
! To invert scored list:
[ PHR_1130_r168  ;
    ! [2: sort table of scored listing in reverse assigned score order]
    TableSort(T10_scored_listing, 139, -1);
    rfalse;
];
! From "Complex Listing" by Emily Short
! Request 169: phrase nothing -> number
! To decide what number is the current enumeration:
[ PHR_1131_r169  
    tmp_0 ! Let/loop value, e.g., 'N': number
    ;
    ! [2: let n be 1 + current listing total]

    		tmp_0 = (1 + (Global_Vars-->27));
    ! [3: decrease n by current listing index]
    tmp_0 = tmp_0 - (Global_Vars-->28);;
    ! [4: decide on n]
    return tmp_0;
    return 0;
];
! From "Complex Listing" by Emily Short
! Request 170: phrase nothing -> nothing
! To order list by length:
[ PHR_1132_r170  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_106();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_106 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: repeat through table of scored listing]
    @push ct_0; @push ct_1;
    		for (tmp_0=T10_scored_listing, tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [3: let name be the printed name of the output entry]
        tmp_2 = I7SFRAME; 
        		BlkValueCopy(tmp_2, GProperty(OBJECT_TY, TableLookUpEntry(ct_0,138,ct_1),short_name));
        ! [4: let count be the number of characters in name]

        		tmp_3 = TEXT_TY_BlobAccess(tmp_2, CHR_BLOB);
        ! [5: now assigned score entry is count]
        TableLookUpEntry(ct_0,139,ct_1,1,tmp_3);
        }
        @pull ct_1; @pull ct_0;rfalse;
];
! From "Complex Listing" by Emily Short
! Request 171: phrase table name -> nothing
! To say a/the/-- list of ( selected table - a table-name ):
[ PHR_1133_r171  
    t_0 ! Call parameter 'selected table': table name
I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_107(t_0);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_107 
    t_0 ! Call parameter 'selected table': table name
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ! [2: now current listing total is the number of filled rows in the selected table]
    (Global_Vars-->27) = TableFilledRows(t_0);
    ! [3: now current listing index is current listing total]
    (Global_Vars-->28) = (Global_Vars-->27);
    ! [4: repeat through selected table]
    @push ct_0; @push ct_1;
    		for (tmp_0=t_0, tmp_1=1, ct_0=tmp_0, ct_1=tmp_1:
    			tmp_1<=TableRows(tmp_0):
    			tmp_1++, ct_0=tmp_0, ct_1=tmp_1)
    			if (TableRowIsBlank(ct_0, ct_1)==false)
    {! [5: now current listed object is output entry]
        (Global_Vars-->29) = TableLookUpEntry(ct_0,138,ct_1);
        ! [6: let wording be ~~]
        tmp_2 = I7SFRAME; 
        		BlkValueCopy(tmp_2, EMPTY_TEXT_VALUE);
        ! [7: if the current articulation style is definite]
        if ((((Global_Vars-->22) == I197_definite)))
        {! [8: let wording be the definite name phrase corresponding to a list style of the current list style in the table of list style assignments]
            BlkValueCopy(tmp_2, TableLookUpCorr(T11_list_style_assignments,145,140,(Global_Vars-->26)));
            } else {
            ! [9: let wording be the indefinite name phrase corresponding to a list style of the current list style in the table of list style assignments]
            BlkValueCopy(tmp_2, TableLookUpCorr(T11_list_style_assignments,144,140,(Global_Vars-->26)));
            }
        ! [10: if the current listed object is a direction]
        if ((((Global_Vars-->29) ofclass K3_direction)))
        {! [11: say ~[current listed object]~]
            say__p=1;! [12: current listed object]
            ParaContent(); PrintShortName((Global_Vars-->29)); .L_Say869; .L_SayX860;} else {
            ! [13: if the current articulation style is bare]
            if ((((Global_Vars-->22) == I196_bare)))
            {! [14: say ~[current listed object]~]
                say__p=1;! [15: current listed object]
                ParaContent(); PrintShortName((Global_Vars-->29)); .L_Say870; .L_SayX861;} else {
                ! [16: say ~[wording]~]
                say__p=1;! [17: wording]
                ParaContent(); print (TEXT_TY_Say) tmp_2; .L_Say871; .L_SayX862;}
                }
        ! [18: decrease current listing index by 1]
        (Global_Vars-->28) = (Global_Vars-->28) - 1;;
        ! [19: carry out the delimiting a list activity]
        CarryOutActivity(V44_delimiting_a_list);
        }
        @pull ct_1; @pull ct_0;rfalse;
];
! From "Exit Lister" by Eric Eve
! Request 172: phrase nothing -> nothing
! To say exit list:
[ PHR_1143_r172  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = KERNEL_108();
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_108 
    tmp_0 ! Let/loop value, e.g., 'exits count': number
    tmp_1 ! Let/loop value, e.g., 'farplace': object
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    ;
    ! [2: let exits count be 0]

    		tmp_0 = 0;
    ! [3: let farplace be location]

    		tmp_1 = real_location;
    ! [4: say ~Exits: ~]
    say__p=1;! [5: ~Exits: ~]
    ParaContent(); print "Exits: "; .L_Say872; .L_SayX863;! [6: repeat with way running through directions]
    for (tmp_2=Prop_132(0), tmp_3=Prop_132(tmp_2): tmp_2: tmp_2=tmp_3, tmp_3=Prop_132(tmp_3))
    {! [7: let farplace be the room way from the location]
        tmp_1 = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par1 ofclass K1_room) && (formal_par1 ofclass K1_room))))) && ((
                        formal_rv = MapConnection(formal_par1,formal_par0)) | 1)
                        )|| (ArgumentTypeFailed(89, 43))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = real_location) +
                    (formal_par0 = tmp_2)
                    ))
            )

        ! Resolution complete
        ;
        ! [8: now direction-object is the room-or-door way from the location]
        (Global_Vars-->35) = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par1 ofclass K1_room) && (formal_par1 ofclass K1_room))))) && ((
                        formal_rv = RoomOrDoorFrom(formal_par1,formal_par0)) | 1)
                        )|| (ArgumentTypeFailed(90, 43))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = real_location) +
                    (formal_par0 = tmp_2)
                    ))
            )

        ! Resolution complete
        ;
        ! [9: if direction-object is apparent and farplace is not darkness-occluded]
        if (((((Adj_58_t1_v10((Global_Vars-->35)))))) && (((~~(((Adj_60_t1_v10(tmp_1))))))))
        {! [10: increase the exits count by 1]
            tmp_0 = tmp_0 + 1;;
            ! [11: if farplace is unvisited and indicate-unvisited is show-unvisited]
            if (((((Adj_81_t1_v10(tmp_1))))) && ((((Global_Vars-->34) == I213_show_unvisited))))
            {! [12: say ~[unvisited-mark][u-v way][end-unvisited-mark]~]
                say__p=1;! [13: unvisited-mark]
                ParaContent(); (PHR_1163_r180 ());! [14: u-v way]
                ParaContent(); (PHR_1165_r182 (tmp_2));! [15: end-unvisited-mark]
                ParaContent(); (PHR_1164_r181 ()); .L_Say873; .L_SayX864;} else {
                ! [16: say ~[way]~]
                say__p=1;! [17: way]
                ParaContent(); PrintShortName(tmp_2); .L_Say874; .L_SayX865;}
            ! [18: say ~ ~]
            say__p=1;! [19: ~ ~]
            ParaContent(); print " "; .L_Say875; .L_SayX866;}
            }
    ! [20: if exits count is 0]
    if (((tmp_0 == 0)))
    {! [21: say ~[italic type][no-exits][roman type]~]
        say__p=1;! [22: italic type]
        ParaContent(); (PHR_353_r9 ());! [23: no-exits]
        ParaContent(); (PHR_1145_r174 ());! [24: roman type]
        ParaContent(); (PHR_354_r3 ()); .L_Say876; .L_SayX867;}
        rfalse;
];
! From "Exit Lister" by Eric Eve
! Request 173: phrase nothing -> list of directions
! To decide what list of directions is the exit list:
[ PHR_1144_r173  I7RBLK ;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(1, KD7_list_of_directions);
    BlkValueCreateOnStack(0, KD7_list_of_directions);
    @push formal_par0;
    @push formal_par1;
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_109());
    @pull formal_par1;
    @pull formal_par0;
    BlkValueFreeOnStack(1);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! list of directions
];
[ KERNEL_109 
    tmp_0 ! Let/loop value, e.g., 'result': list of directions
    tmp_1 ! Let/loop value, e.g., 'farplace': object
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    tmp_3 ! Let/loop value (deallocated by end of phrase)
    ;
    ! [2: let result be a list of directions]
    tmp_0 = I7SFRAME; 
    		
    ! [3: let farplace be location]

    		tmp_1 = real_location;
    ! [4: repeat with way running through directions]
    for (tmp_2=Prop_133(0), tmp_3=Prop_133(tmp_2): tmp_2: tmp_2=tmp_3, tmp_3=Prop_133(tmp_3))
    {! [5: let farplace be the room way from the location]
        tmp_1 = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par1 ofclass K1_room) && (formal_par1 ofclass K1_room))))) && ((
                        formal_rv = MapConnection(formal_par1,formal_par0)) | 1)
                        )|| (ArgumentTypeFailed(107, 43))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = real_location) +
                    (formal_par0 = tmp_2)
                    ))
            )

        ! Resolution complete
        ;
        ! [6: now direction-object is the room-or-door way from the location]
        (Global_Vars-->35) = 
        ! Resolution of run-time phrase ambiguity (deciding a value):
            (
                ! This value evaluates third (i.e., last)
                formal_rv
            +
                0*(
                    ! The following condition evaluates second
                    ((
                        ((((((formal_par1 ofclass K1_room) && (formal_par1 ofclass K1_room))))) && ((
                        formal_rv = RoomOrDoorFrom(formal_par1,formal_par0)) | 1)
                        )|| (ArgumentTypeFailed(108, 43))

                    ))
                +
                    ! The following assignments evaluate first
                    ((formal_par1 = real_location) +
                    (formal_par0 = tmp_2)
                    ))
            )

        ! Resolution complete
        ;
        ! [7: if direction-object is apparent and farplace is not darkness-occluded]
        if (((((Adj_58_t1_v10((Global_Vars-->35)))))) && (((~~(((Adj_60_t1_v10(tmp_1))))))))
        {! [8: add way to result]
            LIST_OF_TY_InsertItem(tmp_0, tmp_2, 0, 0, 0);
            }
            }
    ! [9: decide on result]
    return BlkValueCopy((I7SFRAME+WORDSIZE), tmp_0);
    return BC_3094;
];
! From "Exit Lister" by Eric Eve
! Request 174: phrase nothing -> nothing
! To say no-exits:
[ PHR_1145_r174  ;
    ! [2: say ~None~]
    say__p=1;! [3: ~None~]
    ParaContent(); print "None"; .L_Say877; .L_SayX868;rfalse;
];
! From "Exit Lister" by Eric Eve
! Request 175: phrase nothing -> nothing
! To say list the exits:
[ PHR_1152_r175  ;
    ! [2: list the exits]
    (PHR_1151_r65 ());
    rfalse;
];
! From "Exit Lister" by Eric Eve
! Request 176: phrase nothing -> nothing
! To say no-obvious-exits:
[ PHR_1153_r176  ;
    ! [2: say ~There are no obvious exits.~]
    say__p=1;! [3: ~There are no obvious exits.~]
    ParaContent(); print "There are no obvious exits."; new_line; .L_Say878; .L_SayX869;rfalse;
];
! From "Exit Lister" by Eric Eve
! Request 177: phrase nothing -> nothing
! To say only-obvious-exit:
[ PHR_1154_r177  ;
    ! [2: say ~The only obvious exit is~]
    say__p=1;! [3: ~The only obvious exit is~]
    ParaContent(); print "The only obvious exit is"; .L_Say879; .L_SayX870;rfalse;
];
! From "Exit Lister" by Eric Eve
! Request 178: phrase nothing -> nothing
! To say obvious-exits:
[ PHR_1155_r178  ;
    ! [2: say ~The obvious exits are~]
    say__p=1;! [3: ~The obvious exits are~]
    ParaContent(); print "The obvious exits are"; .L_Say880; .L_SayX871;rfalse;
];
! From "Exit Lister" by Eric Eve
! Request 179: phrase nothing -> nothing
! To say and-conjunction:
[ PHR_1156_r179  ;
    ! [2: say ~and~]
    say__p=1;! [3: ~and~]
    ParaContent(); print "and"; .L_Say881; .L_SayX872;rfalse;
];
! From "Exit Lister" by Eric Eve
! Request 180: phrase nothing -> nothing
! to say unvisited-mark:
[ PHR_1163_r180  ;
    ! [2: say ~[exit-marker]~]
    say__p=1;! [3: exit-marker]
    ParaContent(); print (TEXT_TY_Say) (Global_Vars-->39); .L_Say882; .L_SayX873;rfalse;
];
! From "Exit Lister" by Eric Eve
! Request 181: phrase nothing -> nothing
! to say end-unvisited-mark:
[ PHR_1164_r181  ;
    ! [2: say ~[exit-marker]~]
    say__p=1;! [3: exit-marker]
    ParaContent(); print (TEXT_TY_Say) (Global_Vars-->39); .L_Say883; .L_SayX874;rfalse;
];
! From "Exit Lister" by Eric Eve
! Request 182: phrase direction -> nothing
! to say u-v ( way - a direction ):
[ PHR_1165_r182  
    t_0 ! Call parameter 'way': direction
I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(6);
    BlkValueCreateOnStack(4, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_110(t_0);
    BlkValueFreeOnStack(4);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_110 
    t_0 ! Call parameter 'way': direction
    tmp_0 ! Let/loop value, e.g., 'cap-way': text
    ;
    ! [2: let cap-way be ~[way]~]
    tmp_0 = I7SFRAME; 
    		BlkValueCopy(tmp_0, ((LocalParking-->0=t_0),(LocalParking-->1=tmp_0),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*2),TX_S_586)));
    ! [3: say ~[cap-way in upper case] ~]
    say__p=1;! [4: cap-way in upper case]
    ParaContent(); print (TEXT_TY_Say) TEXT_TY_CharactersToCase((I7SFRAME+WORDSIZE*4), tmp_0, 1);! [5: ~ ~]
    ParaContent(); print " "; .L_Say884; .L_SayX875;rfalse;
];
! From "Choices" by Philip Riley
! Request 183: phrase list of objects -> nothing
! To prepare a/the/-- list of ( selection - list of objects ):
[ PHR_1174_r183  
    t_0 ! Call parameter 'selection': list of objects
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value: number
    ;
    ! [2: now every thing is unmarked for special listing]
    Prop_134();
    ! [3: now every direction is unmarked for special listing]
    Prop_135();
    ! [4: now every room is unmarked for special listing]
    Prop_136();
    ! [5: now every region is unmarked for special listing]
    Prop_137();
    ! [6: repeat with item running through selection]
    for (tmp_2=t_0, tmp_1=1, tmp_0=LIST_OF_TY_GetItem(tmp_2, tmp_1, true): tmp_1<=LIST_OF_TY_GetLength(tmp_2): tmp_1++, tmp_0=LIST_OF_TY_GetItem(tmp_2, tmp_1, true))
    {! [7: now the item is marked for special listing]
        (Adj_145_t2_v10(tmp_0));
        }
    ! [8: register things marked for listing]
    (PHR_1114_r154 ());
    rfalse;
];
! From "New Light" by Philip Riley
! Request 184: phrase room -> nothing
! To unlight ( R - a room ):
[ PHR_1180_r184  
    t_0 ! Call parameter 'R': room
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    ! [2: repeat with ls running through light sources in r]
    for (tmp_0=Prop_138(t_0,0), tmp_1=Prop_138(t_0,tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_138(t_0,tmp_1))
    {! [3: now ls is not lit]
        (Adj_82_t3_v10(tmp_0));
        }
        rfalse;
];
! From "New Light" by Philip Riley
! Request 185: phrase room -> nothing
! To light ( R - a room ):
[ PHR_1181_r185  
    t_0 ! Call parameter 'R': room
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    ;
    ! [2: repeat with ls running through light sources in r]
    for (tmp_0=Prop_139(t_0,0), tmp_1=Prop_139(t_0,tmp_0): tmp_0: tmp_0=tmp_1, tmp_1=Prop_139(t_0,tmp_1))
    {! [3: now ls is lit]
        (Adj_82_t2_v10(tmp_0));
        }
        rfalse;
];
! From "Memories" by Philip Riley
! Request 186: phrase person -> nothing
! To print memory list for ( P - a person ):
[ PHR_1187_r186  
    t_0 ! Call parameter 'P': person
    ;
    ! [2: say ~[remembrances of P]~]
    say__p=1;! [3: remembrances of p]
    ParaContent(); @push self; LIST_OF_TY_Say(GProperty(10, self=t_0,p26_remembrances));@pull self;  .L_Say885; .L_SayX876;rfalse;
];
! From "Memories" by Philip Riley
! Request 187: phrase memory -> nothing
! To queue ( M - a memory ):
[ PHR_1189_r187  
    t_0 ! Call parameter 'M': memory
    ;
    ! [2: if m is not listed in memory queue]
    if (((LIST_OF_TY_FindItem((Global_Vars-->42), t_0) == false)))
    {! [3: add m to memory queue]
        LIST_OF_TY_InsertItem((Global_Vars-->42), t_0, 0, 0, 0);
        }
        rfalse;
];
! From "Simple Conversation" by Philip Riley
! Request 188: phrase quip -> truth state
! To decide whether a ( Q - a quip ) is queued-up:
[ PHR_1227_r188  
    t_0 ! Call parameter 'Q': quip
    ;
    ! [2: if the current interlocutor is nothing]
    if ((((Global_Vars-->11) == nothing)))
    {! [3: decide no]
        rfalse;
        }
    ! [4: decide on whether or not q is listed in the queue of the current interlocutor]
    return ((((LIST_OF_TY_FindItem(GProperty(OBJECT_TY, (Global_Vars-->11),p29_queue), t_0)))));
    return false;
];
! From "Hyperspace" by Philip Riley
! Request 189: phrase number -> nothing
! To say symbol for ( N - a number ):
[ PHR_1248_r189  
    t_0 ! Call parameter 'N': number
    ;
    ! [2: if n is 0]
    if (((t_0 == 0)))
    {! [3: say ~[unicode 9674]~]
        say__p=1;! [4: unicode 9674]
        ParaContent(); unicode_temp = 9674; #ifdef TARGET_ZCODE; @print_unicode unicode_temp; #ifnot; @streamunichar unicode_temp; #endif; .L_Say886; .L_SayX877;}
    ! [5: if n is 1]
    if (((t_0 == 1)))
    {! [6: say ~[unicode 9496]~]
        say__p=1;! [7: unicode 9496]
        ParaContent(); unicode_temp = 9496; #ifdef TARGET_ZCODE; @print_unicode unicode_temp; #ifnot; @streamunichar unicode_temp; #endif; .L_Say887; .L_SayX878;}
    ! [8: if n is 2]
    if (((t_0 == 2)))
    {! [9: say ~[unicode 9488]~]
        say__p=1;! [10: unicode 9488]
        ParaContent(); unicode_temp = 9488; #ifdef TARGET_ZCODE; @print_unicode unicode_temp; #ifnot; @streamunichar unicode_temp; #endif; .L_Say888; .L_SayX879;}
    ! [11: if n is 3]
    if (((t_0 == 3)))
    {! [12: say ~[unicode 9484]~]
        say__p=1;! [13: unicode 9484]
        ParaContent(); unicode_temp = 9484; #ifdef TARGET_ZCODE; @print_unicode unicode_temp; #ifnot; @streamunichar unicode_temp; #endif; .L_Say889; .L_SayX880;}
    ! [14: if n is 4]
    if (((t_0 == 4)))
    {! [15: say ~[unicode 9492]~]
        say__p=1;! [16: unicode 9492]
        ParaContent(); unicode_temp = 9492; #ifdef TARGET_ZCODE; @print_unicode unicode_temp; #ifnot; @streamunichar unicode_temp; #endif; .L_Say890; .L_SayX881;}
    ! [17: if n is -1]
    if (((t_0 == -1)))
    {! [18: say ~[unicode 8962]~]
        say__p=1;! [19: unicode 8962]
        ParaContent(); unicode_temp = 8962; #ifdef TARGET_ZCODE; @print_unicode unicode_temp; #ifnot; @streamunichar unicode_temp; #endif; .L_Say891; .L_SayX882;}
        rfalse;
];
! From "Hyperspace" by Philip Riley
! Request 190: phrase number -> nothing
! To say symbol for ( N - a number ):
[ PHR_1255_r190  
    t_0 ! Call parameter 'N': number
    ;
    ! [2: if n is 0]
    if (((t_0 == 0)))
    {! [3: say ~[unicode 9674]~]
        say__p=1;! [4: unicode 9674]
        ParaContent(); unicode_temp = 9674; #ifdef TARGET_ZCODE; @print_unicode unicode_temp; #ifnot; @streamunichar unicode_temp; #endif; .L_Say892; .L_SayX883;}
    ! [5: if n is 1]
    if (((t_0 == 1)))
    {! [6: say ~[unicode 9496]~]
        say__p=1;! [7: unicode 9496]
        ParaContent(); unicode_temp = 9496; #ifdef TARGET_ZCODE; @print_unicode unicode_temp; #ifnot; @streamunichar unicode_temp; #endif; .L_Say893; .L_SayX884;}
    ! [8: if n is 2]
    if (((t_0 == 2)))
    {! [9: say ~[unicode 9488]~]
        say__p=1;! [10: unicode 9488]
        ParaContent(); unicode_temp = 9488; #ifdef TARGET_ZCODE; @print_unicode unicode_temp; #ifnot; @streamunichar unicode_temp; #endif; .L_Say894; .L_SayX885;}
    ! [11: if n is 3]
    if (((t_0 == 3)))
    {! [12: say ~[unicode 9484]~]
        say__p=1;! [13: unicode 9484]
        ParaContent(); unicode_temp = 9484; #ifdef TARGET_ZCODE; @print_unicode unicode_temp; #ifnot; @streamunichar unicode_temp; #endif; .L_Say895; .L_SayX886;}
    ! [14: if n is 4]
    if (((t_0 == 4)))
    {! [15: say ~[unicode 9492]~]
        say__p=1;! [16: unicode 9492]
        ParaContent(); unicode_temp = 9492; #ifdef TARGET_ZCODE; @print_unicode unicode_temp; #ifnot; @streamunichar unicode_temp; #endif; .L_Say896; .L_SayX887;}
    ! [17: if n is -1]
    if (((t_0 == -1)))
    {! [18: say ~[unicode 8962]~]
        say__p=1;! [19: unicode 8962]
        ParaContent(); unicode_temp = 8962; #ifdef TARGET_ZCODE; @print_unicode unicode_temp; #ifnot; @streamunichar unicode_temp; #endif; .L_Say897; .L_SayX888;}
        rfalse;
];
! From "Image Strip" by Philip Riley
! Request 191: phrase (text, number, number, number, number) -> nothing
! To color the/-- graphics window ( gcv - a text ) from ( x - a number ) by ( y - a number ) to ( xx - a number ) by ( yy - a number ):
[ PHR_1329_r191  
    t_0 ! Call parameter 'gcv': text
    t_1 ! Call parameter 'x': number
    t_2 ! Call parameter 'y': number
    t_3 ! Call parameter 'xx': number
    t_4 ! Call parameter 'yy': number
I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_111(t_0, t_1, t_2, t_3, t_4);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_111 
    t_0 ! Call parameter 'gcv': text
    t_1 ! Call parameter 'x': number
    t_2 ! Call parameter 'y': number
    t_3 ! Call parameter 'xx': number
    t_4 ! Call parameter 'yy': number
    tmp_0 ! Let/loop value, e.g., 'numerical gcv': number
    ;
    ! [2: let numerical gcv be the color number of gcv]

    		tmp_0 = GTE_ConvertColour( BlkValueCopy(I7SFRAME, t_0) );
    ! [3: color graphics window numerical gcv from x by y to xx by yy]
    glk_window_fill_rect(gg_picwin, tmp_0 , t_1, t_2, t_3, t_4);
    rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! Request 192: phrase two-sided door -> nothing
! To lock ( TSD - a two-sided door ) from the front:
[ PHR_1369_r192  
    t_0 ! Call parameter 'TSD': two-sided door
    ;
    ! [2: if tsd is front-locks-the-back]
    if ((((Adj_166_t1_v10(t_0)))))
    {! [3: now tsd is back-locked]
        (Adj_161_t2_v10(t_0));
        }
    ! [4: if tsd is front-locks-the-front]
    if ((((Adj_167_t1_v10(t_0)))))
    {! [5: now tsd is front-locked]
        (Adj_160_t2_v10(t_0));
        }
        rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! Request 193: phrase two-sided door -> nothing
! To lock ( TSD - a two-sided door ) from the back:
[ PHR_1370_r193  
    t_0 ! Call parameter 'TSD': two-sided door
    ;
    ! [2: if tsd is back-locks-the-back]
    if ((((Adj_168_t1_v10(t_0)))))
    {! [3: now tsd is back-locked]
        (Adj_161_t2_v10(t_0));
        }
    ! [4: if tsd is back-locks-the-front]
    if ((((Adj_169_t1_v10(t_0)))))
    {! [5: now tsd is front-locked]
        (Adj_160_t2_v10(t_0));
        }
        rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! Request 194: phrase two-sided door -> nothing
! To lock ( TSD - a two-sided door ) in the front:
[ PHR_1371_r194  
    t_0 ! Call parameter 'TSD': two-sided door
    ;
    ! [2: now tsd is front-locked]
    (Adj_160_t2_v10(t_0));
    rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! Request 195: phrase two-sided door -> nothing
! To lock ( TSD - a two-sided door ) in the back:
[ PHR_1372_r195  
    t_0 ! Call parameter 'TSD': two-sided door
    ;
    ! [2: now tsd is back-locked]
    (Adj_161_t2_v10(t_0));
    rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! Request 196: phrase two-sided door -> nothing
! To close ( TSD - a two-sided door ):
[ PHR_1375_r196  
    t_0 ! Call parameter 'TSD': two-sided door
    ;
    ! [2: now tsd is closed]
    (Adj_102_t2_v10(t_0));
    ! [3: if tsd is close-lock-the-back]
    if ((((Adj_170_t1_v10(t_0)))))
    {! [4: lock tsd in the back]
        (PHR_1372_r195 (t_0));
        }
    ! [5: if tsd is close-lock-the-front]
    if ((((Adj_171_t1_v10(t_0)))))
    {! [6: lock tsd in the front]
        (PHR_1371_r194 (t_0));
        }
        rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! Request 197: phrase (door, side, side) -> nothing
! To locking ( D - a door ) from the ( locking-side - a side ) locks the ( locked-side - a side ):
[ PHR_1378_r197  
    t_0 ! Call parameter 'D': door
    t_1 ! Call parameter 'locking-side': side
    t_2 ! Call parameter 'locked-side': side
    ;
    ! [2: if locking-side is front]
    if (((t_1 == I286_front)))
    {! [3: if locked-side is front]
        if (((t_2 == I286_front)))
        {! [4: now d is front-locks-the-front]
            (Adj_167_t2_v10(t_0));
            ! [5: now d is not front-locks-the-back]
            (Adj_166_t3_v10(t_0));
            }
        ! [6: if locked-side is xback]
        if (((t_2 == I287_xback)))
        {! [7: now d is front-locks-the-back]
            (Adj_166_t2_v10(t_0));
            ! [8: now d is not front-locks-the-front]
            (Adj_167_t3_v10(t_0));
            }
            }
    ! [9: if locking-side is xback]
    if (((t_1 == I287_xback)))
    {! [10: if locked-side is front]
        if (((t_2 == I286_front)))
        {! [11: now d is back-locks-the-front]
            (Adj_169_t2_v10(t_0));
            ! [12: now d is not back-locks-the-back]
            (Adj_168_t3_v10(t_0));
            }
        ! [13: if locked-side is xback]
        if (((t_2 == I287_xback)))
        {! [14: now d is back-locks-the-back]
            (Adj_168_t2_v10(t_0));
            ! [15: now d is not back-locks-the-front]
            (Adj_169_t3_v10(t_0));
            }
            }
            rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! Request 198: phrase (door, side) -> nothing
! To locking ( D - a door ) from the ( locking-side - a side ) locks both sides:
[ PHR_1379_r198  
    t_0 ! Call parameter 'D': door
    t_1 ! Call parameter 'locking-side': side
    ;
    ! [2: if locking-side is front]
    if (((t_1 == I286_front)))
    {! [3: now d is front-locks-the-front]
        (Adj_167_t2_v10(t_0));
        ! [4: now d is front-locks-the-back]
        (Adj_166_t2_v10(t_0));
        }
    ! [5: if locking-side is xback]
    if (((t_1 == I287_xback)))
    {! [6: now d is back-locks-the-front]
        (Adj_169_t2_v10(t_0));
        ! [7: now d is back-locks-the-back]
        (Adj_168_t2_v10(t_0));
        }
        rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! Request 199: phrase (door, side) -> nothing
! To ( D - a door ) locks from the ( locking side - a side ):
[ PHR_1380_r199  
    t_0 ! Call parameter 'D': door
    t_1 ! Call parameter 'locking side': side
    ;
    ! [2: locking the d from the locking side locks both sides]
    (PHR_1379_r198 (t_0,t_1));
    rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! Request 200: phrase door -> nothing
! To ( D - a door ) locks from both sides:
[ PHR_1381_r200  
    t_0 ! Call parameter 'D': door
    ;
    ! [2: locking the d from the front locks both sides]
    (PHR_1379_r198 (t_0,I286_front));
    ! [3: locking the d from the xback locks both sides]
    (PHR_1379_r198 (t_0,I287_xback));
    rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! Request 201: phrase (door, side) -> nothing
! To ( D - a door ) opens from the ( opening side - a side ):
[ PHR_1382_r201  
    t_0 ! Call parameter 'D': door
    t_1 ! Call parameter 'opening side': side
    ;
    ! [2: if opening side is front]
    if (((t_1 == I286_front)))
    {! [3: now d is front-openable]
        (Adj_162_t2_v10(t_0));
        ! [4: now d is not back-openable]
        (Adj_163_t3_v10(t_0));
        } else {
        ! [5: now d is back-openable]
        (Adj_163_t2_v10(t_0));
        ! [6: now d is not front-openable]
        (Adj_162_t3_v10(t_0));
        }
        rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! Request 202: phrase door -> nothing
! To ( D - a door ) opens from both sides:
[ PHR_1383_r202  
    t_0 ! Call parameter 'D': door
    ;
    ! [2: now d is front-openable]
    (Adj_162_t2_v10(t_0));
    ! [3: now d is back-openable]
    (Adj_163_t2_v10(t_0));
    rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! Request 203: phrase (door, side) -> nothing
! To ( D - a door ) is locked on the ( lock-side - a side ):
[ PHR_1384_r203  
    t_0 ! Call parameter 'D': door
    t_1 ! Call parameter 'lock-side': side
    ;
    ! [2: if lock-side is front]
    if (((t_1 == I286_front)))
    {! [3: now d is front-locked]
        (Adj_160_t2_v10(t_0));
        ! [4: now d is not back-locked]
        (Adj_161_t3_v10(t_0));
        } else {
        ! [5: now d is back-locked]
        (Adj_161_t2_v10(t_0));
        ! [6: now d is not front-locked]
        (Adj_160_t3_v10(t_0));
        }
        rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! Request 204: phrase door -> nothing
! To ( D - a door ) is locked on both sides:
[ PHR_1385_r204  
    t_0 ! Call parameter 'D': door
    ;
    ! [2: now d is front-locked]
    (Adj_160_t2_v10(t_0));
    ! [3: now d is back-locked]
    (Adj_161_t2_v10(t_0));
    rfalse;
];
! From "Two-Sided Doors" by Philip Riley
! Request 205: phrase (door, number) -> nothing
! To auto-close ( D - a door ) with a delay of ( N - a number ):
[ PHR_1386_r205  
    t_0 ! Call parameter 'D': door
    t_1 ! Call parameter 'N': number
    ;
    ! [2: now d is auto-closable]
    (Adj_174_t2_v10(t_0));
    ! [3: now the close delay of d is n]
    WriteGProperty(10, t_0,p31_close_delay,t_1);
    rfalse;
];
! From "Gender Options" by Nathanael Nerode
! Request 206: phrase object -> grammatical gender
! To decide which grammatical gender is the printing gender for ( o - an object ):
[ PHR_1436_r206  
    t_0 ! Call parameter 'o': object
    ;
    ! [2: if o is not male and o is not female and o is not nomale]
    if ((((~~(((Adj_109_t1_v10(t_0))))))) && ((((~~(((Adj_110_t1_v10(t_0))))))) && (((~~(((Adj_111_t1_v10(t_0)))))))))
    {! [3: decide on neuter gender]
        return I65_neuter_gender;
        }
    ! [4: if o is neuter and prefer neuter gender is true]
    if (((((Adj_108_t1_v10(t_0))))) && (((((Global_Vars-->73) && true) == (1 && true)))))
    {! [5: decide on neuter gender]
        return I65_neuter_gender;
        }
    ! [6: if o is female and o is male]
    if (((((Adj_110_t1_v10(t_0))))) && ((((Adj_109_t1_v10(t_0))))))
    {! [7: decide on preferred animate gender]
        return (Global_Vars-->74);
        }
    ! [8: if o is male]
    if ((((Adj_109_t1_v10(t_0)))))
    {! [9: decide on masculine gender]
        return I66_masculine_gender;
        }
    ! [10: if o is female]
    if ((((Adj_110_t1_v10(t_0)))))
    {! [11: decide on feminine gender]
        return I67_feminine_gender;
        }
    ! [12: if o is nomale]
    if ((((Adj_111_t1_v10(t_0)))))
    {! [13: decide on neitherine gender]
        return I68_neitherine_gender;
        }
        return I65_neuter_gender;
];
! Request 207: phrase nothing -> nothing
! To say location-title-case:
[ PHR_1449_r207  I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(8);
    BlkValueCreateOnStack(6, TEXT_TY);
    BlkValueCreateOnStack(4, TEXT_TY);
    BlkValueCreateOnStack(2, TEXT_TY);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_112();
    BlkValueFreeOnStack(6);
    BlkValueFreeOnStack(4);
    BlkValueFreeOnStack(2);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_112 
    tmp_0 ! Let/loop value, e.g., 'L': text
    ;
    ! [2: let l be the substituted form of ~[location]~ for comparison purposes]
    tmp_0 = I7SFRAME; 
    		BlkValueCopy(tmp_0, SubstituteForComparison((I7SFRAME+WORDSIZE*2), ((LocalParking-->0=tmp_0),TEXT_TY_ExpandIfPerishable((I7SFRAME+WORDSIZE*4),TX_S_587))));
    ! [3: say ~[L in title case]~]
    say__p=1;! [4: l in title case]
    ParaContent(); print (TEXT_TY_Say) TEXT_TY_CharactersToCase((I7SFRAME+WORDSIZE*6), tmp_0, 2); .L_Say898; .L_SayX889;rfalse;
];
! Request 208: phrase text -> nothing
! To tip ( message - a text ):
[ PHR_1452_r208  
    t_0 ! Call parameter 'message': text
    ;
    ! [2: if accessible is true]
    if (((((Global_Vars-->78) && true) == (1 && true))))
    {! [3: say ~Tip: [message][line break]~]
        say__p=1;! [4: ~Tip: ~]
        ParaContent(); print "Tip: ";! [5: message]
        ParaContent(); print (TEXT_TY_Say) t_0;! [6: line break]
        ParaContent(); new_line; .L_Say899; .L_SayX890;} else {
        ! [7: say ~[unicode 8658] [message][line break]~]
        say__p=1;! [8: unicode 8658]
        ParaContent(); unicode_temp = 8658; #ifdef TARGET_ZCODE; @print_unicode unicode_temp; #ifnot; @streamunichar unicode_temp; #endif;! [9: ~ ~]
        ParaContent(); print " ";! [10: message]
        ParaContent(); print (TEXT_TY_Say) t_0;! [11: line break]
        ParaContent(); new_line; .L_Say900; .L_SayX891;}
        rfalse;
];
! Request 209: phrase nothing -> nothing
! To tell klimp something he already knows:
[ PHR_1464_r209  ;
    ! [2: say ~Klimp looks at [us] funny. 'Uh, yeah, you already told me that.'~]
    say__p=1;! [3: ~Klimp looks at ~]
    ParaContent(); print "Klimp looks at ";! [4: us]
    ParaContent(); (PHR_760_r49 ());! [5: ~ funny. 'Uh, yeah, you already told me that.'~]
    ParaContent(); print " funny. ~Uh, yeah, you already told me that.~"; new_line; .L_Say901; .L_SayX892;rfalse;
];
! Request 210: phrase nothing -> nothing
! To say EG:
[ PHR_1475_r210  ;
    ! [2: capture speech for ezra gaunt]
    (PHR_1479_r214 (I404_ezra_gaunt));
    rfalse;
];
! Request 211: phrase nothing -> nothing
! To say PCG:
[ PHR_1476_r211  ;
    ! [2: capture speech for petula goldberg]
    (PHR_1479_r214 (I405_petula_goldberg));
    rfalse;
];
! Request 212: phrase nothing -> nothing
! To say LF:
[ PHR_1477_r212  ;
    ! [2: capture speech for larch faraji]
    (PHR_1479_r214 (I406_larch_faraji));
    rfalse;
];
! Request 213: phrase nothing -> nothing
! To say end say:
[ PHR_1478_r213  ;
    ! [2: stop capturing text]
    EndCapture();
    ! [3: if player is capture player]
    if (((player == (Global_Vars-->80))))
    {! [4: say captured text]
        say__p=1;! [5: captured text]
        ParaContent(); PrintCapture(0); .L_Say902; .L_SayX893;}
        rfalse;
];
! Request 214: phrase person -> nothing
! To capture speech for ( P - a person ):
[ PHR_1479_r214  
    t_0 ! Call parameter 'P': person
    ;
    ! [2: if text capturing is active]
    if (((capture_active > 0)))
    {! [3: stop capturing text]
        EndCapture();
        ! [4: if player is capture player]
        if (((player == (Global_Vars-->80))))
        {! [5: say captured text]
            say__p=1;! [6: captured text]
            ParaContent(); PrintCapture(0); .L_Say903; .L_SayX894;}
            }
    ! [7: start capturing text]
    StartCapture();
    ! [8: now capture player is p]
    (Global_Vars-->80) = t_0;
    rfalse;
];
! Request 215: phrase nothing -> nothing
! To say maybe insert computer muttering:
[ PHR_1480_r215  ;
    ! [2: if biff's computer is not seen]
    if (((~~(((Adj_116_t1_v10(I362_biff_s_computer)))))))
    {! [3: say ~[paragraph break][reset LPR][We] [mutter], 'Where's my computer?'[run paragraph on]~]
        say__p=1;! [4: paragraph break]
        ParaContent(); DivideParagraphPoint(); new_line;! [5: reset lpr]
        ParaContent(); (PHR_755_r81 ());! [6: we]
        ParaContent(); (PHR_764_r7 ());! [7: ~ ~]
        ParaContent(); print " ";! [8: mutter]
        ConjugateVerb_128(CV_POS, PNToVP(), story_tense); say__p=1; ! [9: ~, 'Where's my computer?'~]
        ParaContent(); print ", ~Where's my computer?~";! [10: run paragraph on]
        ParaContent(); RunParagraphOn(); .L_Say904; .L_SayX895;}
        rfalse;
];
! Request 216: phrase nothing -> nothing
! To resize windows:
[ PHR_1513_r216  ;
    ! [2: call resize function]
    ResizeGraphicsWindow();
    ! [3: follow the current graphics drawing rule]
    FollowRulebook((Global_Vars-->70));
    ! [4: if the current interlocutor is something]
    if ((((Global_Vars-->11) ofclass K2_thing)))
    {! [5: draw speech bubble]
        DrawSpeechBubble();
        }
        rfalse;
];
! From the Standard Rules
! Request 217: phrase (description of choices, list of objects) -> list of objects
! To decide what list of K is the filter to ( criterion - description of Ks ) of ( full list - list of values of kind K ) ( documented at ph_filter ):
[ PHR_571_r217  I7RBLK 
    t_0 ! Call parameter 'criterion': description of choices
    t_1 ! Call parameter 'full list': list of objects
;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(1, KD11_list_of_objects);
    BlkValueCreateOnStack(0, KD11_list_of_objects);
    I7RBLK = BlkValueCopy(I7RBLK, KERNEL_113(t_0, t_1));
    BlkValueFreeOnStack(1);
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! list of objects
];
[ KERNEL_113 
    t_0 ! Call parameter 'criterion': description of choices
    t_1 ! Call parameter 'full list': list of objects
    tmp_0 ! Let/loop value, e.g., 'filtered list': list of objects
    tmp_1 ! Let/loop value (deallocated by end of phrase)
    tmp_2 ! Let/loop value (deallocated by end of phrase)
    tmp_3 ! Let/loop value: number
    ;
    ! [2: let the filtered list be a list of k]
    tmp_0 = I7SFRAME; 
    		
    ! [3: repeat with item running through the full list]
    for (tmp_3=t_1, tmp_2=1, tmp_1=LIST_OF_TY_GetItem(tmp_3, tmp_2, true): tmp_2<=LIST_OF_TY_GetLength(tmp_3): tmp_2++, tmp_1=LIST_OF_TY_GetItem(tmp_3, tmp_2, true))
    {! [4: if the item matches the criterion]
        if (((t_0(-1,tmp_1))))
        {! [5: add the item to the filtered list]
            LIST_OF_TY_InsertItem(tmp_0, tmp_1, 0, 0, 0);
            }
            }
    ! [6: decide on the filtered list]
    return BlkValueCopy((I7SFRAME+WORDSIZE), tmp_0);
    return BC_3095;
];
Array TX_R_0 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_0_R;
[ TX_R_0_R ;
    ResponseViaActivity(R_460_RESP_A);
];
[ ADJUST_LIGHT_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_0;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_1 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_1_R;
[ TX_R_1_R ;
    ResponseViaActivity(R_462_RESP_A);
];
[ GENERATE_ACTION_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_1;
        'B': str = TX_R_2;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_2 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_2_R;
[ TX_R_2_R ;
    ResponseViaActivity(R_462_RESP_B);
];
Array TX_R_3 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_3_R;
[ TX_R_3_R ;
    ResponseViaActivity(R_469_RESP_A);
];
[ BASIC_ACCESSIBILITY_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_3;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_4 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_4_R;
[ TX_R_4_R ;
    ResponseViaActivity(R_470_RESP_A);
];
[ BASIC_VISIBILITY_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_4;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_5 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_5_R;
[ TX_R_5_R ;
    ResponseViaActivity(R_472_RESP_A);
];
[ REQUESTED_ACTIONS_REQUIRE_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_5;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_6 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_6_R;
[ TX_R_6_R ;
    ResponseViaActivity(R_473_RESP_A);
];
[ CARRY_OUT_REQUESTED_ACTIONS_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_6;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_7 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_7_R;
[ TX_R_7_R ;
    ResponseViaActivity(R_476_RESP_A);
];
[ ACCESS_THROUGH_BARRIERS_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_7;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_8 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_8_R;
[ TX_R_8_R ;
    ResponseViaActivity(R_477_RESP_A);
];
[ CANT_REACH_INSIDE_CLOSED_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_8;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_9 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_9_R;
[ TX_R_9_R ;
    ResponseViaActivity(R_478_RESP_A);
];
[ CANT_REACH_INSIDE_ROOMS_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_9;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_10 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_10_R;
[ TX_R_10_R ;
    ResponseViaActivity(R_479_RESP_A);
];
[ CANT_REACH_OUTSIDE_CLOSED_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_10;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_11 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_11_R;
[ TX_R_11_R ;
    ResponseViaActivity(R_480_RESP_A);
];
[ LIST_WRITER_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_11;
        'B': str = TX_R_12;
        'C': str = TX_R_13;
        'D': str = TX_R_14;
        'E': str = TX_R_15;
        'F': str = TX_R_16;
        'G': str = TX_R_17;
        'H': str = TX_R_18;
        'I': str = TX_R_19;
        'J': str = TX_R_20;
        'K': str = TX_R_21;
        'L': str = TX_R_22;
        'M': str = TX_R_23;
        'N': str = TX_R_24;
        'O': str = TX_R_25;
        'P': str = TX_R_26;
        'Q': str = TX_R_27;
        'R': str = TX_R_28;
        'S': str = TX_R_29;
        'T': str = TX_R_30;
        'U': str = TX_R_31;
        'V': str = TX_R_32;
        'W': str = TX_R_33;
        'X': str = TX_R_34;
        'Y': str = TX_R_35;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_12 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_12_R;
[ TX_R_12_R ;
    ResponseViaActivity(R_480_RESP_B);
];
Array TX_R_13 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_13_R;
[ TX_R_13_R ;
    ResponseViaActivity(R_480_RESP_C);
];
Array TX_R_14 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_14_R;
[ TX_R_14_R ;
    ResponseViaActivity(R_480_RESP_D);
];
Array TX_R_15 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_15_R;
[ TX_R_15_R ;
    ResponseViaActivity(R_480_RESP_E);
];
Array TX_R_16 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_16_R;
[ TX_R_16_R ;
    ResponseViaActivity(R_480_RESP_F);
];
Array TX_R_17 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_17_R;
[ TX_R_17_R ;
    ResponseViaActivity(R_480_RESP_G);
];
Array TX_R_18 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_18_R;
[ TX_R_18_R ;
    ResponseViaActivity(R_480_RESP_H);
];
Array TX_R_19 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_19_R;
[ TX_R_19_R ;
    ResponseViaActivity(R_480_RESP_I);
];
Array TX_R_20 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_20_R;
[ TX_R_20_R ;
    ResponseViaActivity(R_480_RESP_J);
];
Array TX_R_21 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_21_R;
[ TX_R_21_R ;
    ResponseViaActivity(R_480_RESP_K);
];
Array TX_R_22 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_22_R;
[ TX_R_22_R ;
    ResponseViaActivity(R_480_RESP_L);
];
Array TX_R_23 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_23_R;
[ TX_R_23_R ;
    ResponseViaActivity(R_480_RESP_M);
];
Array TX_R_24 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_24_R;
[ TX_R_24_R ;
    ResponseViaActivity(R_480_RESP_N);
];
Array TX_R_25 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_25_R;
[ TX_R_25_R ;
    ResponseViaActivity(R_480_RESP_O);
];
Array TX_R_26 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_26_R;
[ TX_R_26_R ;
    ResponseViaActivity(R_480_RESP_P);
];
Array TX_R_27 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_27_R;
[ TX_R_27_R ;
    ResponseViaActivity(R_480_RESP_Q);
];
Array TX_R_28 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_28_R;
[ TX_R_28_R ;
    ResponseViaActivity(R_480_RESP_R);
];
Array TX_R_29 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_29_R;
[ TX_R_29_R ;
    ResponseViaActivity(R_480_RESP_S);
];
Array TX_R_30 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_30_R;
[ TX_R_30_R ;
    ResponseViaActivity(R_480_RESP_T);
];
Array TX_R_31 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_31_R;
[ TX_R_31_R ;
    ResponseViaActivity(R_480_RESP_U);
];
Array TX_R_32 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_32_R;
[ TX_R_32_R ;
    ResponseViaActivity(R_480_RESP_V);
];
Array TX_R_33 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_33_R;
[ TX_R_33_R ;
    ResponseViaActivity(R_480_RESP_W);
];
Array TX_R_34 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_34_R;
[ TX_R_34_R ;
    ResponseViaActivity(R_480_RESP_X);
];
Array TX_R_35 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_35_R;
[ TX_R_35_R ;
    ResponseViaActivity(R_480_RESP_Y);
];
Array TX_R_36 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_36_R;
[ TX_R_36_R ;
    ResponseViaActivity(R_481_RESP_A);
];
[ ACTION_PROCESSING_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_36;
        'B': str = TX_R_37;
        'C': str = TX_R_38;
        'D': str = TX_R_39;
        'E': str = TX_R_40;
        'F': str = TX_R_41;
        'G': str = TX_R_42;
        'H': str = TX_R_43;
        'I': str = TX_R_44;
        'J': str = TX_R_45;
        'K': str = TX_R_46;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_37 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_37_R;
[ TX_R_37_R ;
    ResponseViaActivity(R_481_RESP_B);
];
Array TX_R_38 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_38_R;
[ TX_R_38_R ;
    ResponseViaActivity(R_481_RESP_C);
];
Array TX_R_39 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_39_R;
[ TX_R_39_R ;
    ResponseViaActivity(R_481_RESP_D);
];
Array TX_R_40 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_40_R;
[ TX_R_40_R ;
    ResponseViaActivity(R_481_RESP_E);
];
Array TX_R_41 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_41_R;
[ TX_R_41_R ;
    ResponseViaActivity(R_481_RESP_F);
];
Array TX_R_42 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_42_R;
[ TX_R_42_R ;
    ResponseViaActivity(R_481_RESP_G);
];
Array TX_R_43 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_43_R;
[ TX_R_43_R ;
    ResponseViaActivity(R_481_RESP_H);
];
Array TX_R_44 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_44_R;
[ TX_R_44_R ;
    ResponseViaActivity(R_481_RESP_I);
];
Array TX_R_45 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_45_R;
[ TX_R_45_R ;
    ResponseViaActivity(R_481_RESP_J);
];
Array TX_R_46 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_46_R;
[ TX_R_46_R ;
    ResponseViaActivity(R_481_RESP_K);
];
Array TX_R_47 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_47_R;
[ TX_R_47_R ;
    ResponseViaActivity(R_482_RESP_A);
];
[ PARSER_ERROR_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_47;
        'B': str = TX_R_48;
        'C': str = TX_R_49;
        'D': str = TX_R_50;
        'E': str = TX_R_51;
        'F': str = TX_R_52;
        'G': str = TX_R_53;
        'H': str = TX_R_54;
        'I': str = TX_R_55;
        'J': str = TX_R_56;
        'K': str = TX_R_57;
        'L': str = TX_R_58;
        'M': str = TX_R_59;
        'N': str = TX_R_60;
        'O': str = TX_R_61;
        'P': str = TX_R_62;
        'Q': str = TX_R_63;
        'R': str = TX_R_64;
        'S': str = TX_R_65;
        'T': str = TX_R_66;
        'U': str = TX_R_67;
        'V': str = TX_R_68;
        'W': str = TX_R_69;
        'X': str = TX_R_70;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_48 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_48_R;
[ TX_R_48_R ;
    ResponseViaActivity(R_482_RESP_B);
];
Array TX_R_49 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_49_R;
[ TX_R_49_R ;
    ResponseViaActivity(R_482_RESP_C);
];
Array TX_R_50 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_50_R;
[ TX_R_50_R ;
    ResponseViaActivity(R_482_RESP_D);
];
Array TX_R_51 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_51_R;
[ TX_R_51_R ;
    ResponseViaActivity(R_482_RESP_E);
];
Array TX_R_52 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_52_R;
[ TX_R_52_R ;
    ResponseViaActivity(R_482_RESP_F);
];
Array TX_R_53 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_53_R;
[ TX_R_53_R ;
    ResponseViaActivity(R_482_RESP_G);
];
Array TX_R_54 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_54_R;
[ TX_R_54_R ;
    ResponseViaActivity(R_482_RESP_H);
];
Array TX_R_55 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_55_R;
[ TX_R_55_R ;
    ResponseViaActivity(R_482_RESP_I);
];
Array TX_R_56 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_56_R;
[ TX_R_56_R ;
    ResponseViaActivity(R_482_RESP_J);
];
Array TX_R_57 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_57_R;
[ TX_R_57_R ;
    ResponseViaActivity(R_482_RESP_K);
];
Array TX_R_58 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_58_R;
[ TX_R_58_R ;
    ResponseViaActivity(R_482_RESP_L);
];
Array TX_R_59 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_59_R;
[ TX_R_59_R ;
    ResponseViaActivity(R_482_RESP_M);
];
Array TX_R_60 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_60_R;
[ TX_R_60_R ;
    ResponseViaActivity(R_482_RESP_N);
];
Array TX_R_61 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_61_R;
[ TX_R_61_R ;
    ResponseViaActivity(R_482_RESP_O);
];
Array TX_R_62 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_62_R;
[ TX_R_62_R ;
    ResponseViaActivity(R_482_RESP_P);
];
Array TX_R_63 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_63_R;
[ TX_R_63_R ;
    ResponseViaActivity(R_482_RESP_Q);
];
Array TX_R_64 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_64_R;
[ TX_R_64_R ;
    ResponseViaActivity(R_482_RESP_R);
];
Array TX_R_65 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_65_R;
[ TX_R_65_R ;
    ResponseViaActivity(R_482_RESP_S);
];
Array TX_R_66 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_66_R;
[ TX_R_66_R ;
    ResponseViaActivity(R_482_RESP_T);
];
Array TX_R_67 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_67_R;
[ TX_R_67_R ;
    ResponseViaActivity(R_482_RESP_U);
];
Array TX_R_68 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_68_R;
[ TX_R_68_R ;
    ResponseViaActivity(R_482_RESP_V);
];
Array TX_R_69 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_69_R;
[ TX_R_69_R ;
    ResponseViaActivity(R_482_RESP_W);
];
Array TX_R_70 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_70_R;
[ TX_R_70_R ;
    ResponseViaActivity(R_482_RESP_X);
];
Array TX_R_71 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_71_R;
[ TX_R_71_R ;
    ResponseViaActivity(R_483_RESP_A);
];
[ PARSER_N_ERROR_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_71;
        'B': str = TX_R_72;
        'C': str = TX_R_73;
        'D': str = TX_R_74;
        'E': str = TX_R_75;
        'F': str = TX_R_76;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_72 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_72_R;
[ TX_R_72_R ;
    ResponseViaActivity(R_483_RESP_B);
];
Array TX_R_73 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_73_R;
[ TX_R_73_R ;
    ResponseViaActivity(R_483_RESP_C);
];
Array TX_R_74 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_74_R;
[ TX_R_74_R ;
    ResponseViaActivity(R_483_RESP_D);
];
Array TX_R_75 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_75_R;
[ TX_R_75_R ;
    ResponseViaActivity(R_483_RESP_E);
];
Array TX_R_76 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_76_R;
[ TX_R_76_R ;
    ResponseViaActivity(R_483_RESP_F);
];
Array TX_R_77 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_77_R;
[ TX_R_77_R ;
    ResponseViaActivity(R_484_RESP_A);
];
[ DARKNESS_NAME_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_77;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_78 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_78_R;
[ TX_R_78_R ;
    ResponseViaActivity(R_485_RESP_A);
];
[ PARSER_COMMAND_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_78;
        'B': str = TX_R_79;
        'C': str = TX_R_80;
        'D': str = TX_R_81;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_79 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_79_R;
[ TX_R_79_R ;
    ResponseViaActivity(R_485_RESP_B);
];
Array TX_R_80 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_80_R;
[ TX_R_80_R ;
    ResponseViaActivity(R_485_RESP_C);
];
Array TX_R_81 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_81_R;
[ TX_R_81_R ;
    ResponseViaActivity(R_485_RESP_D);
];
Array TX_R_82 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_82_R;
[ TX_R_82_R ;
    ResponseViaActivity(R_486_RESP_A);
];
[ PARSER_CLARIF_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_82;
        'B': str = TX_R_83;
        'C': str = TX_R_84;
        'D': str = TX_R_85;
        'E': str = TX_R_86;
        'F': str = TX_R_87;
        'G': str = TX_R_88;
        'H': str = TX_R_89;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_83 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_83_R;
[ TX_R_83_R ;
    ResponseViaActivity(R_486_RESP_B);
];
Array TX_R_84 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_84_R;
[ TX_R_84_R ;
    ResponseViaActivity(R_486_RESP_C);
];
Array TX_R_85 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_85_R;
[ TX_R_85_R ;
    ResponseViaActivity(R_486_RESP_D);
];
Array TX_R_86 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_86_R;
[ TX_R_86_R ;
    ResponseViaActivity(R_486_RESP_E);
];
Array TX_R_87 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_87_R;
[ TX_R_87_R ;
    ResponseViaActivity(R_486_RESP_F);
];
Array TX_R_88 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_88_R;
[ TX_R_88_R ;
    ResponseViaActivity(R_486_RESP_G);
];
Array TX_R_89 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_89_R;
[ TX_R_89_R ;
    ResponseViaActivity(R_486_RESP_H);
];
Array TX_R_90 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_90_R;
[ TX_R_90_R ;
    ResponseViaActivity(R_487_RESP_A);
];
[ YES_OR_NO_QUESTION_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_90;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_91 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_91_R;
[ TX_R_91_R ;
    ResponseViaActivity(R_488_RESP_A);
];
[ PRINT_PROTAGONIST_INTERNAL_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_91;
        'B': str = TX_R_92;
        'C': str = TX_R_93;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_92 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_92_R;
[ TX_R_92_R ;
    ResponseViaActivity(R_488_RESP_B);
];
Array TX_R_93 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_93_R;
[ TX_R_93_R ;
    ResponseViaActivity(R_488_RESP_C);
];
Array TX_R_94 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_94_R;
[ TX_R_94_R ;
    ResponseViaActivity(R_491_RESP_A);
];
[ STANDARD_IMPLICIT_TAKING_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_94;
        'B': str = TX_R_95;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_95 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_95_R;
[ TX_R_95_R ;
    ResponseViaActivity(R_491_RESP_B);
];
Array TX_R_96 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_96_R;
[ TX_R_96_R ;
    ResponseViaActivity(R_493_RESP_A);
];
[ PRINT_OBITUARY_HEADLINE_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_96;
        'B': str = TX_R_97;
        'C': str = TX_R_98;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_97 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_97_R;
[ TX_R_97_R ;
    ResponseViaActivity(R_493_RESP_B);
];
Array TX_R_98 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_98_R;
[ TX_R_98_R ;
    ResponseViaActivity(R_493_RESP_C);
];
Array TX_R_99 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_99_R;
[ TX_R_99_R ;
    ResponseViaActivity(R_499_RESP_A);
];
[ IMMEDIATELY_UNDO_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_99;
        'B': str = TX_R_100;
        'C': str = TX_R_101;
        'D': str = TX_R_102;
        'E': str = TX_R_103;
        'F': str = TX_R_104;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_100 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_100_R;
[ TX_R_100_R ;
    ResponseViaActivity(R_499_RESP_B);
];
Array TX_R_101 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_101_R;
[ TX_R_101_R ;
    ResponseViaActivity(R_499_RESP_C);
];
Array TX_R_102 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_102_R;
[ TX_R_102_R ;
    ResponseViaActivity(R_499_RESP_D);
];
Array TX_R_103 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_103_R;
[ TX_R_103_R ;
    ResponseViaActivity(R_499_RESP_E);
];
Array TX_R_104 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_104_R;
[ TX_R_104_R ;
    ResponseViaActivity(R_499_RESP_F);
];
Array TX_R_105 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_105_R;
[ TX_R_105_R ;
    ResponseViaActivity(R_502_RESP_A);
];
[ QUIT_THE_GAME_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_105;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_106 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_106_R;
[ TX_R_106_R ;
    ResponseViaActivity(R_503_RESP_A);
];
[ SAVE_THE_GAME_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_106;
        'B': str = TX_R_107;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_107 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_107_R;
[ TX_R_107_R ;
    ResponseViaActivity(R_503_RESP_B);
];
Array TX_R_108 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_108_R;
[ TX_R_108_R ;
    ResponseViaActivity(R_504_RESP_A);
];
[ RESTORE_THE_GAME_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_108;
        'B': str = TX_R_109;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_109 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_109_R;
[ TX_R_109_R ;
    ResponseViaActivity(R_504_RESP_B);
];
Array TX_R_110 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_110_R;
[ TX_R_110_R ;
    ResponseViaActivity(R_505_RESP_A);
];
[ RESTART_THE_GAME_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_110;
        'B': str = TX_R_111;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_111 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_111_R;
[ TX_R_111_R ;
    ResponseViaActivity(R_505_RESP_B);
];
Array TX_R_112 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_112_R;
[ TX_R_112_R ;
    ResponseViaActivity(R_506_RESP_A);
];
[ VERIFY_THE_STORY_FILE_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_112;
        'B': str = TX_R_113;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_113 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_113_R;
[ TX_R_113_R ;
    ResponseViaActivity(R_506_RESP_B);
];
Array TX_R_114 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_114_R;
[ TX_R_114_R ;
    ResponseViaActivity(R_507_RESP_A);
];
[ SWITCH_TRANSCRIPT_ON_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_114;
        'B': str = TX_R_115;
        'C': str = TX_R_116;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_115 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_115_R;
[ TX_R_115_R ;
    ResponseViaActivity(R_507_RESP_B);
];
Array TX_R_116 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_116_R;
[ TX_R_116_R ;
    ResponseViaActivity(R_507_RESP_C);
];
Array TX_R_117 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_117_R;
[ TX_R_117_R ;
    ResponseViaActivity(R_508_RESP_A);
];
[ SWITCH_TRANSCRIPT_OFF_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_117;
        'B': str = TX_R_118;
        'C': str = TX_R_119;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_118 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_118_R;
[ TX_R_118_R ;
    ResponseViaActivity(R_508_RESP_B);
];
Array TX_R_119 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_119_R;
[ TX_R_119_R ;
    ResponseViaActivity(R_508_RESP_C);
];
Array TX_R_120 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_120_R;
[ TX_R_120_R ;
    ResponseViaActivity(R_510_RESP_A);
];
[ ANNOUNCE_SCORE_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_120;
        'B': str = TX_R_121;
        'C': str = TX_R_122;
        'D': str = TX_R_123;
        'E': str = TX_R_124;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_121 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_121_R;
[ TX_R_121_R ;
    ResponseViaActivity(R_510_RESP_B);
];
Array TX_R_122 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_122_R;
[ TX_R_122_R ;
    ResponseViaActivity(R_510_RESP_C);
];
Array TX_R_123 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_123_R;
[ TX_R_123_R ;
    ResponseViaActivity(R_510_RESP_D);
];
Array TX_R_124 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_124_R;
[ TX_R_124_R ;
    ResponseViaActivity(R_510_RESP_E);
];
Array TX_R_125 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_125_R;
[ TX_R_125_R ;
    ResponseViaActivity(R_512_RESP_A);
];
[ REP_PREFER_ABBREVIATED_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_125;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_126 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_126_R;
[ TX_R_126_R ;
    ResponseViaActivity(R_514_RESP_A);
];
[ REP_PREFER_UNABBREVIATED_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_126;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_127 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_127_R;
[ TX_R_127_R ;
    ResponseViaActivity(R_516_RESP_A);
];
[ REP_PREFER_SOMETIMES_ABBR_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_127;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_128 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_128_R;
[ TX_R_128_R ;
    ResponseViaActivity(R_518_RESP_A);
];
[ REP_SWITCH_NOTIFY_ON_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_128;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_129 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_129_R;
[ TX_R_129_R ;
    ResponseViaActivity(R_520_RESP_A);
];
[ REP_SWITCH_NOTIFY_OFF_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_129;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_130 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_130_R;
[ TX_R_130_R ;
    ResponseViaActivity(R_521_RESP_A);
];
[ ANNOUNCE_PRONOUN_MEANINGS_RM 
    code ! Implied call parameter
    val ! Implied call parameter
    val2 ! Implied call parameter
    s ! internal use only
    s2 ! internal use only
    s3 ! internal use only
    str ! internal use only
    f ! internal use only
    ;
    if ((code >= 'a') && (code <= 'z')) { f = true; code = code - 'a' + 'A'; }
    s = noun; s2 = second; s3 = parsed_number;
    noun = val; second = val2; parsed_number = val;
    switch (code) {
        'A': str = TX_R_130;
        'B': str = TX_R_131;
        'C': str = TX_R_132;
        'D': str = TX_R_133;
    }
    if ((str) && (f == false)) { TEXT_TY_Say(str); }
    noun = s; second = s2; parsed_number = s3;
    return str;
];
Array TX_R_131 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_131_R;
[ TX_R_131_R ;
    ResponseViaActivity(R_521_RESP_B);
];
Array TX_R_132 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_132_R;
[ TX_R_132_R ;
    ResponseViaActivity(R_521_RESP_C);
];
Array TX_R_133 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_133_R;
[ TX_R_133_R ;
    ResponseViaActivity(R_521_RESP_D);
];
Array TX_R_134 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_134_R;
[ TX_R_134_R ;
    ResponseViaActivity(R_11_RESP_A);
];
Array TX_R_135 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_135_R;
[ TX_R_135_R ;
    ResponseViaActivity(R_269_RESP_A);
];
Array TX_R_136 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_136_R;
[ TX_R_136_R ;
    ResponseViaActivity(R_268_RESP_A);
];
Array TX_R_137 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_137_R;
[ TX_R_137_R ;
    ResponseViaActivity(R_268_RESP_B);
];
Array TX_R_138 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_138_R;
[ TX_R_138_R ;
    ResponseViaActivity(R_268_RESP_C);
];
Array TX_R_139 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_139_R;
[ TX_R_139_R ;
    ResponseViaActivity(R_268_RESP_D);
];
Array TX_R_140 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_140_R;
[ TX_R_140_R ;
    ResponseViaActivity(R_332_RESP_A);
];
Array TX_R_141 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_141_R;
[ TX_R_141_R ;
    ResponseViaActivity(R_332_RESP_B);
];
Array TX_R_142 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_142_R;
[ TX_R_142_R ;
    ResponseViaActivity(R_340_RESP_A);
];
Array TX_R_143 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_143_R;
[ TX_R_143_R ;
    ResponseViaActivity(R_342_RESP_A);
];
Array TX_R_144 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_144_R;
[ TX_R_144_R ;
    ResponseViaActivity(R_350_RESP_A);
];
Array TX_R_145 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_145_R;
[ TX_R_145_R ;
    ResponseViaActivity(R_359_RESP_A);
];
Array TX_R_146 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_146_R;
[ TX_R_146_R ;
    ResponseViaActivity(R_37_RESP_A);
];
Array TX_R_147 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_147_R;
[ TX_R_147_R ;
    ResponseViaActivity(R_39_RESP_A);
];
Array TX_R_148 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_148_R;
[ TX_R_148_R ;
    ResponseViaActivity(R_39_RESP_B);
];
Array TX_R_149 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_149_R;
[ TX_R_149_R ;
    ResponseViaActivity(R_38_RESP_A);
];
Array TX_R_150 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_150_R;
[ TX_R_150_R ;
    ResponseViaActivity(R_40_RESP_A);
];
Array TX_R_151 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_151_R;
[ TX_R_151_R ;
    ResponseViaActivity(R_336_RESP_A);
];
Array TX_R_152 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_152_R;
[ TX_R_152_R ;
    ResponseViaActivity(R_336_RESP_B);
];
Array TX_R_153 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_153_R;
[ TX_R_153_R ;
    ResponseViaActivity(R_336_RESP_C);
];
Array TX_R_154 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_154_R;
[ TX_R_154_R ;
    ResponseViaActivity(R_51_RESP_A);
];
Array TX_R_155 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_155_R;
[ TX_R_155_R ;
    ResponseViaActivity(R_53_RESP_A);
];
Array TX_R_156 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_156_R;
[ TX_R_156_R ;
    ResponseViaActivity(R_54_RESP_A);
];
Array TX_R_157 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_157_R;
[ TX_R_157_R ;
    ResponseViaActivity(R_55_RESP_A);
];
Array TX_R_158 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_158_R;
[ TX_R_158_R ;
    ResponseViaActivity(R_56_RESP_A);
];
Array TX_R_159 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_159_R;
[ TX_R_159_R ;
    ResponseViaActivity(R_57_RESP_A);
];
Array TX_R_160 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_160_R;
[ TX_R_160_R ;
    ResponseViaActivity(R_348_RESP_A);
];
Array TX_R_161 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_161_R;
[ TX_R_161_R ;
    ResponseViaActivity(R_356_RESP_A);
];
Array TX_R_162 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_162_R;
[ TX_R_162_R ;
    ResponseViaActivity(R_367_RESP_A);
];
Array TX_R_163 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_163_R;
[ TX_R_163_R ;
    ResponseViaActivity(R_58_RESP_A);
];
Array TX_R_164 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_164_R;
[ TX_R_164_R ;
    ResponseViaActivity(R_59_RESP_A);
];
Array TX_R_165 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_165_R;
[ TX_R_165_R ;
    ResponseViaActivity(R_60_RESP_A);
];
Array TX_R_166 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_166_R;
[ TX_R_166_R ;
    ResponseViaActivity(R_61_RESP_A);
];
Array TX_R_167 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_167_R;
[ TX_R_167_R ;
    ResponseViaActivity(R_62_RESP_A);
];
Array TX_R_168 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_168_R;
[ TX_R_168_R ;
    ResponseViaActivity(R_63_RESP_A);
];
Array TX_R_169 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_169_R;
[ TX_R_169_R ;
    ResponseViaActivity(R_64_RESP_A);
];
Array TX_R_170 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_170_R;
[ TX_R_170_R ;
    ResponseViaActivity(R_65_RESP_A);
];
Array TX_R_171 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_171_R;
[ TX_R_171_R ;
    ResponseViaActivity(R_66_RESP_A);
];
Array TX_R_172 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_172_R;
[ TX_R_172_R ;
    ResponseViaActivity(R_67_RESP_A);
];
Array TX_R_173 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_173_R;
[ TX_R_173_R ;
    ResponseViaActivity(R_68_RESP_A);
];
Array TX_R_174 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_174_R;
[ TX_R_174_R ;
    ResponseViaActivity(R_69_RESP_A);
];
Array TX_R_175 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_175_R;
[ TX_R_175_R ;
    ResponseViaActivity(R_71_RESP_A);
];
Array TX_R_176 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_176_R;
[ TX_R_176_R ;
    ResponseViaActivity(R_71_RESP_B);
];
Array TX_R_177 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_177_R;
[ TX_R_177_R ;
    ResponseViaActivity(R_72_RESP_A);
];
Array TX_R_178 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_178_R;
[ TX_R_178_R ;
    ResponseViaActivity(R_73_RESP_A);
];
Array TX_R_179 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_179_R;
[ TX_R_179_R ;
    ResponseViaActivity(R_76_RESP_A);
];
Array TX_R_180 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_180_R;
[ TX_R_180_R ;
    ResponseViaActivity(R_75_RESP_A);
];
Array TX_R_181 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_181_R;
[ TX_R_181_R ;
    ResponseViaActivity(R_77_RESP_A);
];
Array TX_R_182 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_182_R;
[ TX_R_182_R ;
    ResponseViaActivity(R_78_RESP_A);
];
Array TX_R_183 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_183_R;
[ TX_R_183_R ;
    ResponseViaActivity(R_79_RESP_A);
];
Array TX_R_184 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_184_R;
[ TX_R_184_R ;
    ResponseViaActivity(R_80_RESP_A);
];
Array TX_R_185 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_185_R;
[ TX_R_185_R ;
    ResponseViaActivity(R_80_RESP_B);
];
Array TX_R_186 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_186_R;
[ TX_R_186_R ;
    ResponseViaActivity(R_82_RESP_A);
];
Array TX_R_187 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_187_R;
[ TX_R_187_R ;
    ResponseViaActivity(R_82_RESP_B);
];
Array TX_R_188 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_188_R;
[ TX_R_188_R ;
    ResponseViaActivity(R_85_RESP_A);
];
Array TX_R_189 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_189_R;
[ TX_R_189_R ;
    ResponseViaActivity(R_86_RESP_A);
];
Array TX_R_190 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_190_R;
[ TX_R_190_R ;
    ResponseViaActivity(R_87_RESP_A);
];
Array TX_R_191 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_191_R;
[ TX_R_191_R ;
    ResponseViaActivity(R_88_RESP_A);
];
Array TX_R_192 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_192_R;
[ TX_R_192_R ;
    ResponseViaActivity(R_90_RESP_A);
];
Array TX_R_193 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_193_R;
[ TX_R_193_R ;
    ResponseViaActivity(R_91_RESP_A);
];
Array TX_R_194 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_194_R;
[ TX_R_194_R ;
    ResponseViaActivity(R_94_RESP_A);
];
Array TX_R_195 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_195_R;
[ TX_R_195_R ;
    ResponseViaActivity(R_95_RESP_A);
];
Array TX_R_196 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_196_R;
[ TX_R_196_R ;
    ResponseViaActivity(R_96_RESP_A);
];
Array TX_R_197 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_197_R;
[ TX_R_197_R ;
    ResponseViaActivity(R_97_RESP_A);
];
Array TX_R_198 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_198_R;
[ TX_R_198_R ;
    ResponseViaActivity(R_98_RESP_A);
];
Array TX_R_199 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_199_R;
[ TX_R_199_R ;
    ResponseViaActivity(R_100_RESP_A);
];
Array TX_R_200 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_200_R;
[ TX_R_200_R ;
    ResponseViaActivity(R_101_RESP_A);
];
Array TX_R_201 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_201_R;
[ TX_R_201_R ;
    ResponseViaActivity(R_102_RESP_A);
];
Array TX_R_202 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_202_R;
[ TX_R_202_R ;
    ResponseViaActivity(R_103_RESP_A);
];
Array TX_R_203 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_203_R;
[ TX_R_203_R ;
    ResponseViaActivity(R_104_RESP_A);
];
Array TX_R_204 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_204_R;
[ TX_R_204_R ;
    ResponseViaActivity(R_107_RESP_A);
];
Array TX_R_205 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_205_R;
[ TX_R_205_R ;
    ResponseViaActivity(R_107_RESP_B);
];
Array TX_R_206 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_206_R;
[ TX_R_206_R ;
    ResponseViaActivity(R_109_RESP_A);
];
Array TX_R_207 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_207_R;
[ TX_R_207_R ;
    ResponseViaActivity(R_110_RESP_A);
];
Array TX_R_208 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_208_R;
[ TX_R_208_R ;
    ResponseViaActivity(R_110_RESP_B);
];
Array TX_R_209 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_209_R;
[ TX_R_209_R ;
    ResponseViaActivity(R_111_RESP_A);
];
Array TX_R_210 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_210_R;
[ TX_R_210_R ;
    ResponseViaActivity(R_112_RESP_A);
];
Array TX_R_211 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_211_R;
[ TX_R_211_R ;
    ResponseViaActivity(R_114_RESP_A);
];
Array TX_R_212 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_212_R;
[ TX_R_212_R ;
    ResponseViaActivity(R_114_RESP_B);
];
Array TX_R_213 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_213_R;
[ TX_R_213_R ;
    ResponseViaActivity(R_118_RESP_A);
];
Array TX_R_214 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_214_R;
[ TX_R_214_R ;
    ResponseViaActivity(R_118_RESP_B);
];
Array TX_R_215 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_215_R;
[ TX_R_215_R ;
    ResponseViaActivity(R_118_RESP_C);
];
Array TX_R_216 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_216_R;
[ TX_R_216_R ;
    ResponseViaActivity(R_118_RESP_D);
];
Array TX_R_217 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_217_R;
[ TX_R_217_R ;
    ResponseViaActivity(R_118_RESP_E);
];
Array TX_R_218 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_218_R;
[ TX_R_218_R ;
    ResponseViaActivity(R_118_RESP_F);
];
Array TX_R_219 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_219_R;
[ TX_R_219_R ;
    ResponseViaActivity(R_118_RESP_G);
];
Array TX_R_220 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_220_R;
[ TX_R_220_R ;
    ResponseViaActivity(R_118_RESP_H);
];
Array TX_R_221 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_221_R;
[ TX_R_221_R ;
    ResponseViaActivity(R_118_RESP_I);
];
Array TX_R_222 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_222_R;
[ TX_R_222_R ;
    ResponseViaActivity(R_118_RESP_J);
];
Array TX_R_223 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_223_R;
[ TX_R_223_R ;
    ResponseViaActivity(R_118_RESP_K);
];
Array TX_R_224 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_224_R;
[ TX_R_224_R ;
    ResponseViaActivity(R_118_RESP_L);
];
Array TX_R_225 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_225_R;
[ TX_R_225_R ;
    ResponseViaActivity(R_118_RESP_M);
];
Array TX_R_226 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_226_R;
[ TX_R_226_R ;
    ResponseViaActivity(R_118_RESP_N);
];
Array TX_R_227 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_227_R;
[ TX_R_227_R ;
    ResponseViaActivity(R_118_RESP_O);
];
Array TX_R_228 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_228_R;
[ TX_R_228_R ;
    ResponseViaActivity(R_118_RESP_P);
];
Array TX_R_229 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_229_R;
[ TX_R_229_R ;
    ResponseViaActivity(R_118_RESP_Q);
];
Array TX_R_230 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_230_R;
[ TX_R_230_R ;
    ResponseViaActivity(R_118_RESP_R);
];
Array TX_R_231 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_231_R;
[ TX_R_231_R ;
    ResponseViaActivity(R_118_RESP_S);
];
Array TX_R_232 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_232_R;
[ TX_R_232_R ;
    ResponseViaActivity(R_122_RESP_A);
];
Array TX_R_233 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_233_R;
[ TX_R_233_R ;
    ResponseViaActivity(R_122_RESP_B);
];
Array TX_R_234 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_234_R;
[ TX_R_234_R ;
    ResponseViaActivity(R_123_RESP_A);
];
Array TX_R_235 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_235_R;
[ TX_R_235_R ;
    ResponseViaActivity(R_123_RESP_B);
];
Array TX_R_236 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_236_R;
[ TX_R_236_R ;
    ResponseViaActivity(R_123_RESP_C);
];
Array TX_R_237 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_237_R;
[ TX_R_237_R ;
    ResponseViaActivity(R_123_RESP_D);
];
Array TX_R_238 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_238_R;
[ TX_R_238_R ;
    ResponseViaActivity(R_124_RESP_A);
];
Array TX_R_239 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_239_R;
[ TX_R_239_R ;
    ResponseViaActivity(R_125_RESP_A);
];
Array TX_R_240 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_240_R;
[ TX_R_240_R ;
    ResponseViaActivity(R_125_RESP_B);
];
Array TX_R_241 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_241_R;
[ TX_R_241_R ;
    ResponseViaActivity(R_126_RESP_A);
];
Array TX_R_242 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_242_R;
[ TX_R_242_R ;
    ResponseViaActivity(R_127_RESP_A);
];
Array TX_R_243 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_243_R;
[ TX_R_243_R ;
    ResponseViaActivity(R_127_RESP_B);
];
Array TX_R_244 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_244_R;
[ TX_R_244_R ;
    ResponseViaActivity(R_127_RESP_C);
];
Array TX_R_245 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_245_R;
[ TX_R_245_R ;
    ResponseViaActivity(R_127_RESP_D);
];
Array TX_R_246 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_246_R;
[ TX_R_246_R ;
    ResponseViaActivity(R_127_RESP_E);
];
Array TX_R_247 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_247_R;
[ TX_R_247_R ;
    ResponseViaActivity(R_129_RESP_A);
];
Array TX_R_248 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_248_R;
[ TX_R_248_R ;
    ResponseViaActivity(R_129_RESP_B);
];
Array TX_R_249 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_249_R;
[ TX_R_249_R ;
    ResponseViaActivity(R_129_RESP_C);
];
Array TX_R_250 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_250_R;
[ TX_R_250_R ;
    ResponseViaActivity(R_129_RESP_D);
];
Array TX_R_251 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_251_R;
[ TX_R_251_R ;
    ResponseViaActivity(R_132_RESP_A);
];
Array TX_R_252 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_252_R;
[ TX_R_252_R ;
    ResponseViaActivity(R_133_RESP_A);
];
Array TX_R_253 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_253_R;
[ TX_R_253_R ;
    ResponseViaActivity(R_370_RESP_A);
];
Array TX_R_254 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_254_R;
[ TX_R_254_R ;
    ResponseViaActivity(R_136_RESP_A);
];
Array TX_R_255 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_255_R;
[ TX_R_255_R ;
    ResponseViaActivity(R_136_RESP_B);
];
Array TX_R_256 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_256_R;
[ TX_R_256_R ;
    ResponseViaActivity(R_136_RESP_C);
];
Array TX_R_257 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_257_R;
[ TX_R_257_R ;
    ResponseViaActivity(R_138_RESP_A);
];
Array TX_R_258 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_258_R;
[ TX_R_258_R ;
    ResponseViaActivity(R_140_RESP_A);
];
Array TX_R_259 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_259_R;
[ TX_R_259_R ;
    ResponseViaActivity(R_335_RESP_A);
];
Array TX_R_260 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_260_R;
[ TX_R_260_R ;
    ResponseViaActivity(R_335_RESP_B);
];
Array TX_R_261 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_261_R;
[ TX_R_261_R ;
    ResponseViaActivity(R_335_RESP_C);
];
Array TX_R_262 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_262_R;
[ TX_R_262_R ;
    ResponseViaActivity(R_145_RESP_A);
];
Array TX_R_263 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_263_R;
[ TX_R_263_R ;
    ResponseViaActivity(R_148_RESP_A);
];
Array TX_R_264 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_264_R;
[ TX_R_264_R ;
    ResponseViaActivity(R_150_RESP_A);
];
Array TX_R_265 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_265_R;
[ TX_R_265_R ;
    ResponseViaActivity(R_151_RESP_A);
];
Array TX_R_266 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_266_R;
[ TX_R_266_R ;
    ResponseViaActivity(R_151_RESP_B);
];
Array TX_R_267 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_267_R;
[ TX_R_267_R ;
    ResponseViaActivity(R_152_RESP_A);
];
Array TX_R_268 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_268_R;
[ TX_R_268_R ;
    ResponseViaActivity(R_153_RESP_A);
];
Array TX_R_269 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_269_R;
[ TX_R_269_R ;
    ResponseViaActivity(R_154_RESP_A);
];
Array TX_R_270 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_270_R;
[ TX_R_270_R ;
    ResponseViaActivity(R_155_RESP_A);
];
Array TX_R_271 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_271_R;
[ TX_R_271_R ;
    ResponseViaActivity(R_156_RESP_A);
];
Array TX_R_272 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_272_R;
[ TX_R_272_R ;
    ResponseViaActivity(R_157_RESP_A);
];
Array TX_R_273 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_273_R;
[ TX_R_273_R ;
    ResponseViaActivity(R_158_RESP_A);
];
Array TX_R_274 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_274_R;
[ TX_R_274_R ;
    ResponseViaActivity(R_159_RESP_A);
];
Array TX_R_275 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_275_R;
[ TX_R_275_R ;
    ResponseViaActivity(R_160_RESP_A);
];
Array TX_R_276 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_276_R;
[ TX_R_276_R ;
    ResponseViaActivity(R_160_RESP_B);
];
Array TX_R_277 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_277_R;
[ TX_R_277_R ;
    ResponseViaActivity(R_161_RESP_A);
];
Array TX_R_278 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_278_R;
[ TX_R_278_R ;
    ResponseViaActivity(R_161_RESP_B);
];
Array TX_R_279 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_279_R;
[ TX_R_279_R ;
    ResponseViaActivity(R_162_RESP_A);
];
Array TX_R_280 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_280_R;
[ TX_R_280_R ;
    ResponseViaActivity(R_163_RESP_A);
];
Array TX_R_281 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_281_R;
[ TX_R_281_R ;
    ResponseViaActivity(R_163_RESP_B);
];
Array TX_R_282 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_282_R;
[ TX_R_282_R ;
    ResponseViaActivity(R_431_RESP_A);
];
Array TX_R_283 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_283_R;
[ TX_R_283_R ;
    ResponseViaActivity(R_432_RESP_A);
];
Array TX_R_284 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_284_R;
[ TX_R_284_R ;
    ResponseViaActivity(R_164_RESP_A);
];
Array TX_R_285 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_285_R;
[ TX_R_285_R ;
    ResponseViaActivity(R_165_RESP_A);
];
Array TX_R_286 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_286_R;
[ TX_R_286_R ;
    ResponseViaActivity(R_166_RESP_A);
];
Array TX_R_287 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_287_R;
[ TX_R_287_R ;
    ResponseViaActivity(R_167_RESP_A);
];
Array TX_R_288 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_288_R;
[ TX_R_288_R ;
    ResponseViaActivity(R_169_RESP_A);
];
Array TX_R_289 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_289_R;
[ TX_R_289_R ;
    ResponseViaActivity(R_169_RESP_B);
];
Array TX_R_290 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_290_R;
[ TX_R_290_R ;
    ResponseViaActivity(R_447_RESP_A);
];
Array TX_R_291 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_291_R;
[ TX_R_291_R ;
    ResponseViaActivity(R_170_RESP_A);
];
Array TX_R_292 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_292_R;
[ TX_R_292_R ;
    ResponseViaActivity(R_171_RESP_A);
];
Array TX_R_293 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_293_R;
[ TX_R_293_R ;
    ResponseViaActivity(R_172_RESP_A);
];
Array TX_R_294 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_294_R;
[ TX_R_294_R ;
    ResponseViaActivity(R_174_RESP_A);
];
Array TX_R_295 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_295_R;
[ TX_R_295_R ;
    ResponseViaActivity(R_174_RESP_B);
];
Array TX_R_296 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_296_R;
[ TX_R_296_R ;
    ResponseViaActivity(R_175_RESP_A);
];
Array TX_R_297 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_297_R;
[ TX_R_297_R ;
    ResponseViaActivity(R_176_RESP_A);
];
Array TX_R_298 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_298_R;
[ TX_R_298_R ;
    ResponseViaActivity(R_178_RESP_A);
];
Array TX_R_299 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_299_R;
[ TX_R_299_R ;
    ResponseViaActivity(R_179_RESP_A);
];
Array TX_R_300 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_300_R;
[ TX_R_300_R ;
    ResponseViaActivity(R_180_RESP_A);
];
Array TX_R_301 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_301_R;
[ TX_R_301_R ;
    ResponseViaActivity(R_182_RESP_A);
];
Array TX_R_302 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_302_R;
[ TX_R_302_R ;
    ResponseViaActivity(R_441_RESP_A);
];
Array TX_R_303 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_303_R;
[ TX_R_303_R ;
    ResponseViaActivity(R_442_RESP_A);
];
Array TX_R_304 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_304_R;
[ TX_R_304_R ;
    ResponseViaActivity(R_183_RESP_A);
];
Array TX_R_305 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_305_R;
[ TX_R_305_R ;
    ResponseViaActivity(R_184_RESP_A);
];
Array TX_R_306 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_306_R;
[ TX_R_306_R ;
    ResponseViaActivity(R_185_RESP_A);
];
Array TX_R_307 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_307_R;
[ TX_R_307_R ;
    ResponseViaActivity(R_187_RESP_A);
];
Array TX_R_308 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_308_R;
[ TX_R_308_R ;
    ResponseViaActivity(R_188_RESP_A);
];
Array TX_R_309 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_309_R;
[ TX_R_309_R ;
    ResponseViaActivity(R_188_RESP_B);
];
Array TX_R_310 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_310_R;
[ TX_R_310_R ;
    ResponseViaActivity(R_188_RESP_C);
];
Array TX_R_311 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_311_R;
[ TX_R_311_R ;
    ResponseViaActivity(R_443_RESP_A);
];
Array TX_R_312 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_312_R;
[ TX_R_312_R ;
    ResponseViaActivity(R_189_RESP_A);
];
Array TX_R_313 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_313_R;
[ TX_R_313_R ;
    ResponseViaActivity(R_190_RESP_A);
];
Array TX_R_314 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_314_R;
[ TX_R_314_R ;
    ResponseViaActivity(R_192_RESP_A);
];
Array TX_R_315 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_315_R;
[ TX_R_315_R ;
    ResponseViaActivity(R_192_RESP_B);
];
Array TX_R_316 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_316_R;
[ TX_R_316_R ;
    ResponseViaActivity(R_192_RESP_C);
];
Array TX_R_317 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_317_R;
[ TX_R_317_R ;
    ResponseViaActivity(R_193_RESP_A);
];
Array TX_R_318 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_318_R;
[ TX_R_318_R ;
    ResponseViaActivity(R_194_RESP_A);
];
Array TX_R_319 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_319_R;
[ TX_R_319_R ;
    ResponseViaActivity(R_195_RESP_A);
];
Array TX_R_320 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_320_R;
[ TX_R_320_R ;
    ResponseViaActivity(R_197_RESP_A);
];
Array TX_R_321 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_321_R;
[ TX_R_321_R ;
    ResponseViaActivity(R_197_RESP_B);
];
Array TX_R_322 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_322_R;
[ TX_R_322_R ;
    ResponseViaActivity(R_198_RESP_A);
];
Array TX_R_323 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_323_R;
[ TX_R_323_R ;
    ResponseViaActivity(R_199_RESP_A);
];
Array TX_R_324 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_324_R;
[ TX_R_324_R ;
    ResponseViaActivity(R_201_RESP_A);
];
Array TX_R_325 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_325_R;
[ TX_R_325_R ;
    ResponseViaActivity(R_201_RESP_B);
];
Array TX_R_326 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_326_R;
[ TX_R_326_R ;
    ResponseViaActivity(R_202_RESP_A);
];
Array TX_R_327 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_327_R;
[ TX_R_327_R ;
    ResponseViaActivity(R_203_RESP_A);
];
Array TX_R_328 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_328_R;
[ TX_R_328_R ;
    ResponseViaActivity(R_204_RESP_A);
];
Array TX_R_329 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_329_R;
[ TX_R_329_R ;
    ResponseViaActivity(R_205_RESP_A);
];
Array TX_R_330 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_330_R;
[ TX_R_330_R ;
    ResponseViaActivity(R_207_RESP_A);
];
Array TX_R_331 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_331_R;
[ TX_R_331_R ;
    ResponseViaActivity(R_210_RESP_A);
];
Array TX_R_332 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_332_R;
[ TX_R_332_R ;
    ResponseViaActivity(R_213_RESP_A);
];
Array TX_R_333 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_333_R;
[ TX_R_333_R ;
    ResponseViaActivity(R_214_RESP_A);
];
Array TX_R_334 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_334_R;
[ TX_R_334_R ;
    ResponseViaActivity(R_215_RESP_A);
];
Array TX_R_335 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_335_R;
[ TX_R_335_R ;
    ResponseViaActivity(R_216_RESP_A);
];
Array TX_R_336 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_336_R;
[ TX_R_336_R ;
    ResponseViaActivity(R_345_RESP_A);
];
Array TX_R_337 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_337_R;
[ TX_R_337_R ;
    ResponseViaActivity(R_364_RESP_A);
];
Array TX_R_338 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_338_R;
[ TX_R_338_R ;
    ResponseViaActivity(R_344_RESP_A);
];
Array TX_R_339 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_339_R;
[ TX_R_339_R ;
    ResponseViaActivity(R_363_RESP_A);
];
Array TX_R_340 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_340_R;
[ TX_R_340_R ;
    ResponseViaActivity(R_354_RESP_A);
];
Array TX_R_341 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_341_R;
[ TX_R_341_R ;
    ResponseViaActivity(R_217_RESP_A);
];
Array TX_R_342 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_342_R;
[ TX_R_342_R ;
    ResponseViaActivity(R_218_RESP_A);
];
Array TX_R_343 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_343_R;
[ TX_R_343_R ;
    ResponseViaActivity(R_219_RESP_A);
];
Array TX_R_344 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_344_R;
[ TX_R_344_R ;
    ResponseViaActivity(R_221_RESP_A);
];
Array TX_R_345 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_345_R;
[ TX_R_345_R ;
    ResponseViaActivity(R_226_RESP_A);
];
Array TX_R_346 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_346_R;
[ TX_R_346_R ;
    ResponseViaActivity(R_226_RESP_B);
];
Array TX_R_347 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_347_R;
[ TX_R_347_R ;
    ResponseViaActivity(R_227_RESP_A);
];
Array TX_R_348 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_348_R;
[ TX_R_348_R ;
    ResponseViaActivity(R_227_RESP_B);
];
Array TX_R_349 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_349_R;
[ TX_R_349_R ;
    ResponseViaActivity(R_228_RESP_A);
];
Array TX_R_350 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_350_R;
[ TX_R_350_R ;
    ResponseViaActivity(R_228_RESP_B);
];
Array TX_R_351 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_351_R;
[ TX_R_351_R ;
    ResponseViaActivity(R_228_RESP_C);
];
Array TX_R_352 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_352_R;
[ TX_R_352_R ;
    ResponseViaActivity(R_229_RESP_A);
];
Array TX_R_353 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_353_R;
[ TX_R_353_R ;
    ResponseViaActivity(R_229_RESP_B);
];
Array TX_R_354 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_354_R;
[ TX_R_354_R ;
    ResponseViaActivity(R_230_RESP_A);
];
Array TX_R_355 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_355_R;
[ TX_R_355_R ;
    ResponseViaActivity(R_231_RESP_A);
];
Array TX_R_356 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_356_R;
[ TX_R_356_R ;
    ResponseViaActivity(R_231_RESP_B);
];
Array TX_R_357 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_357_R;
[ TX_R_357_R ;
    ResponseViaActivity(R_232_RESP_A);
];
Array TX_R_358 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_358_R;
[ TX_R_358_R ;
    ResponseViaActivity(R_233_RESP_A);
];
Array TX_R_359 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_359_R;
[ TX_R_359_R ;
    ResponseViaActivity(R_234_RESP_A);
];
Array TX_R_360 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_360_R;
[ TX_R_360_R ;
    ResponseViaActivity(R_235_RESP_A);
];
Array TX_R_361 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_361_R;
[ TX_R_361_R ;
    ResponseViaActivity(R_235_RESP_B);
];
Array TX_R_362 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_362_R;
[ TX_R_362_R ;
    ResponseViaActivity(R_236_RESP_A);
];
Array TX_R_363 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_363_R;
[ TX_R_363_R ;
    ResponseViaActivity(R_237_RESP_A);
];
Array TX_R_364 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_364_R;
[ TX_R_364_R ;
    ResponseViaActivity(R_238_RESP_A);
];
Array TX_R_365 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_365_R;
[ TX_R_365_R ;
    ResponseViaActivity(R_239_RESP_A);
];
Array TX_R_366 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_366_R;
[ TX_R_366_R ;
    ResponseViaActivity(R_239_RESP_B);
];
Array TX_R_367 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_367_R;
[ TX_R_367_R ;
    ResponseViaActivity(R_240_RESP_A);
];
Array TX_R_368 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_368_R;
[ TX_R_368_R ;
    ResponseViaActivity(R_241_RESP_A);
];
Array TX_R_369 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_369_R;
[ TX_R_369_R ;
    ResponseViaActivity(R_242_RESP_A);
];
Array TX_R_370 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_370_R;
[ TX_R_370_R ;
    ResponseViaActivity(R_243_RESP_A);
];
Array TX_R_371 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_371_R;
[ TX_R_371_R ;
    ResponseViaActivity(R_243_RESP_B);
];
Array TX_R_372 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_372_R;
[ TX_R_372_R ;
    ResponseViaActivity(R_244_RESP_A);
];
Array TX_R_373 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_373_R;
[ TX_R_373_R ;
    ResponseViaActivity(R_245_RESP_A);
];
Array TX_R_374 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_374_R;
[ TX_R_374_R ;
    ResponseViaActivity(R_246_RESP_A);
];
Array TX_R_375 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_375_R;
[ TX_R_375_R ;
    ResponseViaActivity(R_247_RESP_A);
];
Array TX_R_376 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_376_R;
[ TX_R_376_R ;
    ResponseViaActivity(R_249_RESP_A);
];
Array TX_R_377 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_377_R;
[ TX_R_377_R ;
    ResponseViaActivity(R_250_RESP_A);
];
Array TX_R_378 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_378_R;
[ TX_R_378_R ;
    ResponseViaActivity(R_251_RESP_A);
];
Array TX_R_379 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_379_R;
[ TX_R_379_R ;
    ResponseViaActivity(R_251_RESP_B);
];
Array TX_R_380 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_380_R;
[ TX_R_380_R ;
    ResponseViaActivity(R_347_RESP_A);
];
Array TX_R_381 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_381_R;
[ TX_R_381_R ;
    ResponseViaActivity(R_366_RESP_A);
];
Array TX_R_382 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_382_R;
[ TX_R_382_R ;
    ResponseViaActivity(R_346_RESP_A);
];
Array TX_R_383 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_383_R;
[ TX_R_383_R ;
    ResponseViaActivity(R_365_RESP_A);
];
Array TX_R_384 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_384_R;
[ TX_R_384_R ;
    ResponseViaActivity(R_355_RESP_A);
];
Array TX_R_385 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_385_R;
[ TX_R_385_R ;
    ResponseViaActivity(R_254_RESP_A);
];
Array TX_R_386 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_386_R;
[ TX_R_386_R ;
    ResponseViaActivity(R_343_RESP_B);
];
Array TX_R_387 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_387_R;
[ TX_R_387_R ;
    ResponseViaActivity(R_353_RESP_B);
];
Array TX_R_388 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_388_R;
[ TX_R_388_R ;
    ResponseViaActivity(R_362_RESP_A);
];
Array TX_R_389 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_389_R;
[ TX_R_389_R ;
    ResponseViaActivity(R_362_RESP_B);
];
Array TX_R_390 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_390_R;
[ TX_R_390_R ;
    ResponseViaActivity(R_256_RESP_A);
];
Array TX_R_391 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_391_R;
[ TX_R_391_R ;
    ResponseViaActivity(R_257_RESP_A);
];
Array TX_R_392 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_392_R;
[ TX_R_392_R ;
    ResponseViaActivity(R_257_RESP_B);
];
Array TX_R_393 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_393_R;
[ TX_R_393_R ;
    ResponseViaActivity(R_258_RESP_A);
];
Array TX_R_394 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_394_R;
[ TX_R_394_R ;
    ResponseViaActivity(R_263_RESP_A);
];
Array TX_R_395 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_395_R;
[ TX_R_395_R ;
    ResponseViaActivity(R_274_RESP_A);
];
Array TX_R_396 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_396_R;
[ TX_R_396_R ;
    ResponseViaActivity(R_274_RESP_B);
];
Array TX_R_397 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_397_R;
[ TX_R_397_R ;
    ResponseViaActivity(R_275_RESP_A);
];
Array TX_R_398 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_398_R;
[ TX_R_398_R ;
    ResponseViaActivity(R_278_RESP_A);
];
Array TX_R_399 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_399_R;
[ TX_R_399_R ;
    ResponseViaActivity(R_280_RESP_A);
];
Array TX_R_400 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_400_R;
[ TX_R_400_R ;
    ResponseViaActivity(R_280_RESP_B);
];
Array TX_R_401 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_401_R;
[ TX_R_401_R ;
    ResponseViaActivity(R_285_RESP_A);
];
Array TX_R_402 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_402_R;
[ TX_R_402_R ;
    ResponseViaActivity(R_283_RESP_A);
];
Array TX_R_403 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_403_R;
[ TX_R_403_R ;
    ResponseViaActivity(R_303_RESP_A);
];
Array TX_R_404 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_404_R;
[ TX_R_404_R ;
    ResponseViaActivity(R_320_RESP_A);
];
Array TX_R_405 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_405_R;
[ TX_R_405_R ;
    ResponseViaActivity(R_330_RESP_A);
];
Array TX_R_406 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_406_R;
[ TX_R_406_R ;
    ResponseViaActivity(R_330_RESP_B);
];
Array TX_R_407 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_407_R;
[ TX_R_407_R ;
    ResponseViaActivity(R_330_RESP_C);
];
Array TX_R_408 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_408_R;
[ TX_R_408_R ;
    ResponseViaActivity(R_331_RESP_A);
];
Array TX_R_409 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_409_R;
[ TX_R_409_R ;
    ResponseViaActivity(R_331_RESP_B);
];
Array TX_R_410 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_410_R;
[ TX_R_410_R ;
    ResponseViaActivity(R_339_RESP_A);
];
Array TX_R_411 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_411_R;
[ TX_R_411_R ;
    ResponseViaActivity(R_339_RESP_B);
];
Array TX_R_412 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_412_R;
[ TX_R_412_R ;
    ResponseViaActivity(R_341_RESP_A);
];
Array TX_R_413 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_413_R;
[ TX_R_413_R ;
    ResponseViaActivity(R_341_RESP_B);
];
Array TX_R_414 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_414_R;
[ TX_R_414_R ;
    ResponseViaActivity(R_349_RESP_A);
];
Array TX_R_415 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_415_R;
[ TX_R_415_R ;
    ResponseViaActivity(R_349_RESP_B);
];
Array TX_R_416 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_416_R;
[ TX_R_416_R ;
    ResponseViaActivity(R_351_RESP_A);
];
Array TX_R_417 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_417_R;
[ TX_R_417_R ;
    ResponseViaActivity(R_351_RESP_B);
];
Array TX_R_418 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_418_R;
[ TX_R_418_R ;
    ResponseViaActivity(R_351_RESP_C);
];
Array TX_R_419 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_419_R;
[ TX_R_419_R ;
    ResponseViaActivity(R_358_RESP_A);
];
Array TX_R_420 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_420_R;
[ TX_R_420_R ;
    ResponseViaActivity(R_358_RESP_B);
];
Array TX_R_421 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_421_R;
[ TX_R_421_R ;
    ResponseViaActivity(R_358_RESP_C);
];
Array TX_R_422 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_422_R;
[ TX_R_422_R ;
    ResponseViaActivity(R_360_RESP_A);
];
Array TX_R_423 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_423_R;
[ TX_R_423_R ;
    ResponseViaActivity(R_360_RESP_B);
];
Array TX_R_424 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_424_R;
[ TX_R_424_R ;
    ResponseViaActivity(R_360_RESP_C);
];
Array TX_R_425 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_425_R;
[ TX_R_425_R ;
    ResponseViaActivity(R_360_RESP_D);
];
Array TX_R_426 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_426_R;
[ TX_R_426_R ;
    ResponseViaActivity(R_369_RESP_A);
];
Array TX_R_427 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_427_R;
[ TX_R_427_R ;
    ResponseViaActivity(R_369_RESP_B);
];
Array TX_R_428 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_428_R;
[ TX_R_428_R ;
    ResponseViaActivity(R_369_RESP_C);
];
Array TX_R_429 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_429_R;
[ TX_R_429_R ;
    ResponseViaActivity(R_369_RESP_D);
];
Array TX_R_430 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_430_R;
[ TX_R_430_R ;
    ResponseViaActivity(R_369_RESP_E);
];
Array TX_R_431 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_431_R;
[ TX_R_431_R ;
    ResponseViaActivity(R_371_RESP_A);
];
Array TX_R_432 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_432_R;
[ TX_R_432_R ;
    ResponseViaActivity(R_372_RESP_A);
];
Array TX_R_433 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_433_R;
[ TX_R_433_R ;
    ResponseViaActivity(R_373_RESP_A);
];
Array TX_R_434 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_434_R;
[ TX_R_434_R ;
    ResponseViaActivity(R_373_RESP_B);
];
Array TX_R_435 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_435_R;
[ TX_R_435_R ;
    ResponseViaActivity(R_373_RESP_C);
];
Array TX_R_436 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_436_R;
[ TX_R_436_R ;
    ResponseViaActivity(R_381_RESP_A);
];
Array TX_R_437 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_437_R;
[ TX_R_437_R ;
    ResponseViaActivity(R_379_RESP_A);
];
Array TX_R_438 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_438_R;
[ TX_R_438_R ;
    ResponseViaActivity(R_383_RESP_A);
];
Array TX_R_439 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_439_R;
[ TX_R_439_R ;
    ResponseViaActivity(R_434_RESP_A);
];
Array TX_R_440 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_440_R;
[ TX_R_440_R ;
    ResponseViaActivity(R_435_RESP_A);
];
Array TX_R_441 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_441_R;
[ TX_R_441_R ;
    ResponseViaActivity(R_44_RESP_A);
];
Array TX_R_442 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_442_R;
[ TX_R_442_R ;
    ResponseViaActivity(R_44_RESP_B);
];
Array TX_R_443 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_443_R;
[ TX_R_443_R ;
    ResponseViaActivity(R_44_RESP_C);
];
Array TX_R_444 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_444_R;
[ TX_R_444_R ;
    ResponseViaActivity(R_44_RESP_D);
];
Array TX_R_445 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_445_R;
[ TX_R_445_R ;
    ResponseViaActivity(R_44_RESP_E);
];
Array TX_R_446 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_446_R;
[ TX_R_446_R ;
    ResponseViaActivity(R_44_RESP_F);
];
Array TX_R_447 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_447_R;
[ TX_R_447_R ;
    ResponseViaActivity(R_144_RESP_A);
];
Array TX_R_448 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_448_R;
[ TX_R_448_R ;
    ResponseViaActivity(R_144_RESP_B);
];
Array TX_R_449 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_449_R;
[ TX_R_449_R ;
    ResponseViaActivity(R_144_RESP_C);
];
Array TX_R_450 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_450_R;
[ TX_R_450_R ;
    ResponseViaActivity(R_206_RESP_A);
];
Array TX_R_451 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_451_R;
[ TX_R_451_R ;
    ResponseViaActivity(R_209_RESP_A);
];
Array TX_R_452 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_452_R;
[ TX_R_452_R ;
    ResponseViaActivity(R_209_RESP_B);
];
Array TX_R_453 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_453_R;
[ TX_R_453_R ;
    ResponseViaActivity(R_209_RESP_C);
];
Array TX_R_454 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_454_R;
[ TX_R_454_R ;
    ResponseViaActivity(R_212_RESP_A);
];
Array TX_R_455 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_455_R;
[ TX_R_455_R ;
    ResponseViaActivity(R_220_RESP_A);
];
Array TX_R_456 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_456_R;
[ TX_R_456_R ;
    ResponseViaActivity(R_222_RESP_A);
];
Array TX_R_457 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_457_R;
[ TX_R_457_R ;
    ResponseViaActivity(R_223_RESP_A);
];
Array TX_R_458 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_458_R;
[ TX_R_458_R ;
    ResponseViaActivity(R_252_RESP_A);
];
Array TX_R_459 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_459_R;
[ TX_R_459_R ;
    ResponseViaActivity(R_253_RESP_A);
];
Array TX_R_460 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_460_R;
[ TX_R_460_R ;
    ResponseViaActivity(R_255_RESP_A);
];
Array TX_R_461 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_461_R;
[ TX_R_461_R ;
    ResponseViaActivity(R_264_RESP_A);
];
Array TX_R_462 --> CONSTANT_PACKED_TEXT_STORAGE TX_R_462_R;
[ TX_R_462_R ;
    ResponseViaActivity(R_265_RESP_A);
];
[ R_TX_S_134 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The desk is a cheap DIY piece held together with hex screws. It has a single drawer [regarding Biff's desk][if Biff's desk's drawer is closed]which is closed.[otherwise]which is open.[end if][if Biff's desk's drawer contains something and Biff's desk's drawer is open] The drawer contains [a list of things in Biff's desk's drawer].[end if]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~The desk is a cheap DIY piece held together with hex screws. It has a single drawer [regarding Biff's desk][if Biff's desk's drawer is closed]which is closed.[otherwise]which is open.[end if][if Biff's desk's drawer contains something and Biff's desk's drawer is open] The drawer contains [a list of things in Biff's desk's drawer].[end if]~]
    say__p=1;! [2: ~The desk is a cheap DIY piece held together with hex screws. It has a single drawer ~]
    ParaContent(); print "The desk is a cheap DIY piece held together with hex screws. It has a single drawer ";! [3: regarding biff's desk]
    ParaContent(); RegardingSingleObject(I430_biff_s_desk);! [4: if biff's desk's drawer is closed]

    	if (~~(((((Adj_102_t1_v10(I431_biff_s_desk_s_drawer))))))) jump L_Say905;! [5: ~which is closed.~]
    ParaContent(); print "which is closed.";! [6: otherwise]

    	jump L_SayX896; .L_Say905;! [7: ~which is open.~]
    ParaContent(); print "which is open.";! [8: end if]

    	.L_Say906; .L_SayX896;! [9: if biff's desk's drawer contains something and biff's desk's drawer is open]

    	if (~~((((((Prop_140())))) && ((((Adj_101_t1_v10(I431_biff_s_desk_s_drawer)))))))) jump L_Say907;! [10: ~ The drawer contains ~]
    ParaContent(); print " The drawer contains ";! [11: a list of things in biff's desk's drawer]
    ParaContent(); objectloop(tmp_0 ofclass Object)
    			if (((tmp_0 ofclass K2_thing) && (I431_biff_s_desk_s_drawer == ContainerOf(tmp_0))))
    				give tmp_0 workflag2;
    			else
    				give tmp_0 ~workflag2;
    		WriteListOfMarkedObjects(ENGLISH_BIT);! [12: ~.~]
    ParaContent(); print ".";! [13: end if]

    	.L_Say907; .L_SayX897; .L_Say908; .L_SayX898;rtrue;
];
[ R_TX_S_135 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[If featureless hyperplane is not visited][We] [rub] [our] eyes as [we] [try] to take in [our] surroundings. [end if][if Descending Stair is not in Featureless Hyperplane]In addition to the usual directions of north and south and east and west, two new directions exist here: [italic type]back[roman type] and [italic type]forth[roman type]. As a result, the 'surface' [we're] standing on is in fact a three-dimensional hyperplane. Up and down still exist, and there is gravity, apparently.As far as one can see, the hyperplane extends infinitely in all six directions[otherwise]It is made of the same gossamer, questionably real stuff as the ground, the pillar, and the readouts. You can't see past the first turn of the stairs, unfortunately[end if].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[If featureless hyperplane is not visited][We] [rub] [our] eyes as [we] [try] to take in [our] surroundings. [end if][if Descending Stair is not in Featureless Hyperplane]In addition to the usual directions of north and south and east and west, two new directions exist here: [italic type]back[roman type] and [italic type]forth[roman type]. As a result, the 'surface' [we're] standing on is in fact a three-dimensional hyperplane. Up and down still exist, and there is gravity, apparently.^^As far as one can see, the hyperplane extends infinitely in all six directions[otherwise]It is made of the same gossamer, questionably real stuff as the ground, the pillar, and the readouts. You can't see past the first turn of the stairs, unfortunately[end if].~]
    say__p=1;! [2: if featureless hyperplane is not visited]

    	if (~~((((~~(((Adj_80_t1_v10(I244_featureless_hyperplane))))))))) jump L_Say909;! [3: we]
    ParaContent(); (PHR_764_r7 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: rub]
    ConjugateVerb_52(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ ~]
    ParaContent(); print " ";! [7: our]
    ParaContent(); (PHR_763_r32 ());! [8: ~ eyes as ~]
    ParaContent(); print " eyes as ";! [9: we]
    ParaContent(); (PHR_757_r16 ());! [10: ~ ~]
    ParaContent(); print " ";! [11: try]
    ConjugateVerb_116(CV_POS, PNToVP(), story_tense); say__p=1; ! [12: ~ to take in ~]
    ParaContent(); print " to take in ";! [13: our]
    ParaContent(); (PHR_763_r32 ());! [14: ~ surroundings. ~]
    ParaContent(); print " surroundings. ";! [15: end if]

    	.L_Say909; .L_SayX899;! [16: if descending stair is not in featureless hyperplane]
    ParaContent(); 
    	if (~~((((~~((I244_featureless_hyperplane == ContainerOf(I245_descending_stair)))))))) jump L_Say910;! [17: ~In addition to the usual directions of north and south and east and west, two new directions exist here: ~]
    ParaContent(); print "In addition to the usual directions of north and south and east and west, two new directions exist here: ";! [18: italic type]
    ParaContent(); (PHR_353_r9 ());! [19: ~back~]
    ParaContent(); print "back";! [20: roman type]
    ParaContent(); (PHR_354_r3 ());! [21: ~ and ~]
    ParaContent(); print " and ";! [22: italic type]
    ParaContent(); (PHR_353_r9 ());! [23: ~forth~]
    ParaContent(); print "forth";! [24: roman type]
    ParaContent(); (PHR_354_r3 ());! [25: ~. As a result, the 'surface' ~]
    ParaContent(); print ". As a result, the ~surface~ ";! [26: we're]
    ParaContent(); (PHR_758_r83 ());! [27: ~ standing on is in fact a three-dimensional hyperplane. Up and down still exist, and there is gravity, apparently.^^As far as one can see, the hyperplane extends infinitely in all six directions~]
    ParaContent(); print " standing on is in fact a three-dimensional hyperplane. Up and down still exist, and there is gravity, apparently.^^As far as one can see, the hyperplane extends infinitely in all six directions";! [28: otherwise]

    	jump L_SayX900; .L_Say910;! [29: ~It is made of the same gossamer, questionably real stuff as the ground, the pillar, and the readouts. You can't see past the first turn of the stairs, unfortunately~]
    ParaContent(); print "It is made of the same gossamer, questionably real stuff as the ground, the pillar, and the readouts. You can't see past the first turn of the stairs, unfortunately";! [30: end if]

    	.L_Say911; .L_SayX900;! [31: ~.~]
    ParaContent(); print "."; .L_Say912; .L_SayX901;rtrue;
];
[ R_TX_S_136 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [ask], 'Just how can I get home from here?'~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [ask], 'Just how can I get home from here?'~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: ask]
    ConjugateVerb_124(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~, 'Just how can I get home from here?'~]
    ParaContent(); print ", ~Just how can I get home from here?~"; .L_Say913; .L_SayX902;rtrue;
];
[ R_TX_S_137 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[force pronoun for player][we] [have] no thumb drive~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[force pronoun for player][we] [have] no thumb drive~]
    say__p=1;! [2: force pronoun for player]
    ParaContent(); (PHR_756_r82 (player));! [3: we]
    ParaContent(); (PHR_757_r16 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: have]
    ConjugateVerb_2(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ no thumb drive~]
    ParaContent(); print " no thumb drive"; .L_Say914; .L_SayX903;rtrue;
];
[ R_TX_S_138 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the thumb drive is familiar][We] [shake] [our] head. 'Sorry, no.'[otherwise][We] [look] quizzical. 'What thumb drive?'~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if the thumb drive is familiar][We] [shake] [our] head. 'Sorry, no.'[otherwise][We] [look] quizzical. 'What thumb drive?'~]
    say__p=1;! [2: if the thumb drive is familiar]

    	if (~~(((((Adj_118_t1_v10(I259_thumb_drive))))))) jump L_Say915;! [3: we]
    ParaContent(); (PHR_764_r7 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: shake]
    ConjugateVerb_99(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ ~]
    ParaContent(); print " ";! [7: our]
    ParaContent(); (PHR_763_r32 ());! [8: ~ head. 'Sorry, no.'~]
    ParaContent(); print " head. ~Sorry, no.~";! [9: otherwise]

    	jump L_SayX904; .L_Say915;! [10: we]
    ParaContent(); (PHR_764_r7 ());! [11: ~ ~]
    ParaContent(); print " ";! [12: look]
    ConjugateVerb_43(CV_POS, PNToVP(), story_tense); say__p=1; ! [13: ~ quizzical. 'What thumb drive?'~]
    ParaContent(); print " quizzical. ~What thumb drive?~"; .L_Say916; .L_SayX904;rtrue;
];
[ R_TX_S_139 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the thumb drive is familiar]'Well, you'll just have to go back and get it, won't you? We can't be fooling around when the fate of the timeline is at stake!' Doris says[otherwise]'Huh. Thought you would have found it by now. I'm almost certain it's in your Swamp Park office. Go find it and bring it here.' Doris busies himself at his desk, pointedly ignoring you[end if].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if the thumb drive is familiar]'Well, you'll just have to go back and get it, won't you? We can't be fooling around when the fate of the timeline is at stake!' Doris says[otherwise]'Huh. Thought you would have found it by now. I'm almost certain it's in your Swamp Park office. Go find it and bring it here.' Doris busies himself at his desk, pointedly ignoring you[end if].~]
    say__p=1;! [2: if the thumb drive is familiar]

    	if (~~(((((Adj_118_t1_v10(I259_thumb_drive))))))) jump L_Say917;! [3: ~'Well, you'll just have to go back and get it, won't you? We can't be fooling around when the fate of the timeline is at stake!' Doris says~]
    ParaContent(); print "~Well, you'll just have to go back and get it, won't you? We can't be fooling around when the fate of the timeline is at stake!~ Doris says";! [4: otherwise]

    	jump L_SayX905; .L_Say917;! [5: ~'Huh. Thought you would have found it by now. I'm almost certain it's in your Swamp Park office. Go find it and bring it here.' Doris busies himself at his desk, pointedly ignoring you~]
    ParaContent(); print "~Huh. Thought you would have found it by now. I'm almost certain it's in your Swamp Park office. Go find it and bring it here.~ Doris busies himself at his desk, pointedly ignoring you";! [6: end if]

    	.L_Say918; .L_SayX905;! [7: ~.~]
    ParaContent(); print "."; .L_Say919; .L_SayX906;rtrue;
];
[ R_TX_S_140 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[force pronoun for player][we] brought the thumb drive~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[force pronoun for player][we] brought the thumb drive~]
    say__p=1;! [2: force pronoun for player]
    ParaContent(); (PHR_756_r82 (player));! [3: we]
    ParaContent(); (PHR_757_r16 ());! [4: ~ brought the thumb drive~]
    ParaContent(); print " brought the thumb drive"; .L_Say920; .L_SayX907;rtrue;
];
[ R_TX_S_141 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [reply], 'Yes, I have it.'~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [reply], 'Yes, I have it.'~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: reply]
    ParaContent(); @push self; print (TEXT_TY_Say) GProperty(OBJECT_TY, self=self,p28_reply);@pull self; ! [5: ~, 'Yes, I have it.'~]
    ParaContent(); print ", ~Yes, I have it.~"; .L_Say921; .L_SayX908;rtrue;
];
[ R_TX_S_142 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [give] the thumb drive to Doris.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [give] the thumb drive to Doris.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: give]
    ConjugateVerb_33(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ the thumb drive to Doris.~]
    ParaContent(); print " the thumb drive to Doris."; .L_Say922; .L_SayX909;rtrue;
];
[ R_TX_S_143 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~'Great, great.' He peruses the drive. 'We lost one of our New York agents to a slingshot effect that threw him far back in time. We're always monitoring for artifacts that are out of place or anachronistic to lead us to lost agents.He continues, 'The scratch marks here say [']They found me out and sent me back. 14th century. Enigma Lake. Savra is going to move on the Dragon.[']'~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~'Great, great.' He peruses the drive. 'We lost one of our New York agents to a slingshot effect that threw him far back in time. We're always monitoring for artifacts that are out of place or anachronistic to lead us to lost agents.^^He continues, 'The scratch marks here say [']They found me out and sent me back. 14th century. Enigma Lake. Savra is going to move on the Dragon.[']'~]
    say__p=1;! [2: ~'Great, great.' He peruses the drive. 'We lost one of our New York agents to a slingshot effect that threw him far back in time. We're always monitoring for artifacts that are out of place or anachronistic to lead us to lost agents.^^He continues, 'The scratch marks here say ~]
    ParaContent(); print "~Great, great.~ He peruses the drive. ~We lost one of our New York agents to a slingshot effect that threw him far back in time. We're always monitoring for artifacts that are out of place or anachronistic to lead us to lost agents.^^He continues, ~The scratch marks here say ";! [3: ']
    ParaContent(); print "'";! [4: ~They found me out and sent me back. 14th century. Enigma Lake. Savra is going to move on the Dragon.~]
    ParaContent(); print "They found me out and sent me back. 14th century. Enigma Lake. Savra is going to move on the Dragon.";! [5: ']
    ParaContent(); print "'";! [6: ~'~]
    ParaContent(); print "~"; .L_Say923; .L_SayX910;rtrue;
];
[ R_TX_S_144 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [gaze] stoically at the sad little storefront that is the new BOSH office. The sign from the previous tenant is still up: 'Angel[']s Department Store'. Through the front window can be seen Margaret, in her usual manic work mode.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [gaze] stoically at the sad little storefront that is the new BOSH office. The sign from the previous tenant is still up: 'Angel[']s Department Store'. Through the front window can be seen Margaret, in her usual manic work mode.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: gaze]
    ConjugateVerb_108(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ stoically at the sad little storefront that is the new BOSH office. The sign from the previous tenant is still up: 'Angel~]
    ParaContent(); print " stoically at the sad little storefront that is the new BOSH office. The sign from the previous tenant is still up: ~Angel";! [6: ']
    ParaContent(); print "'";! [7: ~s Department Store'. Through the front window can be seen Margaret, in her usual manic work mode.~]
    ParaContent(); print "s Department Store~. Through the front window can be seen Margaret, in her usual manic work mode."; .L_Say924; .L_SayX911;rtrue;
];
[ R_TX_S_145 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[our] Hyundai~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[our] Hyundai~]
    say__p=1;! [2: our]
    ParaContent(); (PHR_763_r32 ());! [3: ~ Hyundai~]
    ParaContent(); print " Hyundai"; .L_Say925; .L_SayX912;rtrue;
];
[ R_TX_S_146 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~An old bright red Hyundai Accent, it's been [our] personal means of transportation for years. And since the Bureau lost its fleet, it's [our] work car too.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~An old bright red Hyundai Accent, it's been [our] personal means of transportation for years. And since the Bureau lost its fleet, it's [our] work car too.~]
    say__p=1;! [2: ~An old bright red Hyundai Accent, it's been ~]
    ParaContent(); print "An old bright red Hyundai Accent, it's been ";! [3: our]
    ParaContent(); (PHR_763_r32 ());! [4: ~ personal means of transportation for years. And since the Bureau lost its fleet, it's ~]
    ParaContent(); print " personal means of transportation for years. And since the Bureau lost its fleet, it's ";! [5: our]
    ParaContent(); (PHR_763_r32 ());! [6: ~ work car too.~]
    ParaContent(); print " work car too."; .L_Say926; .L_SayX913;rtrue;
];
[ R_TX_S_147 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[Our] Hyundai is parked nearby.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[Our] Hyundai is parked nearby.~]
    say__p=1;! [2: our]
    ParaContent(); (PHR_770_r14 ());! [3: ~ Hyundai is parked nearby.~]
    ParaContent(); print " Hyundai is parked nearby."; .L_Say927; .L_SayX914;rtrue;
];
[ R_TX_S_148 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [peer] through the windows of the laundromat at the rows of aging machines. A sign on the door says 'Closed for renovations'. [We] [turn] away, unimpressed.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [peer] through the windows of the laundromat at the rows of aging machines. A sign on the door says 'Closed for renovations'. [We] [turn] away, unimpressed.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: peer]
    ConjugateVerb_106(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ through the windows of the laundromat at the rows of aging machines. A sign on the door says 'Closed for renovations'. ~]
    ParaContent(); print " through the windows of the laundromat at the rows of aging machines. A sign on the door says ~Closed for renovations~. ";! [6: we]
    ParaContent(); (PHR_764_r7 ());! [7: ~ ~]
    ParaContent(); print " ";! [8: turn]
    ConjugateVerb_64(CV_POS, PNToVP(), story_tense); say__p=1; ! [9: ~ away, unimpressed.~]
    ParaContent(); print " away, unimpressed."; .L_Say928; .L_SayX915;rtrue;
];
[ R_TX_S_149 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [observe] the pawn shop with obvious distaste. The flashing neon sign in the window advertises 'Cash for gold!'~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [observe] the pawn shop with obvious distaste. The flashing neon sign in the window advertises 'Cash for gold!'~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: observe]
    ConjugateVerb_107(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ the pawn shop with obvious distaste. The flashing neon sign in the window advertises 'Cash for gold!'~]
    ParaContent(); print " the pawn shop with obvious distaste. The flashing neon sign in the window advertises ~Cash for gold!~"; .L_Say929; .L_SayX916;rtrue;
];
[ R_TX_S_150 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[Margaret Chao] is the latest occupant of the rapidly revolving post of office manager. Most of [their] job involves ordering stationery and office supplies, shredding documents, and keeping track of office equipment.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[Margaret Chao] is the latest occupant of the rapidly revolving post of office manager. Most of [their] job involves ordering stationery and office supplies, shredding documents, and keeping track of office equipment.~]
    say__p=1;! [2: margaret chao]
    ParaContent(); PrintShortName(I358_margaret_chao);! [3: ~ is the latest occupant of the rapidly revolving post of office manager. Most of ~]
    ParaContent(); print " is the latest occupant of the rapidly revolving post of office manager. Most of ";! [4: their]
    ParaContent(); (PHR_777_r33 ());! [5: ~ job involves ordering stationery and office supplies, shredding documents, and keeping track of office equipment.~]
    ParaContent(); print " job involves ordering stationery and office supplies, shredding documents, and keeping track of office equipment."; .L_Say930; .L_SayX917;rtrue;
];
[ R_TX_S_151 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The former sales counter now functions as a desk for the office manager (currently [Margaret]). Behind it are a number of shelves holding office supplies.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~The former sales counter now functions as a desk for the office manager (currently [Margaret]). Behind it are a number of shelves holding office supplies.~]
    say__p=1;! [2: ~The former sales counter now functions as a desk for the office manager (currently ~]
    ParaContent(); print "The former sales counter now functions as a desk for the office manager (currently ";! [3: margaret]
    ParaContent(); PrintShortName(I358_margaret_chao);! [4: ~). Behind it are a number of shelves holding office supplies.~]
    ParaContent(); print "). Behind it are a number of shelves holding office supplies."; .L_Say931; .L_SayX918;rtrue;
];
[ R_TX_S_152 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Pens, paper, nothing [we're] really concerned with now.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Pens, paper, nothing [we're] really concerned with now.~]
    say__p=1;! [2: ~Pens, paper, nothing ~]
    ParaContent(); print "Pens, paper, nothing ";! [3: we're]
    ParaContent(); (PHR_758_r83 ());! [4: ~ really concerned with now.~]
    ParaContent(); print " really concerned with now."; .L_Say932; .L_SayX919;rtrue;
];
[ R_TX_S_153 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Even from here one can sense [Margaret]'s irrepressible energy.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Even from here one can sense [Margaret]'s irrepressible energy.~]
    say__p=1;! [2: ~Even from here one can sense ~]
    ParaContent(); print "Even from here one can sense ";! [3: margaret]
    ParaContent(); PrintShortName(I358_margaret_chao);! [4: ~'s irrepressible energy.~]
    ParaContent(); print "'s irrepressible energy."; .L_Say933; .L_SayX920;rtrue;
];
[ R_TX_S_154 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~A man, presumably Dave, stands behind the main counter eyeing [Player].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~A man, presumably Dave, stands behind the main counter eyeing [Player].~]
    say__p=1;! [2: ~A man, presumably Dave, stands behind the main counter eyeing ~]
    ParaContent(); print "A man, presumably Dave, stands behind the main counter eyeing ";! [3: player]
    ParaContent(); PrintShortName(player);! [4: ~.~]
    ParaContent(); print "."; .L_Say934; .L_SayX921;rtrue;
];
[ R_TX_S_155 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [EG][stammer] 'Excuse me, I was wondering, I'm from the office next door...'[Dave] [polish] a spot on the glass counter and [say], 'Spit it out, buddy.''Uh, yes, by the way, nice establishment you have here...''Sure.'[EG]'Anyway, is there any chance that maybe you, um, have a screwdriver? That I could borrow, just for a few minutes of course.'[PCG][smile] warmly and [say], 'Hi, I[']m Petula from next door -- ''[italic type]Very[roman type] pleased to meet you, Petula,' [regarding Dave][interrupt] [Dave].[We] [raise] one eyebrow. 'Of course. Likewise. Anyway, as I was saying, I'm Agent Goldberg from the Bureau next door --'[PCG]'Agent, Bureau, really?' [regarding Dave][They] [chuckle]. 'In this hole? Who'd you piss off?''You couldn't imagine, sir. But to why I came here: do you happen to have a screwdriver I could borrow?'[LF][lean] on the counter. 'Hey, do you have a screwdriver? Can't find mine and I really need one.'[end say]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [EG][stammer] 'Excuse me, I was wondering, I'm from the office next door...'^^[Dave] [polish] a spot on the glass counter and [say], 'Spit it out, buddy.'^^'Uh, yes, by the way, nice establishment you have here...'^^'Sure.'^^[EG]'Anyway, is there any chance that maybe you, um, have a screwdriver? That I could borrow, just for a few minutes of course.'[PCG][smile] warmly and [say], 'Hi, I[']m Petula from next door -- '^^'[italic type]Very[roman type] pleased to meet you, Petula,' [regarding Dave][interrupt] [Dave].^^[We] [raise] one eyebrow. 'Of course. Likewise. Anyway, as I was saying, I'm Agent Goldberg from the Bureau next door --'[PCG]^^'Agent, Bureau, really?' [regarding Dave][They] [chuckle]. 'In this hole? Who'd you piss off?'^^'You couldn't imagine, sir. But to why I came here: do you happen to have a screwdriver I could borrow?'[LF][lean] on the counter. 'Hey, do you have a screwdriver? Can't find mine and I really need one.'[end say]~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: eg]
    ParaContent(); (PHR_1475_r210 ());! [5: stammer]
    ConjugateVerb_132(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ 'Excuse me, I was wondering, I'm from the office next door...'^^~]
    ParaContent(); print " ~Excuse me, I was wondering, I'm from the office next door...~^^";! [7: dave]
    ParaContent(); PrintShortName(I320_dave);! [8: ~ ~]
    ParaContent(); print " ";! [9: polish]
    ConjugateVerb_133(CV_POS, PNToVP(), story_tense); say__p=1; ! [10: ~ a spot on the glass counter and ~]
    ParaContent(); print " a spot on the glass counter and ";! [11: say]
    ConjugateVerb_53(CV_POS, PNToVP(), story_tense); say__p=1; ! [12: ~, 'Spit it out, buddy.'^^'Uh, yes, by the way, nice establishment you have here...'^^'Sure.'^^~]
    ParaContent(); print ", ~Spit it out, buddy.~^^~Uh, yes, by the way, nice establishment you have here...~^^~Sure.~^^";! [13: eg]
    ParaContent(); (PHR_1475_r210 ());! [14: ~'Anyway, is there any chance that maybe you, um, have a screwdriver? That I could borrow, just for a few minutes of course.'~]
    ParaContent(); print "~Anyway, is there any chance that maybe you, um, have a screwdriver? That I could borrow, just for a few minutes of course.~";! [15: pcg]
    ParaContent(); (PHR_1476_r211 ());! [16: smile]
    ConjugateVerb_104(CV_POS, PNToVP(), story_tense); say__p=1; ! [17: ~ warmly and ~]
    ParaContent(); print " warmly and ";! [18: say]
    ConjugateVerb_53(CV_POS, PNToVP(), story_tense); say__p=1; ! [19: ~, 'Hi, I~]
    ParaContent(); print ", ~Hi, I";! [20: ']
    ParaContent(); print "'";! [21: ~m Petula from next door -- '^^'~]
    ParaContent(); print "m Petula from next door -- ~^^~";! [22: italic type]
    ParaContent(); (PHR_353_r9 ());! [23: ~Very~]
    ParaContent(); print "Very";! [24: roman type]
    ParaContent(); (PHR_354_r3 ());! [25: ~ pleased to meet you, Petula,' ~]
    ParaContent(); print " pleased to meet you, Petula,~ ";! [26: regarding dave]
    ParaContent(); RegardingSingleObject(I320_dave);! [27: interrupt]
    ConjugateVerb_134(CV_POS, PNToVP(), story_tense); say__p=1; ! [28: ~ ~]
    ParaContent(); print " ";! [29: dave]
    ParaContent(); PrintShortName(I320_dave);! [30: ~.^^~]
    ParaContent(); print ".^^";! [31: we]
    ParaContent(); (PHR_764_r7 ());! [32: ~ ~]
    ParaContent(); print " ";! [33: raise]
    ConjugateVerb_135(CV_POS, PNToVP(), story_tense); say__p=1; ! [34: ~ one eyebrow. 'Of course. Likewise. Anyway, as I was saying, I'm Agent Goldberg from the Bureau next door --'~]
    ParaContent(); print " one eyebrow. ~Of course. Likewise. Anyway, as I was saying, I'm Agent Goldberg from the Bureau next door --~";! [35: pcg]
    ParaContent(); (PHR_1476_r211 ());! [36: ~^^'Agent, Bureau, really?' ~]
    ParaContent(); print "^^~Agent, Bureau, really?~ ";! [37: regarding dave]
    ParaContent(); RegardingSingleObject(I320_dave);! [38: they]
    ParaContent(); (PHR_776_r43 ());! [39: ~ ~]
    ParaContent(); print " ";! [40: chuckle]
    ConjugateVerb_136(CV_POS, PNToVP(), story_tense); say__p=1; ! [41: ~. 'In this hole? Who'd you piss off?'^^'You couldn't imagine, sir. But to why I came here: do you happen to have a screwdriver I could borrow?'~]
    ParaContent(); print ". ~In this hole? Who'd you piss off?~^^~You couldn't imagine, sir. But to why I came here: do you happen to have a screwdriver I could borrow?~";! [42: lf]
    ParaContent(); (PHR_1477_r212 ());! [43: lean]
    ConjugateVerb_137(CV_POS, PNToVP(), story_tense); say__p=1; ! [44: ~ on the counter. 'Hey, do you have a screwdriver? Can't find mine and I really need one.'~]
    ParaContent(); print " on the counter. ~Hey, do you have a screwdriver? Can't find mine and I really need one.~";! [45: end say]
    ParaContent(); (PHR_1478_r213 ()); .L_Say935; .L_SayX922;rtrue;
];
[ R_TX_S_156 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[EG][Dave] [look] exasperated. 'Is that all? [PCG]The shopkeeper rolls his eyes. '[LF]The man shakes his head and says, 'Sorry, miss. [end say]I had one, but the guy who runs the laundromat borrowed it and didn't bring it back.'[line break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[EG][Dave] [look] exasperated. 'Is that all? [PCG]The shopkeeper rolls his eyes. '[LF]The man shakes his head and says, 'Sorry, miss. [end say]I had one, but the guy who runs the laundromat borrowed it and didn't bring it back.'[line break]~]
    say__p=1;! [2: eg]
    ParaContent(); (PHR_1475_r210 ());! [3: dave]
    ParaContent(); PrintShortName(I320_dave);! [4: ~ ~]
    ParaContent(); print " ";! [5: look]
    ConjugateVerb_43(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ exasperated. 'Is that all? ~]
    ParaContent(); print " exasperated. ~Is that all? ";! [7: pcg]
    ParaContent(); (PHR_1476_r211 ());! [8: ~The shopkeeper rolls his eyes. '~]
    ParaContent(); print "The shopkeeper rolls his eyes. ~";! [9: lf]
    ParaContent(); (PHR_1477_r212 ());! [10: ~The man shakes his head and says, 'Sorry, miss. ~]
    ParaContent(); print "The man shakes his head and says, ~Sorry, miss. ";! [11: end say]
    ParaContent(); (PHR_1478_r213 ());! [12: ~I had one, but the guy who runs the laundromat borrowed it and didn't bring it back.'~]
    ParaContent(); print "I had one, but the guy who runs the laundromat borrowed it and didn't bring it back.~";! [13: line break]
    ParaContent(); new_line; .L_Say936; .L_SayX923;rtrue;
];
[ R_TX_S_157 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [EG][say], 'Huh, um. Do you know how I could, uh, find the laundromat owner -- was it owner, or manager? I don't suppose it really matters. Anyway, do you know where he, um, or she I guess, is?'[PCG][consider] for a moment and [say], 'How do you suppose I might get in touch with this man who runs the laundromat? I really could use a screwdriver.'[LF][nod]. 'Okay, then, how do I get in touch with this laundromat guy?'[end say]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [EG][say], 'Huh, um. Do you know how I could, uh, find the laundromat owner -- was it owner, or manager? I don't suppose it really matters. Anyway, do you know where he, um, or she I guess, is?'[PCG][consider] for a moment and [say], 'How do you suppose I might get in touch with this man who runs the laundromat? I really could use a screwdriver.'[LF][nod]. 'Okay, then, how do I get in touch with this laundromat guy?'[end say]~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: eg]
    ParaContent(); (PHR_1475_r210 ());! [5: say]
    ConjugateVerb_53(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~, 'Huh, um. Do you know how I could, uh, find the laundromat owner -- was it owner, or manager? I don't suppose it really matters. Anyway, do you know where he, um, or she I guess, is?'~]
    ParaContent(); print ", ~Huh, um. Do you know how I could, uh, find the laundromat owner -- was it owner, or manager? I don't suppose it really matters. Anyway, do you know where he, um, or she I guess, is?~";! [7: pcg]
    ParaContent(); (PHR_1476_r211 ());! [8: consider]
    ConjugateVerb_138(CV_POS, PNToVP(), story_tense); say__p=1; ! [9: ~ for a moment and ~]
    ParaContent(); print " for a moment and ";! [10: say]
    ConjugateVerb_53(CV_POS, PNToVP(), story_tense); say__p=1; ! [11: ~, 'How do you suppose I might get in touch with this man who runs the laundromat? I really could use a screwdriver.'~]
    ParaContent(); print ", ~How do you suppose I might get in touch with this man who runs the laundromat? I really could use a screwdriver.~";! [12: lf]
    ParaContent(); (PHR_1477_r212 ());! [13: nod]
    ConjugateVerb_139(CV_POS, PNToVP(), story_tense); say__p=1; ! [14: ~. 'Okay, then, how do I get in touch with this laundromat guy?'~]
    ParaContent(); print ". ~Okay, then, how do I get in touch with this laundromat guy?~";! [15: end say]
    ParaContent(); (PHR_1478_r213 ()); .L_Say937; .L_SayX924;rtrue;
];
[ R_TX_S_158 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [don't] need any of this stuff.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [don't] need any of this stuff.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: don't]
    ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ need any of this stuff.~]
    ParaContent(); print " need any of this stuff."; .L_Say938; .L_SayX925;rtrue;
];
[ R_TX_S_159 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [feel] fine for now.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [feel] fine for now.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: feel]
    ConjugateVerb_30(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ fine for now.~]
    ParaContent(); print " fine for now."; .L_Say939; .L_SayX926;rtrue;
];
[ R_TX_S_160 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [have] no interest in smoking.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [have] no interest in smoking.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: have]
    ConjugateVerb_2(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ no interest in smoking.~]
    ParaContent(); print " no interest in smoking."; .L_Say940; .L_SayX927;rtrue;
];
[ R_TX_S_161 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [feel] no urge to gamble.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [feel] no urge to gamble.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: feel]
    ConjugateVerb_30(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ no urge to gamble.~]
    ParaContent(); print " no urge to gamble."; .L_Say941; .L_SayX928;rtrue;
];
[ R_TX_S_162 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] hardly [need] bread, ketchup, or potato chips.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] hardly [need] bread, ketchup, or potato chips.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ hardly ~]
    ParaContent(); print " hardly ";! [4: need]
    ConjugateVerb_44(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ bread, ketchup, or potato chips.~]
    ParaContent(); print " bread, ketchup, or potato chips."; .L_Say942; .L_SayX929;rtrue;
];
[ R_TX_S_163 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [ask], 'Would you happen to have a screwdriver I could borrow?'~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [ask], 'Would you happen to have a screwdriver I could borrow?'~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: ask]
    ConjugateVerb_124(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~, 'Would you happen to have a screwdriver I could borrow?'~]
    ParaContent(); print ", ~Would you happen to have a screwdriver I could borrow?~"; .L_Say943; .L_SayX930;rtrue;
];
[ R_TX_S_164 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[one of]The clerk looks at you skeptically. 'Sorry, no. Try the pawn shop guy.'[pawn-shop-screwdriver][or]He looks annoyed. 'And have you run off with it? No way. Like I said, try the pawn shop!'[stopping]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[one of]The clerk looks at you skeptically. 'Sorry, no. Try the pawn shop guy.'[pawn-shop-screwdriver][or]He looks annoyed. 'And have you run off with it? No way. Like I said, try the pawn shop!'[stopping]~]
    say__p=1;! [2: one of]
    ParaContent(); 
    	
    	if (I7_ST_say_one_flag-->0 == false) {
    		I7_ST_say_one_of-->0 = i7_soo_stop(I7_ST_say_one_of-->0,
    2);
    	 	I7_ST_say_one_flag-->0 = true;
    	}
    	if (say__comp == false) I7_ST_say_one_flag-->0 =
    false;
    	switch ((I7_ST_say_one_of-->0)%(2+1)-1)
    {
    		0:! [3: ~The clerk looks at you skeptically. 'Sorry, no. Try the pawn shop guy.'~]
    ParaContent(); print "The clerk looks at you skeptically. ~Sorry, no. Try the pawn shop guy.~";! [4: pawn-shop-screwdriver]
    ParaContent(); PrintShortName(I165_pawn_shop_screwdriver);! [5: or]
    ParaContent(); @nop; 1:! [6: ~He looks annoyed. 'And have you run off with it? No way. Like I said, try the pawn shop!'~]
    ParaContent(); print "He looks annoyed. ~And have you run off with it? No way. Like I said, try the pawn shop!~";! [7: stopping]
    ParaContent(); } .L_Say944; .L_SayX931;rtrue;
];
[ R_TX_S_165 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [say] 'How are you[if the current interlocutor is proper-named], [current interlocutor][end if]?'~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [say] 'How are you[if the current interlocutor is proper-named], [current interlocutor][end if]?'~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: say]
    ConjugateVerb_53(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ 'How are you~]
    ParaContent(); print " ~How are you";! [6: if the current interlocutor is proper-named]

    	if (~~(((((Adj_73_t1_v10((Global_Vars-->11)))))))) jump L_Say945;! [7: ~, ~]
    ParaContent(); print ", ";! [8: current interlocutor]
    ParaContent(); PrintShortName((Global_Vars-->11));! [9: end if]

    	.L_Say945; .L_SayX932;! [10: ~?'~]
    ParaContent(); print "?~"; .L_Say946; .L_SayX933;rtrue;
];
[ R_TX_S_166 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The current interlocutor] replies, '[how-are-you-reply of the current interlocutor]'~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The current interlocutor] replies, '[how-are-you-reply of the current interlocutor]'~]
    say__p=1;! [2: the current interlocutor]
    ParaContent(); print (The) (Global_Vars-->11);! [3: ~ replies, '~]
    ParaContent(); print " replies, ~";! [4: how-are-you-reply of the current interlocutor]
    ParaContent(); @push self; print (TEXT_TY_Say) GProperty(OBJECT_TY, self=(Global_Vars-->11),p38_how_are_you_reply);@pull self; ! [5: ~'~]
    ParaContent(); print "~"; .L_Say947; .L_SayX934;rtrue;
];
[ R_TX_S_167 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [remember] finding the drive in an ancient Onandaga root cellar on a farm in upstate New York. [We] [have] never been able to read it.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [remember] finding the drive in an ancient Onandaga root cellar on a farm in upstate New York. [We] [have] never been able to read it.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: remember]
    ConjugateVerb_143(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ finding the drive in an ancient Onandaga root cellar on a farm in upstate New York. ~]
    ParaContent(); print " finding the drive in an ancient Onandaga root cellar on a farm in upstate New York. ";! [6: we]
    ParaContent(); (PHR_764_r7 ());! [7: ~ ~]
    ParaContent(); print " ";! [8: have]
    ConjugateVerb_2(CV_POS, PNToVP(), story_tense); say__p=1; ! [9: ~ never been able to read it.~]
    ParaContent(); print " never been able to read it."; .L_Say948; .L_SayX935;rtrue;
];
[ R_TX_S_168 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [say], '[EG]Um, uh, Margaret? Do you know where the key to my desk is?[PCG]Margaret, sweetheart, do you know where my desk key is?[LF]Hey Margaret, do you know anything about my desk key?[end say]'[line break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [say], '[EG]Um, uh, Margaret? Do you know where the key to my desk is?[PCG]Margaret, sweetheart, do you know where my desk key is?[LF]Hey Margaret, do you know anything about my desk key?[end say]'[line break]~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: say]
    ConjugateVerb_53(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~, '~]
    ParaContent(); print ", ~";! [6: eg]
    ParaContent(); (PHR_1475_r210 ());! [7: ~Um, uh, Margaret? Do you know where the key to my desk is?~]
    ParaContent(); print "Um, uh, Margaret? Do you know where the key to my desk is?";! [8: pcg]
    ParaContent(); (PHR_1476_r211 ());! [9: ~Margaret, sweetheart, do you know where my desk key is?~]
    ParaContent(); print "Margaret, sweetheart, do you know where my desk key is?";! [10: lf]
    ParaContent(); (PHR_1477_r212 ());! [11: ~Hey Margaret, do you know anything about my desk key?~]
    ParaContent(); print "Hey Margaret, do you know anything about my desk key?";! [12: end say]
    ParaContent(); (PHR_1478_r213 ());! [13: ~'~]
    ParaContent(); print "~";! [14: line break]
    ParaContent(); new_line; .L_Say949; .L_SayX936;rtrue;
];
[ R_TX_S_169 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~'Margaret', [we] [say], 'what's up with my computer?'~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~'Margaret', [we] [say], 'what's up with my computer?'~]
    say__p=1;! [2: ~'Margaret', ~]
    ParaContent(); print "~Margaret~, ";! [3: we]
    ParaContent(); (PHR_757_r16 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: say]
    ConjugateVerb_53(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~, 'what's up with my computer?'~]
    ParaContent(); print ", ~what's up with my computer?~"; .L_Say950; .L_SayX937;rtrue;
];
[ R_TX_S_170 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~'[regarding Margaret]Oh, it got busted up during the move. I have it behind my desk -- you can see it if you want. We'll have to get you a new one.'~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~'[regarding Margaret]Oh, it got busted up during the move. I have it behind my desk -- you can see it if you want. We'll have to get you a new one.'~]
    say__p=1;! [2: ~'~]
    ParaContent(); print "~";! [3: regarding margaret]
    ParaContent(); RegardingSingleObject(I358_margaret_chao);! [4: ~Oh, it got busted up during the move. I have it behind my desk -- you can see it if you want. We'll have to get you a new one.'~]
    ParaContent(); print "Oh, it got busted up during the move. I have it behind my desk -- you can see it if you want. We'll have to get you a new one.~"; .L_Say951; .L_SayX938;rtrue;
];
[ R_TX_S_171 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[our] computer~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[our] computer~]
    say__p=1;! [2: our]
    ParaContent(); (PHR_763_r32 ());! [3: ~ computer~]
    ParaContent(); print " computer"; .L_Say952; .L_SayX939;rtrue;
];
[ R_TX_S_172 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[Our] computer has been damaged beyond repair.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[Our] computer has been damaged beyond repair.~]
    say__p=1;! [2: our]
    ParaContent(); (PHR_770_r14 ());! [3: ~ computer has been damaged beyond repair.~]
    ParaContent(); print " computer has been damaged beyond repair."; .L_Say953; .L_SayX940;rtrue;
];
[ R_TX_S_173 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [say], 'Do you happen to have the hex wrench from putting together my desk?'~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [say], 'Do you happen to have the hex wrench from putting together my desk?'~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: say]
    ConjugateVerb_53(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~, 'Do you happen to have the hex wrench from putting together my desk?'~]
    ParaContent(); print ", ~Do you happen to have the hex wrench from putting together my desk?~"; .L_Say954; .L_SayX941;rtrue;
];
[ R_TX_S_174 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~'Well, I [italic type]did[roman type], but I dropped it down a heating vent behind my desk.'~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~'Well, I [italic type]did[roman type], but I dropped it down a heating vent behind my desk.'~]
    say__p=1;! [2: ~'Well, I ~]
    ParaContent(); print "~Well, I ";! [3: italic type]
    ParaContent(); (PHR_353_r9 ());! [4: ~did~]
    ParaContent(); print "did";! [5: roman type]
    ParaContent(); (PHR_354_r3 ());! [6: ~, but I dropped it down a heating vent behind my desk.'~]
    ParaContent(); print ", but I dropped it down a heating vent behind my desk.~"; .L_Say955; .L_SayX942;rtrue;
];
[ R_TX_S_175 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the current interlocutor is Margaret][We] [ask], [one of][EG]'Er, screwdriver? Margaret?'[PCG]'Margaret, dear, do we have a screwdriver around here?'[LF]'Margaret, where's the screwdriver?'[end say][line break][or]'Are you sure we don't have one?'[stopping][otherwise][We] [ask], [one of]'Would you happen to have a screwdriver I could borrow?'[or]'You sure? I could really use one.'[stopping][end if]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if the current interlocutor is Margaret][We] [ask], [one of][EG]'Er, screwdriver? Margaret?'[PCG]'Margaret, dear, do we have a screwdriver around here?'[LF]'Margaret, where's the screwdriver?'[end say][line break][or]'Are you sure we don't have one?'[stopping][otherwise][We] [ask], [one of]'Would you happen to have a screwdriver I could borrow?'[or]'You sure? I could really use one.'[stopping][end if]~]
    say__p=1;! [2: if the current interlocutor is margaret]

    	if (~~(((((Global_Vars-->11) == I358_margaret_chao))))) jump L_Say956;! [3: we]
    ParaContent(); (PHR_764_r7 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: ask]
    ConjugateVerb_124(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~, ~]
    ParaContent(); print ", ";! [7: one of]
    ParaContent(); 
    	
    	if (I7_ST_say_one_flag-->1 == false) {
    		I7_ST_say_one_of-->1 = i7_soo_stop(I7_ST_say_one_of-->1,
    2);
    	 	I7_ST_say_one_flag-->1 = true;
    	}
    	if (say__comp == false) I7_ST_say_one_flag-->1 =
    false;
    	switch ((I7_ST_say_one_of-->1)%(2+1)-1)
    {
    		0:! [8: eg]
    ParaContent(); (PHR_1475_r210 ());! [9: ~'Er, screwdriver? Margaret?'~]
    ParaContent(); print "~Er, screwdriver? Margaret?~";! [10: pcg]
    ParaContent(); (PHR_1476_r211 ());! [11: ~'Margaret, dear, do we have a screwdriver around here?'~]
    ParaContent(); print "~Margaret, dear, do we have a screwdriver around here?~";! [12: lf]
    ParaContent(); (PHR_1477_r212 ());! [13: ~'Margaret, where's the screwdriver?'~]
    ParaContent(); print "~Margaret, where's the screwdriver?~";! [14: end say]
    ParaContent(); (PHR_1478_r213 ());! [15: line break]
    ParaContent(); new_line;! [16: or]
    ParaContent(); @nop; 1:! [17: ~'Are you sure we don't have one?'~]
    ParaContent(); print "~Are you sure we don't have one?~";! [18: stopping]
    ParaContent(); }! [19: otherwise]

    	jump L_SayX943; .L_Say956;! [20: we]
    ParaContent(); (PHR_764_r7 ());! [21: ~ ~]
    ParaContent(); print " ";! [22: ask]
    ConjugateVerb_124(CV_POS, PNToVP(), story_tense); say__p=1; ! [23: ~, ~]
    ParaContent(); print ", ";! [24: one of]
    ParaContent(); 
    	
    	if (I7_ST_say_one_flag-->2 == false) {
    		I7_ST_say_one_of-->2 = i7_soo_stop(I7_ST_say_one_of-->2,
    2);
    	 	I7_ST_say_one_flag-->2 = true;
    	}
    	if (say__comp == false) I7_ST_say_one_flag-->2 =
    false;
    	switch ((I7_ST_say_one_of-->2)%(2+1)-1)
    {
    		0:! [25: ~'Would you happen to have a screwdriver I could borrow?'~]
    ParaContent(); print "~Would you happen to have a screwdriver I could borrow?~";! [26: or]
    ParaContent(); @nop; 1:! [27: ~'You sure? I could really use one.'~]
    ParaContent(); print "~You sure? I could really use one.~";! [28: stopping]
    ParaContent(); }! [29: end if]

    	.L_Say957; .L_SayX943; .L_Say958; .L_SayX944;rtrue;
];
[ R_TX_S_176 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[one of]'Umm... I think it was in a box we had to leave behind.' [Margaret] looks embarrassed. 'What? I never thought we'd need it. This isn't a construction site after all. Maybe if Klimp had paid for the bigger UHaul...' [They] stares past [us] awkwardly.[or][Margaret] just looks at [us] darkly.[stopping]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[one of]'Umm... I think it was in a box we had to leave behind.' [Margaret] looks embarrassed. 'What? I never thought we'd need it. This isn't a construction site after all. Maybe if Klimp had paid for the bigger UHaul...' [They] stares past [us] awkwardly.[or][Margaret] just looks at [us] darkly.[stopping]~]
    say__p=1;! [2: one of]
    ParaContent(); 
    	
    	if (I7_ST_say_one_flag-->3 == false) {
    		I7_ST_say_one_of-->3 = i7_soo_stop(I7_ST_say_one_of-->3,
    2);
    	 	I7_ST_say_one_flag-->3 = true;
    	}
    	if (say__comp == false) I7_ST_say_one_flag-->3 =
    false;
    	switch ((I7_ST_say_one_of-->3)%(2+1)-1)
    {
    		0:! [3: ~'Umm... I think it was in a box we had to leave behind.' ~]
    ParaContent(); print "~Umm... I think it was in a box we had to leave behind.~ ";! [4: margaret]
    ParaContent(); PrintShortName(I358_margaret_chao);! [5: ~ looks embarrassed. 'What? I never thought we'd need it. This isn't a construction site after all. Maybe if Klimp had paid for the bigger UHaul...' ~]
    ParaContent(); print " looks embarrassed. ~What? I never thought we'd need it. This isn't a construction site after all. Maybe if Klimp had paid for the bigger UHaul...~ ";! [6: they]
    ParaContent(); (PHR_776_r43 ());! [7: ~ stares past ~]
    ParaContent(); print " stares past ";! [8: us]
    ParaContent(); (PHR_760_r49 ());! [9: ~ awkwardly.~]
    ParaContent(); print " awkwardly.";! [10: or]
    ParaContent(); @nop; 1:! [11: margaret]
    ParaContent(); PrintShortName(I358_margaret_chao);! [12: ~ just looks at ~]
    ParaContent(); print " just looks at ";! [13: us]
    ParaContent(); (PHR_760_r49 ());! [14: ~ darkly.~]
    ParaContent(); print " darkly.";! [15: stopping]
    ParaContent(); } .L_Say959; .L_SayX945;rtrue;
];
[ R_TX_S_177 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [ask], 'Could you unlock the back door, Margaret?'~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [ask], 'Could you unlock the back door, Margaret?'~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: ask]
    ConjugateVerb_124(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~, 'Could you unlock the back door, Margaret?'~]
    ParaContent(); print ", ~Could you unlock the back door, Margaret?~"; .L_Say960; .L_SayX946;rtrue;
];
[ R_TX_S_178 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~An unremarkable metal door painted white. [state of BOSH back door][run paragraph on]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~An unremarkable metal door painted white. [state of BOSH back door][run paragraph on]~]
    say__p=1;! [2: ~An unremarkable metal door painted white. ~]
    ParaContent(); print "An unremarkable metal door painted white. ";! [3: state of bosh back door]
    ParaContent(); (PHR_1044_r141 (I367_bosh_back_door));! [4: run paragraph on]
    ParaContent(); RunParagraphOn(); .L_Say961; .L_SayX947;rtrue;
];
[ R_TX_S_179 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [ask], 'Chief, mind if I borrow the skull?'~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [ask], 'Chief, mind if I borrow the skull?'~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: ask]
    ConjugateVerb_124(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~, 'Chief, mind if I borrow the skull?'~]
    ParaContent(); print ", ~Chief, mind if I borrow the skull?~"; .L_Say962; .L_SayX948;rtrue;
];
[ R_TX_S_180 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [ask], 'Would it be okay if I borrowed the astral lenses for a while?'~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [ask], 'Would it be okay if I borrowed the astral lenses for a while?'~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: ask]
    ConjugateVerb_124(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~, 'Would it be okay if I borrowed the astral lenses for a while?'~]
    ParaContent(); print ", ~Would it be okay if I borrowed the astral lenses for a while?~"; .L_Say963; .L_SayX949;rtrue;
];
[ R_TX_S_181 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[our] office~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[our] office~]
    say__p=1;! [2: our]
    ParaContent(); (PHR_763_r32 ());! [3: ~ office~]
    ParaContent(); print " office"; .L_Say964; .L_SayX950;rtrue;
];
[ R_TX_S_182 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if biff's office is not visited][We] [pause] and [survey] the scene. It's not much -- four white walls, grey industrial carpet. [Margaret] [have] helpfully assembled [our] desk and chair, though how sturdily is an open question. [Regarding Margaret][They] also took the time to put up some of Agent [Player]'s office decor -- [our] degree in Nonstandard Investigative Techniques, [EG]a trivia competition award, and a poster for [our] favorite movie: the b-movie time-travel classic The Room of Lost Time[PCG]a photo of [our] dog Pluto, and a print of [italic type]Green Pheasant[roman type] by Utagawa Hiroshige[LF]an original pencil drawing of the Pitfall snake by semi-acclaimed Washington DC artist Darius 5200, and a photo of [our] softball team[end say]. At the very least the wall coverings help compensate for the lack of windows. There's a disconnected landline on the desk. The office door is to the north, and there's a white metal door to the west.[maybe insert computer muttering][otherwise]It's basically four white walls and grey carpet. There's a cheap desk and chair, and a disconnected phone on the desk. In lieu of windows, there are a few things on the wall: [our] degree in Nonstandard Investigative Techniques, [EG]a trivia competition award, and a poster for [our] favorite movie[PCG]a photo of [our] dog Pluto, and a Japanese print[LF]a pencil drawing of the Pitfall snake, and a photo of [our] softball team[end say]. The office door is to the north, and there's a white metal door to the west.[end if]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if biff's office is not visited][We] [pause] and [survey] the scene. It's not much -- four white walls, grey industrial carpet. [Margaret] [have] helpfully assembled [our] desk and chair, though how sturdily is an open question. [Regarding Margaret][They] also took the time to put up some of Agent [Player]'s office decor -- [our] degree in Nonstandard Investigative Techniques, [EG]a trivia competition award, and a poster for [our] favorite movie: the b-movie time-travel classic The Room of Lost Time[PCG]a photo of [our] dog Pluto, and a print of [italic type]Green Pheasant[roman type] by Utagawa Hiroshige[LF]an original pencil drawing of the Pitfall snake by semi-acclaimed Washington DC artist Darius 5200, and a photo of [our] softball team[end say]. At the very least the wall coverings help compensate for the lack of windows. There's a disconnected landline on the desk. The office door is to the north, and there's a white metal door to the west.[maybe insert computer muttering][otherwise]It's basically four white walls and grey carpet. There's a cheap desk and chair, and a disconnected phone on the desk. In lieu of windows, there are a few things on the wall: [our] degree in Nonstandard Investigative Techniques, [EG]a trivia competition award, and a poster for [our] favorite movie[PCG]a photo of [our] dog Pluto, and a Japanese print[LF]a pencil drawing of the Pitfall snake, and a photo of [our] softball team[end say]. The office door is to the north, and there's a white metal door to the west.[end if]~]
    say__p=1;! [2: if biff's office is not visited]

    	if (~~((((~~(((Adj_80_t1_v10(I429_biff_s_office))))))))) jump L_Say965;! [3: we]
    ParaContent(); (PHR_764_r7 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: pause]
    ConjugateVerb_114(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ and ~]
    ParaContent(); print " and ";! [7: survey]
    ConjugateVerb_102(CV_POS, PNToVP(), story_tense); say__p=1; ! [8: ~ the scene. It's not much -- four white walls, grey industrial carpet. ~]
    ParaContent(); print " the scene. It's not much -- four white walls, grey industrial carpet. ";! [9: margaret]
    ParaContent(); PrintShortName(I358_margaret_chao);! [10: ~ ~]
    ParaContent(); print " ";! [11: have]
    ConjugateVerb_2(CV_POS, PNToVP(), story_tense); say__p=1; ! [12: ~ helpfully assembled ~]
    ParaContent(); print " helpfully assembled ";! [13: our]
    ParaContent(); (PHR_763_r32 ());! [14: ~ desk and chair, though how sturdily is an open question. ~]
    ParaContent(); print " desk and chair, though how sturdily is an open question. ";! [15: regarding margaret]
    ParaContent(); RegardingSingleObject(I358_margaret_chao);! [16: they]
    ParaContent(); (PHR_776_r43 ());! [17: ~ also took the time to put up some of Agent ~]
    ParaContent(); print " also took the time to put up some of Agent ";! [18: player]
    ParaContent(); PrintShortName(player);! [19: ~'s office decor -- ~]
    ParaContent(); print "'s office decor -- ";! [20: our]
    ParaContent(); (PHR_763_r32 ());! [21: ~ degree in Nonstandard Investigative Techniques, ~]
    ParaContent(); print " degree in Nonstandard Investigative Techniques, ";! [22: eg]
    ParaContent(); (PHR_1475_r210 ());! [23: ~a trivia competition award, and a poster for ~]
    ParaContent(); print "a trivia competition award, and a poster for ";! [24: our]
    ParaContent(); (PHR_763_r32 ());! [25: ~ favorite movie: the b-movie time-travel classic The Room of Lost Time~]
    ParaContent(); print " favorite movie: the b-movie time-travel classic The Room of Lost Time";! [26: pcg]
    ParaContent(); (PHR_1476_r211 ());! [27: ~a photo of ~]
    ParaContent(); print "a photo of ";! [28: our]
    ParaContent(); (PHR_763_r32 ());! [29: ~ dog Pluto, and a print of ~]
    ParaContent(); print " dog Pluto, and a print of ";! [30: italic type]
    ParaContent(); (PHR_353_r9 ());! [31: ~Green Pheasant~]
    ParaContent(); print "Green Pheasant";! [32: roman type]
    ParaContent(); (PHR_354_r3 ());! [33: ~ by Utagawa Hiroshige~]
    ParaContent(); print " by Utagawa Hiroshige";! [34: lf]
    ParaContent(); (PHR_1477_r212 ());! [35: ~an original pencil drawing of the Pitfall snake by semi-acclaimed Washington DC artist Darius 5200, and a photo of ~]
    ParaContent(); print "an original pencil drawing of the Pitfall snake by semi-acclaimed Washington DC artist Darius 5200, and a photo of ";! [36: our]
    ParaContent(); (PHR_763_r32 ());! [37: ~ softball team~]
    ParaContent(); print " softball team";! [38: end say]
    ParaContent(); (PHR_1478_r213 ());! [39: ~. At the very least the wall coverings help compensate for the lack of windows. There's a disconnected landline on the desk. The office door is to the north, and there's a white metal door to the west.~]
    ParaContent(); print ". At the very least the wall coverings help compensate for the lack of windows. There's a disconnected landline on the desk. The office door is to the north, and there's a white metal door to the west.";! [40: maybe insert computer muttering]
    ParaContent(); (PHR_1480_r215 ());! [41: otherwise]

    	jump L_SayX951; .L_Say965;! [42: ~It's basically four white walls and grey carpet. There's a cheap desk and chair, and a disconnected phone on the desk. In lieu of windows, there are a few things on the wall: ~]
    ParaContent(); print "It's basically four white walls and grey carpet. There's a cheap desk and chair, and a disconnected phone on the desk. In lieu of windows, there are a few things on the wall: ";! [43: our]
    ParaContent(); (PHR_763_r32 ());! [44: ~ degree in Nonstandard Investigative Techniques, ~]
    ParaContent(); print " degree in Nonstandard Investigative Techniques, ";! [45: eg]
    ParaContent(); (PHR_1475_r210 ());! [46: ~a trivia competition award, and a poster for ~]
    ParaContent(); print "a trivia competition award, and a poster for ";! [47: our]
    ParaContent(); (PHR_763_r32 ());! [48: ~ favorite movie~]
    ParaContent(); print " favorite movie";! [49: pcg]
    ParaContent(); (PHR_1476_r211 ());! [50: ~a photo of ~]
    ParaContent(); print "a photo of ";! [51: our]
    ParaContent(); (PHR_763_r32 ());! [52: ~ dog Pluto, and a Japanese print~]
    ParaContent(); print " dog Pluto, and a Japanese print";! [53: lf]
    ParaContent(); (PHR_1477_r212 ());! [54: ~a pencil drawing of the Pitfall snake, and a photo of ~]
    ParaContent(); print "a pencil drawing of the Pitfall snake, and a photo of ";! [55: our]
    ParaContent(); (PHR_763_r32 ());! [56: ~ softball team~]
    ParaContent(); print " softball team";! [57: end say]
    ParaContent(); (PHR_1478_r213 ());! [58: ~. The office door is to the north, and there's a white metal door to the west.~]
    ParaContent(); print ". The office door is to the north, and there's a white metal door to the west.";! [59: end if]

    	.L_Say966; .L_SayX951; .L_Say967; .L_SayX952;rtrue;
];
[ R_TX_S_183 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[our] desk~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[our] desk~]
    say__p=1;! [2: our]
    ParaContent(); (PHR_763_r32 ());! [3: ~ desk~]
    ParaContent(); print " desk"; .L_Say968; .L_SayX953;rtrue;
];
[ R_TX_S_184 
    tmp_0 ! Let/loop value (deallocated by end of phrase)
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The desk is a cheap DIY piece held together with hex screws. It has a single drawer [regarding Biff's desk][if Biff's desk's drawer is closed]which is closed.[otherwise]which is open.[end if][if Biff's desk's drawer contains something and Biff's desk's drawer is open] The drawer contains [a list of things in Biff's desk's drawer].[end if]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~The desk is a cheap DIY piece held together with hex screws. It has a single drawer [regarding Biff's desk][if Biff's desk's drawer is closed]which is closed.[otherwise]which is open.[end if][if Biff's desk's drawer contains something and Biff's desk's drawer is open] The drawer contains [a list of things in Biff's desk's drawer].[end if]~]
    say__p=1;! [2: ~The desk is a cheap DIY piece held together with hex screws. It has a single drawer ~]
    ParaContent(); print "The desk is a cheap DIY piece held together with hex screws. It has a single drawer ";! [3: regarding biff's desk]
    ParaContent(); RegardingSingleObject(I430_biff_s_desk);! [4: if biff's desk's drawer is closed]

    	if (~~(((((Adj_102_t1_v10(I431_biff_s_desk_s_drawer))))))) jump L_Say969;! [5: ~which is closed.~]
    ParaContent(); print "which is closed.";! [6: otherwise]

    	jump L_SayX954; .L_Say969;! [7: ~which is open.~]
    ParaContent(); print "which is open.";! [8: end if]

    	.L_Say970; .L_SayX954;! [9: if biff's desk's drawer contains something and biff's desk's drawer is open]

    	if (~~((((((Prop_141())))) && ((((Adj_101_t1_v10(I431_biff_s_desk_s_drawer)))))))) jump L_Say971;! [10: ~ The drawer contains ~]
    ParaContent(); print " The drawer contains ";! [11: a list of things in biff's desk's drawer]
    ParaContent(); objectloop(tmp_0 ofclass Object)
    			if (((tmp_0 ofclass K2_thing) && (I431_biff_s_desk_s_drawer == ContainerOf(tmp_0))))
    				give tmp_0 workflag2;
    			else
    				give tmp_0 ~workflag2;
    		WriteListOfMarkedObjects(ENGLISH_BIT);! [12: ~.~]
    ParaContent(); print ".";! [13: end if]

    	.L_Say971; .L_SayX955; .L_Say972; .L_SayX956;rtrue;
];
[ R_TX_S_185 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[our] office phone~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[our] office phone~]
    say__p=1;! [2: our]
    ParaContent(); (PHR_763_r32 ());! [3: ~ office phone~]
    ParaContent(); print " office phone"; .L_Say973; .L_SayX957;rtrue;
];
[ R_TX_S_186 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~It's a picture of [our] best friend, Pluto.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~It's a picture of [our] best friend, Pluto.~]
    say__p=1;! [2: ~It's a picture of ~]
    ParaContent(); print "It's a picture of ";! [3: our]
    ParaContent(); (PHR_763_r32 ());! [4: ~ best friend, Pluto.~]
    ParaContent(); print " best friend, Pluto."; .L_Say974; .L_SayX958;rtrue;
];
[ R_TX_S_187 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~It's [our] Bachelor's degree in Nonstandard Investigative Techniques from Wichita Institute of Technology. Which officially makes [us] a NITWIT. [We] [shake] [our] head and [sigh].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~It's [our] Bachelor's degree in Nonstandard Investigative Techniques from Wichita Institute of Technology. Which officially makes [us] a NITWIT. [We] [shake] [our] head and [sigh].~]
    say__p=1;! [2: ~It's ~]
    ParaContent(); print "It's ";! [3: our]
    ParaContent(); (PHR_763_r32 ());! [4: ~ Bachelor's degree in Nonstandard Investigative Techniques from Wichita Institute of Technology. Which officially makes ~]
    ParaContent(); print " Bachelor's degree in Nonstandard Investigative Techniques from Wichita Institute of Technology. Which officially makes ";! [5: us]
    ParaContent(); (PHR_760_r49 ());! [6: ~ a NITWIT. ~]
    ParaContent(); print " a NITWIT. ";! [7: we]
    ParaContent(); (PHR_764_r7 ());! [8: ~ ~]
    ParaContent(); print " ";! [9: shake]
    ConjugateVerb_99(CV_POS, PNToVP(), story_tense); say__p=1; ! [10: ~ ~]
    ParaContent(); print " ";! [11: our]
    ParaContent(); (PHR_763_r32 ());! [12: ~ head and ~]
    ParaContent(); print " head and ";! [13: sigh]
    ConjugateVerb_105(CV_POS, PNToVP(), story_tense); say__p=1; ! [14: ~.~]
    ParaContent(); print "."; .L_Say975; .L_SayX959;rtrue;
];
[ R_TX_S_188 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~It's [our] favorite movie, 'The Room of Lost Time', from 1957. The tagline is 'Can one lone time traveler stop invaders from the moon?'~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~It's [our] favorite movie, 'The Room of Lost Time', from 1957. The tagline is 'Can one lone time traveler stop invaders from the moon?'~]
    say__p=1;! [2: ~It's ~]
    ParaContent(); print "It's ";! [3: our]
    ParaContent(); (PHR_763_r32 ());! [4: ~ favorite movie, 'The Room of Lost Time', from 1957. The tagline is 'Can one lone time traveler stop invaders from the moon?'~]
    ParaContent(); print " favorite movie, ~The Room of Lost Time~, from 1957. The tagline is ~Can one lone time traveler stop invaders from the moon?~"; .L_Say976; .L_SayX960;rtrue;
];
[ R_TX_S_189 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~A framed certificate proclaiming [us] the winner of the 2006 Baltimore County Edgar Allan Poe Trivia Competition.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~A framed certificate proclaiming [us] the winner of the 2006 Baltimore County Edgar Allan Poe Trivia Competition.~]
    say__p=1;! [2: ~A framed certificate proclaiming ~]
    ParaContent(); print "A framed certificate proclaiming ";! [3: us]
    ParaContent(); (PHR_760_r49 ());! [4: ~ the winner of the 2006 Baltimore County Edgar Allan Poe Trivia Competition.~]
    ParaContent(); print " the winner of the 2006 Baltimore County Edgar Allan Poe Trivia Competition."; .L_Say977; .L_SayX961;rtrue;
];
[ R_TX_S_190 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[we're] third from left in the front row.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[we're] third from left in the front row.~]
    say__p=1;! [2: we're]
    ParaContent(); (PHR_758_r83 ());! [3: ~ third from left in the front row.~]
    ParaContent(); print " third from left in the front row."; .L_Say978; .L_SayX962;rtrue;
];
[ R_TX_S_191 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~It's a pretty nice phone, only a couple of years old, but [we] [don't] have time to play with it. [We] need to get to the office.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~It's a pretty nice phone, only a couple of years old, but [we] [don't] have time to play with it. [We] need to get to the office.~]
    say__p=1;! [2: ~It's a pretty nice phone, only a couple of years old, but ~]
    ParaContent(); print "It's a pretty nice phone, only a couple of years old, but ";! [3: we]
    ParaContent(); (PHR_757_r16 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: don't]
    ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ have time to play with it. ~]
    ParaContent(); print " have time to play with it. ";! [7: we]
    ParaContent(); (PHR_764_r7 ());! [8: ~ need to get to the office.~]
    ParaContent(); print " need to get to the office."; .L_Say979; .L_SayX963;rtrue;
];
[ R_TX_S_192 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[our] door~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[our] door~]
    say__p=1;! [2: our]
    ParaContent(); (PHR_763_r32 ());! [3: ~ door~]
    ParaContent(); print " door"; .L_Say980; .L_SayX964;rtrue;
];
[ R_TX_S_193 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[Our] office is to the south, Klimp's is to the west, and Moira's is to the north. The front office is east.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[Our] office is to the south, Klimp's is to the west, and Moira's is to the north. The front office is east.~]
    say__p=1;! [2: our]
    ParaContent(); (PHR_770_r14 ());! [3: ~ office is to the south, Klimp's is to the west, and Moira's is to the north. The front office is east.~]
    ParaContent(); print " office is to the south, Klimp's is to the west, and Moira's is to the north. The front office is east."; .L_Say981; .L_SayX965;rtrue;
];
[ R_TX_S_194 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[If the BOSH chief's office is not visited]Looks like the Chief has already moved in.[paragraph break][end if]Chief Klimp's office is full of character. Shelves strewn with knick-knacks abut a cozy armchair and a mahogany side table supporting a large globe. A bookcase on the north wall is packed with books on paranormal happenings. Garish prints adorn the remaining wall space.  Under one of these is a modernistic desk of glass and chrome, behind which is a very nice black leather swivel chair. There is a computer on the desk, and to its side is an antique wooden file cabinet. To tell the truth, it's all a bit much, but it matches Klimp's personality perfectly. There is an exit to the east.[if klimp is in the location][first time][Klimp] says 'What's with that ringing? Someone answer it!'[only]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[If the BOSH chief's office is not visited]Looks like the Chief has already moved in.[paragraph break][end if]Chief Klimp's office is full of character. Shelves strewn with knick-knacks abut a cozy armchair and a mahogany side table supporting a large globe. A bookcase on the north wall is packed with books on paranormal happenings. Garish prints adorn the remaining wall space.  Under one of these is a modernistic desk of glass and chrome, behind which is a very nice black leather swivel chair. There is a computer on the desk, and to its side is an antique wooden file cabinet. To tell the truth, it's all a bit much, but it matches Klimp's personality perfectly. There is an exit to the east.[if klimp is in the location][first time]^^[Klimp] says 'What's with that ringing? Someone answer it!'[only]~]
    say__p=1;! [2: if the bosh chief's office is not visited]

    	if (~~((((~~(((Adj_80_t1_v10(I454_bosh_chief_s_office))))))))) jump L_Say982;! [3: ~Looks like the Chief has already moved in.~]
    ParaContent(); print "Looks like the Chief has already moved in.";! [4: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [5: end if]

    	.L_Say982; .L_SayX966;! [6: ~Chief Klimp's office is full of character. Shelves strewn with knick-knacks abut a cozy armchair and a mahogany side table supporting a large globe. A bookcase on the north wall is packed with books on paranormal happenings. Garish prints adorn the remaining wall space.  Under one of these is a modernistic desk of glass and chrome, behind which is a very nice black leather swivel chair. There is a computer on the desk, and to its side is an antique wooden file cabinet. To tell the truth, it's all a bit much, but it matches Klimp's personality perfectly. There is an exit to the east.~]
    ParaContent(); print "Chief Klimp's office is full of character. Shelves strewn with knick-knacks abut a cozy armchair and a mahogany side table supporting a large globe. A bookcase on the north wall is packed with books on paranormal happenings. Garish prints adorn the remaining wall space.  Under one of these is a modernistic desk of glass and chrome, behind which is a very nice black leather swivel chair. There is a computer on the desk, and to its side is an antique wooden file cabinet. To tell the truth, it's all a bit much, but it matches Klimp's personality perfectly. There is an exit to the east.";! [7: if klimp is in the location]
    ParaContent(); 
    	if (~~((((real_location == ContainerOf(I419_chief_huffton_klimp)))))) jump L_Say983;! [8: first time]
    ParaContent(); 
    	if ((say__comp == false) && ((I7_ST_say_first_time-->0)++ == 0)) {! [9: ~^^~]
    ParaContent(); print "^^";! [10: klimp]
    ParaContent(); PrintShortName(I419_chief_huffton_klimp);! [11: ~ says 'What's with that ringing? Someone answer it!'~]
    ParaContent(); print " says ~What's with that ringing? Someone answer it!~";! [12: only]
    ParaContent(); } .L_Say983; .L_SayX967;rtrue;
];
[ R_TX_S_195 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The Chief's library boasts many interesting titles, from Alton Cherry's [italic type]Waiting for the Aliens[roman type] to Debi Bosworth's [italic type]My Travels in Time[roman type].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~The Chief's library boasts many interesting titles, from Alton Cherry's [italic type]Waiting for the Aliens[roman type] to Debi Bosworth's [italic type]My Travels in Time[roman type].~]
    say__p=1;! [2: ~The Chief's library boasts many interesting titles, from Alton Cherry's ~]
    ParaContent(); print "The Chief's library boasts many interesting titles, from Alton Cherry's ";! [3: italic type]
    ParaContent(); (PHR_353_r9 ());! [4: ~Waiting for the Aliens~]
    ParaContent(); print "Waiting for the Aliens";! [5: roman type]
    ParaContent(); (PHR_354_r3 ());! [6: ~ to Debi Bosworth's ~]
    ParaContent(); print " to Debi Bosworth's ";! [7: italic type]
    ParaContent(); (PHR_353_r9 ());! [8: ~My Travels in Time~]
    ParaContent(); print "My Travels in Time";! [9: roman type]
    ParaContent(); (PHR_354_r3 ());! [10: ~.~]
    ParaContent(); print "."; .L_Say984; .L_SayX968;rtrue;
];
[ R_TX_S_196 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Alton Cherry's [italic type]Waiting for the Aliens[roman type] is a classic of the genre. More a history of publicly-known material than an argument for or against the existence of aliens on earth, it is accessible to believers and non-believers alike.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Alton Cherry's [italic type]Waiting for the Aliens[roman type] is a classic of the genre. More a history of publicly-known material than an argument for or against the existence of aliens on earth, it is accessible to believers and non-believers alike.~]
    say__p=1;! [2: ~Alton Cherry's ~]
    ParaContent(); print "Alton Cherry's ";! [3: italic type]
    ParaContent(); (PHR_353_r9 ());! [4: ~Waiting for the Aliens~]
    ParaContent(); print "Waiting for the Aliens";! [5: roman type]
    ParaContent(); (PHR_354_r3 ());! [6: ~ is a classic of the genre. More a history of publicly-known material than an argument for or against the existence of aliens on earth, it is accessible to believers and non-believers alike.~]
    ParaContent(); print " is a classic of the genre. More a history of publicly-known material than an argument for or against the existence of aliens on earth, it is accessible to believers and non-believers alike."; .L_Say985; .L_SayX969;rtrue;
];
[ R_TX_S_197 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Debi Bosworth's [italic type]My Travels in Time[roman type] is the account of Ms. Bosworth's alleged travels to the past and future. She is careful to point out that she has never known a man in a blue box.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Debi Bosworth's [italic type]My Travels in Time[roman type] is the account of Ms. Bosworth's alleged travels to the past and future. She is careful to point out that she has never known a man in a blue box.~]
    say__p=1;! [2: ~Debi Bosworth's ~]
    ParaContent(); print "Debi Bosworth's ";! [3: italic type]
    ParaContent(); (PHR_353_r9 ());! [4: ~My Travels in Time~]
    ParaContent(); print "My Travels in Time";! [5: roman type]
    ParaContent(); (PHR_354_r3 ());! [6: ~ is the account of Ms. Bosworth's alleged travels to the past and future. She is careful to point out that she has never known a man in a blue box.~]
    ParaContent(); print " is the account of Ms. Bosworth's alleged travels to the past and future. She is careful to point out that she has never known a man in a blue box."; .L_Say986; .L_SayX970;rtrue;
];
[ R_TX_S_198 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [say] '[EG]Uh, thanks, Moira. Hmm. I'm not quite sure. I ought to talk to the Chief about it first[PCG]You wouldn't believe me if I told you, Moira. I'm sure Huffton will catch you up after I talk to him[LF]Strange things are afoot around here, Agent Zin[end say].'[line break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [say] '[EG]Uh, thanks, Moira. Hmm. I'm not quite sure. I ought to talk to the Chief about it first[PCG]You wouldn't believe me if I told you, Moira. I'm sure Huffton will catch you up after I talk to him[LF]Strange things are afoot around here, Agent Zin[end say].'[line break]~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: say]
    ConjugateVerb_53(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ '~]
    ParaContent(); print " ~";! [6: eg]
    ParaContent(); (PHR_1475_r210 ());! [7: ~Uh, thanks, Moira. Hmm. I'm not quite sure. I ought to talk to the Chief about it first~]
    ParaContent(); print "Uh, thanks, Moira. Hmm. I'm not quite sure. I ought to talk to the Chief about it first";! [8: pcg]
    ParaContent(); (PHR_1476_r211 ());! [9: ~You wouldn't believe me if I told you, Moira. I'm sure Huffton will catch you up after I talk to him~]
    ParaContent(); print "You wouldn't believe me if I told you, Moira. I'm sure Huffton will catch you up after I talk to him";! [10: lf]
    ParaContent(); (PHR_1477_r212 ());! [11: ~Strange things are afoot around here, Agent Zin~]
    ParaContent(); print "Strange things are afoot around here, Agent Zin";! [12: end say]
    ParaContent(); (PHR_1478_r213 ());! [13: ~.'~]
    ParaContent(); print ".~";! [14: line break]
    ParaContent(); new_line; .L_Say987; .L_SayX971;rtrue;
];
[ R_TX_S_199 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[EG]Moira raises her eyebrows. 'You do that. I'd like to know why a strange man was hiding in my closet.' Ezra stammers and blushes.[PCG]'Well hurry!' says Moira. 'I can't wait to hear what's going on.'[LF]'Do tell,' says Moira.'After I talk to Klimp.'[end say][line break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[EG]Moira raises her eyebrows. 'You do that. I'd like to know why a strange man was hiding in my closet.' Ezra stammers and blushes.[PCG]'Well hurry!' says Moira. 'I can't wait to hear what's going on.'[LF]'Do tell,' says Moira.^^'After I talk to Klimp.'[end say][line break]~]
    say__p=1;! [2: eg]
    ParaContent(); (PHR_1475_r210 ());! [3: ~Moira raises her eyebrows. 'You do that. I'd like to know why a strange man was hiding in my closet.' Ezra stammers and blushes.~]
    ParaContent(); print "Moira raises her eyebrows. ~You do that. I'd like to know why a strange man was hiding in my closet.~ Ezra stammers and blushes.";! [4: pcg]
    ParaContent(); (PHR_1476_r211 ());! [5: ~'Well hurry!' says Moira. 'I can't wait to hear what's going on.'~]
    ParaContent(); print "~Well hurry!~ says Moira. ~I can't wait to hear what's going on.~";! [6: lf]
    ParaContent(); (PHR_1477_r212 ());! [7: ~'Do tell,' says Moira.^^'After I talk to Klimp.'~]
    ParaContent(); print "~Do tell,~ says Moira.^^~After I talk to Klimp.~";! [8: end say]
    ParaContent(); (PHR_1478_r213 ());! [9: line break]
    ParaContent(); new_line; .L_Say988; .L_SayX972;rtrue;
];
[ R_TX_S_200 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[location]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[location]~]
    say__p=1;! [2: location]
    ParaContent(); PrintShortName(real_location); .L_Say989; .L_SayX973;rtrue;
];
[ R_TX_S_201 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[score]/[turn count]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[score]/[turn count]~]
    say__p=1;! [2: score]
    ParaContent(); print (say__n=score);! [3: ~/~]
    ParaContent(); print "/";! [4: turn count]
    ParaContent(); print (say__n=turns); .L_Say990; .L_SayX974;rtrue;
];
[ R_TX_S_202 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the serial comma option is active],[end if] and ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if the serial comma option is active],[end if] and ~]
    say__p=1;! [2: if the serial comma option is active]

    	if (~~(((((Adj_25_t1_v16(6))))))) jump L_Say991;! [3: ~,~]
    ParaContent(); print ",";! [4: end if]

    	.L_Say991; .L_SayX975;! [5: ~ and ~]
    ParaContent(); print " and "; .L_Say992; .L_SayX976;rtrue;
];
[ R_TX_S_203 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the serial comma option is active],[end if] or ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if the serial comma option is active],[end if] or ~]
    say__p=1;! [2: if the serial comma option is active]

    	if (~~(((((Adj_25_t1_v16(6))))))) jump L_Say993;! [3: ~,~]
    ParaContent(); print ",";! [4: end if]

    	.L_Say993; .L_SayX977;! [5: ~ or ~]
    ParaContent(); print " or "; .L_Say994; .L_SayX978;rtrue;
];
[ R_TX_S_204 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[a current listed object]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[a current listed object]~]
    say__p=1;! [2: a current listed object]
    ParaContent(); print (a) (Global_Vars-->29); .L_Say995; .L_SayX979;rtrue;
];
[ R_TX_S_205 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[a current listed object]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[a current listed object]~]
    say__p=1;! [2: a current listed object]
    ParaContent(); print (a) (Global_Vars-->29); .L_Say996; .L_SayX980;rtrue;
];
[ R_TX_S_206 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[a current listed object]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[a current listed object]~]
    say__p=1;! [2: a current listed object]
    ParaContent(); print (a) (Global_Vars-->29); .L_Say997; .L_SayX981;rtrue;
];
[ R_TX_S_207 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[a current listed object]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[a current listed object]~]
    say__p=1;! [2: a current listed object]
    ParaContent(); print (a) (Global_Vars-->29); .L_Say998; .L_SayX982;rtrue;
];
[ R_TX_S_208 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[current listed object]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[current listed object]~]
    say__p=1;! [2: current listed object]
    ParaContent(); PrintShortName((Global_Vars-->29)); .L_Say999; .L_SayX983;rtrue;
];
[ R_TX_S_209 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[a current listed object]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[a current listed object]~]
    say__p=1;! [2: a current listed object]
    ParaContent(); print (a) (Global_Vars-->29); .L_Say1000; .L_SayX984;rtrue;
];
[ R_TX_S_210 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[A current listed object]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[A current listed object]~]
    say__p=1;! [2: a current listed object]
    ParaContent(); CIndefArt((Global_Vars-->29)); .L_Say1001; .L_SayX985;rtrue;
];
[ R_TX_S_211 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~([current enumeration]) [a current listed object]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~([current enumeration]) [a current listed object]~]
    say__p=1;! [2: ~(~]
    ParaContent(); print "(";! [3: current enumeration]
    ParaContent(); print (say__n=(PHR_1131_r169 ()));! [4: ~) ~]
    ParaContent(); print ") ";! [5: a current listed object]
    ParaContent(); print (a) (Global_Vars-->29); .L_Say1002; .L_SayX986;rtrue;
];
[ R_TX_S_212 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[the current listed object]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[the current listed object]~]
    say__p=1;! [2: the current listed object]
    ParaContent(); print (the) (Global_Vars-->29); .L_Say1003; .L_SayX987;rtrue;
];
[ R_TX_S_213 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[the current listed object]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[the current listed object]~]
    say__p=1;! [2: the current listed object]
    ParaContent(); print (the) (Global_Vars-->29); .L_Say1004; .L_SayX988;rtrue;
];
[ R_TX_S_214 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[the current listed object]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[the current listed object]~]
    say__p=1;! [2: the current listed object]
    ParaContent(); print (the) (Global_Vars-->29); .L_Say1005; .L_SayX989;rtrue;
];
[ R_TX_S_215 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[the current listed object]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[the current listed object]~]
    say__p=1;! [2: the current listed object]
    ParaContent(); print (the) (Global_Vars-->29); .L_Say1006; .L_SayX990;rtrue;
];
[ R_TX_S_216 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[current listed object]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[current listed object]~]
    say__p=1;! [2: current listed object]
    ParaContent(); PrintShortName((Global_Vars-->29)); .L_Say1007; .L_SayX991;rtrue;
];
[ R_TX_S_217 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[the current listed object]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[the current listed object]~]
    say__p=1;! [2: the current listed object]
    ParaContent(); print (the) (Global_Vars-->29); .L_Say1008; .L_SayX992;rtrue;
];
[ R_TX_S_218 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The current listed object]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The current listed object]~]
    say__p=1;! [2: the current listed object]
    ParaContent(); print (The) (Global_Vars-->29); .L_Say1009; .L_SayX993;rtrue;
];
[ R_TX_S_219 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~([current enumeration]) [the current listed object]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~([current enumeration]) [the current listed object]~]
    say__p=1;! [2: ~(~]
    ParaContent(); print "(";! [3: current enumeration]
    ParaContent(); print (say__n=(PHR_1131_r169 ()));! [4: ~) ~]
    ParaContent(); print ") ";! [5: the current listed object]
    ParaContent(); print (the) (Global_Vars-->29); .L_Say1010; .L_SayX994;rtrue;
];
[ R_TX_S_220 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ [left hand status line]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ [left hand status line]~]
    say__p=1;! [2: ~ ~]
    ParaContent(); print " ";! [3: left hand status line]
    ParaContent(); print (TEXT_TY_Say) left_hand_status_line; .L_Say1011; .L_SayX995;rtrue;
];
[ R_TX_S_221 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ [exit list]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ [exit list]~]
    say__p=1;! [2: ~ ~]
    ParaContent(); print " ";! [3: exit list]
    ParaContent(); (PHR_1143_r172 ()); .L_Say1012; .L_SayX996;rtrue;
];
[ R_TX_S_222 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[right hand status line]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[right hand status line]~]
    say__p=1;! [2: right hand status line]
    ParaContent(); print (TEXT_TY_Say) right_hand_status_line; .L_Say1013; .L_SayX997;rtrue;
];
[ R_TX_S_223 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ [left hand status line]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ [left hand status line]~]
    say__p=1;! [2: ~ ~]
    ParaContent(); print " ";! [3: left hand status line]
    ParaContent(); print (TEXT_TY_Say) left_hand_status_line; .L_Say1014; .L_SayX998;rtrue;
];
[ R_TX_S_224 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[right hand status line]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[right hand status line]~]
    say__p=1;! [2: right hand status line]
    ParaContent(); print (TEXT_TY_Say) right_hand_status_line; .L_Say1015; .L_SayX999;rtrue;
];
[ R_TX_S_225 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[location-title-case]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[location-title-case]~]
    say__p=1;! [2: location-title-case]
    ParaContent(); (PHR_1449_r207 ()); .L_Say1016; .L_SayX1000;rtrue;
];
[ R_TX_S_226 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[agent]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[agent]~]
    say__p=1;! [2: agent]
    ParaContent(); (PHR_1445_r13 ()); .L_Say1017; .L_SayX1001;rtrue;
];
[ R_TX_S_227 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [trudge] to the other end of the parking lot. It's much like where [we] left.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [trudge] to the other end of the parking lot. It's much like where [we] left.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: trudge]
    ConjugateVerb_109(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ to the other end of the parking lot. It's much like where ~]
    ParaContent(); print " to the other end of the parking lot. It's much like where ";! [6: we]
    ParaContent(); (PHR_757_r16 ());! [7: ~ left.~]
    ParaContent(); print " left."; .L_Say1018; .L_SayX1002;rtrue;
];
[ R_TX_S_228 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [walk] back to the south end of the parking lot.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [walk] back to the south end of the parking lot.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: walk]
    ConjugateVerb_110(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ back to the south end of the parking lot.~]
    ParaContent(); print " back to the south end of the parking lot."; .L_Say1019; .L_SayX1003;rtrue;
];
[ R_TX_S_229 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Just like in the store this once was, the door chimes as [we] [walk] in.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Just like in the store this once was, the door chimes as [we] [walk] in.~]
    say__p=1;! [2: ~Just like in the store this once was, the door chimes as ~]
    ParaContent(); print "Just like in the store this once was, the door chimes as ";! [3: we]
    ParaContent(); (PHR_757_r16 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: walk]
    ConjugateVerb_110(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ in.~]
    ParaContent(); print " in."; .L_Say1020; .L_SayX1004;rtrue;
];
[ R_TX_S_230 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [step] out of the office into the parking lot.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [step] out of the office into the parking lot.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: step]
    ConjugateVerb_111(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ out of the office into the parking lot.~]
    ParaContent(); print " out of the office into the parking lot."; .L_Say1021; .L_SayX1005;rtrue;
];
[ R_TX_S_231 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [are] greeted by a blast of music as [we] [enter] the store.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [are] greeted by a blast of music as [we] [enter] the store.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ greeted by a blast of music as ~]
    ParaContent(); print " greeted by a blast of music as ";! [6: we]
    ParaContent(); (PHR_757_r16 ());! [7: ~ ~]
    ParaContent(); print " ";! [8: enter]
    ConjugateVerb_112(CV_POS, PNToVP(), story_tense); say__p=1; ! [9: ~ the store.~]
    ParaContent(); print " the store."; .L_Say1022; .L_SayX1006;rtrue;
];
[ R_TX_S_232 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [exit] the store into the relative quiet of the nearby traffic.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [exit] the store into the relative quiet of the nearby traffic.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: exit]
    ConjugateVerb_113(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ the store into the relative quiet of the nearby traffic.~]
    ParaContent(); print " the store into the relative quiet of the nearby traffic."; .L_Say1023; .L_SayX1007;rtrue;
];
[ R_TX_S_233 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~'Cha-ching!'[first time] rings the electronic chime as [we] [step] into the store.[only]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~'Cha-ching!'[first time] rings the electronic chime as [we] [step] into the store.[only]~]
    say__p=1;! [2: ~'Cha-ching!'~]
    ParaContent(); print "~Cha-ching!~";! [3: first time]
    ParaContent(); 
    	if ((say__comp == false) && ((I7_ST_say_first_time-->1)++ == 0)) {! [4: ~ rings the electronic chime as ~]
    ParaContent(); print " rings the electronic chime as ";! [5: we]
    ParaContent(); (PHR_757_r16 ());! [6: ~ ~]
    ParaContent(); print " ";! [7: step]
    ConjugateVerb_111(CV_POS, PNToVP(), story_tense); say__p=1; ! [8: ~ into the store.~]
    ParaContent(); print " into the store.";! [9: only]
    ParaContent(); } .L_Say1024; .L_SayX1008;rtrue;
];
[ R_TX_S_234 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[one of]Once again -- 'Cha-ching!' -- as [we] [leave] the store.[or]'Cha-ching!'[stopping]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[one of]Once again -- 'Cha-ching!' -- as [we] [leave] the store.[or]'Cha-ching!'[stopping]~]
    say__p=1;! [2: one of]
    ParaContent(); 
    	
    	if (I7_ST_say_one_flag-->4 == false) {
    		I7_ST_say_one_of-->4 = i7_soo_stop(I7_ST_say_one_of-->4,
    2);
    	 	I7_ST_say_one_flag-->4 = true;
    	}
    	if (say__comp == false) I7_ST_say_one_flag-->4 =
    false;
    	switch ((I7_ST_say_one_of-->4)%(2+1)-1)
    {
    		0:! [3: ~Once again -- 'Cha-ching!' -- as ~]
    ParaContent(); print "Once again -- ~Cha-ching!~ -- as ";! [4: we]
    ParaContent(); (PHR_757_r16 ());! [5: ~ ~]
    ParaContent(); print " ";! [6: leave]
    ConjugateVerb_129(CV_POS, PNToVP(), story_tense); say__p=1; ! [7: ~ the store.~]
    ParaContent(); print " the store.";! [8: or]
    ParaContent(); @nop; 1:! [9: ~'Cha-ching!'~]
    ParaContent(); print "~Cha-ching!~";! [10: stopping]
    ParaContent(); } .L_Say1025; .L_SayX1009;rtrue;
];
[ R_TX_S_247 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~As an agent of the Bureau of Strange Happenings (BOSH), it is Agent [player's full name]'s job to investigate unexplained phenomena throughout the United States and its territories. Recently, however, business hasn't been good. Once a bustling office with a dozen Agents, the Bureau's been reduced to just three: [Player's surname], Moira Zin, and Chief Huffton Klimp. The Bureau's expansive and well-appointed office suite was taken over by the State Department Book Club, and now the agents are consigned to a tiny suite in a strip mall in the remote D.C. suburb of Swamp Park, Maryland.We open on a decrepit strip mall just as an aging Hyundai pulls into the potholed parking lot. [agent] steps out of the car. [We] [survey] the area and [wrinkle] [our] nose.[paragraph break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~As an agent of the Bureau of Strange Happenings (BOSH), it is Agent [player's full name]'s job to investigate unexplained phenomena throughout the United States and its territories. Recently, however, business hasn't been good. Once a bustling office with a dozen Agents, the Bureau's been reduced to just three: [Player's surname], Moira Zin, and Chief Huffton Klimp. The Bureau's expansive and well-appointed office suite was taken over by the State Department Book Club, and now the agents are consigned to a tiny suite in a strip mall in the remote D.C. suburb of Swamp Park, Maryland.^^We open on a decrepit strip mall just as an aging Hyundai pulls into the potholed parking lot. [agent] steps out of the car. [We] [survey] the area and [wrinkle] [our] nose.[paragraph break]~]
    say__p=1;! [2: ~As an agent of the Bureau of Strange Happenings (BOSH), it is Agent ~]
    ParaContent(); print "As an agent of the Bureau of Strange Happenings (BOSH), it is Agent ";! [3: player's full name]
    ParaContent(); print (TEXT_TY_Say) (Global_Vars-->77);! [4: ~'s job to investigate unexplained phenomena throughout the United States and its territories. Recently, however, business hasn't been good. Once a bustling office with a dozen Agents, the Bureau's been reduced to just three: ~]
    ParaContent(); print "'s job to investigate unexplained phenomena throughout the United States and its territories. Recently, however, business hasn't been good. Once a bustling office with a dozen Agents, the Bureau's been reduced to just three: ";! [5: player's surname]
    ParaContent(); print (TEXT_TY_Say) (Global_Vars-->20);! [6: ~, Moira Zin, and Chief Huffton Klimp. The Bureau's expansive and well-appointed office suite was taken over by the State Department Book Club, and now the agents are consigned to a tiny suite in a strip mall in the remote D.C. suburb of Swamp Park, Maryland.^^We open on a decrepit strip mall just as an aging Hyundai pulls into the potholed parking lot. ~]
    ParaContent(); print ", Moira Zin, and Chief Huffton Klimp. The Bureau's expansive and well-appointed office suite was taken over by the State Department Book Club, and now the agents are consigned to a tiny suite in a strip mall in the remote D.C. suburb of Swamp Park, Maryland.^^We open on a decrepit strip mall just as an aging Hyundai pulls into the potholed parking lot. ";! [7: agent]
    ParaContent(); (PHR_1445_r13 ());! [8: ~ steps out of the car. ~]
    ParaContent(); print " steps out of the car. ";! [9: we]
    ParaContent(); (PHR_764_r7 ());! [10: ~ ~]
    ParaContent(); print " ";! [11: survey]
    ConjugateVerb_102(CV_POS, PNToVP(), story_tense); say__p=1; ! [12: ~ the area and ~]
    ParaContent(); print " the area and ";! [13: wrinkle]
    ConjugateVerb_103(CV_POS, PNToVP(), story_tense); say__p=1; ! [14: ~ ~]
    ParaContent(); print " ";! [15: our]
    ParaContent(); (PHR_763_r32 ());! [16: ~ nose.~]
    ParaContent(); print " nose.";! [17: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line; .L_Say1026; .L_SayX1010;rtrue;
];
Array TX_S_247 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_247;
[ R_TX_S_365 
    tmp_0 ! Let/loop value, e.g., 'directions': list of texts
    tmp_1 ! Let/loop value, e.g., 'D': direction
    tmp_2 ! Let/loop value: direction
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
#ifdef DEBUG; if (suppress_text_substitution) { print "~'[D]'~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~'[D]'~]
    say__p=1;! [2: ~'~]
    ParaContent(); print "~";! [3: d]
    ParaContent(); PrintShortName(tmp_1);! [4: ~'~]
    ParaContent(); print "~"; .L_Say1027; .L_SayX1011;rtrue;
];
Array TX_S_365 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_365;
[ R_TX_S_508 
    tmp_0 ! Let/loop value, e.g., 'callee phone': phone
    tmp_1 ! Let/loop value, e.g., 'caller phone': phone
    tmp_2 ! Let/loop value, e.g., 'PN': fact
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [don't] know that phone number.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [don't] know that phone number.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: don't]
    ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ know that phone number.~]
    ParaContent(); print " know that phone number."; .L_Say1028; .L_SayX1012;rtrue;
];
Array TX_S_508 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_508;
[ R_TX_S_509 
    tmp_0 ! Let/loop value, e.g., 'callee phone': phone
    tmp_1 ! Let/loop value, e.g., 'caller phone': phone
    tmp_2 ! Let/loop value, e.g., 'PN': fact
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't] call the phone [we're] calling from!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't] call the phone [we're] calling from!~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ call the phone ~]
    ParaContent(); print " call the phone ";! [6: we're]
    ParaContent(); (PHR_758_r83 ());! [7: ~ calling from!~]
    ParaContent(); print " calling from!"; .L_Say1029; .L_SayX1013;rtrue;
];
Array TX_S_509 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_509;
[ R_TX_S_510 
    tmp_0 ! Let/loop value, e.g., 'callee phone': phone
    tmp_1 ! Let/loop value, e.g., 'caller phone': phone
    tmp_2 ! Let/loop value, e.g., 'PN': fact
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[The caller phone] is busy.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The caller phone] is busy.~]
    say__p=1;! [2: the caller phone]
    ParaContent(); print (The) tmp_1;! [3: ~ is busy.~]
    ParaContent(); print " is busy."; .L_Say1030; .L_SayX1014;rtrue;
];
Array TX_S_510 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_510;
[ R_TX_S_511 
    tmp_0 ! Let/loop value, e.g., 'callee phone': phone
    tmp_1 ! Let/loop value, e.g., 'caller phone': phone
    tmp_2 ! Let/loop value, e.g., 'PN': fact
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[The callee phone] is busy.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The callee phone] is busy.~]
    say__p=1;! [2: the callee phone]
    ParaContent(); print (The) tmp_0;! [3: ~ is busy.~]
    ParaContent(); print " is busy."; .L_Say1031; .L_SayX1015;rtrue;
];
Array TX_S_511 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_511;
[ R_TX_S_512 
    tmp_0 ! Let/loop value, e.g., 'callee': person
    tmp_1 ! Let/loop value, e.g., 'caller phone': thing
    tmp_2 ! Let/loop value, e.g., 'Ph': object
    tmp_3 ! Let/loop value: phone
    tmp_4 ! Let/loop value: phone
    tmp_5 ! Let/loop value: fact
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
tmp_3=LocalParking-->3;
tmp_4=LocalParking-->4;
tmp_5=LocalParking-->5;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding actor][Actor] [don't] know of any phones owned by [Callee].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding actor][Actor] [don't] know of any phones owned by [Callee].~]
    say__p=1;! [2: regarding actor]
    ParaContent(); RegardingSingleObject(actor);! [3: actor]
    ParaContent(); PrintShortName(actor);! [4: ~ ~]
    ParaContent(); print " ";! [5: don't]
    ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ know of any phones owned by ~]
    ParaContent(); print " know of any phones owned by ";! [7: callee]
    ParaContent(); PrintShortName(tmp_0);! [8: ~.~]
    ParaContent(); print "."; .L_Say1032; .L_SayX1016;rtrue;
];
Array TX_S_512 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_512;
[ R_TX_S_513 
    tmp_0 ! Let/loop value, e.g., 'callee phone': phone
    tmp_1 ! Let/loop value, e.g., 'caller phone': phone
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[Actor] calls someone on [caller phone].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[Actor] calls someone on [caller phone].~]
    say__p=1;! [2: actor]
    ParaContent(); PrintShortName(actor);! [3: ~ calls someone on ~]
    ParaContent(); print " calls someone on ";! [4: caller phone]
    ParaContent(); PrintShortName(tmp_1);! [5: ~.~]
    ParaContent(); print "."; .L_Say1033; .L_SayX1017;rtrue;
];
Array TX_S_513 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_513;
[ R_TX_S_517 
    tmp_0 ! Let/loop value, e.g., 'phone': phone
    tmp_1 ! Let/loop value, e.g., 'caller': thing
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(on the phone with [Caller]) >~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(on the phone with [Caller]) >~]
    say__p=1;! [2: ~(on the phone with ~]
    ParaContent(); print "(on the phone with ";! [3: caller]
    ParaContent(); PrintShortName(tmp_1);! [4: ~) >~]
    ParaContent(); print ") >"; .L_Say1034; .L_SayX1018;rtrue;
];
Array TX_S_517 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_517;
[ R_TX_S_518 
    tmp_0 ! Let/loop value, e.g., 'phone': phone
    tmp_1 ! Let/loop value, e.g., 'caller': thing
    tmp_2 ! Let/loop value, e.g., 'a': text
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[Actor]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[Actor]~]
    say__p=1;! [2: actor]
    ParaContent(); PrintShortName(actor); .L_Say1035; .L_SayX1019;rtrue;
];
Array TX_S_518 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_518;
[ R_TX_S_519 
    tmp_0 ! Let/loop value, e.g., 'phone': phone
    tmp_1 ! Let/loop value, e.g., 'caller': thing
    tmp_2 ! Let/loop value, e.g., 'a': text
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(on the phone with [a]) >~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(on the phone with [a]) >~]
    say__p=1;! [2: ~(on the phone with ~]
    ParaContent(); print "(on the phone with ";! [3: a]
    ParaContent(); print (TEXT_TY_Say) tmp_2;! [4: ~) >~]
    ParaContent(); print ") >"; .L_Say1036; .L_SayX1020;rtrue;
];
Array TX_S_519 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_519;
[ R_TX_S_522 
    tmp_0 ! Let/loop value, e.g., 'P': person
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding actor][if actor is player][We][otherwise][Actor][end if] [hang] up the phone.[line break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding actor][if actor is player][We][otherwise][Actor][end if] [hang] up the phone.[line break]~]
    say__p=1;! [2: regarding actor]
    ParaContent(); RegardingSingleObject(actor);! [3: if actor is player]

    	if (~~((((actor == player))))) jump L_Say1037;! [4: we]
    ParaContent(); (PHR_764_r7 ());! [5: otherwise]

    	jump L_SayX1021; .L_Say1037;! [6: actor]
    ParaContent(); PrintShortName(actor);! [7: end if]

    	.L_Say1038; .L_SayX1021;! [8: ~ ~]
    ParaContent(); print " ";! [9: hang]
    ConjugateVerb_88(CV_POS, PNToVP(), story_tense); say__p=1; ! [10: ~ up the phone.~]
    ParaContent(); print " up the phone.";! [11: line break]
    ParaContent(); new_line; .L_Say1039; .L_SayX1022;rtrue;
];
Array TX_S_522 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_522;
[ R_TX_S_523 
    tmp_0 ! Let/loop value, e.g., 'callee': person
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding actor][if actor is player][We][otherwise][Actor][end if] [say] goodbye to [if callee is player][us][otherwise][Callee][end if].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding actor][if actor is player][We][otherwise][Actor][end if] [say] goodbye to [if callee is player][us][otherwise][Callee][end if].~]
    say__p=1;! [2: regarding actor]
    ParaContent(); RegardingSingleObject(actor);! [3: if actor is player]

    	if (~~((((actor == player))))) jump L_Say1040;! [4: we]
    ParaContent(); (PHR_764_r7 ());! [5: otherwise]

    	jump L_SayX1023; .L_Say1040;! [6: actor]
    ParaContent(); PrintShortName(actor);! [7: end if]

    	.L_Say1041; .L_SayX1023;! [8: ~ ~]
    ParaContent(); print " ";! [9: say]
    ConjugateVerb_53(CV_POS, PNToVP(), story_tense); say__p=1; ! [10: ~ goodbye to ~]
    ParaContent(); print " goodbye to ";! [11: if callee is player]

    	if (~~((((tmp_0 == player))))) jump L_Say1042;! [12: us]
    ParaContent(); (PHR_760_r49 ());! [13: otherwise]

    	jump L_SayX1024; .L_Say1042;! [14: callee]
    ParaContent(); PrintShortName(tmp_0);! [15: end if]

    	.L_Say1043; .L_SayX1024;! [16: ~.~]
    ParaContent(); print "."; .L_Say1044; .L_SayX1025;rtrue;
];
Array TX_S_523 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_523;
[ R_TX_S_544 
    tmp_0 ! Let/loop value, e.g., 'dir': direction
    tmp_1 ! Let/loop value, e.g., 'source': room
    tmp_2 ! Let/loop value: object
    tmp_3 ! Let/loop value: object
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[text of the can't exit when not inside anything rule response (A)]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[text of the can't exit when not inside anything rule response (A)]~]
    say__p=1;! [2: text of the can't exit when not inside anything rule response ( a )]
    ParaContent(); (PHR_380_r40 (R_132_RESP_A)); .L_Say1045; .L_SayX1026;rtrue;
];
Array TX_S_544 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_544;
[ R_TX_S_578 
    tmp_0 ! Let/loop value, e.g., 'P': text
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[Player's surname] s~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[Player's surname] s~]
    say__p=1;! [2: player's surname]
    ParaContent(); print (TEXT_TY_Say) (Global_Vars-->20);! [3: ~ s~]
    ParaContent(); print " s"; .L_Say1046; .L_SayX1027;rtrue;
];
Array TX_S_578 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_578;
[ R_TX_S_579 
    t_0 ! Call parameter 'place': room
    ;
    t_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[the place]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[the place]~]
    say__p=1;! [2: the place]
    ParaContent(); print (the) t_0; .L_Say1047; .L_SayX1028;rtrue;
];
Array TX_S_579 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_579;
[ R_TX_S_580 
    tmp_0 ! Let/loop value, e.g., 'nsdiff': real number
    tmp_1 ! Let/loop value, e.g., 'wediff': real number
    tmp_2 ! Let/loop value, e.g., 'fbdiff': real number
    tmp_3 ! Let/loop value, e.g., 'nsdir': text
    tmp_4 ! Let/loop value, e.g., 'wedir': text
    tmp_5 ! Let/loop value, e.g., 'fbdir': text
    tmp_6 ! Let/loop value, e.g., 'nsdivwe': real number
    tmp_7 ! Let/loop value, e.g., 'nsdivfb': real number
    tmp_8 ! Let/loop value, e.g., 'wedivfb': real number
    tmp_9 ! Let/loop value, e.g., 'nsscore': real number
    tmp_10 ! Let/loop value, e.g., 'wescore': real number
    tmp_11 ! Let/loop value, e.g., 'fbscore': real number
    tmp_12 ! Let/loop value, e.g., 'dir': text
    tmp_13 ! Let/loop value, e.g., 'count': number
    tmp_14 ! Let/loop value, e.g., 'x': real number
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
tmp_3=LocalParking-->3;
tmp_4=LocalParking-->4;
tmp_5=LocalParking-->5;
tmp_6=LocalParking-->6;
tmp_7=LocalParking-->7;
tmp_8=LocalParking-->8;
tmp_9=LocalParking-->9;
tmp_10=LocalParking-->10;
tmp_11=LocalParking-->11;
tmp_12=LocalParking-->12;
tmp_13=LocalParking-->13;
tmp_14=LocalParking-->14;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[dir][nsdir]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[dir][nsdir]~]
    say__p=1;! [2: dir]
    ParaContent(); print (TEXT_TY_Say) tmp_12;! [3: nsdir]
    ParaContent(); print (TEXT_TY_Say) tmp_3; .L_Say1048; .L_SayX1029;rtrue;
];
Array TX_S_580 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_580;
[ R_TX_S_581 
    tmp_0 ! Let/loop value, e.g., 'nsdiff': real number
    tmp_1 ! Let/loop value, e.g., 'wediff': real number
    tmp_2 ! Let/loop value, e.g., 'fbdiff': real number
    tmp_3 ! Let/loop value, e.g., 'nsdir': text
    tmp_4 ! Let/loop value, e.g., 'wedir': text
    tmp_5 ! Let/loop value, e.g., 'fbdir': text
    tmp_6 ! Let/loop value, e.g., 'nsdivwe': real number
    tmp_7 ! Let/loop value, e.g., 'nsdivfb': real number
    tmp_8 ! Let/loop value, e.g., 'wedivfb': real number
    tmp_9 ! Let/loop value, e.g., 'nsscore': real number
    tmp_10 ! Let/loop value, e.g., 'wescore': real number
    tmp_11 ! Let/loop value, e.g., 'fbscore': real number
    tmp_12 ! Let/loop value, e.g., 'dir': text
    tmp_13 ! Let/loop value, e.g., 'count': number
    tmp_14 ! Let/loop value, e.g., 'x': real number
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
tmp_3=LocalParking-->3;
tmp_4=LocalParking-->4;
tmp_5=LocalParking-->5;
tmp_6=LocalParking-->6;
tmp_7=LocalParking-->7;
tmp_8=LocalParking-->8;
tmp_9=LocalParking-->9;
tmp_10=LocalParking-->10;
tmp_11=LocalParking-->11;
tmp_12=LocalParking-->12;
tmp_13=LocalParking-->13;
tmp_14=LocalParking-->14;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[dir][wedir]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[dir][wedir]~]
    say__p=1;! [2: dir]
    ParaContent(); print (TEXT_TY_Say) tmp_12;! [3: wedir]
    ParaContent(); print (TEXT_TY_Say) tmp_4; .L_Say1049; .L_SayX1030;rtrue;
];
Array TX_S_581 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_581;
[ R_TX_S_582 
    tmp_0 ! Let/loop value, e.g., 'nsdiff': real number
    tmp_1 ! Let/loop value, e.g., 'wediff': real number
    tmp_2 ! Let/loop value, e.g., 'fbdiff': real number
    tmp_3 ! Let/loop value, e.g., 'nsdir': text
    tmp_4 ! Let/loop value, e.g., 'wedir': text
    tmp_5 ! Let/loop value, e.g., 'fbdir': text
    tmp_6 ! Let/loop value, e.g., 'nsdivwe': real number
    tmp_7 ! Let/loop value, e.g., 'nsdivfb': real number
    tmp_8 ! Let/loop value, e.g., 'wedivfb': real number
    tmp_9 ! Let/loop value, e.g., 'nsscore': real number
    tmp_10 ! Let/loop value, e.g., 'wescore': real number
    tmp_11 ! Let/loop value, e.g., 'fbscore': real number
    tmp_12 ! Let/loop value, e.g., 'dir': text
    tmp_13 ! Let/loop value, e.g., 'count': number
    tmp_14 ! Let/loop value: real number
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
tmp_3=LocalParking-->3;
tmp_4=LocalParking-->4;
tmp_5=LocalParking-->5;
tmp_6=LocalParking-->6;
tmp_7=LocalParking-->7;
tmp_8=LocalParking-->8;
tmp_9=LocalParking-->9;
tmp_10=LocalParking-->10;
tmp_11=LocalParking-->11;
tmp_12=LocalParking-->12;
tmp_13=LocalParking-->13;
tmp_14=LocalParking-->14;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[dir][wedir]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[dir][wedir]~]
    say__p=1;! [2: dir]
    ParaContent(); print (TEXT_TY_Say) tmp_12;! [3: wedir]
    ParaContent(); print (TEXT_TY_Say) tmp_4; .L_Say1050; .L_SayX1031;rtrue;
];
Array TX_S_582 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_582;
[ R_TX_S_583 
    tmp_0 ! Let/loop value, e.g., 'nsdiff': real number
    tmp_1 ! Let/loop value, e.g., 'wediff': real number
    tmp_2 ! Let/loop value, e.g., 'fbdiff': real number
    tmp_3 ! Let/loop value, e.g., 'nsdir': text
    tmp_4 ! Let/loop value, e.g., 'wedir': text
    tmp_5 ! Let/loop value, e.g., 'fbdir': text
    tmp_6 ! Let/loop value, e.g., 'nsdivwe': real number
    tmp_7 ! Let/loop value, e.g., 'nsdivfb': real number
    tmp_8 ! Let/loop value, e.g., 'wedivfb': real number
    tmp_9 ! Let/loop value, e.g., 'nsscore': real number
    tmp_10 ! Let/loop value, e.g., 'wescore': real number
    tmp_11 ! Let/loop value, e.g., 'fbscore': real number
    tmp_12 ! Let/loop value, e.g., 'dir': text
    tmp_13 ! Let/loop value, e.g., 'count': number
    tmp_14 ! Let/loop value: real number
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
tmp_3=LocalParking-->3;
tmp_4=LocalParking-->4;
tmp_5=LocalParking-->5;
tmp_6=LocalParking-->6;
tmp_7=LocalParking-->7;
tmp_8=LocalParking-->8;
tmp_9=LocalParking-->9;
tmp_10=LocalParking-->10;
tmp_11=LocalParking-->11;
tmp_12=LocalParking-->12;
tmp_13=LocalParking-->13;
tmp_14=LocalParking-->14;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[fbdir][dir]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[fbdir][dir]~]
    say__p=1;! [2: fbdir]
    ParaContent(); print (TEXT_TY_Say) tmp_5;! [3: dir]
    ParaContent(); print (TEXT_TY_Say) tmp_12; .L_Say1051; .L_SayX1032;rtrue;
];
Array TX_S_583 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_583;
[ R_TX_S_584 
    tmp_0 ! Let/loop value, e.g., 'nsdiff': real number
    tmp_1 ! Let/loop value, e.g., 'wediff': real number
    tmp_2 ! Let/loop value, e.g., 'fbdiff': real number
    tmp_3 ! Let/loop value, e.g., 'nsdir': text
    tmp_4 ! Let/loop value, e.g., 'wedir': text
    tmp_5 ! Let/loop value, e.g., 'fbdir': text
    tmp_6 ! Let/loop value, e.g., 'nsdivwe': real number
    tmp_7 ! Let/loop value, e.g., 'nsdivfb': real number
    tmp_8 ! Let/loop value, e.g., 'wedivfb': real number
    tmp_9 ! Let/loop value, e.g., 'nsscore': real number
    tmp_10 ! Let/loop value, e.g., 'wescore': real number
    tmp_11 ! Let/loop value, e.g., 'fbscore': real number
    tmp_12 ! Let/loop value, e.g., 'dir': text
    tmp_13 ! Let/loop value, e.g., 'count': number
    tmp_14 ! Let/loop value, e.g., 'x': real number
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
tmp_3=LocalParking-->3;
tmp_4=LocalParking-->4;
tmp_5=LocalParking-->5;
tmp_6=LocalParking-->6;
tmp_7=LocalParking-->7;
tmp_8=LocalParking-->8;
tmp_9=LocalParking-->9;
tmp_10=LocalParking-->10;
tmp_11=LocalParking-->11;
tmp_12=LocalParking-->12;
tmp_13=LocalParking-->13;
tmp_14=LocalParking-->14;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[nsdir][dir]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[nsdir][dir]~]
    say__p=1;! [2: nsdir]
    ParaContent(); print (TEXT_TY_Say) tmp_3;! [3: dir]
    ParaContent(); print (TEXT_TY_Say) tmp_12; .L_Say1052; .L_SayX1033;rtrue;
];
Array TX_S_584 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_584;
[ R_TX_S_585 
    tmp_0 ! Let/loop value, e.g., 'nsdiff': real number
    tmp_1 ! Let/loop value, e.g., 'wediff': real number
    tmp_2 ! Let/loop value, e.g., 'fbdiff': real number
    tmp_3 ! Let/loop value, e.g., 'nsdir': text
    tmp_4 ! Let/loop value, e.g., 'wedir': text
    tmp_5 ! Let/loop value, e.g., 'fbdir': text
    tmp_6 ! Let/loop value, e.g., 'nsdivwe': real number
    tmp_7 ! Let/loop value, e.g., 'nsdivfb': real number
    tmp_8 ! Let/loop value, e.g., 'wedivfb': real number
    tmp_9 ! Let/loop value, e.g., 'nsscore': real number
    tmp_10 ! Let/loop value, e.g., 'wescore': real number
    tmp_11 ! Let/loop value, e.g., 'fbscore': real number
    tmp_12 ! Let/loop value, e.g., 'dir': text
    tmp_13 ! Let/loop value, e.g., 'count': number
    tmp_14 ! Let/loop value, e.g., 'x': real number
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
tmp_3=LocalParking-->3;
tmp_4=LocalParking-->4;
tmp_5=LocalParking-->5;
tmp_6=LocalParking-->6;
tmp_7=LocalParking-->7;
tmp_8=LocalParking-->8;
tmp_9=LocalParking-->9;
tmp_10=LocalParking-->10;
tmp_11=LocalParking-->11;
tmp_12=LocalParking-->12;
tmp_13=LocalParking-->13;
tmp_14=LocalParking-->14;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[fbdir][dir]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[fbdir][dir]~]
    say__p=1;! [2: fbdir]
    ParaContent(); print (TEXT_TY_Say) tmp_5;! [3: dir]
    ParaContent(); print (TEXT_TY_Say) tmp_12; .L_Say1053; .L_SayX1034;rtrue;
];
Array TX_S_585 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_585;
[ R_TX_S_586 
    t_0 ! Call parameter 'way': direction
    tmp_0 ! Let/loop value, e.g., 'cap-way': text
    ;
    t_0=LocalParking-->0;
tmp_0=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[way]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[way]~]
    say__p=1;! [2: way]
    ParaContent(); PrintShortName(t_0); .L_Say1054; .L_SayX1035;rtrue;
];
Array TX_S_586 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_586;
[ R_TX_S_587 
    tmp_0 ! Let/loop value, e.g., 'L': text
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[location]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[location]~]
    say__p=1;! [2: location]
    ParaContent(); PrintShortName(real_location); .L_Say1055; .L_SayX1036;rtrue;
];
Array TX_S_587 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_587;
! Find next x satisfying:
! [ thing(x) ]
[ Prop_0 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ subject(x) ]
[ Prop_1 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK17_First: x: x=x.IK17_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ object(x) ]
[ Prop_2 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x ofclass Object){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! Force this to be true via 'now':
! [ ForAll x IN[ choice(x) IN] : is('the room of choices', ContainerOf(x)) ]
[ Prop_3 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=nothing: false: ){
        qcn_0++;
        MoveObject(x,I216_room_of_choices);
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Force this to be true via 'now':
! [ ForAll x IN[ quip(x) IN] : is('the room of quips', ContainerOf(x)) ]
[ Prop_4 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK29_First: x: x=x.IK29_Link){
        qcn_0++;
        MoveObject(x,I231_room_of_quips);
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Construct a list of x satisfying:
! [ person(x) ]
[ Prop_5 
    list ! Implied call parameter
    strong_kind ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    total ! internal use only
    ;
    ;
    BlkValueWrite(list, LIST_ITEM_KOV_F, strong_kind);
    total = LIST_OF_TY_GetLength(list);
    for (x=IK8_First: x: x=x.IK8_Link){
        counter++;
        if (counter > total) { total = 3*(total/2)+8; LIST_OF_TY_SetLength(list, total); }
        BlkValueWrite(list, counter+LIST_ITEM_BASE-1, x);
        jump NextOuterLoop_8;
        .NextOuterLoop_8;
    }
    LIST_OF_TY_SetLength(list, counter);
    return list;
];
! Construct a list of x satisfying:
! [ quip(x) & stocking(x, const_0) ]
[ Prop_6 
    const_0 ! Implied call parameter
    list ! Implied call parameter
    strong_kind ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    total ! internal use only
    ;
    ;
    BlkValueWrite(list, LIST_ITEM_KOV_F, strong_kind);
    total = LIST_OF_TY_GetLength(list);
    for (x=IK29_First: x: x=x.IK29_Link){
        if (((RGuard_T_15(x,const_0)))){
            counter++;
            if (counter > total) { total = 3*(total/2)+8; LIST_OF_TY_SetLength(list, total); }
            BlkValueWrite(list, counter+LIST_ITEM_BASE-1, x);
            jump NextOuterLoop_8;
        }
        .NextOuterLoop_8;
    }
    LIST_OF_TY_SetLength(list, counter);
    return list;
];
! Find next x satisfying:
! [ subject(x) ]
[ Prop_7 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK17_First: x: x=x.IK17_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ DoesNotExist x IN[ person(x) IN] : talking('player', x) ]
[ Prop_8 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK8_First: x: x=x.IK8_Link){
        qcn_0++;
        if (((RGuard_T_4(player,x)))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];
! Find next x satisfying:
! [ person(x) & Exists y : person(y) & talking(x, y) ]
[ Prop_9 
    x ! internal use only
    x_ix ! internal use only
    y ! internal use only
    y_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK8_First: x: x=x.IK8_Link){
        for (y=IK8_First: y: y=y.IK8_Link){
            if (((RGuard_T_4(x,y)))){
                return x;
            }
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ person(x) & NOT[ is(x, 'the player') NOT] ]
[ Prop_10 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK8_First: x: x=x.IK8_Link){
        if (~~((x == player))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ two-sided door(x) ]
[ Prop_11 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK30_First: x: x=x.IK30_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ two-sided door(x) ]
[ Prop_12 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK30_First: x: x=x.IK30_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : person(x) & called='p'(person)(x) & talking('player', x) ]
[ Prop_13 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK8_First: x: x=x.IK8_Link){
        if (((RGuard_T_4(player,x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];
! How many x satisfy this?
! [ person(x) & 'visible'(x) & NOT[ is(x, 'the player') NOT] ]
[ Prop_14 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    for (x=IK8_First: x: x=x.IK8_Link){
        if (((Adj_3_t1_v10(x)))){
            if (~~((x == player))){
                counter++;
                jump NextOuterLoop_5;
            }
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! Find a random x satisfying:
! [ person(x) & 'visible'(x) & NOT[ is(x, 'the player') NOT] ]
[ Prop_15 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    selection ! internal use only
    ;
    ;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK8_First: x: x=x.IK8_Link){
            if (((Adj_3_t1_v10(x)))){
                if (~~((x == player))){
                    counter++;
                    if (counter == selection) return x;
                    jump NextOuterLoop_7;
                }
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];
! True or false?
! [ Exists x : person(x) & called='p'(person)(x) & talking('player', x) ]
[ Prop_16 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK8_First: x: x=x.IK8_Link){
        if (((RGuard_T_4(player,x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];
! Find a random x satisfying:
! [ person(x) & is((RGuard_f1_5(x)), const_0) ]
[ Prop_17 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    selection ! internal use only
    ;
    ;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK8_First: x: x=x.IK8_Link){
            if (((RGuard_f1_5(x)) == const_0)){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];
! Find a random x satisfying:
! [ phone number(x) & is((RGuard_f1_6(x)), const_0) ]
[ Prop_18 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    selection ! internal use only
    ;
    ;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK21_First: x: x=x.IK21_Link){
            if (((RGuard_f1_6(x)) == const_0)){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];
! True or false?
! [ Exists x : drawer(x) & called='dr'(drawer)(x) & is(const_0, (x.component_parent)) ]
[ Prop_19 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK23_First: x: x=x.IK23_Link){
        if ((const_0 == (x.component_parent))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : drawer(x) & called='dr'(drawer)(x) & is(const_0, (x.component_parent)) ]
[ Prop_20 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK23_First: x: x=x.IK23_Link){
        if ((const_0 == (x.component_parent))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];
! Find next x satisfying:
! [ person(x) & is('the location', ContainerOf(x)) ]
[ Prop_21 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=TestContainmentRange(real_location): x: x=TestContainmentRange(real_location,x)){
        if ((x ofclass K8_person)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : person(x) & 'visible'(x) & called='p'(person)(x) & quip-supplying(const_0, x) ]
[ Prop_22 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK8_First: x: x=x.IK8_Link){
        if (((Adj_3_t1_v10(x))) && ((RGuard_T_11(const_0,x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];
! Find next x satisfying:
! [ person(x) & can-see(x, 'the person asked') ]
[ Prop_23 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK8_First: x: x=x.IK8_Link){
        if ((TestVisibility(x,actor))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : person(x) & called='callee'(person)(x) & talking('the player', x) ]
[ Prop_24 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK8_First: x: x=x.IK8_Link){
        if (((RGuard_T_4(player,x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];
! Find a random x satisfying:
! [ thing(x) & 'visible'(x) & quip-supplying(const_0, x) ]
[ Prop_25 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    selection ! internal use only
    ;
    ;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK2_First: x: x=x.IK2_Link){
            if (((Adj_3_t1_v10(x))) && ((RGuard_T_11(const_0,x)))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];
! True or false?
! [ Exists x : thing(x) & 'enterable'(x) & called='box'(thing)(x) & is('the location', ContainerOf(x)) ]
[ Prop_26 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=TestContainmentRange(real_location): x: x=TestContainmentRange(real_location,x)){
        if ((x ofclass K2_thing) && ((Adj_98_t1_v10(x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];
! Construct a list of x satisfying:
! [ money card(x) ]
[ Prop_27 
    list ! Implied call parameter
    strong_kind ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    total ! internal use only
    ;
    ;
    BlkValueWrite(list, LIST_ITEM_KOV_F, strong_kind);
    total = LIST_OF_TY_GetLength(list);
    for (x=IK22_First: x: x=x.IK22_Link){
        counter++;
        if (counter > total) { total = 3*(total/2)+8; LIST_OF_TY_SetLength(list, total); }
        BlkValueWrite(list, counter+LIST_ITEM_BASE-1, x);
        jump NextOuterLoop_8;
        .NextOuterLoop_8;
    }
    LIST_OF_TY_SetLength(list, counter);
    return list;
];
! Find next x satisfying:
! [ thing(x) ]
[ Prop_28 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ thing(x) ]
[ Prop_29 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! How many x satisfy this?
! [ thing(x) & 'marked for listing'(x) ]
[ Prop_30 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_94_t1_v10(x)))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! Find next x satisfying:
! [ thing(x) & 'marked for listing'(x) ]
[ Prop_31 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_94_t1_v10(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Abstraction for set of x such that:
! [ thing(x) & thing(x) & 'unmentioned'(x) ]
[ Prop_32 
    reason ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    total ! internal use only
    counter ! internal use only
    selection ! internal use only
    best ! internal use only
    best_with ! internal use only
    ;
    ;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK2_First: x: x=x.IK2_Link){
                if ((x ofclass K2_thing) && ((Adj_97_t1_v10(x)))){
                    if (property_loop_sign>0) {
                        if (x.property_to_be_totalled >= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    } else {
                        if (x.property_to_be_totalled <= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK2_First: x: x=x.IK2_Link){
                if ((x ofclass K2_thing) && ((Adj_97_t1_v10(x)))){
                    total = total + x.property_to_be_totalled;
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK2_First: x: x=x.IK2_Link){
                    if ((x ofclass K2_thing) && ((Adj_97_t1_v10(x)))){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK2_First: x: x=x.IK2_Link){
                if ((x ofclass K2_thing) && ((Adj_97_t1_v10(x)))){
                    counter++;
                    jump NextOuterLoop_5;
                }
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK2_First: x: x=x.IK2_Link){
                if ((x ofclass K2_thing) && ((Adj_97_t1_v10(x)))){
                    return x;
                }
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K2_thing) && (x ofclass K2_thing) && ((Adj_97_t1_v10(x)))){
                rtrue;
            }
            rfalse;
    }
];
! Find next x satisfying:
! [ thing(x) & not-'handled'(x) & supporter(const_0) & provides(const_1, 'the property initial appearance') & is(const_2, SupporterOf(x)) ]
[ Prop_33 
    const_0 ! Implied call parameter
    const_1 ! Implied call parameter
    const_2 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in const_2) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && (~~((Adj_91_t1_v10(x)))) && (const_0 ofclass K6_supporter) && (WhetherProvides(const_1, false, initial))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : thing(x) & 'locale-supportable'(x) & is(const_0, SupporterOf(x)) ]
[ Prop_34 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_41_t1_v10(x)))){
            rtrue;
        }
    }
    rfalse;
];
! Find next x satisfying:
! [ thing(x) & is(const_0, SupporterOf(x)) ]
[ Prop_35 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : thing(x) & 'locale-supportable'(x) & is(const_0, SupporterOf(x)) ]
[ Prop_36 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_41_t1_v10(x)))){
            rtrue;
        }
    }
    rfalse;
];
! Find next x satisfying:
! [ thing(x) & is(const_0, SupporterOf(x)) ]
[ Prop_37 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : thing(x) & 'locale-supportable'(x) & is(const_0, SupporterOf(x)) ]
[ Prop_38 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_41_t1_v10(x)))){
            rtrue;
        }
    }
    rfalse;
];
! Find next x satisfying:
! [ thing(x) & is(const_0, SupporterOf(x)) ]
[ Prop_39 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! How many x satisfy this?
! [ thing(x) & is('the actor', CarrierOf(x)) ]
[ Prop_40 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! True or false?
! [ Exists x : player's holdall(x) & called='current working sack'(player's holdall)(x) & is('actor', HolderOf(x)) ]
[ Prop_41 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=nothing: false: ){
        if ((actor == HolderOf(x))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];
! Find next x satisfying:
! [ thing(x) & is('the actor', CarrierOf(x)) ]
[ Prop_42 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! How many x satisfy this?
! [ thing(x) & is('the actor', CarrierOf(x)) ]
[ Prop_43 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! How many x satisfy this?
! [ thing(x) & is(const_0, SupporterOf(x)) ]
[ Prop_44 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! How many x satisfy this?
! [ thing(x) & is(const_0, ContainerOf(x)) ]
[ Prop_45 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    for (x=TestContainmentRange(const_0): x: x=TestContainmentRange(const_0,x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! How many x satisfy this?
! [ thing(x) & is('the second noun', SupporterOf(x)) ]
[ Prop_46 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in second) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! How many x satisfy this?
! [ thing(x) & is('the second noun', ContainerOf(x)) ]
[ Prop_47 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    for (x=TestContainmentRange(second): x: x=TestContainmentRange(second,x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! True or false?
! [ Exists x : person(x) & called='owner'(person)(x) & NOT[ is(x, 'the actor') NOT] & encloses(x, 'noun') ]
[ Prop_48 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK8_First: x: x=x.IK8_Link){
        if (~~((x == actor))){
            if ((IndirectlyContains(x,noun))){
                deferred_calling_list-->0 = x;
                rtrue;
            }
        }
    }
    rfalse;
];
! How many x satisfy this?
! [ thing(x) & is('the noun', SupporterOf(x)) ]
[ Prop_49 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! How many x satisfy this?
! [ thing(x) & is('the noun', ContainerOf(x)) ]
[ Prop_50 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! Find next x satisfying:
! [ thing(x) ]
[ Prop_51 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ direction(x) & 'hyperspatial'(x) ]
[ Prop_52 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK3_First: x: x=x.IK3_Link){
        if (((Adj_159_t1_v10(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Force this to be true via 'now':
! [ ForAll x IN[ backdrop(x) & is('the location', ContainerOf(x)) IN] : 'seen'(x) ]
[ Prop_53 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK7_First: x: x=x.IK7_Link){
        if ((real_location == ContainerOf(x))){
            qcn_0++;
            (Adj_116_t2_v10(x));
            qcy_0++;
        }
    }
    if (qcy_0 == qcn_0){
    }
];
! Find next x satisfying:
! [ thing(x) & encloses('the location', x) ]
[ Prop_54 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if ((IndirectlyContains(real_location,x))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : container(x) & 'opaque'(x) & 'closed'(x) & encloses(x, const_0) ]
[ Prop_55 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK5_First: x: x=x.IK5_Link){
        if (((Adj_99_t1_v10(x))) && ((Adj_102_t1_v10(x))) && (IndirectlyContains(x,const_0))){
            rtrue;
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('the noun', ContainerOf(x)) ]
[ Prop_56 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing) && ((Adj_92_t1_v10(x)))){
            if (~~(((Adj_88_t1_v10(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & NOT[ is(x, 'the player') NOT] & is('the noun', ContainerOf(x)) ]
[ Prop_57 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing)){
            if (~~((x == player))){
                rtrue;
            }
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('the noun', SupporterOf(x)) ]
[ Prop_58 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_92_t1_v10(x)))){
            if (~~(((Adj_88_t1_v10(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & NOT[ is(x, 'the player') NOT] & is('the noun', SupporterOf(x)) ]
[ Prop_59 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            if (~~((x == player))){
                rtrue;
            }
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('noun', ContainerOf(x)) ]
[ Prop_60 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing) && ((Adj_92_t1_v10(x)))){
            if (~~(((Adj_88_t1_v10(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('noun', SupporterOf(x)) ]
[ Prop_61 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_92_t1_v10(x)))){
            if (~~(((Adj_88_t1_v10(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];
! Find next x satisfying:
! [ thing(x) & encloses('the noun', x) ]
[ Prop_62 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if ((IndirectlyContains(noun,x))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! How many x satisfy this?
! [ thing(x) & is('the actor', CarrierOf(x)) ]
[ Prop_63 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! How many x satisfy this?
! [ thing(x) & is('the second noun', CarrierOf(x)) ]
[ Prop_64 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    objectloop (x in second) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! Find a random x satisfying:
! [ person(x) & 'visible'(x) & NOT[ is(x, 'the player') NOT] ]
[ Prop_65 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    selection ! internal use only
    ;
    ;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK8_First: x: x=x.IK8_Link){
            if (((Adj_3_t1_v10(x)))){
                if (~~((x == player))){
                    counter++;
                    if (counter == selection) return x;
                    jump NextOuterLoop_7;
                }
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];
! Abstraction for set of x such that:
! [ room(x) & room(x) & 'indoors'(x) ]
[ Prop_66 
    reason ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    total ! internal use only
    counter ! internal use only
    selection ! internal use only
    best ! internal use only
    best_with ! internal use only
    ;
    ;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK1_First: x: x=x.IK1_Link){
                if ((x ofclass K1_room) && ((Adj_122_t1_v10(x)))){
                    if (property_loop_sign>0) {
                        if (x.property_to_be_totalled >= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    } else {
                        if (x.property_to_be_totalled <= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK1_First: x: x=x.IK1_Link){
                if ((x ofclass K1_room) && ((Adj_122_t1_v10(x)))){
                    total = total + x.property_to_be_totalled;
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK1_First: x: x=x.IK1_Link){
                    if ((x ofclass K1_room) && ((Adj_122_t1_v10(x)))){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK1_First: x: x=x.IK1_Link){
                if ((x ofclass K1_room) && ((Adj_122_t1_v10(x)))){
                    counter++;
                    jump NextOuterLoop_5;
                }
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK1_First: x: x=x.IK1_Link){
                if ((x ofclass K1_room) && ((Adj_122_t1_v10(x)))){
                    return x;
                }
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K1_room) && (x ofclass K1_room) && ((Adj_122_t1_v10(x)))){
                rtrue;
            }
            rfalse;
    }
];
! Abstraction for set of x such that:
! [ room(x) & room(x) & 'indoors'(x) ]
[ Prop_67 
    reason ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    total ! internal use only
    counter ! internal use only
    selection ! internal use only
    best ! internal use only
    best_with ! internal use only
    ;
    ;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK1_First: x: x=x.IK1_Link){
                if ((x ofclass K1_room) && ((Adj_122_t1_v10(x)))){
                    if (property_loop_sign>0) {
                        if (x.property_to_be_totalled >= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    } else {
                        if (x.property_to_be_totalled <= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK1_First: x: x=x.IK1_Link){
                if ((x ofclass K1_room) && ((Adj_122_t1_v10(x)))){
                    total = total + x.property_to_be_totalled;
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK1_First: x: x=x.IK1_Link){
                    if ((x ofclass K1_room) && ((Adj_122_t1_v10(x)))){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK1_First: x: x=x.IK1_Link){
                if ((x ofclass K1_room) && ((Adj_122_t1_v10(x)))){
                    counter++;
                    jump NextOuterLoop_5;
                }
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK1_First: x: x=x.IK1_Link){
                if ((x ofclass K1_room) && ((Adj_122_t1_v10(x)))){
                    return x;
                }
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K1_room) && (x ofclass K1_room) && ((Adj_122_t1_v10(x)))){
                rtrue;
            }
            rfalse;
    }
];
! Abstraction for set of x such that:
! [ room(x) & room(x) & 'outdoors'(x) ]
[ Prop_68 
    reason ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    total ! internal use only
    counter ! internal use only
    selection ! internal use only
    best ! internal use only
    best_with ! internal use only
    ;
    ;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK1_First: x: x=x.IK1_Link){
                if ((x ofclass K1_room) && ((Adj_123_t1_v10(x)))){
                    if (property_loop_sign>0) {
                        if (x.property_to_be_totalled >= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    } else {
                        if (x.property_to_be_totalled <= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK1_First: x: x=x.IK1_Link){
                if ((x ofclass K1_room) && ((Adj_123_t1_v10(x)))){
                    total = total + x.property_to_be_totalled;
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK1_First: x: x=x.IK1_Link){
                    if ((x ofclass K1_room) && ((Adj_123_t1_v10(x)))){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK1_First: x: x=x.IK1_Link){
                if ((x ofclass K1_room) && ((Adj_123_t1_v10(x)))){
                    counter++;
                    jump NextOuterLoop_5;
                }
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK1_First: x: x=x.IK1_Link){
                if ((x ofclass K1_room) && ((Adj_123_t1_v10(x)))){
                    return x;
                }
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K1_room) && (x ofclass K1_room) && ((Adj_123_t1_v10(x)))){
                rtrue;
            }
            rfalse;
    }
];
! Abstraction for set of x such that:
! [ room(x) & room(x) & 'outdoors'(x) ]
[ Prop_69 
    reason ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    total ! internal use only
    counter ! internal use only
    selection ! internal use only
    best ! internal use only
    best_with ! internal use only
    ;
    ;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK1_First: x: x=x.IK1_Link){
                if ((x ofclass K1_room) && ((Adj_123_t1_v10(x)))){
                    if (property_loop_sign>0) {
                        if (x.property_to_be_totalled >= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    } else {
                        if (x.property_to_be_totalled <= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK1_First: x: x=x.IK1_Link){
                if ((x ofclass K1_room) && ((Adj_123_t1_v10(x)))){
                    total = total + x.property_to_be_totalled;
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK1_First: x: x=x.IK1_Link){
                    if ((x ofclass K1_room) && ((Adj_123_t1_v10(x)))){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK1_First: x: x=x.IK1_Link){
                if ((x ofclass K1_room) && ((Adj_123_t1_v10(x)))){
                    counter++;
                    jump NextOuterLoop_5;
                }
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK1_First: x: x=x.IK1_Link){
                if ((x ofclass K1_room) && ((Adj_123_t1_v10(x)))){
                    return x;
                }
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K1_room) && (x ofclass K1_room) && ((Adj_123_t1_v10(x)))){
                rtrue;
            }
            rfalse;
    }
];
! True or false?
! [ Exists x : thing(x) & 'noisy'(x) ]
[ Prop_70 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_129_t1_v10(x)))){
            rtrue;
        }
    }
    rfalse;
];
! Find next x satisfying:
! [ thing(x) & 'audible'(x) & 'insistent'(x) ]
[ Prop_71 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_128_t1_v10(x))) && ((Adj_131_t1_v10(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ thing(x) & 'audible'(x) & 'background'(x) ]
[ Prop_72 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_128_t1_v10(x))) && ((Adj_132_t1_v10(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : thing(x) & 'visible'(x) & called='vt'(thing)(x) & encloses(x, const_0) ]
[ Prop_73 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_3_t1_v10(x))) && (IndirectlyContains(x,const_0))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];
! Find a random x satisfying:
! [ phone number(x) & is((RGuard_f1_6(x)), const_0) ]
[ Prop_74 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    selection ! internal use only
    ;
    ;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK21_First: x: x=x.IK21_Link){
            if (((RGuard_f1_6(x)) == const_0)){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];
! Find next x satisfying:
! [ phone(x) & is(const_0, (RGuard_f0_7(x))) ]
[ Prop_75 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK20_First: x: x=x.IK20_Link){
        if ((const_0 == (RGuard_f0_7(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find a random x satisfying:
! [ phone number(x) & is((RGuard_f1_6(x)), const_0) ]
[ Prop_76 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    selection ! internal use only
    ;
    ;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK21_First: x: x=x.IK21_Link){
            if (((RGuard_f1_6(x)) == const_0)){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];
! Find a random x satisfying:
! [ person(x) & is(x, (RGuard_f0_7(const_0))) ]
[ Prop_77 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    selection ! internal use only
    ;
    ;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK8_First: x: x=x.IK8_Link){
            if ((x == (RGuard_f0_7(const_0)))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];
! Find a random x satisfying:
! [ person(x) & is((RGuard_f1_5(x)), const_0) ]
[ Prop_78 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    selection ! internal use only
    ;
    ;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK8_First: x: x=x.IK8_Link){
            if (((RGuard_f1_5(x)) == const_0)){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];
! Find a random x satisfying:
! [ person(x) & is((RGuard_f1_5(x)), const_0) ]
[ Prop_79 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    selection ! internal use only
    ;
    ;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK8_First: x: x=x.IK8_Link){
            if (((RGuard_f1_5(x)) == const_0)){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];
! Find a random x satisfying:
! [ person(x) & is((RGuard_f1_5(x)), const_0) ]
[ Prop_80 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    selection ! internal use only
    ;
    ;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK8_First: x: x=x.IK8_Link){
            if (((RGuard_f1_5(x)) == const_0)){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];
! True or false?
! [ DoesNotExist x IN[ person(x) IN] : talking('the actor', x) ]
[ Prop_81 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK8_First: x: x=x.IK8_Link){
        qcn_0++;
        if (((RGuard_T_4(actor,x)))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];
! True or false?
! [ Exists x : person(x) & called='callee'(person)(x) & talking('the actor', x) ]
[ Prop_82 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK8_First: x: x=x.IK8_Link){
        if (((RGuard_T_4(actor,x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];
! Force this to be true via 'now':
! [ DoesNotExist x IN[ person(x) IN] : talking('the actor', x) ]
[ Prop_83 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK8_First: x: x=x.IK8_Link){
        qcn_0++;
        (RGuard_MF_4(actor,x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Force this to be true via 'now':
! [ DoesNotExist x IN[ phone(x) IN] : is((RGuard_f1_5('the actor')), x) ]
[ Prop_84 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK20_First: x: x=x.IK20_Link){
        qcn_0++;
        (RGuard_MF_5(actor,x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Force this to be true via 'now':
! [ DoesNotExist x IN[ phone(x) IN] : is((RGuard_f1_3('the actor')), x) ]
[ Prop_85 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK20_First: x: x=x.IK20_Link){
        qcn_0++;
        (RGuard_MF_3(actor,x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! True or false?
! [ Exists x : person(x) & called='p'(person)(x) & talking('actor', x) ]
[ Prop_86 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK8_First: x: x=x.IK8_Link){
        if (((RGuard_T_4(actor,x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];
! Construct a list of x satisfying:
! [ person(x) & 'visible'(x) & is(x, (RGuard_f0_7(const_0))) ]
[ Prop_87 
    const_0 ! Implied call parameter
    list ! Implied call parameter
    strong_kind ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    total ! internal use only
    ;
    ;
    BlkValueWrite(list, LIST_ITEM_KOV_F, strong_kind);
    total = LIST_OF_TY_GetLength(list);
    for (x=IK8_First: x: x=x.IK8_Link){
        if (((Adj_3_t1_v10(x))) && (x == (RGuard_f0_7(const_0)))){
            counter++;
            if (counter > total) { total = 3*(total/2)+8; LIST_OF_TY_SetLength(list, total); }
            BlkValueWrite(list, counter+LIST_ITEM_BASE-1, x);
            jump NextOuterLoop_8;
        }
        .NextOuterLoop_8;
    }
    LIST_OF_TY_SetLength(list, counter);
    return list;
];
! Construct a list of x satisfying:
! [ money card(x) & 'held'(x) ]
[ Prop_88 
    list ! Implied call parameter
    strong_kind ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    total ! internal use only
    ;
    ;
    BlkValueWrite(list, LIST_ITEM_KOV_F, strong_kind);
    total = LIST_OF_TY_GetLength(list);
    for (x=IK22_First: x: x=x.IK22_Link){
        if (((Adj_2_t1_v10(x)))){
            counter++;
            if (counter > total) { total = 3*(total/2)+8; LIST_OF_TY_SetLength(list, total); }
            BlkValueWrite(list, counter+LIST_ITEM_BASE-1, x);
            jump NextOuterLoop_8;
        }
        .NextOuterLoop_8;
    }
    LIST_OF_TY_SetLength(list, counter);
    return list;
];
! True or false?
! [ Exists x : door(x) & 'unlocked'(x) ]
[ Prop_89 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK4_First: x: x=x.IK4_Link){
        if (((Adj_107_t1_v10(x)))){
            rtrue;
        }
    }
    rfalse;
];
! True or false?
! [ DoesNotExist x IN[ thing(x) IN] : is((RGuard_f1_10(x)), 'the noun') ]
[ Prop_90 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK2_First: x: x=x.IK2_Link){
        qcn_0++;
        if (((RGuard_f1_10(x)) == noun)){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];
! Find next x satisfying:
! [ thing(x) & is((RGuard_f1_10(x)), 'the noun') ]
[ Prop_91 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((RGuard_f1_10(x)) == noun)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Construct a list of x satisfying:
! [ quip(x) & following(x, const_0) ]
[ Prop_92 
    const_0 ! Implied call parameter
    list ! Implied call parameter
    strong_kind ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    total ! internal use only
    ;
    ;
    BlkValueWrite(list, LIST_ITEM_KOV_F, strong_kind);
    total = LIST_OF_TY_GetLength(list);
    for (x=IK29_First: x: x=x.IK29_Link){
        if (((RGuard_T_12(x,const_0)))){
            counter++;
            if (counter > total) { total = 3*(total/2)+8; LIST_OF_TY_SetLength(list, total); }
            BlkValueWrite(list, counter+LIST_ITEM_BASE-1, x);
            jump NextOuterLoop_8;
        }
        .NextOuterLoop_8;
    }
    LIST_OF_TY_SetLength(list, counter);
    return list;
];
! Construct a list of x satisfying:
! [ quip(x) & exclusion(const_0, x) ]
[ Prop_93 
    const_0 ! Implied call parameter
    list ! Implied call parameter
    strong_kind ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    total ! internal use only
    ;
    ;
    BlkValueWrite(list, LIST_ITEM_KOV_F, strong_kind);
    total = LIST_OF_TY_GetLength(list);
    for (x=IK29_First: x: x=x.IK29_Link){
        if (((RGuard_T_13(const_0,x)))){
            counter++;
            if (counter > total) { total = 3*(total/2)+8; LIST_OF_TY_SetLength(list, total); }
            BlkValueWrite(list, counter+LIST_ITEM_BASE-1, x);
            jump NextOuterLoop_8;
        }
        .NextOuterLoop_8;
    }
    LIST_OF_TY_SetLength(list, counter);
    return list;
];
! Construct a list of x satisfying:
! [ quip(x) & 'plausible'(x) & 'q-available'(x) & NOT[ 'exhausted'(x) NOT] ]
[ Prop_94 
    list ! Implied call parameter
    strong_kind ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    total ! internal use only
    ;
    ;
    BlkValueWrite(list, LIST_ITEM_KOV_F, strong_kind);
    total = LIST_OF_TY_GetLength(list);
    for (x=IK29_First: x: x=x.IK29_Link){
        if (((Adj_66_t1_v10(x))) && ((Adj_64_t1_v10(x)))){
            if (~~(((Adj_147_t1_v10(x))))){
                counter++;
                if (counter > total) { total = 3*(total/2)+8; LIST_OF_TY_SetLength(list, total); }
                BlkValueWrite(list, counter+LIST_ITEM_BASE-1, x);
                jump NextOuterLoop_8;
            }
        }
        .NextOuterLoop_8;
    }
    LIST_OF_TY_SetLength(list, counter);
    return list;
];
! Find next x satisfying:
! [ thing(x) & 'visible'(x) ]
[ Prop_95 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_3_t1_v10(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ person(x) & is('the location', ContainerOf(x)) ]
[ Prop_96 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=TestContainmentRange(real_location): x: x=TestContainmentRange(real_location,x)){
        if ((x ofclass K8_person)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ person(x) & talking(x, 'the player') ]
[ Prop_97 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK8_First: x: x=x.IK8_Link){
        if (((RGuard_T_4(x,player)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ thing(x) ]
[ Prop_98 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ thing(x) ]
[ Prop_99 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! How many x satisfy this?
! [ thing(x) & 'marked for listing'(x) ]
[ Prop_100 
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    ;
    ;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_94_t1_v10(x)))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
! Find next x satisfying:
! [ thing(x) & 'marked for listing'(x) ]
[ Prop_101 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_94_t1_v10(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Abstraction for set of x such that:
! [ thing(x) & thing(x) & 'unmentioned'(x) ]
[ Prop_102 
    reason ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    total ! internal use only
    counter ! internal use only
    selection ! internal use only
    best ! internal use only
    best_with ! internal use only
    ;
    ;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK2_First: x: x=x.IK2_Link){
                if ((x ofclass K2_thing) && ((Adj_97_t1_v10(x)))){
                    if (property_loop_sign>0) {
                        if (x.property_to_be_totalled >= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    } else {
                        if (x.property_to_be_totalled <= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK2_First: x: x=x.IK2_Link){
                if ((x ofclass K2_thing) && ((Adj_97_t1_v10(x)))){
                    total = total + x.property_to_be_totalled;
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK2_First: x: x=x.IK2_Link){
                    if ((x ofclass K2_thing) && ((Adj_97_t1_v10(x)))){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK2_First: x: x=x.IK2_Link){
                if ((x ofclass K2_thing) && ((Adj_97_t1_v10(x)))){
                    counter++;
                    jump NextOuterLoop_5;
                }
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK2_First: x: x=x.IK2_Link){
                if ((x ofclass K2_thing) && ((Adj_97_t1_v10(x)))){
                    return x;
                }
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K2_thing) && (x ofclass K2_thing) && ((Adj_97_t1_v10(x)))){
                rtrue;
            }
            rfalse;
    }
];
! True or false?
! [ Exists x : thing(x) & 'lit'(x) & can-see('light-meter', x) ]
[ Prop_103 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_82_t1_v10(x))) && (TestVisibility(I208_light_meter,x))){
            rtrue;
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : light source(x) & 'fluorescent'(x) & called='f'(light source)(x) & is(const_0, ContainerOf(x)) ]
[ Prop_104 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=TestContainmentRange(const_0): x: x=TestContainmentRange(const_0,x)){
        if ((x ofclass K27_light_source) && ((Adj_148_t1_v10(x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : person(x) & talking(const_0, x) ]
[ Prop_105 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=IK8_First: x: x=x.IK8_Link){
        if (((RGuard_T_4(const_0,x)))){
            rtrue;
        }
    }
    rfalse;
];
! Find a random x satisfying:
! [ person(x) & talking(x, const_0) ]
[ Prop_106 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    selection ! internal use only
    ;
    ;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK8_First: x: x=x.IK8_Link){
            if (((RGuard_T_4(x,const_0)))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];
! Force this to be true via 'now':
! [ DoesNotExist x IN[ person(x) IN] : talking(const_0, x) ]
[ Prop_107 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK8_First: x: x=x.IK8_Link){
        qcn_0++;
        (RGuard_MF_4(const_0,x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Force this to be true via 'now':
! [ DoesNotExist x IN[ phone(x) IN] : is((RGuard_f1_5(const_0)), x) ]
[ Prop_108 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK20_First: x: x=x.IK20_Link){
        qcn_0++;
        (RGuard_MF_5(const_0,x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Force this to be true via 'now':
! [ DoesNotExist x IN[ phone(x) IN] : is((RGuard_f1_3(const_0)), x) ]
[ Prop_109 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK20_First: x: x=x.IK20_Link){
        qcn_0++;
        (RGuard_MF_3(const_0,x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Force this to be true via 'now':
! [ DoesNotExist x IN[ person(x) IN] : talking(const_0, x) ]
[ Prop_110 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK8_First: x: x=x.IK8_Link){
        qcn_0++;
        (RGuard_MF_4(const_0,x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Force this to be true via 'now':
! [ DoesNotExist x IN[ phone(x) IN] : is((RGuard_f1_5(const_0)), x) ]
[ Prop_111 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK20_First: x: x=x.IK20_Link){
        qcn_0++;
        (RGuard_MF_5(const_0,x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Force this to be true via 'now':
! [ DoesNotExist x IN[ phone(x) IN] : is((RGuard_f1_3(const_0)), x) ]
[ Prop_112 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK20_First: x: x=x.IK20_Link){
        qcn_0++;
        (RGuard_MF_3(const_0,x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Find next x satisfying:
! [ direction(x) ]
[ Prop_113 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK3_First: x: x=x.IK3_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ direction(x) ]
[ Prop_114 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK3_First: x: x=x.IK3_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! Construct a list of x satisfying:
! [ choice(x) & 'available'(x) ]
[ Prop_115 
    list ! Implied call parameter
    strong_kind ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    total ! internal use only
    ;
    ;
    BlkValueWrite(list, LIST_ITEM_KOV_F, strong_kind);
    total = LIST_OF_TY_GetLength(list);
    for (x=nothing: false: ){
        if (((Adj_46_t1_v10(x)))){
            counter++;
            if (counter > total) { total = 3*(total/2)+8; LIST_OF_TY_SetLength(list, total); }
            BlkValueWrite(list, counter+LIST_ITEM_BASE-1, x);
            jump NextOuterLoop_8;
        }
        .NextOuterLoop_8;
    }
    LIST_OF_TY_SetLength(list, counter);
    return list;
];
! Find next x satisfying:
! [ thing(x) & is('the location', ContainerOf(x)) ]
[ Prop_116 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=TestContainmentRange(real_location): x: x=TestContainmentRange(real_location,x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Construct a list of x satisfying:
! [ choice(x) & is((RGuard_f1_9(x)), const_0) ]
[ Prop_117 
    const_0 ! Implied call parameter
    list ! Implied call parameter
    strong_kind ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    counter ! internal use only
    total ! internal use only
    ;
    ;
    BlkValueWrite(list, LIST_ITEM_KOV_F, strong_kind);
    total = LIST_OF_TY_GetLength(list);
    for (x=nothing: false: ){
        if (((RGuard_f1_9(x)) == const_0)){
            counter++;
            if (counter > total) { total = 3*(total/2)+8; LIST_OF_TY_SetLength(list, total); }
            BlkValueWrite(list, counter+LIST_ITEM_BASE-1, x);
            jump NextOuterLoop_8;
        }
        .NextOuterLoop_8;
    }
    LIST_OF_TY_SetLength(list, counter);
    return list;
];
! Abstraction for set of x such that:
! [ choice(x) & choice(x) & 'unexhausted'(x) ]
[ Prop_118 
    reason ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    total ! internal use only
    counter ! internal use only
    selection ! internal use only
    best ! internal use only
    best_with ! internal use only
    ;
    ;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=nothing: false: ){
                if ((x ofclass K26_choice) && ((Adj_61_t1_v10(x)))){
                    if (property_loop_sign>0) {
                        if (x.property_to_be_totalled >= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    } else {
                        if (x.property_to_be_totalled <= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=nothing: false: ){
                if ((x ofclass K26_choice) && ((Adj_61_t1_v10(x)))){
                    total = total + x.property_to_be_totalled;
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=nothing: false: ){
                    if ((x ofclass K26_choice) && ((Adj_61_t1_v10(x)))){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=nothing: false: ){
                if ((x ofclass K26_choice) && ((Adj_61_t1_v10(x)))){
                    counter++;
                    jump NextOuterLoop_5;
                }
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=nothing: false: ){
                if ((x ofclass K26_choice) && ((Adj_61_t1_v10(x)))){
                    return x;
                }
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K26_choice) && (x ofclass K26_choice) && ((Adj_61_t1_v10(x)))){
                rtrue;
            }
            rfalse;
    }
];
! Force this to be true via 'now':
! [ ForAll x IN[ thing(x) IN] : 'unmarked for special listing'(x) ]
[ Prop_119 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK2_First: x: x=x.IK2_Link){
        qcn_0++;
        (Adj_146_t2_v10(x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Force this to be true via 'now':
! [ ForAll x IN[ direction(x) IN] : 'unmarked for special listing'(x) ]
[ Prop_120 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK3_First: x: x=x.IK3_Link){
        qcn_0++;
        (Adj_146_t2_v10(x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Force this to be true via 'now':
! [ ForAll x IN[ room(x) IN] : 'unmarked for special listing'(x) ]
[ Prop_121 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK1_First: x: x=x.IK1_Link){
        qcn_0++;
        (Adj_146_t2_v10(x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Force this to be true via 'now':
! [ ForAll x IN[ region(x) IN] : 'unmarked for special listing'(x) ]
[ Prop_122 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK9_First: x: x=x.IK9_Link){
        qcn_0++;
        (Adj_146_t2_v10(x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Find next x satisfying:
! [ direction(x) & 'hyperspatial'(x) ]
[ Prop_123 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK3_First: x: x=x.IK3_Link){
        if (((Adj_159_t1_v10(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ person(x) & can-see(x, 'the person asked') ]
[ Prop_124 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK8_First: x: x=x.IK8_Link){
        if ((TestVisibility(x,actor))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Force this to be true via 'now':
! [ ForAll x IN[ thing(x) IN] : 'unmarked for special listing'(x) ]
[ Prop_125 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK2_First: x: x=x.IK2_Link){
        qcn_0++;
        (Adj_146_t2_v10(x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Force this to be true via 'now':
! [ ForAll x IN[ direction(x) IN] : 'unmarked for special listing'(x) ]
[ Prop_126 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK3_First: x: x=x.IK3_Link){
        qcn_0++;
        (Adj_146_t2_v10(x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Force this to be true via 'now':
! [ ForAll x IN[ room(x) IN] : 'unmarked for special listing'(x) ]
[ Prop_127 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK1_First: x: x=x.IK1_Link){
        qcn_0++;
        (Adj_146_t2_v10(x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Force this to be true via 'now':
! [ ForAll x IN[ region(x) IN] : 'unmarked for special listing'(x) ]
[ Prop_128 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK9_First: x: x=x.IK9_Link){
        qcn_0++;
        (Adj_146_t2_v10(x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Find next x satisfying:
! [ direction(x) & 'marked for special listing'(x) ]
[ Prop_129 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK3_First: x: x=x.IK3_Link){
        if (((Adj_145_t1_v10(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ room(x) & 'marked for special listing'(x) ]
[ Prop_130 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK1_First: x: x=x.IK1_Link){
        if (((Adj_145_t1_v10(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ thing(x) & 'marked for special listing'(x) ]
[ Prop_131 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_145_t1_v10(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ direction(x) ]
[ Prop_132 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK3_First: x: x=x.IK3_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ direction(x) ]
[ Prop_133 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK3_First: x: x=x.IK3_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];
! Force this to be true via 'now':
! [ ForAll x IN[ thing(x) IN] : 'unmarked for special listing'(x) ]
[ Prop_134 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK2_First: x: x=x.IK2_Link){
        qcn_0++;
        (Adj_146_t2_v10(x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Force this to be true via 'now':
! [ ForAll x IN[ direction(x) IN] : 'unmarked for special listing'(x) ]
[ Prop_135 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK3_First: x: x=x.IK3_Link){
        qcn_0++;
        (Adj_146_t2_v10(x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Force this to be true via 'now':
! [ ForAll x IN[ room(x) IN] : 'unmarked for special listing'(x) ]
[ Prop_136 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK1_First: x: x=x.IK1_Link){
        qcn_0++;
        (Adj_146_t2_v10(x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Force this to be true via 'now':
! [ ForAll x IN[ region(x) IN] : 'unmarked for special listing'(x) ]
[ Prop_137 
    x ! internal use only
    x_ix ! internal use only
    qcy_0 ! internal use only
    qcn_0 ! internal use only
    ;
    ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK9_First: x: x=x.IK9_Link){
        qcn_0++;
        (Adj_146_t2_v10(x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];
! Find next x satisfying:
! [ light source(x) & is(const_0, ContainerOf(x)) ]
[ Prop_138 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=TestContainmentRange(const_0): x: x=TestContainmentRange(const_0,x)){
        if ((x ofclass K27_light_source)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! Find next x satisfying:
! [ light source(x) & is(const_0, ContainerOf(x)) ]
[ Prop_139 
    const_0 ! Implied call parameter
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=TestContainmentRange(const_0): x: x=TestContainmentRange(const_0,x)){
        if ((x ofclass K27_light_source)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];
! True or false?
! [ Exists x : thing(x) & is('biff's desk's drawer', ContainerOf(x)) ]
[ Prop_140 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=TestContainmentRange(I431_biff_s_desk_s_drawer): x: x=TestContainmentRange(I431_biff_s_desk_s_drawer,x)){
        if ((x ofclass K2_thing)){
            rtrue;
        }
    }
    rfalse;
];
! True or false?
! [ Exists x : thing(x) & is('biff's desk's drawer', ContainerOf(x)) ]
[ Prop_141 
    x ! internal use only
    x_ix ! internal use only
    ;
    ;
    for (x=TestContainmentRange(I431_biff_s_desk_s_drawer): x: x=TestContainmentRange(I431_biff_s_desk_s_drawer,x)){
        if ((x ofclass K2_thing)){
            rtrue;
        }
    }
    rfalse;
];

Constant R_11_RESP_A = 1;
Constant R_37_RESP_A = 2;
Constant R_38_RESP_A = 3;
Constant R_39_RESP_A = 4;
Constant R_39_RESP_B = 5;
Constant R_40_RESP_A = 6;
Constant R_44_RESP_A = 7;
Constant R_44_RESP_B = 8;
Constant R_44_RESP_C = 9;
Constant R_44_RESP_D = 10;
Constant R_44_RESP_E = 11;
Constant R_44_RESP_F = 12;
Constant R_51_RESP_A = 13;
Constant R_53_RESP_A = 14;
Constant R_54_RESP_A = 15;
Constant R_55_RESP_A = 16;
Constant R_56_RESP_A = 17;
Constant R_57_RESP_A = 18;
Constant R_58_RESP_A = 19;
Constant R_59_RESP_A = 20;
Constant R_60_RESP_A = 21;
Constant R_61_RESP_A = 22;
Constant R_62_RESP_A = 23;
Constant R_63_RESP_A = 24;
Constant R_64_RESP_A = 25;
Constant R_65_RESP_A = 26;
Constant R_66_RESP_A = 27;
Constant R_67_RESP_A = 28;
Constant R_68_RESP_A = 29;
Constant R_69_RESP_A = 30;
Constant R_71_RESP_A = 31;
Constant R_71_RESP_B = 32;
Constant R_72_RESP_A = 33;
Constant R_73_RESP_A = 34;
Constant R_75_RESP_A = 35;
Constant R_76_RESP_A = 36;
Constant R_77_RESP_A = 37;
Constant R_78_RESP_A = 38;
Constant R_79_RESP_A = 39;
Constant R_80_RESP_A = 40;
Constant R_80_RESP_B = 41;
Constant R_82_RESP_A = 42;
Constant R_82_RESP_B = 43;
Constant R_85_RESP_A = 44;
Constant R_86_RESP_A = 45;
Constant R_87_RESP_A = 46;
Constant R_88_RESP_A = 47;
Constant R_90_RESP_A = 48;
Constant R_91_RESP_A = 49;
Constant R_94_RESP_A = 50;
Constant R_95_RESP_A = 51;
Constant R_96_RESP_A = 52;
Constant R_97_RESP_A = 53;
Constant R_98_RESP_A = 54;
Constant R_100_RESP_A = 55;
Constant R_101_RESP_A = 56;
Constant R_102_RESP_A = 57;
Constant R_103_RESP_A = 58;
Constant R_104_RESP_A = 59;
Constant R_107_RESP_A = 60;
Constant R_107_RESP_B = 61;
Constant R_109_RESP_A = 62;
Constant R_110_RESP_A = 63;
Constant R_110_RESP_B = 64;
Constant R_111_RESP_A = 65;
Constant R_112_RESP_A = 66;
Constant R_114_RESP_A = 67;
Constant R_114_RESP_B = 68;
Constant R_118_RESP_A = 69;
Constant R_118_RESP_B = 70;
Constant R_118_RESP_C = 71;
Constant R_118_RESP_D = 72;
Constant R_118_RESP_E = 73;
Constant R_118_RESP_F = 74;
Constant R_118_RESP_G = 75;
Constant R_118_RESP_H = 76;
Constant R_118_RESP_I = 77;
Constant R_118_RESP_J = 78;
Constant R_118_RESP_K = 79;
Constant R_118_RESP_L = 80;
Constant R_118_RESP_M = 81;
Constant R_118_RESP_N = 82;
Constant R_118_RESP_O = 83;
Constant R_118_RESP_P = 84;
Constant R_118_RESP_Q = 85;
Constant R_118_RESP_R = 86;
Constant R_118_RESP_S = 87;
Constant R_122_RESP_A = 88;
Constant R_122_RESP_B = 89;
Constant R_123_RESP_A = 90;
Constant R_123_RESP_B = 91;
Constant R_123_RESP_C = 92;
Constant R_123_RESP_D = 93;
Constant R_124_RESP_A = 94;
Constant R_125_RESP_A = 95;
Constant R_125_RESP_B = 96;
Constant R_126_RESP_A = 97;
Constant R_127_RESP_A = 98;
Constant R_127_RESP_B = 99;
Constant R_127_RESP_C = 100;
Constant R_127_RESP_D = 101;
Constant R_127_RESP_E = 102;
Constant R_129_RESP_A = 103;
Constant R_129_RESP_B = 104;
Constant R_129_RESP_C = 105;
Constant R_129_RESP_D = 106;
Constant R_132_RESP_A = 107;
Constant R_133_RESP_A = 108;
Constant R_136_RESP_A = 109;
Constant R_136_RESP_B = 110;
Constant R_136_RESP_C = 111;
Constant R_138_RESP_A = 112;
Constant R_140_RESP_A = 113;
Constant R_144_RESP_A = 114;
Constant R_144_RESP_B = 115;
Constant R_144_RESP_C = 116;
Constant R_145_RESP_A = 117;
Constant R_148_RESP_A = 118;
Constant R_150_RESP_A = 119;
Constant R_151_RESP_A = 120;
Constant R_151_RESP_B = 121;
Constant R_152_RESP_A = 122;
Constant R_153_RESP_A = 123;
Constant R_154_RESP_A = 124;
Constant R_155_RESP_A = 125;
Constant R_156_RESP_A = 126;
Constant R_157_RESP_A = 127;
Constant R_158_RESP_A = 128;
Constant R_159_RESP_A = 129;
Constant R_160_RESP_A = 130;
Constant R_160_RESP_B = 131;
Constant R_161_RESP_A = 132;
Constant R_161_RESP_B = 133;
Constant R_162_RESP_A = 134;
Constant R_163_RESP_A = 135;
Constant R_163_RESP_B = 136;
Constant R_164_RESP_A = 137;
Constant R_165_RESP_A = 138;
Constant R_166_RESP_A = 139;
Constant R_167_RESP_A = 140;
Constant R_169_RESP_A = 141;
Constant R_169_RESP_B = 142;
Constant R_170_RESP_A = 143;
Constant R_171_RESP_A = 144;
Constant R_172_RESP_A = 145;
Constant R_174_RESP_A = 146;
Constant R_174_RESP_B = 147;
Constant R_175_RESP_A = 148;
Constant R_176_RESP_A = 149;
Constant R_178_RESP_A = 150;
Constant R_179_RESP_A = 151;
Constant R_180_RESP_A = 152;
Constant R_182_RESP_A = 153;
Constant R_183_RESP_A = 154;
Constant R_184_RESP_A = 155;
Constant R_185_RESP_A = 156;
Constant R_187_RESP_A = 157;
Constant R_188_RESP_A = 158;
Constant R_188_RESP_B = 159;
Constant R_188_RESP_C = 160;
Constant R_189_RESP_A = 161;
Constant R_190_RESP_A = 162;
Constant R_192_RESP_A = 163;
Constant R_192_RESP_B = 164;
Constant R_192_RESP_C = 165;
Constant R_193_RESP_A = 166;
Constant R_194_RESP_A = 167;
Constant R_195_RESP_A = 168;
Constant R_197_RESP_A = 169;
Constant R_197_RESP_B = 170;
Constant R_198_RESP_A = 171;
Constant R_199_RESP_A = 172;
Constant R_201_RESP_A = 173;
Constant R_201_RESP_B = 174;
Constant R_202_RESP_A = 175;
Constant R_203_RESP_A = 176;
Constant R_204_RESP_A = 177;
Constant R_205_RESP_A = 178;
Constant R_206_RESP_A = 179;
Constant R_207_RESP_A = 180;
Constant R_209_RESP_A = 181;
Constant R_209_RESP_B = 182;
Constant R_209_RESP_C = 183;
Constant R_210_RESP_A = 184;
Constant R_212_RESP_A = 185;
Constant R_213_RESP_A = 186;
Constant R_214_RESP_A = 187;
Constant R_215_RESP_A = 188;
Constant R_216_RESP_A = 189;
Constant R_217_RESP_A = 190;
Constant R_218_RESP_A = 191;
Constant R_219_RESP_A = 192;
Constant R_220_RESP_A = 193;
Constant R_221_RESP_A = 194;
Constant R_222_RESP_A = 195;
Constant R_223_RESP_A = 196;
Constant R_226_RESP_A = 197;
Constant R_226_RESP_B = 198;
Constant R_227_RESP_A = 199;
Constant R_227_RESP_B = 200;
Constant R_228_RESP_A = 201;
Constant R_228_RESP_B = 202;
Constant R_228_RESP_C = 203;
Constant R_229_RESP_A = 204;
Constant R_229_RESP_B = 205;
Constant R_230_RESP_A = 206;
Constant R_231_RESP_A = 207;
Constant R_231_RESP_B = 208;
Constant R_232_RESP_A = 209;
Constant R_233_RESP_A = 210;
Constant R_234_RESP_A = 211;
Constant R_235_RESP_A = 212;
Constant R_235_RESP_B = 213;
Constant R_236_RESP_A = 214;
Constant R_237_RESP_A = 215;
Constant R_238_RESP_A = 216;
Constant R_239_RESP_A = 217;
Constant R_239_RESP_B = 218;
Constant R_240_RESP_A = 219;
Constant R_241_RESP_A = 220;
Constant R_242_RESP_A = 221;
Constant R_243_RESP_A = 222;
Constant R_243_RESP_B = 223;
Constant R_244_RESP_A = 224;
Constant R_245_RESP_A = 225;
Constant R_246_RESP_A = 226;
Constant R_247_RESP_A = 227;
Constant R_249_RESP_A = 228;
Constant R_250_RESP_A = 229;
Constant R_251_RESP_A = 230;
Constant R_251_RESP_B = 231;
Constant R_252_RESP_A = 232;
Constant R_253_RESP_A = 233;
Constant R_254_RESP_A = 234;
Constant R_255_RESP_A = 235;
Constant R_256_RESP_A = 236;
Constant R_257_RESP_A = 237;
Constant R_257_RESP_B = 238;
Constant R_258_RESP_A = 239;
Constant R_263_RESP_A = 240;
Constant R_264_RESP_A = 241;
Constant R_265_RESP_A = 242;
Constant R_268_RESP_A = 243;
Constant R_268_RESP_B = 244;
Constant R_268_RESP_C = 245;
Constant R_268_RESP_D = 246;
Constant R_269_RESP_A = 247;
Constant R_274_RESP_A = 248;
Constant R_274_RESP_B = 249;
Constant R_275_RESP_A = 250;
Constant R_278_RESP_A = 251;
Constant R_280_RESP_A = 252;
Constant R_280_RESP_B = 253;
Constant R_283_RESP_A = 254;
Constant R_285_RESP_A = 255;
Constant R_303_RESP_A = 256;
Constant R_320_RESP_A = 257;
Constant R_330_RESP_A = 258;
Constant R_330_RESP_B = 259;
Constant R_330_RESP_C = 260;
Constant R_331_RESP_A = 261;
Constant R_331_RESP_B = 262;
Constant R_332_RESP_A = 263;
Constant R_332_RESP_B = 264;
Constant R_335_RESP_A = 265;
Constant R_335_RESP_B = 266;
Constant R_335_RESP_C = 267;
Constant R_336_RESP_A = 268;
Constant R_336_RESP_B = 269;
Constant R_336_RESP_C = 270;
Constant R_339_RESP_A = 271;
Constant R_339_RESP_B = 272;
Constant R_340_RESP_A = 273;
Constant R_341_RESP_A = 274;
Constant R_341_RESP_B = 275;
Constant R_342_RESP_A = 276;
Constant R_343_RESP_B = 277;
Constant R_344_RESP_A = 278;
Constant R_345_RESP_A = 279;
Constant R_346_RESP_A = 280;
Constant R_347_RESP_A = 281;
Constant R_348_RESP_A = 282;
Constant R_349_RESP_A = 283;
Constant R_349_RESP_B = 284;
Constant R_350_RESP_A = 285;
Constant R_351_RESP_A = 286;
Constant R_351_RESP_B = 287;
Constant R_351_RESP_C = 288;
Constant R_353_RESP_B = 289;
Constant R_354_RESP_A = 290;
Constant R_355_RESP_A = 291;
Constant R_356_RESP_A = 292;
Constant R_358_RESP_A = 293;
Constant R_358_RESP_B = 294;
Constant R_358_RESP_C = 295;
Constant R_359_RESP_A = 296;
Constant R_360_RESP_A = 297;
Constant R_360_RESP_B = 298;
Constant R_360_RESP_C = 299;
Constant R_360_RESP_D = 300;
Constant R_362_RESP_A = 301;
Constant R_362_RESP_B = 302;
Constant R_363_RESP_A = 303;
Constant R_364_RESP_A = 304;
Constant R_365_RESP_A = 305;
Constant R_366_RESP_A = 306;
Constant R_367_RESP_A = 307;
Constant R_369_RESP_A = 308;
Constant R_369_RESP_B = 309;
Constant R_369_RESP_C = 310;
Constant R_369_RESP_D = 311;
Constant R_369_RESP_E = 312;
Constant R_370_RESP_A = 313;
Constant R_371_RESP_A = 314;
Constant R_372_RESP_A = 315;
Constant R_373_RESP_A = 316;
Constant R_373_RESP_B = 317;
Constant R_373_RESP_C = 318;
Constant R_379_RESP_A = 319;
Constant R_381_RESP_A = 320;
Constant R_383_RESP_A = 321;
Constant R_431_RESP_A = 322;
Constant R_432_RESP_A = 323;
Constant R_434_RESP_A = 324;
Constant R_435_RESP_A = 325;
Constant R_441_RESP_A = 326;
Constant R_442_RESP_A = 327;
Constant R_443_RESP_A = 328;
Constant R_447_RESP_A = 329;
Constant R_460_RESP_A = 330;
Constant R_462_RESP_A = 331;
Constant R_462_RESP_B = 332;
Constant R_469_RESP_A = 333;
Constant R_470_RESP_A = 334;
Constant R_472_RESP_A = 335;
Constant R_473_RESP_A = 336;
Constant R_476_RESP_A = 337;
Constant R_477_RESP_A = 338;
Constant R_478_RESP_A = 339;
Constant R_479_RESP_A = 340;
Constant R_480_RESP_A = 341;
Constant R_480_RESP_B = 342;
Constant R_480_RESP_C = 343;
Constant R_480_RESP_D = 344;
Constant R_480_RESP_E = 345;
Constant R_480_RESP_F = 346;
Constant R_480_RESP_G = 347;
Constant R_480_RESP_H = 348;
Constant R_480_RESP_I = 349;
Constant R_480_RESP_J = 350;
Constant R_480_RESP_K = 351;
Constant R_480_RESP_L = 352;
Constant R_480_RESP_M = 353;
Constant R_480_RESP_N = 354;
Constant R_480_RESP_O = 355;
Constant R_480_RESP_P = 356;
Constant R_480_RESP_Q = 357;
Constant R_480_RESP_R = 358;
Constant R_480_RESP_S = 359;
Constant R_480_RESP_T = 360;
Constant R_480_RESP_U = 361;
Constant R_480_RESP_V = 362;
Constant R_480_RESP_W = 363;
Constant R_480_RESP_X = 364;
Constant R_480_RESP_Y = 365;
Constant R_481_RESP_A = 366;
Constant R_481_RESP_B = 367;
Constant R_481_RESP_C = 368;
Constant R_481_RESP_D = 369;
Constant R_481_RESP_E = 370;
Constant R_481_RESP_F = 371;
Constant R_481_RESP_G = 372;
Constant R_481_RESP_H = 373;
Constant R_481_RESP_I = 374;
Constant R_481_RESP_J = 375;
Constant R_481_RESP_K = 376;
Constant R_482_RESP_A = 377;
Constant R_482_RESP_B = 378;
Constant R_482_RESP_C = 379;
Constant R_482_RESP_D = 380;
Constant R_482_RESP_E = 381;
Constant R_482_RESP_F = 382;
Constant R_482_RESP_G = 383;
Constant R_482_RESP_H = 384;
Constant R_482_RESP_I = 385;
Constant R_482_RESP_J = 386;
Constant R_482_RESP_K = 387;
Constant R_482_RESP_L = 388;
Constant R_482_RESP_M = 389;
Constant R_482_RESP_N = 390;
Constant R_482_RESP_O = 391;
Constant R_482_RESP_P = 392;
Constant R_482_RESP_Q = 393;
Constant R_482_RESP_R = 394;
Constant R_482_RESP_S = 395;
Constant R_482_RESP_T = 396;
Constant R_482_RESP_U = 397;
Constant R_482_RESP_V = 398;
Constant R_482_RESP_W = 399;
Constant R_482_RESP_X = 400;
Constant R_483_RESP_A = 401;
Constant R_483_RESP_B = 402;
Constant R_483_RESP_C = 403;
Constant R_483_RESP_D = 404;
Constant R_483_RESP_E = 405;
Constant R_483_RESP_F = 406;
Constant R_484_RESP_A = 407;
Constant R_485_RESP_A = 408;
Constant R_485_RESP_B = 409;
Constant R_485_RESP_C = 410;
Constant R_485_RESP_D = 411;
Constant R_486_RESP_A = 412;
Constant R_486_RESP_B = 413;
Constant R_486_RESP_C = 414;
Constant R_486_RESP_D = 415;
Constant R_486_RESP_E = 416;
Constant R_486_RESP_F = 417;
Constant R_486_RESP_G = 418;
Constant R_486_RESP_H = 419;
Constant R_487_RESP_A = 420;
Constant R_488_RESP_A = 421;
Constant R_488_RESP_B = 422;
Constant R_488_RESP_C = 423;
Constant R_491_RESP_A = 424;
Constant R_491_RESP_B = 425;
Constant R_493_RESP_A = 426;
Constant R_493_RESP_B = 427;
Constant R_493_RESP_C = 428;
Constant R_499_RESP_A = 429;
Constant R_499_RESP_B = 430;
Constant R_499_RESP_C = 431;
Constant R_499_RESP_D = 432;
Constant R_499_RESP_E = 433;
Constant R_499_RESP_F = 434;
Constant R_502_RESP_A = 435;
Constant R_503_RESP_A = 436;
Constant R_503_RESP_B = 437;
Constant R_504_RESP_A = 438;
Constant R_504_RESP_B = 439;
Constant R_505_RESP_A = 440;
Constant R_505_RESP_B = 441;
Constant R_506_RESP_A = 442;
Constant R_506_RESP_B = 443;
Constant R_507_RESP_A = 444;
Constant R_507_RESP_B = 445;
Constant R_507_RESP_C = 446;
Constant R_508_RESP_A = 447;
Constant R_508_RESP_B = 448;
Constant R_508_RESP_C = 449;
Constant R_510_RESP_A = 450;
Constant R_510_RESP_B = 451;
Constant R_510_RESP_C = 452;
Constant R_510_RESP_D = 453;
Constant R_510_RESP_E = 454;
Constant R_512_RESP_A = 455;
Constant R_514_RESP_A = 456;
Constant R_516_RESP_A = 457;
Constant R_518_RESP_A = 458;
Constant R_520_RESP_A = 459;
Constant R_521_RESP_A = 460;
Constant R_521_RESP_B = 461;
Constant R_521_RESP_C = 462;
Constant R_521_RESP_D = 463;
Constant NO_RESPONSES = 463;
Array ResponseTexts -->
    TX_S_235 TX_S_248 TX_S_251 TX_S_249 TX_S_250 TX_S_252 TX_S_556 TX_S_557 TX_S_558 TX_S_559 TX_S_560 TX_S_561 TX_S_256 TX_S_257 TX_S_258 TX_S_259 TX_S_260 TX_S_261 TX_S_265 TX_S_266 TX_S_267 TX_S_268 TX_S_269 TX_S_270 TX_S_271 TX_S_588 TX_S_273 TX_S_589 TX_S_275 TX_S_276 TX_S_277 TX_S_278 TX_S_279 TX_S_280 TX_S_282 TX_S_281 TX_S_590 TX_S_284 TX_S_285 TX_S_286 TX_S_287 TX_S_288 TX_S_289 TX_S_290 TX_S_291 TX_S_292 TX_S_293 TX_S_294 TX_S_295 TX_S_296 TX_S_297 TX_S_298 TX_S_299 TX_S_300 TX_S_301 TX_S_302 TX_S_303 TX_S_304 TX_S_305 TX_S_306 TX_S_307 TX_S_308 TX_S_309 TX_S_310 TX_S_311 TX_S_312 TX_S_313 TX_S_314 TX_S_315 TX_S_316 TX_S_317 TX_S_318 TX_S_319 TX_S_320 TX_S_321 TX_S_322 TX_S_323 TX_S_324 TX_S_325 TX_S_326 TX_S_327 TX_S_328 TX_S_329 TX_S_330 TX_S_331 TX_S_332 TX_S_333 TX_S_334 TX_S_335 TX_S_336 TX_S_337 TX_S_338 TX_S_339 TX_S_340 TX_S_341 TX_S_342 TX_S_343 TX_S_344 TX_S_345 TX_S_346 TX_S_347 TX_S_348 TX_S_349 TX_S_350 TX_S_351 TX_S_352 TX_S_353 TX_S_354 TX_S_356 TX_S_357 TX_S_358 TX_S_359 TX_S_360 TX_S_562 TX_S_563 TX_S_564 TX_S_364 TX_S_366 TX_S_367 TX_S_368 TX_S_369 TX_S_370 TX_S_371 TX_S_591 TX_S_373 TX_S_374 TX_S_375 TX_S_376 TX_S_377 TX_S_378 TX_S_379 TX_S_380 TX_S_381 TX_S_382 TX_S_383 TX_S_384 TX_S_387 TX_S_388 TX_S_389 TX_S_390 TX_S_391 TX_S_392 TX_S_394 TX_S_395 TX_S_396 TX_S_397 TX_S_398 TX_S_592 TX_S_400 TX_S_401 TX_S_402 TX_S_403 TX_S_404 TX_S_407 TX_S_408 TX_S_409 TX_S_410 TX_S_411 TX_S_412 TX_S_413 TX_S_415 TX_S_416 TX_S_417 TX_S_418 TX_S_419 TX_S_420 TX_S_421 TX_S_422 TX_S_423 TX_S_424 TX_S_425 TX_S_426 TX_S_427 TX_S_428 TX_S_429 TX_S_430 TX_S_431 TX_S_432 TX_S_565 TX_S_433 TX_S_566 TX_S_567 TX_S_568 TX_S_434 TX_S_569 TX_S_435 TX_S_436 TX_S_437 TX_S_438 TX_S_444 TX_S_445 TX_S_446 TX_S_570 TX_S_447 TX_S_571 TX_S_572 TX_S_593 TX_S_449 TX_S_450 TX_S_451 TX_S_452 TX_S_453 TX_S_454 TX_S_455 TX_S_456 TX_S_457 TX_S_458 TX_S_459 TX_S_594 TX_S_595 TX_S_462 TX_S_463 TX_S_464 TX_S_596 TX_S_597 TX_S_467 TX_S_468 TX_S_469 TX_S_470 TX_S_471 TX_S_472 TX_S_473 TX_S_474 TX_S_475 TX_S_476 TX_S_477 TX_S_478 TX_S_479 TX_S_480 TX_S_481 TX_S_482 TX_S_573 TX_S_574 TX_S_488 TX_S_575 TX_S_493 TX_S_494 TX_S_495 TX_S_496 TX_S_497 TX_S_598 TX_S_599 TX_S_237 TX_S_238 TX_S_239 TX_S_240 TX_S_236 TX_S_600 TX_S_499 TX_S_601 TX_S_501 TX_S_502 TX_S_503 TX_S_505 TX_S_504 TX_S_602 TX_S_507 TX_S_514 TX_S_515 TX_S_516 TX_S_520 TX_S_521 TX_S_241 TX_S_242 TX_S_361 TX_S_362 TX_S_363 TX_S_253 TX_S_254 TX_S_255 TX_S_524 TX_S_525 TX_S_243 TX_S_526 TX_S_527 TX_S_244 TX_S_489 TX_S_441 TX_S_439 TX_S_485 TX_S_483 TX_S_262 TX_S_528 TX_S_529 TX_S_245 TX_S_530 TX_S_531 TX_S_532 TX_S_490 TX_S_443 TX_S_487 TX_S_263 TX_S_533 TX_S_534 TX_S_535 TX_S_246 TX_S_536 TX_S_537 TX_S_538 TX_S_539 TX_S_491 TX_S_492 TX_S_442 TX_S_440 TX_S_486 TX_S_484 TX_S_264 TX_S_540 TX_S_541 TX_S_542 TX_S_543 TX_S_545 TX_S_355 TX_S_546 TX_S_547 TX_S_548 TX_S_549 TX_S_550 TX_S_552 TX_S_551 TX_S_553 TX_S_385 TX_S_386 TX_S_554 TX_S_555 TX_S_405 TX_S_406 TX_S_414 TX_S_393 TX_S_0 TX_S_1 TX_S_2 TX_S_3 TX_S_4 TX_S_5 TX_S_6 TX_S_603 TX_S_604 TX_S_9 TX_S_10 TX_S_11 TX_S_12 TX_S_13 TX_S_14 TX_S_15 TX_S_16 TX_S_17 TX_S_18 TX_S_19 TX_S_20 TX_S_21 TX_S_22 TX_S_23 TX_S_24 TX_S_25 TX_S_26 TX_S_27 TX_S_28 TX_S_29 TX_S_30 TX_S_31 TX_S_32 TX_S_33 TX_S_34 TX_S_35 TX_S_36 TX_S_37 TX_S_38 TX_S_39 TX_S_40 TX_S_41 TX_S_42 TX_S_43 TX_S_44 TX_S_45 TX_S_46 TX_S_47 TX_S_48 TX_S_49 TX_S_50 TX_S_605 TX_S_52 TX_S_53 TX_S_54 TX_S_55 TX_S_56 TX_S_57 TX_S_58 TX_S_59 TX_S_60 TX_S_61 TX_S_62 TX_S_63 TX_S_606 TX_S_65 TX_S_66 TX_S_67 TX_S_68 TX_S_69 TX_S_70 TX_S_71 TX_S_72 TX_S_73 TX_S_74 TX_S_75 TX_S_76 TX_S_77 TX_S_78 TX_S_79 TX_S_80 TX_S_81 TX_S_82 TX_S_83 TX_S_84 TX_S_85 TX_S_86 TX_S_87 TX_S_88 TX_S_89 TX_S_90 TX_S_91 TX_S_92 TX_S_93 TX_S_94 TX_S_95 TX_S_96 TX_S_97 TX_S_98 TX_S_99 TX_S_100 TX_S_101 TX_S_102 TX_S_103 TX_S_104 TX_S_105 TX_S_106 TX_S_107 TX_S_108 TX_S_109 TX_S_110 TX_S_111 TX_S_112 TX_S_113 TX_S_114 TX_S_115 TX_S_116 TX_S_117 TX_S_118 TX_S_119 TX_S_120 TX_S_121 TX_S_122 TX_S_123 TX_S_124 TX_S_125 TX_S_126 TX_S_127 TX_S_128 TX_S_129 TX_S_130 TX_S_131 TX_S_132 TX_S_133 0 0;
[ PrintResponse 
    R ! Implied call parameter
    ;
    if (R == R_460_RESP_A) print (RulePrintingRule) ADJUST_LIGHT_R, " response (A)";
    if (R == R_462_RESP_A) print (RulePrintingRule) GENERATE_ACTION_R, " response (A)";
    if (R == R_462_RESP_B) print (RulePrintingRule) GENERATE_ACTION_R, " response (B)";
    if (R == R_469_RESP_A) print (RulePrintingRule) BASIC_ACCESSIBILITY_R, " response (A)";
    if (R == R_470_RESP_A) print (RulePrintingRule) BASIC_VISIBILITY_R, " response (A)";
    if (R == R_472_RESP_A) print (RulePrintingRule) REQUESTED_ACTIONS_REQUIRE_R, " response (A)";
    if (R == R_473_RESP_A) print (RulePrintingRule) CARRY_OUT_REQUESTED_ACTIONS_R, " response (A)";
    if (R == R_476_RESP_A) print (RulePrintingRule) I6_Rule_Shell_476, " response (A)";
    if (R == R_477_RESP_A) print (RulePrintingRule) CANT_REACH_INSIDE_CLOSED_R, " response (A)";
    if (R == R_478_RESP_A) print (RulePrintingRule) CANT_REACH_INSIDE_ROOMS_R, " response (A)";
    if (R == R_479_RESP_A) print (RulePrintingRule) CANT_REACH_OUTSIDE_CLOSED_R, " response (A)";
    if (R == R_480_RESP_A) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (A)";
    if (R == R_480_RESP_B) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (B)";
    if (R == R_480_RESP_C) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (C)";
    if (R == R_480_RESP_D) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (D)";
    if (R == R_480_RESP_E) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (E)";
    if (R == R_480_RESP_F) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (F)";
    if (R == R_480_RESP_G) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (G)";
    if (R == R_480_RESP_H) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (H)";
    if (R == R_480_RESP_I) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (I)";
    if (R == R_480_RESP_J) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (J)";
    if (R == R_480_RESP_K) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (K)";
    if (R == R_480_RESP_L) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (L)";
    if (R == R_480_RESP_M) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (M)";
    if (R == R_480_RESP_N) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (N)";
    if (R == R_480_RESP_O) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (O)";
    if (R == R_480_RESP_P) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (P)";
    if (R == R_480_RESP_Q) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (Q)";
    if (R == R_480_RESP_R) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (R)";
    if (R == R_480_RESP_S) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (S)";
    if (R == R_480_RESP_T) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (T)";
    if (R == R_480_RESP_U) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (U)";
    if (R == R_480_RESP_V) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (V)";
    if (R == R_480_RESP_W) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (W)";
    if (R == R_480_RESP_X) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (X)";
    if (R == R_480_RESP_Y) print (RulePrintingRule) LIST_WRITER_INTERNAL_R, " response (Y)";
    if (R == R_481_RESP_A) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (A)";
    if (R == R_481_RESP_B) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (B)";
    if (R == R_481_RESP_C) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (C)";
    if (R == R_481_RESP_D) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (D)";
    if (R == R_481_RESP_E) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (E)";
    if (R == R_481_RESP_F) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (F)";
    if (R == R_481_RESP_G) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (G)";
    if (R == R_481_RESP_H) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (H)";
    if (R == R_481_RESP_I) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (I)";
    if (R == R_481_RESP_J) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (J)";
    if (R == R_481_RESP_K) print (RulePrintingRule) ACTION_PROCESSING_INTERNAL_R, " response (K)";
    if (R == R_482_RESP_A) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (A)";
    if (R == R_482_RESP_B) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (B)";
    if (R == R_482_RESP_C) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (C)";
    if (R == R_482_RESP_D) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (D)";
    if (R == R_482_RESP_E) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (E)";
    if (R == R_482_RESP_F) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (F)";
    if (R == R_482_RESP_G) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (G)";
    if (R == R_482_RESP_H) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (H)";
    if (R == R_482_RESP_I) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (I)";
    if (R == R_482_RESP_J) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (J)";
    if (R == R_482_RESP_K) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (K)";
    if (R == R_482_RESP_L) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (L)";
    if (R == R_482_RESP_M) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (M)";
    if (R == R_482_RESP_N) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (N)";
    if (R == R_482_RESP_O) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (O)";
    if (R == R_482_RESP_P) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (P)";
    if (R == R_482_RESP_Q) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (Q)";
    if (R == R_482_RESP_R) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (R)";
    if (R == R_482_RESP_S) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (S)";
    if (R == R_482_RESP_T) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (T)";
    if (R == R_482_RESP_U) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (U)";
    if (R == R_482_RESP_V) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (V)";
    if (R == R_482_RESP_W) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (W)";
    if (R == R_482_RESP_X) print (RulePrintingRule) PARSER_ERROR_INTERNAL_R, " response (X)";
    if (R == R_483_RESP_A) print (RulePrintingRule) PARSER_N_ERROR_INTERNAL_R, " response (A)";
    if (R == R_483_RESP_B) print (RulePrintingRule) PARSER_N_ERROR_INTERNAL_R, " response (B)";
    if (R == R_483_RESP_C) print (RulePrintingRule) PARSER_N_ERROR_INTERNAL_R, " response (C)";
    if (R == R_483_RESP_D) print (RulePrintingRule) PARSER_N_ERROR_INTERNAL_R, " response (D)";
    if (R == R_483_RESP_E) print (RulePrintingRule) PARSER_N_ERROR_INTERNAL_R, " response (E)";
    if (R == R_483_RESP_F) print (RulePrintingRule) PARSER_N_ERROR_INTERNAL_R, " response (F)";
    if (R == R_484_RESP_A) print (RulePrintingRule) DARKNESS_NAME_INTERNAL_R, " response (A)";
    if (R == R_485_RESP_A) print (RulePrintingRule) PARSER_COMMAND_INTERNAL_R, " response (A)";
    if (R == R_485_RESP_B) print (RulePrintingRule) PARSER_COMMAND_INTERNAL_R, " response (B)";
    if (R == R_485_RESP_C) print (RulePrintingRule) PARSER_COMMAND_INTERNAL_R, " response (C)";
    if (R == R_485_RESP_D) print (RulePrintingRule) PARSER_COMMAND_INTERNAL_R, " response (D)";
    if (R == R_486_RESP_A) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (A)";
    if (R == R_486_RESP_B) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (B)";
    if (R == R_486_RESP_C) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (C)";
    if (R == R_486_RESP_D) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (D)";
    if (R == R_486_RESP_E) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (E)";
    if (R == R_486_RESP_F) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (F)";
    if (R == R_486_RESP_G) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (G)";
    if (R == R_486_RESP_H) print (RulePrintingRule) PARSER_CLARIF_INTERNAL_R, " response (H)";
    if (R == R_487_RESP_A) print (RulePrintingRule) YES_OR_NO_QUESTION_INTERNAL_R, " response (A)";
    if (R == R_488_RESP_A) print (RulePrintingRule) PRINT_PROTAGONIST_INTERNAL_R, " response (A)";
    if (R == R_488_RESP_B) print (RulePrintingRule) PRINT_PROTAGONIST_INTERNAL_R, " response (B)";
    if (R == R_488_RESP_C) print (RulePrintingRule) PRINT_PROTAGONIST_INTERNAL_R, " response (C)";
    if (R == R_491_RESP_A) print (RulePrintingRule) STANDARD_IMPLICIT_TAKING_R, " response (A)";
    if (R == R_491_RESP_B) print (RulePrintingRule) STANDARD_IMPLICIT_TAKING_R, " response (B)";
    if (R == R_493_RESP_A) print (RulePrintingRule) PRINT_OBITUARY_HEADLINE_R, " response (A)";
    if (R == R_493_RESP_B) print (RulePrintingRule) PRINT_OBITUARY_HEADLINE_R, " response (B)";
    if (R == R_493_RESP_C) print (RulePrintingRule) PRINT_OBITUARY_HEADLINE_R, " response (C)";
    if (R == R_499_RESP_A) print (RulePrintingRule) IMMEDIATELY_UNDO_R, " response (A)";
    if (R == R_499_RESP_B) print (RulePrintingRule) IMMEDIATELY_UNDO_R, " response (B)";
    if (R == R_499_RESP_C) print (RulePrintingRule) IMMEDIATELY_UNDO_R, " response (C)";
    if (R == R_499_RESP_D) print (RulePrintingRule) IMMEDIATELY_UNDO_R, " response (D)";
    if (R == R_499_RESP_E) print (RulePrintingRule) IMMEDIATELY_UNDO_R, " response (E)";
    if (R == R_499_RESP_F) print (RulePrintingRule) IMMEDIATELY_UNDO_R, " response (F)";
    if (R == R_502_RESP_A) print (RulePrintingRule) QUIT_THE_GAME_R, " response (A)";
    if (R == R_503_RESP_A) print (RulePrintingRule) SAVE_THE_GAME_R, " response (A)";
    if (R == R_503_RESP_B) print (RulePrintingRule) SAVE_THE_GAME_R, " response (B)";
    if (R == R_504_RESP_A) print (RulePrintingRule) RESTORE_THE_GAME_R, " response (A)";
    if (R == R_504_RESP_B) print (RulePrintingRule) RESTORE_THE_GAME_R, " response (B)";
    if (R == R_505_RESP_A) print (RulePrintingRule) RESTART_THE_GAME_R, " response (A)";
    if (R == R_505_RESP_B) print (RulePrintingRule) RESTART_THE_GAME_R, " response (B)";
    if (R == R_506_RESP_A) print (RulePrintingRule) VERIFY_THE_STORY_FILE_R, " response (A)";
    if (R == R_506_RESP_B) print (RulePrintingRule) VERIFY_THE_STORY_FILE_R, " response (B)";
    if (R == R_507_RESP_A) print (RulePrintingRule) SWITCH_TRANSCRIPT_ON_R, " response (A)";
    if (R == R_507_RESP_B) print (RulePrintingRule) SWITCH_TRANSCRIPT_ON_R, " response (B)";
    if (R == R_507_RESP_C) print (RulePrintingRule) SWITCH_TRANSCRIPT_ON_R, " response (C)";
    if (R == R_508_RESP_A) print (RulePrintingRule) SWITCH_TRANSCRIPT_OFF_R, " response (A)";
    if (R == R_508_RESP_B) print (RulePrintingRule) SWITCH_TRANSCRIPT_OFF_R, " response (B)";
    if (R == R_508_RESP_C) print (RulePrintingRule) SWITCH_TRANSCRIPT_OFF_R, " response (C)";
    if (R == R_510_RESP_A) print (RulePrintingRule) ANNOUNCE_SCORE_R, " response (A)";
    if (R == R_510_RESP_B) print (RulePrintingRule) ANNOUNCE_SCORE_R, " response (B)";
    if (R == R_510_RESP_C) print (RulePrintingRule) ANNOUNCE_SCORE_R, " response (C)";
    if (R == R_510_RESP_D) print (RulePrintingRule) ANNOUNCE_SCORE_R, " response (D)";
    if (R == R_510_RESP_E) print (RulePrintingRule) ANNOUNCE_SCORE_R, " response (E)";
    if (R == R_512_RESP_A) print (RulePrintingRule) REP_PREFER_ABBREVIATED_R, " response (A)";
    if (R == R_514_RESP_A) print (RulePrintingRule) REP_PREFER_UNABBREVIATED_R, " response (A)";
    if (R == R_516_RESP_A) print (RulePrintingRule) REP_PREFER_SOMETIMES_ABBR_R, " response (A)";
    if (R == R_518_RESP_A) print (RulePrintingRule) REP_SWITCH_NOTIFY_ON_R, " response (A)";
    if (R == R_520_RESP_A) print (RulePrintingRule) REP_SWITCH_NOTIFY_OFF_R, " response (A)";
    if (R == R_521_RESP_A) print (RulePrintingRule) ANNOUNCE_PRONOUN_MEANINGS_R, " response (A)";
    if (R == R_521_RESP_B) print (RulePrintingRule) ANNOUNCE_PRONOUN_MEANINGS_R, " response (B)";
    if (R == R_521_RESP_C) print (RulePrintingRule) ANNOUNCE_PRONOUN_MEANINGS_R, " response (C)";
    if (R == R_521_RESP_D) print (RulePrintingRule) ANNOUNCE_PRONOUN_MEANINGS_R, " response (D)";
    if (R == R_11_RESP_A) print (RulePrintingRule) R_22, " response (A)";
    if (R == R_269_RESP_A) print (RulePrintingRule) R_808, " response (A)";
    if (R == R_268_RESP_A) print (RulePrintingRule) R_807, " response (A)";
    if (R == R_268_RESP_B) print (RulePrintingRule) R_807, " response (B)";
    if (R == R_268_RESP_C) print (RulePrintingRule) R_807, " response (C)";
    if (R == R_268_RESP_D) print (RulePrintingRule) R_807, " response (D)";
    if (R == R_332_RESP_A) print (RulePrintingRule) R_1017, " response (A)";
    if (R == R_332_RESP_B) print (RulePrintingRule) R_1017, " response (B)";
    if (R == R_340_RESP_A) print (RulePrintingRule) R_1064, " response (A)";
    if (R == R_342_RESP_A) print (RulePrintingRule) R_1067, " response (A)";
    if (R == R_350_RESP_A) print (RulePrintingRule) R_1078, " response (A)";
    if (R == R_359_RESP_A) print (RulePrintingRule) R_1093, " response (A)";
    if (R == R_37_RESP_A) print (RulePrintingRule) R_75, " response (A)";
    if (R == R_39_RESP_A) print (RulePrintingRule) R_77, " response (A)";
    if (R == R_39_RESP_B) print (RulePrintingRule) R_77, " response (B)";
    if (R == R_38_RESP_A) print (RulePrintingRule) R_76, " response (A)";
    if (R == R_40_RESP_A) print (RulePrintingRule) R_78, " response (A)";
    if (R == R_336_RESP_A) print (RulePrintingRule) R_1043, " response (A)";
    if (R == R_336_RESP_B) print (RulePrintingRule) R_1043, " response (B)";
    if (R == R_336_RESP_C) print (RulePrintingRule) R_1043, " response (C)";
    if (R == R_51_RESP_A) print (RulePrintingRule) R_91, " response (A)";
    if (R == R_53_RESP_A) print (RulePrintingRule) R_94, " response (A)";
    if (R == R_54_RESP_A) print (RulePrintingRule) R_95, " response (A)";
    if (R == R_55_RESP_A) print (RulePrintingRule) R_96, " response (A)";
    if (R == R_56_RESP_A) print (RulePrintingRule) R_97, " response (A)";
    if (R == R_57_RESP_A) print (RulePrintingRule) R_98, " response (A)";
    if (R == R_348_RESP_A) print (RulePrintingRule) R_1073, " response (A)";
    if (R == R_356_RESP_A) print (RulePrintingRule) R_1085, " response (A)";
    if (R == R_367_RESP_A) print (RulePrintingRule) R_1102, " response (A)";
    if (R == R_58_RESP_A) print (RulePrintingRule) R_99, " response (A)";
    if (R == R_59_RESP_A) print (RulePrintingRule) R_100, " response (A)";
    if (R == R_60_RESP_A) print (RulePrintingRule) R_101, " response (A)";
    if (R == R_61_RESP_A) print (RulePrintingRule) R_102, " response (A)";
    if (R == R_62_RESP_A) print (RulePrintingRule) R_103, " response (A)";
    if (R == R_63_RESP_A) print (RulePrintingRule) R_104, " response (A)";
    if (R == R_64_RESP_A) print (RulePrintingRule) R_105, " response (A)";
    if (R == R_65_RESP_A) print (RulePrintingRule) R_106, " response (A)";
    if (R == R_66_RESP_A) print (RulePrintingRule) R_107, " response (A)";
    if (R == R_67_RESP_A) print (RulePrintingRule) R_108, " response (A)";
    if (R == R_68_RESP_A) print (RulePrintingRule) R_109, " response (A)";
    if (R == R_69_RESP_A) print (RulePrintingRule) R_110, " response (A)";
    if (R == R_71_RESP_A) print (RulePrintingRule) R_112, " response (A)";
    if (R == R_71_RESP_B) print (RulePrintingRule) R_112, " response (B)";
    if (R == R_72_RESP_A) print (RulePrintingRule) R_113, " response (A)";
    if (R == R_73_RESP_A) print (RulePrintingRule) R_114, " response (A)";
    if (R == R_76_RESP_A) print (RulePrintingRule) R_117, " response (A)";
    if (R == R_75_RESP_A) print (RulePrintingRule) R_116, " response (A)";
    if (R == R_77_RESP_A) print (RulePrintingRule) R_118, " response (A)";
    if (R == R_78_RESP_A) print (RulePrintingRule) R_119, " response (A)";
    if (R == R_79_RESP_A) print (RulePrintingRule) R_120, " response (A)";
    if (R == R_80_RESP_A) print (RulePrintingRule) R_121, " response (A)";
    if (R == R_80_RESP_B) print (RulePrintingRule) R_121, " response (B)";
    if (R == R_82_RESP_A) print (RulePrintingRule) R_123, " response (A)";
    if (R == R_82_RESP_B) print (RulePrintingRule) R_123, " response (B)";
    if (R == R_85_RESP_A) print (RulePrintingRule) R_126, " response (A)";
    if (R == R_86_RESP_A) print (RulePrintingRule) R_127, " response (A)";
    if (R == R_87_RESP_A) print (RulePrintingRule) R_128, " response (A)";
    if (R == R_88_RESP_A) print (RulePrintingRule) R_129, " response (A)";
    if (R == R_90_RESP_A) print (RulePrintingRule) R_131, " response (A)";
    if (R == R_91_RESP_A) print (RulePrintingRule) R_132, " response (A)";
    if (R == R_94_RESP_A) print (RulePrintingRule) R_135, " response (A)";
    if (R == R_95_RESP_A) print (RulePrintingRule) R_136, " response (A)";
    if (R == R_96_RESP_A) print (RulePrintingRule) R_137, " response (A)";
    if (R == R_97_RESP_A) print (RulePrintingRule) R_138, " response (A)";
    if (R == R_98_RESP_A) print (RulePrintingRule) R_139, " response (A)";
    if (R == R_100_RESP_A) print (RulePrintingRule) R_141, " response (A)";
    if (R == R_101_RESP_A) print (RulePrintingRule) R_142, " response (A)";
    if (R == R_102_RESP_A) print (RulePrintingRule) R_143, " response (A)";
    if (R == R_103_RESP_A) print (RulePrintingRule) R_144, " response (A)";
    if (R == R_104_RESP_A) print (RulePrintingRule) R_145, " response (A)";
    if (R == R_107_RESP_A) print (RulePrintingRule) R_148, " response (A)";
    if (R == R_107_RESP_B) print (RulePrintingRule) R_148, " response (B)";
    if (R == R_109_RESP_A) print (RulePrintingRule) R_150, " response (A)";
    if (R == R_110_RESP_A) print (RulePrintingRule) R_151, " response (A)";
    if (R == R_110_RESP_B) print (RulePrintingRule) R_151, " response (B)";
    if (R == R_111_RESP_A) print (RulePrintingRule) R_152, " response (A)";
    if (R == R_112_RESP_A) print (RulePrintingRule) R_153, " response (A)";
    if (R == R_114_RESP_A) print (RulePrintingRule) R_155, " response (A)";
    if (R == R_114_RESP_B) print (RulePrintingRule) R_155, " response (B)";
    if (R == R_118_RESP_A) print (RulePrintingRule) R_159, " response (A)";
    if (R == R_118_RESP_B) print (RulePrintingRule) R_159, " response (B)";
    if (R == R_118_RESP_C) print (RulePrintingRule) R_159, " response (C)";
    if (R == R_118_RESP_D) print (RulePrintingRule) R_159, " response (D)";
    if (R == R_118_RESP_E) print (RulePrintingRule) R_159, " response (E)";
    if (R == R_118_RESP_F) print (RulePrintingRule) R_159, " response (F)";
    if (R == R_118_RESP_G) print (RulePrintingRule) R_159, " response (G)";
    if (R == R_118_RESP_H) print (RulePrintingRule) R_159, " response (H)";
    if (R == R_118_RESP_I) print (RulePrintingRule) R_159, " response (I)";
    if (R == R_118_RESP_J) print (RulePrintingRule) R_159, " response (J)";
    if (R == R_118_RESP_K) print (RulePrintingRule) R_159, " response (K)";
    if (R == R_118_RESP_L) print (RulePrintingRule) R_159, " response (L)";
    if (R == R_118_RESP_M) print (RulePrintingRule) R_159, " response (M)";
    if (R == R_118_RESP_N) print (RulePrintingRule) R_159, " response (N)";
    if (R == R_118_RESP_O) print (RulePrintingRule) R_159, " response (O)";
    if (R == R_118_RESP_P) print (RulePrintingRule) R_159, " response (P)";
    if (R == R_118_RESP_Q) print (RulePrintingRule) R_159, " response (Q)";
    if (R == R_118_RESP_R) print (RulePrintingRule) R_159, " response (R)";
    if (R == R_118_RESP_S) print (RulePrintingRule) R_159, " response (S)";
    if (R == R_122_RESP_A) print (RulePrintingRule) R_163, " response (A)";
    if (R == R_122_RESP_B) print (RulePrintingRule) R_163, " response (B)";
    if (R == R_123_RESP_A) print (RulePrintingRule) R_164, " response (A)";
    if (R == R_123_RESP_B) print (RulePrintingRule) R_164, " response (B)";
    if (R == R_123_RESP_C) print (RulePrintingRule) R_164, " response (C)";
    if (R == R_123_RESP_D) print (RulePrintingRule) R_164, " response (D)";
    if (R == R_124_RESP_A) print (RulePrintingRule) R_165, " response (A)";
    if (R == R_125_RESP_A) print (RulePrintingRule) R_166, " response (A)";
    if (R == R_125_RESP_B) print (RulePrintingRule) R_166, " response (B)";
    if (R == R_126_RESP_A) print (RulePrintingRule) R_167, " response (A)";
    if (R == R_127_RESP_A) print (RulePrintingRule) R_168, " response (A)";
    if (R == R_127_RESP_B) print (RulePrintingRule) R_168, " response (B)";
    if (R == R_127_RESP_C) print (RulePrintingRule) R_168, " response (C)";
    if (R == R_127_RESP_D) print (RulePrintingRule) R_168, " response (D)";
    if (R == R_127_RESP_E) print (RulePrintingRule) R_168, " response (E)";
    if (R == R_129_RESP_A) print (RulePrintingRule) R_170, " response (A)";
    if (R == R_129_RESP_B) print (RulePrintingRule) R_170, " response (B)";
    if (R == R_129_RESP_C) print (RulePrintingRule) R_170, " response (C)";
    if (R == R_129_RESP_D) print (RulePrintingRule) R_170, " response (D)";
    if (R == R_132_RESP_A) print (RulePrintingRule) R_174, " response (A)";
    if (R == R_133_RESP_A) print (RulePrintingRule) R_175, " response (A)";
    if (R == R_370_RESP_A) print (RulePrintingRule) R_1107, " response (A)";
    if (R == R_136_RESP_A) print (RulePrintingRule) R_178, " response (A)";
    if (R == R_136_RESP_B) print (RulePrintingRule) R_178, " response (B)";
    if (R == R_136_RESP_C) print (RulePrintingRule) R_178, " response (C)";
    if (R == R_138_RESP_A) print (RulePrintingRule) R_180, " response (A)";
    if (R == R_140_RESP_A) print (RulePrintingRule) R_182, " response (A)";
    if (R == R_335_RESP_A) print (RulePrintingRule) R_1042, " response (A)";
    if (R == R_335_RESP_B) print (RulePrintingRule) R_1042, " response (B)";
    if (R == R_335_RESP_C) print (RulePrintingRule) R_1042, " response (C)";
    if (R == R_145_RESP_A) print (RulePrintingRule) R_187, " response (A)";
    if (R == R_148_RESP_A) print (RulePrintingRule) R_190, " response (A)";
    if (R == R_150_RESP_A) print (RulePrintingRule) R_192, " response (A)";
    if (R == R_151_RESP_A) print (RulePrintingRule) R_193, " response (A)";
    if (R == R_151_RESP_B) print (RulePrintingRule) R_193, " response (B)";
    if (R == R_152_RESP_A) print (RulePrintingRule) R_194, " response (A)";
    if (R == R_153_RESP_A) print (RulePrintingRule) R_195, " response (A)";
    if (R == R_154_RESP_A) print (RulePrintingRule) R_196, " response (A)";
    if (R == R_155_RESP_A) print (RulePrintingRule) R_197, " response (A)";
    if (R == R_156_RESP_A) print (RulePrintingRule) R_198, " response (A)";
    if (R == R_157_RESP_A) print (RulePrintingRule) R_199, " response (A)";
    if (R == R_158_RESP_A) print (RulePrintingRule) R_200, " response (A)";
    if (R == R_159_RESP_A) print (RulePrintingRule) R_201, " response (A)";
    if (R == R_160_RESP_A) print (RulePrintingRule) R_202, " response (A)";
    if (R == R_160_RESP_B) print (RulePrintingRule) R_202, " response (B)";
    if (R == R_161_RESP_A) print (RulePrintingRule) R_203, " response (A)";
    if (R == R_161_RESP_B) print (RulePrintingRule) R_203, " response (B)";
    if (R == R_162_RESP_A) print (RulePrintingRule) R_204, " response (A)";
    if (R == R_163_RESP_A) print (RulePrintingRule) R_205, " response (A)";
    if (R == R_163_RESP_B) print (RulePrintingRule) R_205, " response (B)";
    if (R == R_431_RESP_A) print (RulePrintingRule) R_1353, " response (A)";
    if (R == R_432_RESP_A) print (RulePrintingRule) R_1354, " response (A)";
    if (R == R_164_RESP_A) print (RulePrintingRule) R_206, " response (A)";
    if (R == R_165_RESP_A) print (RulePrintingRule) R_207, " response (A)";
    if (R == R_166_RESP_A) print (RulePrintingRule) R_208, " response (A)";
    if (R == R_167_RESP_A) print (RulePrintingRule) R_209, " response (A)";
    if (R == R_169_RESP_A) print (RulePrintingRule) R_211, " response (A)";
    if (R == R_169_RESP_B) print (RulePrintingRule) R_211, " response (B)";
    if (R == R_447_RESP_A) print (RulePrintingRule) R_1389, " response (A)";
    if (R == R_170_RESP_A) print (RulePrintingRule) R_212, " response (A)";
    if (R == R_171_RESP_A) print (RulePrintingRule) R_213, " response (A)";
    if (R == R_172_RESP_A) print (RulePrintingRule) R_214, " response (A)";
    if (R == R_174_RESP_A) print (RulePrintingRule) R_216, " response (A)";
    if (R == R_174_RESP_B) print (RulePrintingRule) R_216, " response (B)";
    if (R == R_175_RESP_A) print (RulePrintingRule) R_217, " response (A)";
    if (R == R_176_RESP_A) print (RulePrintingRule) R_218, " response (A)";
    if (R == R_178_RESP_A) print (RulePrintingRule) R_220, " response (A)";
    if (R == R_179_RESP_A) print (RulePrintingRule) R_221, " response (A)";
    if (R == R_180_RESP_A) print (RulePrintingRule) R_222, " response (A)";
    if (R == R_182_RESP_A) print (RulePrintingRule) R_224, " response (A)";
    if (R == R_441_RESP_A) print (RulePrintingRule) R_1365, " response (A)";
    if (R == R_442_RESP_A) print (RulePrintingRule) R_1366, " response (A)";
    if (R == R_183_RESP_A) print (RulePrintingRule) R_225, " response (A)";
    if (R == R_184_RESP_A) print (RulePrintingRule) R_226, " response (A)";
    if (R == R_185_RESP_A) print (RulePrintingRule) R_227, " response (A)";
    if (R == R_187_RESP_A) print (RulePrintingRule) R_229, " response (A)";
    if (R == R_188_RESP_A) print (RulePrintingRule) R_230, " response (A)";
    if (R == R_188_RESP_B) print (RulePrintingRule) R_230, " response (B)";
    if (R == R_188_RESP_C) print (RulePrintingRule) R_230, " response (C)";
    if (R == R_443_RESP_A) print (RulePrintingRule) R_1367, " response (A)";
    if (R == R_189_RESP_A) print (RulePrintingRule) R_231, " response (A)";
    if (R == R_190_RESP_A) print (RulePrintingRule) R_232, " response (A)";
    if (R == R_192_RESP_A) print (RulePrintingRule) R_234, " response (A)";
    if (R == R_192_RESP_B) print (RulePrintingRule) R_234, " response (B)";
    if (R == R_192_RESP_C) print (RulePrintingRule) R_234, " response (C)";
    if (R == R_193_RESP_A) print (RulePrintingRule) R_235, " response (A)";
    if (R == R_194_RESP_A) print (RulePrintingRule) R_236, " response (A)";
    if (R == R_195_RESP_A) print (RulePrintingRule) R_237, " response (A)";
    if (R == R_197_RESP_A) print (RulePrintingRule) R_239, " response (A)";
    if (R == R_197_RESP_B) print (RulePrintingRule) R_239, " response (B)";
    if (R == R_198_RESP_A) print (RulePrintingRule) R_241, " response (A)";
    if (R == R_199_RESP_A) print (RulePrintingRule) R_242, " response (A)";
    if (R == R_201_RESP_A) print (RulePrintingRule) R_244, " response (A)";
    if (R == R_201_RESP_B) print (RulePrintingRule) R_244, " response (B)";
    if (R == R_202_RESP_A) print (RulePrintingRule) R_245, " response (A)";
    if (R == R_203_RESP_A) print (RulePrintingRule) R_246, " response (A)";
    if (R == R_204_RESP_A) print (RulePrintingRule) R_247, " response (A)";
    if (R == R_205_RESP_A) print (RulePrintingRule) R_248, " response (A)";
    if (R == R_207_RESP_A) print (RulePrintingRule) R_250, " response (A)";
    if (R == R_210_RESP_A) print (RulePrintingRule) R_253, " response (A)";
    if (R == R_213_RESP_A) print (RulePrintingRule) R_256, " response (A)";
    if (R == R_214_RESP_A) print (RulePrintingRule) R_257, " response (A)";
    if (R == R_215_RESP_A) print (RulePrintingRule) R_258, " response (A)";
    if (R == R_216_RESP_A) print (RulePrintingRule) R_259, " response (A)";
    if (R == R_345_RESP_A) print (RulePrintingRule) R_1070, " response (A)";
    if (R == R_364_RESP_A) print (RulePrintingRule) R_1099, " response (A)";
    if (R == R_344_RESP_A) print (RulePrintingRule) R_1069, " response (A)";
    if (R == R_363_RESP_A) print (RulePrintingRule) R_1098, " response (A)";
    if (R == R_354_RESP_A) print (RulePrintingRule) R_1083, " response (A)";
    if (R == R_217_RESP_A) print (RulePrintingRule) R_260, " response (A)";
    if (R == R_218_RESP_A) print (RulePrintingRule) R_261, " response (A)";
    if (R == R_219_RESP_A) print (RulePrintingRule) R_262, " response (A)";
    if (R == R_221_RESP_A) print (RulePrintingRule) R_264, " response (A)";
    if (R == R_226_RESP_A) print (RulePrintingRule) R_269, " response (A)";
    if (R == R_226_RESP_B) print (RulePrintingRule) R_269, " response (B)";
    if (R == R_227_RESP_A) print (RulePrintingRule) R_270, " response (A)";
    if (R == R_227_RESP_B) print (RulePrintingRule) R_270, " response (B)";
    if (R == R_228_RESP_A) print (RulePrintingRule) R_271, " response (A)";
    if (R == R_228_RESP_B) print (RulePrintingRule) R_271, " response (B)";
    if (R == R_228_RESP_C) print (RulePrintingRule) R_271, " response (C)";
    if (R == R_229_RESP_A) print (RulePrintingRule) R_272, " response (A)";
    if (R == R_229_RESP_B) print (RulePrintingRule) R_272, " response (B)";
    if (R == R_230_RESP_A) print (RulePrintingRule) R_273, " response (A)";
    if (R == R_231_RESP_A) print (RulePrintingRule) R_274, " response (A)";
    if (R == R_231_RESP_B) print (RulePrintingRule) R_274, " response (B)";
    if (R == R_232_RESP_A) print (RulePrintingRule) R_275, " response (A)";
    if (R == R_233_RESP_A) print (RulePrintingRule) R_276, " response (A)";
    if (R == R_234_RESP_A) print (RulePrintingRule) R_277, " response (A)";
    if (R == R_235_RESP_A) print (RulePrintingRule) R_278, " response (A)";
    if (R == R_235_RESP_B) print (RulePrintingRule) R_278, " response (B)";
    if (R == R_236_RESP_A) print (RulePrintingRule) R_279, " response (A)";
    if (R == R_237_RESP_A) print (RulePrintingRule) R_280, " response (A)";
    if (R == R_238_RESP_A) print (RulePrintingRule) R_281, " response (A)";
    if (R == R_239_RESP_A) print (RulePrintingRule) R_282, " response (A)";
    if (R == R_239_RESP_B) print (RulePrintingRule) R_282, " response (B)";
    if (R == R_240_RESP_A) print (RulePrintingRule) R_283, " response (A)";
    if (R == R_241_RESP_A) print (RulePrintingRule) R_284, " response (A)";
    if (R == R_242_RESP_A) print (RulePrintingRule) R_285, " response (A)";
    if (R == R_243_RESP_A) print (RulePrintingRule) R_286, " response (A)";
    if (R == R_243_RESP_B) print (RulePrintingRule) R_286, " response (B)";
    if (R == R_244_RESP_A) print (RulePrintingRule) R_287, " response (A)";
    if (R == R_245_RESP_A) print (RulePrintingRule) R_288, " response (A)";
    if (R == R_246_RESP_A) print (RulePrintingRule) R_289, " response (A)";
    if (R == R_247_RESP_A) print (RulePrintingRule) R_290, " response (A)";
    if (R == R_249_RESP_A) print (RulePrintingRule) R_292, " response (A)";
    if (R == R_250_RESP_A) print (RulePrintingRule) R_293, " response (A)";
    if (R == R_251_RESP_A) print (RulePrintingRule) R_294, " response (A)";
    if (R == R_251_RESP_B) print (RulePrintingRule) R_294, " response (B)";
    if (R == R_347_RESP_A) print (RulePrintingRule) R_1072, " response (A)";
    if (R == R_366_RESP_A) print (RulePrintingRule) R_1101, " response (A)";
    if (R == R_346_RESP_A) print (RulePrintingRule) R_1071, " response (A)";
    if (R == R_365_RESP_A) print (RulePrintingRule) R_1100, " response (A)";
    if (R == R_355_RESP_A) print (RulePrintingRule) R_1084, " response (A)";
    if (R == R_254_RESP_A) print (RulePrintingRule) R_297, " response (A)";
    if (R == R_343_RESP_B) print (RulePrintingRule) R_1068, " response (B)";
    if (R == R_353_RESP_B) print (RulePrintingRule) R_1082, " response (B)";
    if (R == R_362_RESP_A) print (RulePrintingRule) R_1097, " response (A)";
    if (R == R_362_RESP_B) print (RulePrintingRule) R_1097, " response (B)";
    if (R == R_256_RESP_A) print (RulePrintingRule) R_299, " response (A)";
    if (R == R_257_RESP_A) print (RulePrintingRule) R_300, " response (A)";
    if (R == R_257_RESP_B) print (RulePrintingRule) R_300, " response (B)";
    if (R == R_258_RESP_A) print (RulePrintingRule) R_301, " response (A)";
    if (R == R_263_RESP_A) print (RulePrintingRule) R_802, " response (A)";
    if (R == R_274_RESP_A) print (RulePrintingRule) R_820, " response (A)";
    if (R == R_274_RESP_B) print (RulePrintingRule) R_820, " response (B)";
    if (R == R_275_RESP_A) print (RulePrintingRule) R_821, " response (A)";
    if (R == R_278_RESP_A) print (RulePrintingRule) R_824, " response (A)";
    if (R == R_280_RESP_A) print (RulePrintingRule) R_826, " response (A)";
    if (R == R_280_RESP_B) print (RulePrintingRule) R_826, " response (B)";
    if (R == R_285_RESP_A) print (RulePrintingRule) R_833, " response (A)";
    if (R == R_283_RESP_A) print (RulePrintingRule) R_831, " response (A)";
    if (R == R_303_RESP_A) print (RulePrintingRule) R_872, " response (A)";
    if (R == R_320_RESP_A) print (RulePrintingRule) R_895, " response (A)";
    if (R == R_330_RESP_A) print (RulePrintingRule) R_1010, " response (A)";
    if (R == R_330_RESP_B) print (RulePrintingRule) R_1010, " response (B)";
    if (R == R_330_RESP_C) print (RulePrintingRule) R_1010, " response (C)";
    if (R == R_331_RESP_A) print (RulePrintingRule) R_1016, " response (A)";
    if (R == R_331_RESP_B) print (RulePrintingRule) R_1016, " response (B)";
    if (R == R_339_RESP_A) print (RulePrintingRule) R_1062, " response (A)";
    if (R == R_339_RESP_B) print (RulePrintingRule) R_1062, " response (B)";
    if (R == R_341_RESP_A) print (RulePrintingRule) R_1065, " response (A)";
    if (R == R_341_RESP_B) print (RulePrintingRule) R_1065, " response (B)";
    if (R == R_349_RESP_A) print (RulePrintingRule) R_1076, " response (A)";
    if (R == R_349_RESP_B) print (RulePrintingRule) R_1076, " response (B)";
    if (R == R_351_RESP_A) print (RulePrintingRule) R_1079, " response (A)";
    if (R == R_351_RESP_B) print (RulePrintingRule) R_1079, " response (B)";
    if (R == R_351_RESP_C) print (RulePrintingRule) R_1079, " response (C)";
    if (R == R_358_RESP_A) print (RulePrintingRule) R_1091, " response (A)";
    if (R == R_358_RESP_B) print (RulePrintingRule) R_1091, " response (B)";
    if (R == R_358_RESP_C) print (RulePrintingRule) R_1091, " response (C)";
    if (R == R_360_RESP_A) print (RulePrintingRule) R_1094, " response (A)";
    if (R == R_360_RESP_B) print (RulePrintingRule) R_1094, " response (B)";
    if (R == R_360_RESP_C) print (RulePrintingRule) R_1094, " response (C)";
    if (R == R_360_RESP_D) print (RulePrintingRule) R_1094, " response (D)";
    if (R == R_369_RESP_A) print (RulePrintingRule) R_1104, " response (A)";
    if (R == R_369_RESP_B) print (RulePrintingRule) R_1104, " response (B)";
    if (R == R_369_RESP_C) print (RulePrintingRule) R_1104, " response (C)";
    if (R == R_369_RESP_D) print (RulePrintingRule) R_1104, " response (D)";
    if (R == R_369_RESP_E) print (RulePrintingRule) R_1104, " response (E)";
    if (R == R_371_RESP_A) print (RulePrintingRule) R_1108, " response (A)";
    if (R == R_372_RESP_A) print (RulePrintingRule) R_1110, " response (A)";
    if (R == R_373_RESP_A) print (RulePrintingRule) R_1134, " response (A)";
    if (R == R_373_RESP_B) print (RulePrintingRule) R_1134, " response (B)";
    if (R == R_373_RESP_C) print (RulePrintingRule) R_1134, " response (C)";
    if (R == R_381_RESP_A) print (RulePrintingRule) R_1149, " response (A)";
    if (R == R_379_RESP_A) print (RulePrintingRule) R_1147, " response (A)";
    if (R == R_383_RESP_A) print (RulePrintingRule) R_1158, " response (A)";
    if (R == R_434_RESP_A) print (RulePrintingRule) R_1356, " response (A)";
    if (R == R_435_RESP_A) print (RulePrintingRule) R_1358, " response (A)";
    if (R == R_44_RESP_A) print (RulePrintingRule) R_84, " response (A)";
    if (R == R_44_RESP_B) print (RulePrintingRule) R_84, " response (B)";
    if (R == R_44_RESP_C) print (RulePrintingRule) R_84, " response (C)";
    if (R == R_44_RESP_D) print (RulePrintingRule) R_84, " response (D)";
    if (R == R_44_RESP_E) print (RulePrintingRule) R_84, " response (E)";
    if (R == R_44_RESP_F) print (RulePrintingRule) R_84, " response (F)";
    if (R == R_144_RESP_A) print (RulePrintingRule) R_186, " response (A)";
    if (R == R_144_RESP_B) print (RulePrintingRule) R_186, " response (B)";
    if (R == R_144_RESP_C) print (RulePrintingRule) R_186, " response (C)";
    if (R == R_206_RESP_A) print (RulePrintingRule) R_249, " response (A)";
    if (R == R_209_RESP_A) print (RulePrintingRule) R_252, " response (A)";
    if (R == R_209_RESP_B) print (RulePrintingRule) R_252, " response (B)";
    if (R == R_209_RESP_C) print (RulePrintingRule) R_252, " response (C)";
    if (R == R_212_RESP_A) print (RulePrintingRule) R_255, " response (A)";
    if (R == R_220_RESP_A) print (RulePrintingRule) R_263, " response (A)";
    if (R == R_222_RESP_A) print (RulePrintingRule) R_265, " response (A)";
    if (R == R_223_RESP_A) print (RulePrintingRule) R_266, " response (A)";
    if (R == R_252_RESP_A) print (RulePrintingRule) R_295, " response (A)";
    if (R == R_253_RESP_A) print (RulePrintingRule) R_296, " response (A)";
    if (R == R_255_RESP_A) print (RulePrintingRule) R_298, " response (A)";
    if (R == R_264_RESP_A) print (RulePrintingRule) R_803, " response (A)";
    if (R == R_265_RESP_A) print (RulePrintingRule) R_804, " response (A)";
];
[ STANDARD_RESPONSE_ISSUING_R ;
    RegardingSingleObject(); TEXT_TY_Say(ResponseTexts-->(parameter_value-1));
];
Array ResponseDivisions -->
    "Standard Rules" 1 239
    EMPTY_TEXT_PACKED 330 462
    "Epistemology by Eric Eve" 240 240
    "Conversation Framework by Eric Eve" 241 255
    "Conversational Defaults by Eric Eve" 256 256
    "Basic Screen Effects by Emily Short" 257 257
    "Phones by Philip Riley" 258 264
    "Third Person Narration by Philip Riley" 265 270
    "Walls by Philip Riley" 271 282
    "Floors by Philip Riley" 283 292
    "Ceilings by Philip Riley" 293 307
    "Can't Go That Way by Philip Riley" 308 313
    "Can't Take That by Philip Riley" 314 315
    "Complex Listing by Emily Short" 316 318
    "Exit Lister by Eric Eve" 319 321
    "Door Varieties by Philip Riley" 329 329
    "Two-Sided Doors by Philip Riley" 322 328
    0 0 0;
[ R_TX_S_0 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[It] [are] [if story tense is present tense]now [end if]pitch dark in
    [if story tense is present tense]here[else]there[end if]!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[It] [are] [if story tense is present tense]now [end if]pitch dark in [if story tense is present tense]here[else]there[end if]!~]
    say__p=1;! [2: it]
    ParaContent(); (PHR_787_r103 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: if story tense is present tense]

    	if (~~((((story_tense == I112_present_tense))))) jump L_Say1056;! [7: ~now ~]
    ParaContent(); print "now ";! [8: end if]

    	.L_Say1056; .L_SayX1037;! [9: ~pitch dark in ~]
    ParaContent(); print "pitch dark in ";! [10: if story tense is present tense]

    	if (~~((((story_tense == I112_present_tense))))) jump L_Say1057;! [11: ~here~]
    ParaContent(); print "here";! [12: else]

    	jump L_SayX1038; .L_Say1057;! [13: ~there~]
    ParaContent(); print "there";! [14: end if]

    	.L_Say1058; .L_SayX1038;! [15: ~!~]
    ParaContent(); print "!"; .L_Say1059; .L_SayX1039;rtrue;
];
Array TX_S_0 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_0;
[ R_TX_S_1 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(considering the first sixteen objects only)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(considering the first sixteen objects only)[command clarification break]~]
    say__p=1;! [2: ~(considering the first sixteen objects only)~]
    ParaContent(); print "(considering the first sixteen objects only)";! [3: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1060; .L_SayX1040;rtrue;
];
Array TX_S_1 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_1;
[ R_TX_S_2 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Nothing to do!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Nothing to do!~]
    say__p=1;! [2: ~Nothing to do!~]
    ParaContent(); print "Nothing to do!"; .L_Say1061; .L_SayX1041;rtrue;
];
Array TX_S_2 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_2;
[ R_TX_S_3 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You must name something more substantial.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You must name something more substantial.~]
    say__p=1;! [2: ~You must name something more substantial.~]
    ParaContent(); print "You must name something more substantial."; .L_Say1062; .L_SayX1042;rtrue;
];
Array TX_S_3 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_3;
[ R_TX_S_4 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[It] [are] pitch dark, and [we] [can't see] a thing.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[It] [are] pitch dark, and [we] [can't see] a thing.~]
    say__p=1;! [2: it]
    ParaContent(); (PHR_787_r103 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ pitch dark, and ~]
    ParaContent(); print " pitch dark, and ";! [6: we]
    ParaContent(); (PHR_757_r16 ());! [7: ~ ~]
    ParaContent(); print " ";! [8: can't see]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_16); say__p=1; ! [9: ~ a thing.~]
    ParaContent(); print " a thing."; .L_Say1063; .L_SayX1043;rtrue;
];
Array TX_S_4 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_4;
[ R_TX_S_5 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [have] better things to do.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [have] better things to do.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: have]
    ConjugateVerb_2(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ better things to do.~]
    ParaContent(); print " better things to do."; .L_Say1064; .L_SayX1044;rtrue;
];
Array TX_S_5 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_5;
[ R_TX_S_6 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [are] unable to do that.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [are] unable to do that.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ unable to do that.~]
    ParaContent(); print " unable to do that."; .L_Say1065; .L_SayX1045;rtrue;
];
Array TX_S_6 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_6;
[ R_TX_S_9 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't] reach into [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't] reach into [the noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ reach into ~]
    ParaContent(); print " reach into ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1066; .L_SayX1046;rtrue;
];
Array TX_S_9 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_9;
[ R_TX_S_10 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [aren't] open.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [aren't] open.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ open.~]
    ParaContent(); print " open."; .L_Say1067; .L_SayX1047;rtrue;
];
Array TX_S_10 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_10;
[ R_TX_S_11 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ (~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ (~]
    say__p=1;! [2: ~ (~]
    ParaContent(); print " ("; .L_Say1068; .L_SayX1048;rtrue;
];
Array TX_S_11 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_11;
[ R_TX_S_12 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~)~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~)~]
    say__p=1;! [2: ~)~]
    ParaContent(); print ")"; .L_Say1069; .L_SayX1049;rtrue;
];
Array TX_S_12 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_12;
[ R_TX_S_13 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ and ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ and ~]
    say__p=1;! [2: ~ and ~]
    ParaContent(); print " and "; .L_Say1070; .L_SayX1050;rtrue;
];
Array TX_S_13 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_13;
[ R_TX_S_14 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~providing light~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~providing light~]
    say__p=1;! [2: ~providing light~]
    ParaContent(); print "providing light"; .L_Say1071; .L_SayX1051;rtrue;
];
Array TX_S_14 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_14;
[ R_TX_S_15 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~closed~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~closed~]
    say__p=1;! [2: ~closed~]
    ParaContent(); print "closed"; .L_Say1072; .L_SayX1052;rtrue;
];
Array TX_S_15 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_15;
[ R_TX_S_16 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~empty~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~empty~]
    say__p=1;! [2: ~empty~]
    ParaContent(); print "empty"; .L_Say1073; .L_SayX1053;rtrue;
];
Array TX_S_16 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_16;
[ R_TX_S_17 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~closed and empty~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~closed and empty~]
    say__p=1;! [2: ~closed and empty~]
    ParaContent(); print "closed and empty"; .L_Say1074; .L_SayX1054;rtrue;
];
Array TX_S_17 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_17;
[ R_TX_S_18 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~closed and providing light~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~closed and providing light~]
    say__p=1;! [2: ~closed and providing light~]
    ParaContent(); print "closed and providing light"; .L_Say1075; .L_SayX1055;rtrue;
];
Array TX_S_18 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_18;
[ R_TX_S_19 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~empty and providing light~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~empty and providing light~]
    say__p=1;! [2: ~empty and providing light~]
    ParaContent(); print "empty and providing light"; .L_Say1076; .L_SayX1056;rtrue;
];
Array TX_S_19 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_19;
[ R_TX_S_20 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~closed, empty[if serial comma option is active],[end if] and providing light~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~closed, empty[if serial comma option is active],[end if] and providing light~]
    say__p=1;! [2: ~closed, empty~]
    ParaContent(); print "closed, empty";! [3: if serial comma option is active]

    	if (~~(((((Adj_25_t1_v16(6))))))) jump L_Say1077;! [4: ~,~]
    ParaContent(); print ",";! [5: end if]

    	.L_Say1077; .L_SayX1057;! [6: ~ and providing light~]
    ParaContent(); print " and providing light"; .L_Say1078; .L_SayX1058;rtrue;
];
Array TX_S_20 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_20;
[ R_TX_S_21 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~providing light and being worn~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~providing light and being worn~]
    say__p=1;! [2: ~providing light and being worn~]
    ParaContent(); print "providing light and being worn"; .L_Say1079; .L_SayX1059;rtrue;
];
Array TX_S_21 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_21;
[ R_TX_S_22 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~being worn~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~being worn~]
    say__p=1;! [2: ~being worn~]
    ParaContent(); print "being worn"; .L_Say1080; .L_SayX1060;rtrue;
];
Array TX_S_22 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_22;
[ R_TX_S_23 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~open~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~open~]
    say__p=1;! [2: ~open~]
    ParaContent(); print "open"; .L_Say1081; .L_SayX1061;rtrue;
];
Array TX_S_23 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_23;
[ R_TX_S_24 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~open but empty~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~open but empty~]
    say__p=1;! [2: ~open but empty~]
    ParaContent(); print "open but empty"; .L_Say1082; .L_SayX1062;rtrue;
];
Array TX_S_24 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_24;
[ R_TX_S_25 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~closed~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~closed~]
    say__p=1;! [2: ~closed~]
    ParaContent(); print "closed"; .L_Say1083; .L_SayX1063;rtrue;
];
Array TX_S_25 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_25;
[ R_TX_S_26 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~closed and locked~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~closed and locked~]
    say__p=1;! [2: ~closed and locked~]
    ParaContent(); print "closed and locked"; .L_Say1084; .L_SayX1064;rtrue;
];
Array TX_S_26 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_26;
[ R_TX_S_27 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~containing~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~containing~]
    say__p=1;! [2: ~containing~]
    ParaContent(); print "containing"; .L_Say1085; .L_SayX1065;rtrue;
];
Array TX_S_27 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_27;
[ R_TX_S_28 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~on [if the noun is a person]whom[otherwise]which[end if] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~on [if the noun is a person]whom[otherwise]which[end if] ~]
    say__p=1;! [2: ~on ~]
    ParaContent(); print "on ";! [3: if the noun is a person]

    	if (~~((((noun ofclass K8_person))))) jump L_Say1086;! [4: ~whom~]
    ParaContent(); print "whom";! [5: otherwise]

    	jump L_SayX1066; .L_Say1086;! [6: ~which~]
    ParaContent(); print "which";! [7: end if]

    	.L_Say1087; .L_SayX1066;! [8: ~ ~]
    ParaContent(); print " "; .L_Say1088; .L_SayX1067;rtrue;
];
Array TX_S_28 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_28;
[ R_TX_S_29 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, on top of [if the noun is a person]whom[otherwise]which[end if] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~, on top of [if the noun is a person]whom[otherwise]which[end if] ~]
    say__p=1;! [2: ~, on top of ~]
    ParaContent(); print ", on top of ";! [3: if the noun is a person]

    	if (~~((((noun ofclass K8_person))))) jump L_Say1089;! [4: ~whom~]
    ParaContent(); print "whom";! [5: otherwise]

    	jump L_SayX1068; .L_Say1089;! [6: ~which~]
    ParaContent(); print "which";! [7: end if]

    	.L_Say1090; .L_SayX1068;! [8: ~ ~]
    ParaContent(); print " "; .L_Say1091; .L_SayX1069;rtrue;
];
Array TX_S_29 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_29;
[ R_TX_S_30 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~in [if the noun is a person]whom[otherwise]which[end if] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~in [if the noun is a person]whom[otherwise]which[end if] ~]
    say__p=1;! [2: ~in ~]
    ParaContent(); print "in ";! [3: if the noun is a person]

    	if (~~((((noun ofclass K8_person))))) jump L_Say1092;! [4: ~whom~]
    ParaContent(); print "whom";! [5: otherwise]

    	jump L_SayX1070; .L_Say1092;! [6: ~which~]
    ParaContent(); print "which";! [7: end if]

    	.L_Say1093; .L_SayX1070;! [8: ~ ~]
    ParaContent(); print " "; .L_Say1094; .L_SayX1071;rtrue;
];
Array TX_S_30 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_30;
[ R_TX_S_31 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, inside [if the noun is a person]whom[otherwise]which[end if] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~, inside [if the noun is a person]whom[otherwise]which[end if] ~]
    say__p=1;! [2: ~, inside ~]
    ParaContent(); print ", inside ";! [3: if the noun is a person]

    	if (~~((((noun ofclass K8_person))))) jump L_Say1095;! [4: ~whom~]
    ParaContent(); print "whom";! [5: otherwise]

    	jump L_SayX1072; .L_Say1095;! [6: ~which~]
    ParaContent(); print "which";! [7: end if]

    	.L_Say1096; .L_SayX1072;! [8: ~ ~]
    ParaContent(); print " "; .L_Say1097; .L_SayX1073;rtrue;
];
Array TX_S_31 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_31;
[ R_TX_S_32 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding list writer internals][are]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding list writer internals][are]~]
    say__p=1;! [2: regarding list writer internals]
    ParaContent(); RegardingLWI();! [3: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say1098; .L_SayX1074;rtrue;
];
Array TX_S_32 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_32;
[ R_TX_S_33 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding list writer internals][are] nothing~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding list writer internals][are] nothing~]
    say__p=1;! [2: regarding list writer internals]
    ParaContent(); RegardingLWI();! [3: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [4: ~ nothing~]
    ParaContent(); print " nothing"; .L_Say1099; .L_SayX1075;rtrue;
];
Array TX_S_33 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_33;
[ R_TX_S_34 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Nothing~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Nothing~]
    say__p=1;! [2: ~Nothing~]
    ParaContent(); print "Nothing"; .L_Say1100; .L_SayX1076;rtrue;
];
Array TX_S_34 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_34;
[ R_TX_S_35 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~nothing~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~nothing~]
    say__p=1;! [2: ~nothing~]
    ParaContent(); print "nothing"; .L_Say1101; .L_SayX1077;rtrue;
];
Array TX_S_35 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_35;
[ R_TX_S_36 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bracket]That command asks to do something outside of play, so it can
    only make sense from you to me. [The noun] cannot be asked to do this.[close
    bracket]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[bracket]That command asks to do something outside of play, so it can only make sense from you to me. [The noun] cannot be asked to do this.[close bracket]~]
    say__p=1;! [2: bracket]
    ParaContent(); print "[";! [3: ~That command asks to do something outside of play, so it can only make sense from you to me. ~]
    ParaContent(); print "That command asks to do something outside of play, so it can only make sense from you to me. ";! [4: the noun]
    ParaContent(); print (The) noun;! [5: ~ cannot be asked to do this.~]
    ParaContent(); print " cannot be asked to do this.";! [6: close bracket]
    ParaContent(); print "]"; .L_Say1102; .L_SayX1078;rtrue;
];
Array TX_S_36 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_36;
[ R_TX_S_37 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You must name an object.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You must name an object.~]
    say__p=1;! [2: ~You must name an object.~]
    ParaContent(); print "You must name an object."; .L_Say1103; .L_SayX1079;rtrue;
];
Array TX_S_37 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_37;
[ R_TX_S_38 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You may not name an object.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You may not name an object.~]
    say__p=1;! [2: ~You may not name an object.~]
    ParaContent(); print "You may not name an object."; .L_Say1104; .L_SayX1080;rtrue;
];
Array TX_S_38 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_38;
[ R_TX_S_39 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You must supply a noun.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You must supply a noun.~]
    say__p=1;! [2: ~You must supply a noun.~]
    ParaContent(); print "You must supply a noun."; .L_Say1105; .L_SayX1081;rtrue;
];
Array TX_S_39 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_39;
[ R_TX_S_40 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You may not supply a noun.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You may not supply a noun.~]
    say__p=1;! [2: ~You may not supply a noun.~]
    ParaContent(); print "You may not supply a noun."; .L_Say1106; .L_SayX1082;rtrue;
];
Array TX_S_40 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_40;
[ R_TX_S_41 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You must name a second object.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You must name a second object.~]
    say__p=1;! [2: ~You must name a second object.~]
    ParaContent(); print "You must name a second object."; .L_Say1107; .L_SayX1083;rtrue;
];
Array TX_S_41 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_41;
[ R_TX_S_42 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You may not name a second object.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You may not name a second object.~]
    say__p=1;! [2: ~You may not name a second object.~]
    ParaContent(); print "You may not name a second object."; .L_Say1108; .L_SayX1084;rtrue;
];
Array TX_S_42 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_42;
[ R_TX_S_43 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You must supply a second noun.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You must supply a second noun.~]
    say__p=1;! [2: ~You must supply a second noun.~]
    ParaContent(); print "You must supply a second noun."; .L_Say1109; .L_SayX1085;rtrue;
];
Array TX_S_43 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_43;
[ R_TX_S_44 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You may not supply a second noun.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You may not supply a second noun.~]
    say__p=1;! [2: ~You may not supply a second noun.~]
    ParaContent(); print "You may not supply a second noun."; .L_Say1110; .L_SayX1086;rtrue;
];
Array TX_S_44 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_44;
[ R_TX_S_45 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(Since something dramatic has happened, your list of commands has been
    cut short.)~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(Since something dramatic has happened, your list of commands has been cut short.)~]
    say__p=1;! [2: ~(Since something dramatic has happened, your list of commands has been cut short.)~]
    ParaContent(); print "(Since something dramatic has happened, your list of commands has been cut short.)"; .L_Say1111; .L_SayX1087;rtrue;
];
Array TX_S_45 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_45;
[ R_TX_S_46 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~I didn't understand that instruction.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~I didn't understand that instruction.~]
    say__p=1;! [2: ~I didn't understand that instruction.~]
    ParaContent(); print "I didn't understand that instruction."; .L_Say1112; .L_SayX1088;rtrue;
];
Array TX_S_46 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_46;
[ R_TX_S_47 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~I didn't understand that sentence.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~I didn't understand that sentence.~]
    say__p=1;! [2: ~I didn't understand that sentence.~]
    ParaContent(); print "I didn't understand that sentence."; .L_Say1113; .L_SayX1089;rtrue;
];
Array TX_S_47 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_47;
[ R_TX_S_48 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~I only understood you as far as wanting to ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~I only understood you as far as wanting to ~]
    say__p=1;! [2: ~I only understood you as far as wanting to ~]
    ParaContent(); print "I only understood you as far as wanting to "; .L_Say1114; .L_SayX1090;rtrue;
];
Array TX_S_48 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_48;
[ R_TX_S_49 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~I only understood you as far as wanting to (go) ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~I only understood you as far as wanting to (go) ~]
    say__p=1;! [2: ~I only understood you as far as wanting to (go) ~]
    ParaContent(); print "I only understood you as far as wanting to (go) "; .L_Say1115; .L_SayX1091;rtrue;
];
Array TX_S_49 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_49;
[ R_TX_S_50 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~I didn't understand that number.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~I didn't understand that number.~]
    say__p=1;! [2: ~I didn't understand that number.~]
    ParaContent(); print "I didn't understand that number."; .L_Say1116; .L_SayX1092;rtrue;
];
Array TX_S_50 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_50;
[ R_TX_S_52 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You seem to have said too little!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You seem to have said too little!~]
    say__p=1;! [2: ~You seem to have said too little!~]
    ParaContent(); print "You seem to have said too little!"; .L_Say1117; .L_SayX1093;rtrue;
];
Array TX_S_52 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_52;
[ R_TX_S_53 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [aren't] holding that!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [aren't] holding that!~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ holding that!~]
    ParaContent(); print " holding that!"; .L_Say1118; .L_SayX1094;rtrue;
];
Array TX_S_53 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_53;
[ R_TX_S_54 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You can't use multiple objects with that verb.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You can't use multiple objects with that verb.~]
    say__p=1;! [2: ~You can't use multiple objects with that verb.~]
    ParaContent(); print "You can't use multiple objects with that verb."; .L_Say1119; .L_SayX1095;rtrue;
];
Array TX_S_54 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_54;
[ R_TX_S_55 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You can only use multiple objects once on a line.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You can only use multiple objects once on a line.~]
    say__p=1;! [2: ~You can only use multiple objects once on a line.~]
    ParaContent(); print "You can only use multiple objects once on a line."; .L_Say1120; .L_SayX1096;rtrue;
];
Array TX_S_55 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_55;
[ R_TX_S_56 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~I'm not sure what ['][pronoun i6 dictionary word]['] refers to.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~I'm not sure what ['][pronoun i6 dictionary word]['] refers to.~]
    say__p=1;! [2: ~I'm not sure what ~]
    ParaContent(); print "I'm not sure what ";! [3: ']
    ParaContent(); print "'";! [4: pronoun i6 dictionary word]
    ParaContent(); print (address) pronoun_word;! [5: ']
    ParaContent(); print "'";! [6: ~ refers to.~]
    ParaContent(); print " refers to."; .L_Say1121; .L_SayX1097;rtrue;
];
Array TX_S_56 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_56;
[ R_TX_S_57 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't] see ['][pronoun i6 dictionary word]['] ([the noun]) at the moment.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't] see ['][pronoun i6 dictionary word]['] ([the noun]) at the moment.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ see ~]
    ParaContent(); print " see ";! [6: ']
    ParaContent(); print "'";! [7: pronoun i6 dictionary word]
    ParaContent(); print (address) pronoun_word;! [8: ']
    ParaContent(); print "'";! [9: ~ (~]
    ParaContent(); print " (";! [10: the noun]
    ParaContent(); print (the) noun;! [11: ~) at the moment.~]
    ParaContent(); print ") at the moment."; .L_Say1122; .L_SayX1098;rtrue;
];
Array TX_S_57 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_57;
[ R_TX_S_58 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You excepted something not included anyway!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You excepted something not included anyway!~]
    say__p=1;! [2: ~You excepted something not included anyway!~]
    ParaContent(); print "You excepted something not included anyway!"; .L_Say1123; .L_SayX1099;rtrue;
];
Array TX_S_58 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_58;
[ R_TX_S_59 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You can only do that to something animate.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You can only do that to something animate.~]
    say__p=1;! [2: ~You can only do that to something animate.~]
    ParaContent(); print "You can only do that to something animate."; .L_Say1124; .L_SayX1100;rtrue;
];
Array TX_S_59 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_59;
[ R_TX_S_60 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~That's not a verb I [if American dialect option is
    active]recognize[otherwise]recognise[end if].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~That's not a verb I [if American dialect option is active]recognize[otherwise]recognise[end if].~]
    say__p=1;! [2: ~That's not a verb I ~]
    ParaContent(); print "That's not a verb I ";! [3: if american dialect option is active]

    	if (~~(((((Adj_25_t1_v16(5))))))) jump L_Say1125;! [4: ~recognize~]
    ParaContent(); print "recognize";! [5: otherwise]

    	jump L_SayX1101; .L_Say1125;! [6: ~recognise~]
    ParaContent(); print "recognise";! [7: end if]

    	.L_Say1126; .L_SayX1101;! [8: ~.~]
    ParaContent(); print "."; .L_Say1127; .L_SayX1102;rtrue;
];
Array TX_S_60 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_60;
[ R_TX_S_61 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~That's not something you need to refer to in the course of this game.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~That's not something you need to refer to in the course of this game.~]
    say__p=1;! [2: ~That's not something you need to refer to in the course of this game.~]
    ParaContent(); print "That's not something you need to refer to in the course of this game."; .L_Say1128; .L_SayX1103;rtrue;
];
Array TX_S_61 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_61;
[ R_TX_S_62 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~I didn't understand the way that finished.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~I didn't understand the way that finished.~]
    say__p=1;! [2: ~I didn't understand the way that finished.~]
    ParaContent(); print "I didn't understand the way that finished."; .L_Say1129; .L_SayX1104;rtrue;
];
Array TX_S_62 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_62;
[ R_TX_S_63 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if number understood is 0]None[otherwise]Only [number understood in words][end if]
    of those [regarding the number understood][are] available.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if number understood is 0]None[otherwise]Only [number understood in words][end if] of those [regarding the number understood][are] available.~]
    say__p=1;! [2: if number understood is 0]

    	if (~~((((parsed_number == 0))))) jump L_Say1130;! [3: ~None~]
    ParaContent(); print "None";! [4: otherwise]

    	jump L_SayX1105; .L_Say1130;! [5: ~Only ~]
    ParaContent(); print "Only ";! [6: number understood in words]
    ParaContent(); print (number) say__n=(parsed_number);! [7: end if]

    	.L_Say1131; .L_SayX1105;! [8: ~ of those ~]
    ParaContent(); print " of those ";! [9: regarding the number understood]
    ParaContent(); RegardingNumber(parsed_number);! [10: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [11: ~ available.~]
    ParaContent(); print " available."; .L_Say1132; .L_SayX1106;rtrue;
];
Array TX_S_63 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_63;
[ R_TX_S_65 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~To repeat a command like 'frog, jump', just say 'again', not 'frog, again'.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~To repeat a command like 'frog, jump', just say 'again', not 'frog, again'.~]
    say__p=1;! [2: ~To repeat a command like 'frog, jump', just say 'again', not 'frog, again'.~]
    ParaContent(); print "To repeat a command like ~frog, jump~, just say ~again~, not ~frog, again~."; .L_Say1133; .L_SayX1107;rtrue;
];
Array TX_S_65 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_65;
[ R_TX_S_66 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You can't begin with a comma.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You can't begin with a comma.~]
    say__p=1;! [2: ~You can't begin with a comma.~]
    ParaContent(); print "You can't begin with a comma."; .L_Say1134; .L_SayX1108;rtrue;
];
Array TX_S_66 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_66;
[ R_TX_S_67 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You seem to want to talk to someone, but I can't see whom.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You seem to want to talk to someone, but I can't see whom.~]
    say__p=1;! [2: ~You seem to want to talk to someone, but I can't see whom.~]
    ParaContent(); print "You seem to want to talk to someone, but I can't see whom."; .L_Say1135; .L_SayX1109;rtrue;
];
Array TX_S_67 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_67;
[ R_TX_S_68 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You can't talk to [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You can't talk to [the noun].~]
    say__p=1;! [2: ~You can't talk to ~]
    ParaContent(); print "You can't talk to ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~.~]
    ParaContent(); print "."; .L_Say1136; .L_SayX1110;rtrue;
];
Array TX_S_68 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_68;
[ R_TX_S_69 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~To talk to someone, try 'someone, hello' or some such.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~To talk to someone, try 'someone, hello' or some such.~]
    say__p=1;! [2: ~To talk to someone, try 'someone, hello' or some such.~]
    ParaContent(); print "To talk to someone, try ~someone, hello~ or some such."; .L_Say1137; .L_SayX1111;rtrue;
];
Array TX_S_69 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_69;
[ R_TX_S_70 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~I beg your pardon?~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~I beg your pardon?~]
    say__p=1;! [2: ~I beg your pardon?~]
    ParaContent(); print "I beg your pardon?"; .L_Say1138; .L_SayX1112;rtrue;
];
Array TX_S_70 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_70;
[ R_TX_S_71 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Nothing to do!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Nothing to do!~]
    say__p=1;! [2: ~Nothing to do!~]
    ParaContent(); print "Nothing to do!"; .L_Say1139; .L_SayX1113;rtrue;
];
Array TX_S_71 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_71;
[ R_TX_S_72 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [adapt the verb are from the third person plural] none at all available!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[There] [adapt the verb are from the third person plural] none at all available!~]
    say__p=1;! [2: there]
    ParaContent(); (PHR_788_r104 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: adapt the verb are from the third person plural]
    ParaContent(); ConjugateVerb_0(CV_POS, I123_third_person_plural, story_tense);! [5: ~ none at all available!~]
    ParaContent(); print " none at all available!"; .L_Say1140; .L_SayX1114;rtrue;
];
Array TX_S_72 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_72;
[ R_TX_S_73 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][Those] [seem] to belong to [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][Those] [seem] to belong to [the noun].~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: those]
    ParaContent(); (PHR_772_r39 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: seem]
    ConjugateVerb_55(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ to belong to ~]
    ParaContent(); print " to belong to ";! [7: the noun]
    ParaContent(); print (the) noun;! [8: ~.~]
    ParaContent(); print "."; .L_Say1141; .L_SayX1115;rtrue;
];
Array TX_S_73 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_73;
[ R_TX_S_74 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][Those] [can't] contain things.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][Those] [can't] contain things.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: those]
    ParaContent(); (PHR_772_r39 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: can't]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ contain things.~]
    ParaContent(); print " contain things."; .L_Say1142; .L_SayX1116;rtrue;
];
Array TX_S_74 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_74;
[ R_TX_S_75 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [aren't] open.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [aren't] open.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ open.~]
    ParaContent(); print " open."; .L_Say1143; .L_SayX1117;rtrue;
];
Array TX_S_75 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_75;
[ R_TX_S_76 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [are] empty.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [are] empty.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ empty.~]
    ParaContent(); print " empty."; .L_Say1144; .L_SayX1118;rtrue;
];
Array TX_S_76 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_76;
[ R_TX_S_77 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Darkness~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Darkness~]
    say__p=1;! [2: ~Darkness~]
    ParaContent(); print "Darkness"; .L_Say1145; .L_SayX1119;rtrue;
];
Array TX_S_77 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_77;
[ R_TX_S_78 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Sorry, that can't be corrected.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Sorry, that can't be corrected.~]
    say__p=1;! [2: ~Sorry, that can't be corrected.~]
    ParaContent(); print "Sorry, that can't be corrected."; .L_Say1146; .L_SayX1120;rtrue;
];
Array TX_S_78 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_78;
[ R_TX_S_79 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Think nothing of it.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Think nothing of it.~]
    say__p=1;! [2: ~Think nothing of it.~]
    ParaContent(); print "Think nothing of it."; .L_Say1147; .L_SayX1121;rtrue;
];
Array TX_S_79 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_79;
[ R_TX_S_80 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~'Oops' can only correct a single word.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~'Oops' can only correct a single word.~]
    say__p=1;! [2: ~'Oops' can only correct a single word.~]
    ParaContent(); print "~Oops~ can only correct a single word."; .L_Say1148; .L_SayX1122;rtrue;
];
Array TX_S_80 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_80;
[ R_TX_S_81 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You can hardly repeat that.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You can hardly repeat that.~]
    say__p=1;! [2: ~You can hardly repeat that.~]
    ParaContent(); print "You can hardly repeat that."; .L_Say1149; .L_SayX1123;rtrue;
];
Array TX_S_81 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_81;
[ R_TX_S_82 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Who do you mean, ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Who do you mean, ~]
    say__p=1;! [2: ~Who do you mean, ~]
    ParaContent(); print "Who do you mean, "; .L_Say1150; .L_SayX1124;rtrue;
];
Array TX_S_82 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_82;
[ R_TX_S_83 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Which do you mean, ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Which do you mean, ~]
    say__p=1;! [2: ~Which do you mean, ~]
    ParaContent(); print "Which do you mean, "; .L_Say1151; .L_SayX1125;rtrue;
];
Array TX_S_83 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_83;
[ R_TX_S_84 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Sorry, you can only have one item here. Which exactly?~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Sorry, you can only have one item here. Which exactly?~]
    say__p=1;! [2: ~Sorry, you can only have one item here. Which exactly?~]
    ParaContent(); print "Sorry, you can only have one item here. Which exactly?"; .L_Say1152; .L_SayX1126;rtrue;
];
Array TX_S_84 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_84;
[ R_TX_S_85 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Whom do you want [if the noun is not the player][the noun] [end if]to
    [parser command so far]?~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Whom do you want [if the noun is not the player][the noun] [end if]to [parser command so far]?~]
    say__p=1;! [2: ~Whom do you want ~]
    ParaContent(); print "Whom do you want ";! [3: if the noun is not the player]

    	if (~~((((~~((noun == player))))))) jump L_Say1153;! [4: the noun]
    ParaContent(); print (the) noun;! [5: ~ ~]
    ParaContent(); print " ";! [6: end if]

    	.L_Say1153; .L_SayX1127;! [7: ~to ~]
    ParaContent(); print "to ";! [8: parser command so far]
    ParaContent(); PrintCommand();! [9: ~?~]
    ParaContent(); print "?"; .L_Say1154; .L_SayX1128;rtrue;
];
Array TX_S_85 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_85;
[ R_TX_S_86 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~What do you want [if the noun is not the player][the noun] [end if]to
    [parser command so far]?~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~What do you want [if the noun is not the player][the noun] [end if]to [parser command so far]?~]
    say__p=1;! [2: ~What do you want ~]
    ParaContent(); print "What do you want ";! [3: if the noun is not the player]

    	if (~~((((~~((noun == player))))))) jump L_Say1155;! [4: the noun]
    ParaContent(); print (the) noun;! [5: ~ ~]
    ParaContent(); print " ";! [6: end if]

    	.L_Say1155; .L_SayX1129;! [7: ~to ~]
    ParaContent(); print "to ";! [8: parser command so far]
    ParaContent(); PrintCommand();! [9: ~?~]
    ParaContent(); print "?"; .L_Say1156; .L_SayX1130;rtrue;
];
Array TX_S_86 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_86;
[ R_TX_S_87 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~those things~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~those things~]
    say__p=1;! [2: ~those things~]
    ParaContent(); print "those things"; .L_Say1157; .L_SayX1131;rtrue;
];
Array TX_S_87 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_87;
[ R_TX_S_88 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~that~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~that~]
    say__p=1;! [2: ~that~]
    ParaContent(); print "that"; .L_Say1158; .L_SayX1132;rtrue;
];
Array TX_S_88 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_88;
[ R_TX_S_89 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ or ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ or ~]
    say__p=1;! [2: ~ or ~]
    ParaContent(); print " or "; .L_Say1159; .L_SayX1133;rtrue;
];
Array TX_S_89 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_89;
[ R_TX_S_90 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Please answer yes or no.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Please answer yes or no.~]
    say__p=1;! [2: ~Please answer yes or no.~]
    ParaContent(); print "Please answer yes or no."; .L_Say1160; .L_SayX1134;rtrue;
];
Array TX_S_90 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_90;
[ R_TX_S_91 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We]~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ()); .L_Say1161; .L_SayX1135;rtrue;
];
Array TX_S_91 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_91;
[ R_TX_S_92 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[ourselves]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[ourselves]~]
    say__p=1;! [2: ourselves]
    ParaContent(); (PHR_762_r25 ()); .L_Say1162; .L_SayX1136;rtrue;
];
Array TX_S_92 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_92;
[ R_TX_S_93 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[our] former self~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[our] former self~]
    say__p=1;! [2: our]
    ParaContent(); (PHR_763_r32 ());! [3: ~ former self~]
    ParaContent(); print " former self"; .L_Say1163; .L_SayX1137;rtrue;
];
Array TX_S_93 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_93;
[ R_TX_S_94 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(first taking [the noun])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(first taking [the noun])[command clarification break]~]
    say__p=1;! [2: ~(first taking ~]
    ParaContent(); print "(first taking ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1164; .L_SayX1138;rtrue;
];
Array TX_S_94 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_94;
[ R_TX_S_95 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~([the second noun] first taking [the noun])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~([the second noun] first taking [the noun])[command clarification break]~]
    say__p=1;! [2: ~(~]
    ParaContent(); print "(";! [3: the second noun]
    ParaContent(); print (the) second;! [4: ~ first taking ~]
    ParaContent(); print " first taking ";! [5: the noun]
    ParaContent(); print (the) noun;! [6: ~)~]
    ParaContent(); print ")";! [7: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1165; .L_SayX1139;rtrue;
];
Array TX_S_95 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_95;
[ R_TX_S_96 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ You have died ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ You have died ~]
    say__p=1;! [2: ~ You have died ~]
    ParaContent(); print " You have died "; .L_Say1166; .L_SayX1140;rtrue;
];
Array TX_S_96 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_96;
[ R_TX_S_97 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ You have won ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ You have won ~]
    say__p=1;! [2: ~ You have won ~]
    ParaContent(); print " You have won "; .L_Say1167; .L_SayX1141;rtrue;
];
Array TX_S_97 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_97;
[ R_TX_S_98 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ The End ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ The End ~]
    say__p=1;! [2: ~ The End ~]
    ParaContent(); print " The End "; .L_Say1168; .L_SayX1142;rtrue;
];
Array TX_S_98 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_98;
[ R_TX_S_99 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The use of 'undo' is forbidden in this story.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~The use of 'undo' is forbidden in this story.~]
    say__p=1;! [2: ~The use of 'undo' is forbidden in this story.~]
    ParaContent(); print "The use of ~undo~ is forbidden in this story."; .L_Say1169; .L_SayX1143;rtrue;
];
Array TX_S_99 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_99;
[ R_TX_S_100 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You can't 'undo' what hasn't been done!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You can't 'undo' what hasn't been done!~]
    say__p=1;! [2: ~You can't 'undo' what hasn't been done!~]
    ParaContent(); print "You can't ~undo~ what hasn't been done!"; .L_Say1170; .L_SayX1144;rtrue;
];
Array TX_S_100 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_100;
[ R_TX_S_101 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Your interpreter does not provide 'undo'. Sorry!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Your interpreter does not provide 'undo'. Sorry!~]
    say__p=1;! [2: ~Your interpreter does not provide 'undo'. Sorry!~]
    ParaContent(); print "Your interpreter does not provide ~undo~. Sorry!"; .L_Say1171; .L_SayX1145;rtrue;
];
Array TX_S_101 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_101;
[ R_TX_S_102 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~'Undo' failed. Sorry!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~'Undo' failed. Sorry!~]
    say__p=1;! [2: ~'Undo' failed. Sorry!~]
    ParaContent(); print "~Undo~ failed. Sorry!"; .L_Say1172; .L_SayX1146;rtrue;
];
Array TX_S_102 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_102;
[ R_TX_S_103 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bracket]Previous turn undone.[close bracket]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[bracket]Previous turn undone.[close bracket]~]
    say__p=1;! [2: bracket]
    ParaContent(); print "[";! [3: ~Previous turn undone.~]
    ParaContent(); print "Previous turn undone.";! [4: close bracket]
    ParaContent(); print "]"; .L_Say1173; .L_SayX1147;rtrue;
];
Array TX_S_103 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_103;
[ R_TX_S_104 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~'Undo' capacity exhausted. Sorry!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~'Undo' capacity exhausted. Sorry!~]
    say__p=1;! [2: ~'Undo' capacity exhausted. Sorry!~]
    ParaContent(); print "~Undo~ capacity exhausted. Sorry!"; .L_Say1174; .L_SayX1148;rtrue;
];
Array TX_S_104 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_104;
[ R_TX_S_105 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Are you sure you want to quit? ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Are you sure you want to quit? ~]
    say__p=1;! [2: ~Are you sure you want to quit? ~]
    ParaContent(); print "Are you sure you want to quit? "; .L_Say1175; .L_SayX1149;rtrue;
];
Array TX_S_105 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_105;
[ R_TX_S_106 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Save failed.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Save failed.~]
    say__p=1;! [2: ~Save failed.~]
    ParaContent(); print "Save failed."; .L_Say1176; .L_SayX1150;rtrue;
];
Array TX_S_106 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_106;
[ R_TX_S_107 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Ok.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Ok.~]
    say__p=1;! [2: ~Ok.~]
    ParaContent(); print "Ok."; .L_Say1177; .L_SayX1151;rtrue;
];
Array TX_S_107 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_107;
[ R_TX_S_108 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Restore failed.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Restore failed.~]
    say__p=1;! [2: ~Restore failed.~]
    ParaContent(); print "Restore failed."; .L_Say1178; .L_SayX1152;rtrue;
];
Array TX_S_108 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_108;
[ R_TX_S_109 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Ok.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Ok.~]
    say__p=1;! [2: ~Ok.~]
    ParaContent(); print "Ok."; .L_Say1179; .L_SayX1153;rtrue;
];
Array TX_S_109 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_109;
[ R_TX_S_110 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Are you sure you want to restart? ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Are you sure you want to restart? ~]
    say__p=1;! [2: ~Are you sure you want to restart? ~]
    ParaContent(); print "Are you sure you want to restart? "; .L_Say1180; .L_SayX1154;rtrue;
];
Array TX_S_110 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_110;
[ R_TX_S_111 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Failed.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Failed.~]
    say__p=1;! [2: ~Failed.~]
    ParaContent(); print "Failed."; .L_Say1181; .L_SayX1155;rtrue;
];
Array TX_S_111 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_111;
[ R_TX_S_112 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The game file has verified as intact.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~The game file has verified as intact.~]
    say__p=1;! [2: ~The game file has verified as intact.~]
    ParaContent(); print "The game file has verified as intact."; .L_Say1182; .L_SayX1156;rtrue;
];
Array TX_S_112 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_112;
[ R_TX_S_113 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~The game file did not verify as intact, and may be corrupt.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~The game file did not verify as intact, and may be corrupt.~]
    say__p=1;! [2: ~The game file did not verify as intact, and may be corrupt.~]
    ParaContent(); print "The game file did not verify as intact, and may be corrupt."; .L_Say1183; .L_SayX1157;rtrue;
];
Array TX_S_113 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_113;
[ R_TX_S_114 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Transcripting is already on.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Transcripting is already on.~]
    say__p=1;! [2: ~Transcripting is already on.~]
    ParaContent(); print "Transcripting is already on."; .L_Say1184; .L_SayX1158;rtrue;
];
Array TX_S_114 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_114;
[ R_TX_S_115 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Start of a transcript of~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Start of a transcript of~]
    say__p=1;! [2: ~Start of a transcript of~]
    ParaContent(); print "Start of a transcript of"; .L_Say1185; .L_SayX1159;rtrue;
];
Array TX_S_115 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_115;
[ R_TX_S_116 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Attempt to begin transcript failed.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Attempt to begin transcript failed.~]
    say__p=1;! [2: ~Attempt to begin transcript failed.~]
    ParaContent(); print "Attempt to begin transcript failed."; .L_Say1186; .L_SayX1160;rtrue;
];
Array TX_S_116 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_116;
[ R_TX_S_117 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Transcripting is already off.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Transcripting is already off.~]
    say__p=1;! [2: ~Transcripting is already off.~]
    ParaContent(); print "Transcripting is already off."; .L_Say1187; .L_SayX1161;rtrue;
];
Array TX_S_117 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_117;
[ R_TX_S_118 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[line break]End of transcript.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[line break]End of transcript.~]
    say__p=1;! [2: line break]
    ParaContent(); new_line;! [3: ~End of transcript.~]
    ParaContent(); print "End of transcript."; .L_Say1188; .L_SayX1162;rtrue;
];
Array TX_S_118 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_118;
[ R_TX_S_119 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Attempt to end transcript failed.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Attempt to end transcript failed.~]
    say__p=1;! [2: ~Attempt to end transcript failed.~]
    ParaContent(); print "Attempt to end transcript failed."; .L_Say1189; .L_SayX1163;rtrue;
];
Array TX_S_119 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_119;
[ R_TX_S_120 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the story has ended]In that game you scored[otherwise]You have so far scored[end if]
    [score] out of a possible [maximum score], in [turn count] turn[s]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if the story has ended]In that game you scored[otherwise]You have so far scored[end if] [score] out of a possible [maximum score], in [turn count] turn[s]~]
    say__p=1;! [2: if the story has ended]

    	if (~~((((deadflag~=0))))) jump L_Say1190;! [3: ~In that game you scored~]
    ParaContent(); print "In that game you scored";! [4: otherwise]

    	jump L_SayX1164; .L_Say1190;! [5: ~You have so far scored~]
    ParaContent(); print "You have so far scored";! [6: end if]

    	.L_Say1191; .L_SayX1164;! [7: ~ ~]
    ParaContent(); print " ";! [8: score]
    ParaContent(); print (say__n=score);! [9: ~ out of a possible ~]
    ParaContent(); print " out of a possible ";! [10: maximum score]
    ParaContent(); print (say__n=MAX_SCORE);! [11: ~, in ~]
    ParaContent(); print ", in ";! [12: turn count]
    ParaContent(); print (say__n=turns);! [13: ~ turn~]
    ParaContent(); print " turn";! [14: s]
    ParaContent(); STextSubstitution(); .L_Say1192; .L_SayX1165;rtrue;
];
Array TX_S_120 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_120;
[ R_TX_S_121 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, earning you the rank of ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~, earning you the rank of ~]
    say__p=1;! [2: ~, earning you the rank of ~]
    ParaContent(); print ", earning you the rank of "; .L_Say1193; .L_SayX1166;rtrue;
];
Array TX_S_121 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_121;
[ R_TX_S_122 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no score in this story.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[There] [are] no score in this story.~]
    say__p=1;! [2: there]
    ParaContent(); (PHR_788_r104 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ no score in this story.~]
    ParaContent(); print " no score in this story."; .L_Say1194; .L_SayX1167;rtrue;
];
Array TX_S_122 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_122;
[ R_TX_S_123 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bracket]Your score has just gone up by [number understood in words]
    point[s].[close bracket]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[bracket]Your score has just gone up by [number understood in words] point[s].[close bracket]~]
    say__p=1;! [2: bracket]
    ParaContent(); print "[";! [3: ~Your score has just gone up by ~]
    ParaContent(); print "Your score has just gone up by ";! [4: number understood in words]
    ParaContent(); print (number) say__n=(parsed_number);! [5: ~ point~]
    ParaContent(); print " point";! [6: s]
    ParaContent(); STextSubstitution();! [7: ~.~]
    ParaContent(); print ".";! [8: close bracket]
    ParaContent(); print "]"; .L_Say1195; .L_SayX1168;rtrue;
];
Array TX_S_123 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_123;
[ R_TX_S_124 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[bracket]Your score has just gone down by [number understood in words]
    point[s].[close bracket]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[bracket]Your score has just gone down by [number understood in words] point[s].[close bracket]~]
    say__p=1;! [2: bracket]
    ParaContent(); print "[";! [3: ~Your score has just gone down by ~]
    ParaContent(); print "Your score has just gone down by ";! [4: number understood in words]
    ParaContent(); print (number) say__n=(parsed_number);! [5: ~ point~]
    ParaContent(); print " point";! [6: s]
    ParaContent(); STextSubstitution();! [7: ~.~]
    ParaContent(); print ".";! [8: close bracket]
    ParaContent(); print "]"; .L_Say1196; .L_SayX1169;rtrue;
];
Array TX_S_124 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_124;
[ R_TX_S_125 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ is now in its 'superbrief' mode, which always gives short descriptions
    of locations (even if you haven't been there before).~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ is now in its 'superbrief' mode, which always gives short descriptions of locations (even if you haven't been there before).~]
    say__p=1;! [2: ~ is now in its 'superbrief' mode, which always gives short descriptions of locations (even if you haven't been there before).~]
    ParaContent(); print " is now in its ~superbrief~ mode, which always gives short descriptions of locations (even if you haven't been there before)."; .L_Say1197; .L_SayX1170;rtrue;
];
Array TX_S_125 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_125;
[ R_TX_S_126 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ is now in its 'verbose' mode, which always gives long descriptions of
    locations (even if you've been there before).~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ is now in its 'verbose' mode, which always gives long descriptions of locations (even if you've been there before).~]
    say__p=1;! [2: ~ is now in its 'verbose' mode, which always gives long descriptions of locations (even if you've been there before).~]
    ParaContent(); print " is now in its ~verbose~ mode, which always gives long descriptions of locations (even if you've been there before)."; .L_Say1198; .L_SayX1171;rtrue;
];
Array TX_S_126 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_126;
[ R_TX_S_127 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ is now in its 'brief' printing mode, which gives long descriptions
    of places never before visited and short descriptions otherwise.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ is now in its 'brief' printing mode, which gives long descriptions of places never before visited and short descriptions otherwise.~]
    say__p=1;! [2: ~ is now in its 'brief' printing mode, which gives long descriptions of places never before visited and short descriptions otherwise.~]
    ParaContent(); print " is now in its ~brief~ printing mode, which gives long descriptions of places never before visited and short descriptions otherwise."; .L_Say1199; .L_SayX1172;rtrue;
];
Array TX_S_127 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_127;
[ R_TX_S_128 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Score notification on.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Score notification on.~]
    say__p=1;! [2: ~Score notification on.~]
    ParaContent(); print "Score notification on."; .L_Say1200; .L_SayX1173;rtrue;
];
Array TX_S_128 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_128;
[ R_TX_S_129 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Score notification off.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Score notification off.~]
    say__p=1;! [2: ~Score notification off.~]
    ParaContent(); print "Score notification off."; .L_Say1201; .L_SayX1174;rtrue;
];
Array TX_S_129 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_129;
[ R_TX_S_130 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~At the moment, ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~At the moment, ~]
    say__p=1;! [2: ~At the moment, ~]
    ParaContent(); print "At the moment, "; .L_Say1202; .L_SayX1175;rtrue;
];
Array TX_S_130 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_130;
[ R_TX_S_131 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~means ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~means ~]
    say__p=1;! [2: ~means ~]
    ParaContent(); print "means "; .L_Say1203; .L_SayX1176;rtrue;
];
Array TX_S_131 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_131;
[ R_TX_S_132 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~is unset~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~is unset~]
    say__p=1;! [2: ~is unset~]
    ParaContent(); print "is unset"; .L_Say1204; .L_SayX1177;rtrue;
];
Array TX_S_132 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_132;
[ R_TX_S_133 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~no pronouns are known to the game.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~no pronouns are known to the game.~]
    say__p=1;! [2: ~no pronouns are known to the game.~]
    ParaContent(); print "no pronouns are known to the game."; .L_Say1205; .L_SayX1178;rtrue;
];
Array TX_S_133 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_133;
[ R_TX_S_235 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[current item from the multiple object list]: [run paragraph on]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[current item from the multiple object list]: [run paragraph on]~]
    say__p=1;! [2: current item from the multiple object list]
    ParaContent(); PrintShortName(multiple_object_item);! [3: ~: ~]
    ParaContent(); print ": ";! [4: run paragraph on]
    ParaContent(); RunParagraphOn(); .L_Say1206; .L_SayX1179;rtrue;
];
Array TX_S_235 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_235;
[ R_TX_S_236 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The current interlocutor] [aren't] [here].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The current interlocutor] [aren't] [here].~]
    say__p=1;! [2: the current interlocutor]
    ParaContent(); print (The) (Global_Vars-->11);! [3: ~ ~]
    ParaContent(); print " ";! [4: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: here]
    ParaContent(); (PHR_517_r51 ());! [7: ~.~]
    ParaContent(); print "."; .L_Say1207; .L_SayX1180;rtrue;
];
Array TX_S_236 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_236;
[ R_TX_S_237 
    tmp_0 ! Let/loop value, e.g., 'np': number
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There's] no one [here] to talk to.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[There's] no one [here] to talk to.~]
    say__p=1;! [2: there's]
    ParaContent(); (PHR_792_r50 ());! [3: ~ no one ~]
    ParaContent(); print " no one ";! [4: here]
    ParaContent(); (PHR_517_r51 ());! [5: ~ to talk to.~]
    ParaContent(); print " to talk to."; .L_Say1208; .L_SayX1181;rtrue;
];
Array TX_S_237 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_237;
[ R_TX_S_238 
    tmp_0 ! Let/loop value, e.g., 'np': number
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You need to specify who you want to speak to.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You need to specify who you want to speak to.~]
    say__p=1;! [2: ~You need to specify who you want to speak to.~]
    ParaContent(); print "You need to specify who you want to speak to."; .L_Say1209; .L_SayX1182;rtrue;
];
Array TX_S_238 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_238;
[ R_TX_S_239 
    tmp_0 ! Let/loop value, e.g., 'np': number
    tmp_1 ! Let/loop value, e.g., 'interlocutor': thing
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(addressing [the interlocutor])~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(addressing [the interlocutor])~]
    say__p=1;! [2: ~(addressing ~]
    ParaContent(); print "(addressing ";! [3: the interlocutor]
    ParaContent(); print (the) tmp_1;! [4: ~)~]
    ParaContent(); print ")"; .L_Say1210; .L_SayX1183;rtrue;
];
Array TX_S_239 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_239;
[ R_TX_S_240 
    tmp_0 ! Let/loop value, e.g., 'np': number
    tmp_1 ! Let/loop value, e.g., 'interlocutor': thing
    tmp_2 ! Let/loop value: object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [aren't] talking to anyone.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [aren't] talking to anyone.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ talking to anyone.~]
    ParaContent(); print " talking to anyone."; .L_Say1211; .L_SayX1184;rtrue;
];
Array TX_S_240 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_240;
[ R_TX_S_241 
    tmp_0 ! Let/loop value, e.g., 'P': person
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~You can't touch [P].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You can't touch [P].~]
    say__p=1;! [2: ~You can't touch ~]
    ParaContent(); print "You can't touch ";! [3: p]
    ParaContent(); PrintShortName(tmp_0);! [4: ~.~]
    ParaContent(); print "."; .L_Say1212; .L_SayX1185;rtrue;
];
Array TX_S_241 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_241;
[ R_TX_S_242 
    tmp_0 ! Let/loop value, e.g., 'P': person
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~You can't see [P].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You can't see [P].~]
    say__p=1;! [2: ~You can't see ~]
    ParaContent(); print "You can't see ";! [3: p]
    ParaContent(); PrintShortName(tmp_0);! [4: ~.~]
    ParaContent(); print "."; .L_Say1213; .L_SayX1186;rtrue;
];
Array TX_S_242 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_242;
[ R_TX_S_243 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    @push formal_par0;
    I7RBLK = KERNEL_114();
    @pull formal_par0;
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_114 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[wall description for location][line break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[wall description for location][line break]~]
    say__p=1;! [2: wall description for location]
    ParaContent(); print (TEXT_TY_Say) 
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K1_room) && (formal_par0 ofclass K1_room))))) && ((
                    formal_rv = (PHR_1063_r146 (I7SFRAME,formal_par0))) | 1)
                    )|| (ArgumentTypeFailed(1))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par0 = real_location)
                ))
        )

    ! Resolution complete
    ;! [3: line break]
    ParaContent(); new_line; .L_Say1214; .L_SayX1187;rtrue;
];
Array TX_S_243 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_243;
[ R_TX_S_244 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    @push formal_par0;
    I7RBLK = KERNEL_115();
    @pull formal_par0;
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_115 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[wall touch description for location][line break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[wall touch description for location][line break]~]
    say__p=1;! [2: wall touch description for location]
    ParaContent(); print (TEXT_TY_Say) 
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K1_room) && (formal_par0 ofclass K1_room))))) && ((
                    formal_rv = (PHR_1066_r147 (I7SFRAME,formal_par0))) | 1)
                    )|| (ArgumentTypeFailed(1))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par0 = real_location)
                ))
        )

    ! Resolution complete
    ;! [3: line break]
    ParaContent(); new_line; .L_Say1215; .L_SayX1188;rtrue;
];
Array TX_S_244 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_244;
[ R_TX_S_245 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    @push formal_par0;
    I7RBLK = KERNEL_116();
    @pull formal_par0;
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_116 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[floor description for location][line break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[floor description for location][line break]~]
    say__p=1;! [2: floor description for location]
    ParaContent(); print (TEXT_TY_Say) 
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K1_room) && (formal_par0 ofclass K1_room))))) && ((
                    formal_rv = (PHR_1077_r148 (I7SFRAME,formal_par0))) | 1)
                    )|| (ArgumentTypeFailed(1))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par0 = real_location)
                ))
        )

    ! Resolution complete
    ;! [3: line break]
    ParaContent(); new_line; .L_Say1216; .L_SayX1189;rtrue;
];
Array TX_S_245 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_245;
[ R_TX_S_246 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    @push formal_par0;
    I7RBLK = KERNEL_117();
    @pull formal_par0;
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_117 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[ceiling description for location][line break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[ceiling description for location][line break]~]
    say__p=1;! [2: ceiling description for location]
    ParaContent(); print (TEXT_TY_Say) 
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K1_room) && (formal_par0 ofclass K1_room))))) && ((
                    formal_rv = (PHR_1092_r149 (I7SFRAME,formal_par0))) | 1)
                    )|| (ArgumentTypeFailed(1))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par0 = real_location)
                ))
        )

    ! Resolution complete
    ;! [3: line break]
    ParaContent(); new_line; .L_Say1217; .L_SayX1190;rtrue;
];
Array TX_S_246 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_246;
[ R_TX_S_248 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You'll have to say which compass direction to go in.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You'll have to say which compass direction to go in.~]
    say__p=1;! [2: ~You'll have to say which compass direction to go in.~]
    ParaContent(); print "You'll have to say which compass direction to go in."; .L_Say1218; .L_SayX1191;rtrue;
];
Array TX_S_248 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_248;
[ R_TX_S_249 
    tmp_0 ! Let/loop value, e.g., 'named options count': number
    tmp_1 ! Let/loop value: object
    tmp_2 ! Let/loop value: object
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Would you like to ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Would you like to ~]
    say__p=1;! [2: ~Would you like to ~]
    ParaContent(); print "Would you like to "; .L_Say1219; .L_SayX1192;rtrue;
];
Array TX_S_249 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_249;
[ R_TX_S_250 
    tmp_0 ! Let/loop value, e.g., 'named options count': number
    tmp_1 ! Let/loop value: object
    tmp_2 ! Let/loop value: object
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ or ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ or ~]
    say__p=1;! [2: ~ or ~]
    ParaContent(); print " or "; .L_Say1220; .L_SayX1193;rtrue;
];
Array TX_S_250 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_250;
[ R_TX_S_251 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~> [run paragraph on]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~> [run paragraph on]~]
    say__p=1;! [2: ~> ~]
    ParaContent(); print "> ";! [3: run paragraph on]
    ParaContent(); RunParagraphOn(); .L_Say1221; .L_SayX1194;rtrue;
];
Array TX_S_251 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_251;
[ R_TX_S_252 
    tmp_0 ! Let/loop value: object
    tmp_1 ! Let/loop value: object
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Please give one of the answers above.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Please give one of the answers above.~]
    say__p=1;! [2: ~Please give one of the answers above.~]
    ParaContent(); print "Please give one of the answers above."; .L_Say1222; .L_SayX1195;rtrue;
];
Array TX_S_252 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_252;
[ R_TX_S_253 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value: thing
    tmp_3 ! Let/loop value: thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Also here ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Also here ~]
    say__p=1;! [2: ~Also here ~]
    ParaContent(); print "Also here "; .L_Say1223; .L_SayX1196;rtrue;
];
Array TX_S_253 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_253;
[ R_TX_S_254 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value: thing
    tmp_3 ! Let/loop value: thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
tmp_3=LocalParking-->3;
ct_0=LocalParking-->4;
ct_1=LocalParking-->5;
#ifdef DEBUG; if (suppress_text_substitution) { print "~On [the domain] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~On [the domain] ~]
    say__p=1;! [2: ~On ~]
    ParaContent(); print "On ";! [3: the domain]
    ParaContent(); print (the) tmp_0;! [4: ~ ~]
    ParaContent(); print " "; .L_Say1224; .L_SayX1197;rtrue;
];
Array TX_S_254 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_254;
[ R_TX_S_255 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value: thing
    tmp_3 ! Let/loop value: thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
tmp_3=LocalParking-->3;
ct_0=LocalParking-->4;
ct_1=LocalParking-->5;
#ifdef DEBUG; if (suppress_text_substitution) { print "~In [the domain] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~In [the domain] ~]
    say__p=1;! [2: ~In ~]
    ParaContent(); print "In ";! [3: the domain]
    ParaContent(); print (the) tmp_0;! [4: ~ ~]
    ParaContent(); print " "; .L_Say1225; .L_SayX1198;rtrue;
];
Array TX_S_255 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_255;
[ R_TX_S_256 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    tmp_1 ! Let/loop value: thing
    tmp_2 ! Let/loop value: thing
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
#ifdef DEBUG; if (suppress_text_substitution) { print "~On [the item] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~On [the item] ~]
    say__p=1;! [2: ~On ~]
    ParaContent(); print "On ";! [3: the item]
    ParaContent(); print (the) tmp_0;! [4: ~ ~]
    ParaContent(); print " "; .L_Say1226; .L_SayX1199;rtrue;
];
Array TX_S_256 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_256;
[ R_TX_S_257 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    tmp_1 ! Let/loop value: thing
    tmp_2 ! Let/loop value: thing
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
#ifdef DEBUG; if (suppress_text_substitution) { print "~On [the item] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~On [the item] ~]
    say__p=1;! [2: ~On ~]
    ParaContent(); print "On ";! [3: the item]
    ParaContent(); print (the) tmp_0;! [4: ~ ~]
    ParaContent(); print " "; .L_Say1227; .L_SayX1200;rtrue;
];
Array TX_S_257 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_257;
[ R_TX_S_258 
    tmp_0 ! Let/loop value, e.g., 'item': thing
    tmp_1 ! Let/loop value: thing
    tmp_2 ! Let/loop value: thing
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
#ifdef DEBUG; if (suppress_text_substitution) { print "~On [the item] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~On [the item] ~]
    say__p=1;! [2: ~On ~]
    ParaContent(); print "On ";! [3: the item]
    ParaContent(); print (the) tmp_0;! [4: ~ ~]
    ParaContent(); print " "; .L_Say1228; .L_SayX1201;rtrue;
];
Array TX_S_258 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_258;
[ R_TX_S_259 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [are] carrying nothing.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [are] carrying nothing.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ carrying nothing.~]
    ParaContent(); print " carrying nothing."; .L_Say1229; .L_SayX1202;rtrue;
];
Array TX_S_259 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_259;
[ R_TX_S_260 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [are] carrying:[line break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [are] carrying:[line break]~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ carrying:~]
    ParaContent(); print " carrying:";! [6: line break]
    ParaContent(); new_line; .L_Say1230; .L_SayX1203;rtrue;
];
Array TX_S_260 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_260;
[ R_TX_S_261 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [look] through [their] possessions.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [look] through [their] possessions.~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: look]
    ConjugateVerb_43(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ through ~]
    ParaContent(); print " through ";! [6: their]
    ParaContent(); (PHR_777_r33 ());! [7: ~ possessions.~]
    ParaContent(); print " possessions."; .L_Say1231; .L_SayX1204;rtrue;
];
Array TX_S_261 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_261;
[ R_TX_S_262 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There are no walls.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~There are no walls.~]
    say__p=1;! [2: ~There are no walls.~]
    ParaContent(); print "There are no walls."; .L_Say1232; .L_SayX1205;rtrue;
];
Array TX_S_262 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_262;
[ R_TX_S_263 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There is no floor.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~There is no floor.~]
    say__p=1;! [2: ~There is no floor.~]
    ParaContent(); print "There is no floor."; .L_Say1233; .L_SayX1206;rtrue;
];
Array TX_S_263 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_263;
[ R_TX_S_264 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There is no ceiling.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~There is no ceiling.~]
    say__p=1;! [2: ~There is no ceiling.~]
    ParaContent(); print "There is no ceiling."; .L_Say1234; .L_SayX1207;rtrue;
];
Array TX_S_264 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_264;
[ R_TX_S_265 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [are] always self-possessed.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [are] always self-possessed.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ always self-possessed.~]
    ParaContent(); print " always self-possessed."; .L_Say1235; .L_SayX1208;rtrue;
];
Array TX_S_265 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_265;
[ R_TX_S_266 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~I don't suppose [the noun] [would care] for that.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~I don't suppose [the noun] [would care] for that.~]
    say__p=1;! [2: ~I don't suppose ~]
    ParaContent(); print "I don't suppose ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~ ~]
    ParaContent(); print " ";! [5: would care]
    ConjugateVerb_73(CV_POS, PNToVP(), story_tense, ConjugateVerb_24); say__p=1; ! [6: ~ for that.~]
    ParaContent(); print " for that."; .L_Say1236; .L_SayX1209;rtrue;
];
Array TX_S_266 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_266;
[ R_TX_S_267 
    tmp_0 ! Let/loop value, e.g., 'whole': thing
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][Those] [seem] to be a part of [the whole].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][Those] [seem] to be a part of [the whole].~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: those]
    ParaContent(); (PHR_772_r39 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: seem]
    ConjugateVerb_55(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ to be a part of ~]
    ParaContent(); print " to be a part of ";! [7: the whole]
    ParaContent(); print (the) tmp_0;! [8: ~.~]
    ParaContent(); print "."; .L_Say1237; .L_SayX1210;rtrue;
];
Array TX_S_267 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_267;
[ R_TX_S_268 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'owner': object
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][Those] [seem] to belong to [the owner].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][Those] [seem] to belong to [the owner].~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: those]
    ParaContent(); (PHR_772_r39 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: seem]
    ConjugateVerb_55(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ to belong to ~]
    ParaContent(); print " to belong to ";! [7: the owner]
    ParaContent(); print (the) tmp_1;! [8: ~.~]
    ParaContent(); print "."; .L_Say1238; .L_SayX1211;rtrue;
];
Array TX_S_268 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_268;
[ R_TX_S_269 
    tmp_0 ! Let/loop value, e.g., 'H': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][Those] [aren't] available.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][Those] [aren't] available.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: those]
    ParaContent(); (PHR_772_r39 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ available.~]
    ParaContent(); print " available."; .L_Say1239; .L_SayX1212;rtrue;
];
Array TX_S_269 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_269;
[ R_TX_S_270 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [would have] to get
    [if noun is a supporter]off[otherwise]out of[end if] [the noun] first.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [would have] to get [if noun is a supporter]off[otherwise]out of[end if] [the noun] first.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: would have]
    ConjugateVerb_73(CV_POS, PNToVP(), story_tense, ConjugateVerb_2); say__p=1; ! [5: ~ to get ~]
    ParaContent(); print " to get ";! [6: if noun is a supporter]

    	if (~~((((noun ofclass K6_supporter))))) jump L_Say1240;! [7: ~off~]
    ParaContent(); print "off";! [8: otherwise]

    	jump L_SayX1213; .L_Say1240;! [9: ~out of~]
    ParaContent(); print "out of";! [10: end if]

    	.L_Say1241; .L_SayX1213;! [11: ~ ~]
    ParaContent(); print " ";! [12: the noun]
    ParaContent(); print (the) noun;! [13: ~ first.~]
    ParaContent(); print " first."; .L_Say1242; .L_SayX1214;rtrue;
];
Array TX_S_270 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_270;
[ R_TX_S_271 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] already [have] [regarding the noun][those].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] already [have] [regarding the noun][those].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ already ~]
    ParaContent(); print " already ";! [4: have]
    ConjugateVerb_2(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [7: those]
    ParaContent(); (PHR_771_r91 ());! [8: ~.~]
    ParaContent(); print "."; .L_Say1243; .L_SayX1215;rtrue;
];
Array TX_S_271 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_271;
[ R_TX_S_273 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [cannot] carry [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [cannot] carry [the noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: cannot]
    ConjugateVerb_15(CV_NEG, PNToVP(), story_tense); say__p=1; ! [5: ~ carry ~]
    ParaContent(); print " carry ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1244; .L_SayX1216;rtrue;
];
Array TX_S_273 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_273;
[ R_TX_S_275 
    tmp_0 ! Let/loop value, e.g., 'current working sack': player's holdall
    tmp_1 ! Let/loop value, e.g., 'transferred item': object
    tmp_2 ! Let/loop value: thing
    tmp_3 ! Let/loop value: thing
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
tmp_3=LocalParking-->3;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(putting [the transferred item] into [the current working sack]
    to make room)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(putting [the transferred item] into [the current working sack] to make room)[command clarification break]~]
    say__p=1;! [2: ~(putting ~]
    ParaContent(); print "(putting ";! [3: the transferred item]
    ParaContent(); print (the) tmp_1;! [4: ~ into ~]
    ParaContent(); print " into ";! [5: the current working sack]
    ParaContent(); print (the) tmp_0;! [6: ~ to make room)~]
    ParaContent(); print " to make room)";! [7: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1245; .L_SayX1217;rtrue;
];
Array TX_S_275 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_275;
[ R_TX_S_276 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We]['re] carrying too many things already.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We]['re] carrying too many things already.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: 're]
    ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1; ! [4: ~ carrying too many things already.~]
    ParaContent(); print " carrying too many things already."; .L_Say1246; .L_SayX1218;rtrue;
];
Array TX_S_276 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_276;
[ R_TX_S_277 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Taken.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Taken.~]
    say__p=1;! [2: ~Taken.~]
    ParaContent(); print "Taken."; .L_Say1247; .L_SayX1219;rtrue;
];
Array TX_S_277 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_277;
[ R_TX_S_278 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [pick] up [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [pick] up [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: pick]
    ConjugateVerb_47(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ up ~]
    ParaContent(); print " up ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1248; .L_SayX1220;rtrue;
];
Array TX_S_278 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_278;
[ R_TX_S_279 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~But [regarding the noun][they] [aren't] there now.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~But [regarding the noun][they] [aren't] there now.~]
    say__p=1;! [2: ~But ~]
    ParaContent(); print "But ";! [3: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [4: they]
    ParaContent(); (PHR_775_r94 ());! [5: ~ ~]
    ParaContent(); print " ";! [6: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [7: ~ there now.~]
    ParaContent(); print " there now."; .L_Say1249; .L_SayX1221;rtrue;
];
Array TX_S_279 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_279;
[ R_TX_S_280 
    tmp_0 ! Let/loop value, e.g., 'owner': object
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][Those] [seem] to belong to [the owner].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][Those] [seem] to belong to [the owner].~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: those]
    ParaContent(); (PHR_772_r39 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: seem]
    ConjugateVerb_55(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ to belong to ~]
    ParaContent(); print " to belong to ";! [7: the owner]
    ParaContent(); print (the) tmp_0;! [8: ~.~]
    ParaContent(); print "."; .L_Say1250; .L_SayX1222;rtrue;
];
Array TX_S_280 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_280;
[ R_TX_S_281 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't drop] part of [ourselves].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't drop] part of [ourselves].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't drop]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_28); say__p=1; ! [5: ~ part of ~]
    ParaContent(); print " part of ";! [6: ourselves]
    ParaContent(); (PHR_762_r25 ());! [7: ~.~]
    ParaContent(); print "."; .L_Say1251; .L_SayX1223;rtrue;
];
Array TX_S_281 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_281;
[ R_TX_S_282 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [lack] the dexterity.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [lack] the dexterity.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: lack]
    ConjugateVerb_38(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ the dexterity.~]
    ParaContent(); print " the dexterity."; .L_Say1252; .L_SayX1224;rtrue;
];
Array TX_S_282 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_282;
[ R_TX_S_284 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [haven't] got [regarding the noun][those].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [haven't] got [regarding the noun][those].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: haven't]
    ConjugateVerb_78(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ got ~]
    ParaContent(); print " got ";! [6: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [7: those]
    ParaContent(); (PHR_771_r91 ());! [8: ~.~]
    ParaContent(); print "."; .L_Say1253; .L_SayX1225;rtrue;
];
Array TX_S_284 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_284;
[ R_TX_S_285 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(first taking [the noun] off)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(first taking [the noun] off)[command clarification break]~]
    say__p=1;! [2: ~(first taking ~]
    ParaContent(); print "(first taking ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~ off)~]
    ParaContent(); print " off)";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1254; .L_SayX1226;rtrue;
];
Array TX_S_285 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_285;
[ R_TX_S_286 
    tmp_0 ! Let/loop value, e.g., 'receptacle': object
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no more room on [the receptacle].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[There] [are] no more room on [the receptacle].~]
    say__p=1;! [2: there]
    ParaContent(); (PHR_788_r104 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ no more room on ~]
    ParaContent(); print " no more room on ";! [6: the receptacle]
    ParaContent(); print (the) tmp_0;! [7: ~.~]
    ParaContent(); print "."; .L_Say1255; .L_SayX1227;rtrue;
];
Array TX_S_286 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_286;
[ R_TX_S_287 
    tmp_0 ! Let/loop value, e.g., 'receptacle': object
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no more room in [the receptacle].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[There] [are] no more room in [the receptacle].~]
    say__p=1;! [2: there]
    ParaContent(); (PHR_788_r104 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ no more room in ~]
    ParaContent(); print " no more room in ";! [6: the receptacle]
    ParaContent(); print (the) tmp_0;! [7: ~.~]
    ParaContent(); print "."; .L_Say1256; .L_SayX1228;rtrue;
];
Array TX_S_287 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_287;
[ R_TX_S_288 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Dropped.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Dropped.~]
    say__p=1;! [2: ~Dropped.~]
    ParaContent(); print "Dropped."; .L_Say1257; .L_SayX1229;rtrue;
];
Array TX_S_288 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_288;
[ R_TX_S_289 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [put] down [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [put] down [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: put]
    ConjugateVerb_51(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ down ~]
    ParaContent(); print " down ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1258; .L_SayX1230;rtrue;
];
Array TX_S_289 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_289;
[ R_TX_S_290 
    tmp_0 ! Let/loop value, e.g., 'noun-CPC': object
    tmp_1 ! Let/loop value, e.g., 'second-CPC': object
    tmp_2 ! Let/loop value, e.g., 'transfer ceiling': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't put] something on top of itself.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't put] something on top of itself.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't put]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_51); say__p=1; ! [5: ~ something on top of itself.~]
    ParaContent(); print " something on top of itself."; .L_Say1259; .L_SayX1231;rtrue;
];
Array TX_S_290 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_290;
[ R_TX_S_291 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Putting things on [the second noun] [would achieve] nothing.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Putting things on [the second noun] [would achieve] nothing.~]
    say__p=1;! [2: ~Putting things on ~]
    ParaContent(); print "Putting things on ";! [3: the second noun]
    ParaContent(); print (the) second;! [4: ~ ~]
    ParaContent(); print " ";! [5: would achieve]
    ConjugateVerb_73(CV_POS, PNToVP(), story_tense, ConjugateVerb_21); say__p=1; ! [6: ~ nothing.~]
    ParaContent(); print " nothing."; .L_Say1260; .L_SayX1232;rtrue;
];
Array TX_S_291 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_291;
[ R_TX_S_292 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(first taking [regarding the noun][them] off)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(first taking [regarding the noun][them] off)[command clarification break]~]
    say__p=1;! [2: ~(first taking ~]
    ParaContent(); print "(first taking ";! [3: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [4: them]
    ParaContent(); (PHR_779_r69 ());! [5: ~ off)~]
    ParaContent(); print " off)";! [6: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1261; .L_SayX1233;rtrue;
];
Array TX_S_292 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_292;
[ R_TX_S_293 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no more room on [the second noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[There] [are] no more room on [the second noun].~]
    say__p=1;! [2: there]
    ParaContent(); (PHR_788_r104 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ no more room on ~]
    ParaContent(); print " no more room on ";! [6: the second noun]
    ParaContent(); print (the) second;! [7: ~.~]
    ParaContent(); print "."; .L_Say1262; .L_SayX1234;rtrue;
];
Array TX_S_293 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_293;
[ R_TX_S_294 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Done.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Done.~]
    say__p=1;! [2: ~Done.~]
    ParaContent(); print "Done."; .L_Say1263; .L_SayX1235;rtrue;
];
Array TX_S_294 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_294;
[ R_TX_S_295 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [put] [the noun] on [the second noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [put] [the noun] on [the second noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: put]
    ConjugateVerb_51(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~ on ~]
    ParaContent(); print " on ";! [8: the second noun]
    ParaContent(); print (the) second;! [9: ~.~]
    ParaContent(); print "."; .L_Say1264; .L_SayX1236;rtrue;
];
Array TX_S_295 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_295;
[ R_TX_S_296 
    tmp_0 ! Let/loop value, e.g., 'noun-CPC': object
    tmp_1 ! Let/loop value, e.g., 'second-CPC': object
    tmp_2 ! Let/loop value, e.g., 'transfer ceiling': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't put] something inside itself.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't put] something inside itself.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't put]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_51); say__p=1; ! [5: ~ something inside itself.~]
    ParaContent(); print " something inside itself."; .L_Say1265; .L_SayX1237;rtrue;
];
Array TX_S_296 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_296;
[ R_TX_S_297 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The second noun] [are] closed.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The second noun] [are] closed.~]
    say__p=1;! [2: the second noun]
    ParaContent(); print (The) second;! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ closed.~]
    ParaContent(); print " closed."; .L_Say1266; .L_SayX1238;rtrue;
];
Array TX_S_297 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_297;
[ R_TX_S_298 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the second noun][Those] [can't contain] things.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the second noun][Those] [can't contain] things.~]
    say__p=1;! [2: regarding the second noun]
    ParaContent(); RegardingSingleObject(second);! [3: those]
    ParaContent(); (PHR_772_r39 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: can't contain]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_7); say__p=1; ! [6: ~ things.~]
    ParaContent(); print " things."; .L_Say1267; .L_SayX1239;rtrue;
];
Array TX_S_298 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_298;
[ R_TX_S_299 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(first taking [regarding the noun][them] off)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(first taking [regarding the noun][them] off)[command clarification break]~]
    say__p=1;! [2: ~(first taking ~]
    ParaContent(); print "(first taking ";! [3: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [4: them]
    ParaContent(); (PHR_779_r69 ());! [5: ~ off)~]
    ParaContent(); print " off)";! [6: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1268; .L_SayX1240;rtrue;
];
Array TX_S_299 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_299;
[ R_TX_S_300 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no more room in [the second noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[There] [are] no more room in [the second noun].~]
    say__p=1;! [2: there]
    ParaContent(); (PHR_788_r104 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ no more room in ~]
    ParaContent(); print " no more room in ";! [6: the second noun]
    ParaContent(); print (the) second;! [7: ~.~]
    ParaContent(); print "."; .L_Say1269; .L_SayX1241;rtrue;
];
Array TX_S_300 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_300;
[ R_TX_S_301 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Done.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Done.~]
    say__p=1;! [2: ~Done.~]
    ParaContent(); print "Done."; .L_Say1270; .L_SayX1242;rtrue;
];
Array TX_S_301 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_301;
[ R_TX_S_302 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [put] [the noun] into [the second noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [put] [the noun] into [the second noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: put]
    ConjugateVerb_51(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~ into ~]
    ParaContent(); print " into ";! [8: the second noun]
    ParaContent(); print (the) second;! [9: ~.~]
    ParaContent(); print "."; .L_Say1271; .L_SayX1243;rtrue;
];
Array TX_S_302 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_302;
[ R_TX_S_303 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] plainly inedible.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They're] plainly inedible.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they're]
    ParaContent(); (PHR_786_r102 ());! [4: ~ plainly inedible.~]
    ParaContent(); print " plainly inedible."; .L_Say1272; .L_SayX1244;rtrue;
];
Array TX_S_303 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_303;
[ R_TX_S_304 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(first taking [the noun] off)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(first taking [the noun] off)[command clarification break]~]
    say__p=1;! [2: ~(first taking ~]
    ParaContent(); print "(first taking ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~ off)~]
    ParaContent(); print " off)";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1273; .L_SayX1245;rtrue;
];
Array TX_S_304 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_304;
[ R_TX_S_305 
    tmp_0 ! Let/loop value, e.g., 'owner': person
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[The owner] [might not appreciate] that.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The owner] [might not appreciate] that.~]
    say__p=1;! [2: the owner]
    ParaContent(); print (The) tmp_0;! [3: ~ ~]
    ParaContent(); print " ";! [4: might not appreciate]
    ConjugateVerb_70(CV_NEG, PNToVP(), story_tense, ConjugateVerb_22); say__p=1; ! [5: ~ that.~]
    ParaContent(); print " that."; .L_Say1274; .L_SayX1246;rtrue;
];
Array TX_S_305 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_305;
[ R_TX_S_306 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [eat] [the noun]. Not bad.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [eat] [the noun]. Not bad.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: eat]
    ConjugateVerb_29(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~. Not bad.~]
    ParaContent(); print ". Not bad."; .L_Say1275; .L_SayX1247;rtrue;
];
Array TX_S_306 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_306;
[ R_TX_S_307 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [eat] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [eat] [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: eat]
    ConjugateVerb_29(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1276; .L_SayX1248;rtrue;
];
Array TX_S_307 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_307;
[ R_TX_S_308 
    tmp_0 ! Let/loop value, e.g., 'chaise': supporter
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(first getting off [the chaise])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(first getting off [the chaise])[command clarification break]~]
    say__p=1;! [2: ~(first getting off ~]
    ParaContent(); print "(first getting off ";! [3: the chaise]
    ParaContent(); print (the) tmp_0;! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1277; .L_SayX1249;rtrue;
];
Array TX_S_308 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_308;
[ R_TX_S_309 
    tmp_0 ! Let/loop value, e.g., 'nonvehicle': object
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [would have] to get off [the nonvehicle] first.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [would have] to get off [the nonvehicle] first.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: would have]
    ConjugateVerb_73(CV_POS, PNToVP(), story_tense, ConjugateVerb_2); say__p=1; ! [5: ~ to get off ~]
    ParaContent(); print " to get off ";! [6: the nonvehicle]
    ParaContent(); print (the) tmp_0;! [7: ~ first.~]
    ParaContent(); print " first."; .L_Say1278; .L_SayX1250;rtrue;
];
Array TX_S_309 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_309;
[ R_TX_S_310 
    tmp_0 ! Let/loop value, e.g., 'nonvehicle': object
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [would have] to get out of [the nonvehicle] first.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [would have] to get out of [the nonvehicle] first.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: would have]
    ConjugateVerb_73(CV_POS, PNToVP(), story_tense, ConjugateVerb_2); say__p=1; ! [5: ~ to get out of ~]
    ParaContent(); print " to get out of ";! [6: the nonvehicle]
    ParaContent(); print (the) tmp_0;! [7: ~ first.~]
    ParaContent(); print " first."; .L_Say1279; .L_SayX1251;rtrue;
];
Array TX_S_310 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_310;
[ R_TX_S_311 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't go] that way.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't go] that way.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't go]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_34); say__p=1; ! [5: ~ that way.~]
    ParaContent(); print " that way."; .L_Say1280; .L_SayX1252;rtrue;
];
Array TX_S_311 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_311;
[ R_TX_S_312 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(first opening [the door gone through])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(first opening [the door gone through])[command clarification break]~]
    say__p=1;! [2: ~(first opening ~]
    ParaContent(); print "(first opening ";! [3: the door gone through]
    ParaContent(); print (the) (MStack-->MstVO(20007,2));! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1281; .L_SayX1253;rtrue;
];
Array TX_S_312 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_312;
[ R_TX_S_313 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't go] that way.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't go] that way.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't go]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_34); say__p=1; ! [5: ~ that way.~]
    ParaContent(); print " that way."; .L_Say1282; .L_SayX1254;rtrue;
];
Array TX_S_313 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_313;
[ R_TX_S_314 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't], since [the door gone through] [lead] nowhere.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't], since [the door gone through] [lead] nowhere.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~, since ~]
    ParaContent(); print ", since ";! [6: the door gone through]
    ParaContent(); print (the) (MStack-->MstVO(20007,2));! [7: ~ ~]
    ParaContent(); print " ";! [8: lead]
    ConjugateVerb_39(CV_POS, PNToVP(), story_tense); say__p=1; ! [9: ~ nowhere.~]
    ParaContent(); print " nowhere."; .L_Say1283; .L_SayX1255;rtrue;
];
Array TX_S_314 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_314;
[ R_TX_S_315 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [go] up~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [go] up~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: go]
    ConjugateVerb_34(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ up~]
    ParaContent(); print " up"; .L_Say1284; .L_SayX1256;rtrue;
];
Array TX_S_315 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_315;
[ R_TX_S_316 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [go] down~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [go] down~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: go]
    ConjugateVerb_34(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ down~]
    ParaContent(); print " down"; .L_Say1285; .L_SayX1257;rtrue;
];
Array TX_S_316 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_316;
[ R_TX_S_317 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [go] [noun]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [go] [noun]~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: go]
    ConjugateVerb_34(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: noun]
    ParaContent(); PrintShortName(noun); .L_Say1286; .L_SayX1258;rtrue;
];
Array TX_S_317 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_317;
[ R_TX_S_318 
    tmp_0 ! Let/loop value, e.g., 'back way': direction
    tmp_1 ! Let/loop value, e.g., 'room back the other way': room
    tmp_2 ! Let/loop value, e.g., 'room normally this way': room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [arrive] from above~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [arrive] from above~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: arrive]
    ConjugateVerb_23(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ from above~]
    ParaContent(); print " from above"; .L_Say1287; .L_SayX1259;rtrue;
];
Array TX_S_318 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_318;
[ R_TX_S_319 
    tmp_0 ! Let/loop value, e.g., 'back way': direction
    tmp_1 ! Let/loop value, e.g., 'room back the other way': room
    tmp_2 ! Let/loop value, e.g., 'room normally this way': room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [arrive] from below~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [arrive] from below~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: arrive]
    ConjugateVerb_23(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ from below~]
    ParaContent(); print " from below"; .L_Say1288; .L_SayX1260;rtrue;
];
Array TX_S_319 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_319;
[ R_TX_S_320 
    tmp_0 ! Let/loop value, e.g., 'back way': direction
    tmp_1 ! Let/loop value, e.g., 'room back the other way': room
    tmp_2 ! Let/loop value, e.g., 'room normally this way': room
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [arrive] from [the back way]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [arrive] from [the back way]~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: arrive]
    ConjugateVerb_23(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ from ~]
    ParaContent(); print " from ";! [6: the back way]
    ParaContent(); print (the) tmp_0; .L_Say1289; .L_SayX1261;rtrue;
];
Array TX_S_320 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_320;
[ R_TX_S_321 
    tmp_0 ! Let/loop value, e.g., 'back way': direction
    tmp_1 ! Let/loop value, e.g., 'room back the other way': room
    tmp_2 ! Let/loop value, e.g., 'room normally this way': room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [arrive]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [arrive]~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: arrive]
    ConjugateVerb_23(CV_POS, PNToVP(), story_tense); say__p=1;  .L_Say1290; .L_SayX1262;rtrue;
];
Array TX_S_321 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_321;
[ R_TX_S_322 
    tmp_0 ! Let/loop value, e.g., 'back way': direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [arrive] at [the room gone to] from above~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [arrive] at [the room gone to] from above~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: arrive]
    ConjugateVerb_23(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ at ~]
    ParaContent(); print " at ";! [6: the room gone to]
    ParaContent(); print (the) (MStack-->MstVO(20007,1));! [7: ~ from above~]
    ParaContent(); print " from above"; .L_Say1291; .L_SayX1263;rtrue;
];
Array TX_S_322 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_322;
[ R_TX_S_323 
    tmp_0 ! Let/loop value, e.g., 'back way': direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [arrive] at [the room gone to] from below~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [arrive] at [the room gone to] from below~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: arrive]
    ConjugateVerb_23(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ at ~]
    ParaContent(); print " at ";! [6: the room gone to]
    ParaContent(); print (the) (MStack-->MstVO(20007,1));! [7: ~ from below~]
    ParaContent(); print " from below"; .L_Say1292; .L_SayX1264;rtrue;
];
Array TX_S_323 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_323;
[ R_TX_S_324 
    tmp_0 ! Let/loop value, e.g., 'back way': direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [arrive] at [the room gone to] from [the back way]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [arrive] at [the room gone to] from [the back way]~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: arrive]
    ConjugateVerb_23(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ at ~]
    ParaContent(); print " at ";! [6: the room gone to]
    ParaContent(); print (the) (MStack-->MstVO(20007,1));! [7: ~ from ~]
    ParaContent(); print " from ";! [8: the back way]
    ParaContent(); print (the) tmp_0; .L_Say1293; .L_SayX1265;rtrue;
];
Array TX_S_324 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_324;
[ R_TX_S_325 
    tmp_0 ! Let/loop value: direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [go] through [the noun]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [go] through [the noun]~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: go]
    ConjugateVerb_34(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ through ~]
    ParaContent(); print " through ";! [6: the noun]
    ParaContent(); print (the) noun; .L_Say1294; .L_SayX1266;rtrue;
];
Array TX_S_325 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_325;
[ R_TX_S_326 
    tmp_0 ! Let/loop value: direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [arrive] from [the noun]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [arrive] from [the noun]~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: arrive]
    ConjugateVerb_23(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ from ~]
    ParaContent(); print " from ";! [6: the noun]
    ParaContent(); print (the) noun; .L_Say1295; .L_SayX1267;rtrue;
];
Array TX_S_326 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_326;
[ R_TX_S_327 
    tmp_0 ! Let/loop value: direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~on [the vehicle gone by]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~on [the vehicle gone by]~]
    say__p=1;! [2: ~on ~]
    ParaContent(); print "on ";! [3: the vehicle gone by]
    ParaContent(); print (the) (MStack-->MstVO(20007,3)); .L_Say1296; .L_SayX1268;rtrue;
];
Array TX_S_327 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_327;
[ R_TX_S_328 
    tmp_0 ! Let/loop value: direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~in [the vehicle gone by]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~in [the vehicle gone by]~]
    say__p=1;! [2: ~in ~]
    ParaContent(); print "in ";! [3: the vehicle gone by]
    ParaContent(); print (the) (MStack-->MstVO(20007,3)); .L_Say1297; .L_SayX1269;rtrue;
];
Array TX_S_328 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_328;
[ R_TX_S_329 
    tmp_0 ! Let/loop value: direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, pushing [the thing gone with] in front, and [us] along too~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~, pushing [the thing gone with] in front, and [us] along too~]
    say__p=1;! [2: ~, pushing ~]
    ParaContent(); print ", pushing ";! [3: the thing gone with]
    ParaContent(); print (the) (MStack-->MstVO(20007,4));! [4: ~ in front, and ~]
    ParaContent(); print " in front, and ";! [5: us]
    ParaContent(); (PHR_760_r49 ());! [6: ~ along too~]
    ParaContent(); print " along too"; .L_Say1298; .L_SayX1270;rtrue;
];
Array TX_S_329 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_329;
[ R_TX_S_330 
    tmp_0 ! Let/loop value: direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, pushing [the thing gone with] in front~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~, pushing [the thing gone with] in front~]
    say__p=1;! [2: ~, pushing ~]
    ParaContent(); print ", pushing ";! [3: the thing gone with]
    ParaContent(); print (the) (MStack-->MstVO(20007,4));! [4: ~ in front~]
    ParaContent(); print " in front"; .L_Say1299; .L_SayX1271;rtrue;
];
Array TX_S_330 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_330;
[ R_TX_S_331 
    tmp_0 ! Let/loop value: direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, pushing [the thing gone with] away~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~, pushing [the thing gone with] away~]
    say__p=1;! [2: ~, pushing ~]
    ParaContent(); print ", pushing ";! [3: the thing gone with]
    ParaContent(); print (the) (MStack-->MstVO(20007,4));! [4: ~ away~]
    ParaContent(); print " away"; .L_Say1300; .L_SayX1272;rtrue;
];
Array TX_S_331 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_331;
[ R_TX_S_332 
    tmp_0 ! Let/loop value: direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, pushing [the thing gone with] in~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~, pushing [the thing gone with] in~]
    say__p=1;! [2: ~, pushing ~]
    ParaContent(); print ", pushing ";! [3: the thing gone with]
    ParaContent(); print (the) (MStack-->MstVO(20007,4));! [4: ~ in~]
    ParaContent(); print " in"; .L_Say1301; .L_SayX1273;rtrue;
];
Array TX_S_332 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_332;
[ R_TX_S_333 
    tmp_0 ! Let/loop value: direction
    tmp_1 ! Let/loop value: room
    tmp_2 ! Let/loop value: room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~, taking [us] along~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~, taking [us] along~]
    say__p=1;! [2: ~, taking ~]
    ParaContent(); print ", taking ";! [3: us]
    ParaContent(); (PHR_760_r49 ());! [4: ~ along~]
    ParaContent(); print " along"; .L_Say1302; .L_SayX1274;rtrue;
];
Array TX_S_333 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_333;
[ R_TX_S_334 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~But [we]['re] already on [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~But [we]['re] already on [the noun].~]
    say__p=1;! [2: ~But ~]
    ParaContent(); print "But ";! [3: we]
    ParaContent(); (PHR_757_r16 ());! [4: 're]
    ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ already on ~]
    ParaContent(); print " already on ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1303; .L_SayX1275;rtrue;
];
Array TX_S_334 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_334;
[ R_TX_S_335 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~But [we]['re] already in [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~But [we]['re] already in [the noun].~]
    say__p=1;! [2: ~But ~]
    ParaContent(); print "But ";! [3: we]
    ParaContent(); (PHR_757_r16 ());! [4: 're]
    ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ already in ~]
    ParaContent(); print " already in ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1304; .L_SayX1276;rtrue;
];
Array TX_S_335 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_335;
[ R_TX_S_336 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] not something [we] [can] stand on.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They're] not something [we] [can] stand on.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they're]
    ParaContent(); (PHR_786_r102 ());! [4: ~ not something ~]
    ParaContent(); print " not something ";! [5: we]
    ParaContent(); (PHR_757_r16 ());! [6: ~ ~]
    ParaContent(); print " ";! [7: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [8: ~ stand on.~]
    ParaContent(); print " stand on."; .L_Say1305; .L_SayX1277;rtrue;
];
Array TX_S_336 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_336;
[ R_TX_S_337 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] not something [we] [can] sit down on.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They're] not something [we] [can] sit down on.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they're]
    ParaContent(); (PHR_786_r102 ());! [4: ~ not something ~]
    ParaContent(); print " not something ";! [5: we]
    ParaContent(); (PHR_757_r16 ());! [6: ~ ~]
    ParaContent(); print " ";! [7: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [8: ~ sit down on.~]
    ParaContent(); print " sit down on."; .L_Say1306; .L_SayX1278;rtrue;
];
Array TX_S_337 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_337;
[ R_TX_S_338 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] not something [we] [can] lie down on.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They're] not something [we] [can] lie down on.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they're]
    ParaContent(); (PHR_786_r102 ());! [4: ~ not something ~]
    ParaContent(); print " not something ";! [5: we]
    ParaContent(); (PHR_757_r16 ());! [6: ~ ~]
    ParaContent(); print " ";! [7: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [8: ~ lie down on.~]
    ParaContent(); print " lie down on."; .L_Say1307; .L_SayX1279;rtrue;
];
Array TX_S_338 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_338;
[ R_TX_S_339 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] not something [we] [can] enter.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They're] not something [we] [can] enter.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they're]
    ParaContent(); (PHR_786_r102 ());! [4: ~ not something ~]
    ParaContent(); print " not something ";! [5: we]
    ParaContent(); (PHR_757_r16 ());! [6: ~ ~]
    ParaContent(); print " ";! [7: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [8: ~ enter.~]
    ParaContent(); print " enter."; .L_Say1308; .L_SayX1280;rtrue;
];
Array TX_S_339 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_339;
[ R_TX_S_340 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't get] into the closed [noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't get] into the closed [noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't get]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_32); say__p=1; ! [5: ~ into the closed ~]
    ParaContent(); print " into the closed ";! [6: noun]
    ParaContent(); PrintShortName(noun);! [7: ~.~]
    ParaContent(); print "."; .L_Say1309; .L_SayX1281;rtrue;
];
Array TX_S_340 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_340;
[ R_TX_S_341 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no more room on [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[There] [are] no more room on [the noun].~]
    say__p=1;! [2: there]
    ParaContent(); (PHR_788_r104 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ no more room on ~]
    ParaContent(); print " no more room on ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1310; .L_SayX1282;rtrue;
];
Array TX_S_341 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_341;
[ R_TX_S_342 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no more room in [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[There] [are] no more room in [the noun].~]
    say__p=1;! [2: there]
    ParaContent(); (PHR_788_r104 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ no more room in ~]
    ParaContent(); print " no more room in ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1311; .L_SayX1283;rtrue;
];
Array TX_S_342 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_342;
[ R_TX_S_343 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can] only get into something free-standing.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can] only get into something free-standing.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ only get into something free-standing.~]
    ParaContent(); print " only get into something free-standing."; .L_Say1312; .L_SayX1284;rtrue;
];
Array TX_S_343 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_343;
[ R_TX_S_344 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'current home': object
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(getting off [the current home])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(getting off [the current home])[command clarification break]~]
    say__p=1;! [2: ~(getting off ~]
    ParaContent(); print "(getting off ";! [3: the current home]
    ParaContent(); print (the) tmp_1;! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1313; .L_SayX1285;rtrue;
];
Array TX_S_344 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_344;
[ R_TX_S_345 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'current home': object
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(getting out of [the current home])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(getting out of [the current home])[command clarification break]~]
    say__p=1;! [2: ~(getting out of ~]
    ParaContent(); print "(getting out of ";! [3: the current home]
    ParaContent(); print (the) tmp_1;! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1314; .L_SayX1286;rtrue;
];
Array TX_S_345 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_345;
[ R_TX_S_346 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'target': object
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(getting onto [the target])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(getting onto [the target])[command clarification break]~]
    say__p=1;! [2: ~(getting onto ~]
    ParaContent(); print "(getting onto ";! [3: the target]
    ParaContent(); print (the) tmp_1;! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1315; .L_SayX1287;rtrue;
];
Array TX_S_346 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_346;
[ R_TX_S_347 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'target': object
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(getting into [the target])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(getting into [the target])[command clarification break]~]
    say__p=1;! [2: ~(getting into ~]
    ParaContent(); print "(getting into ";! [3: the target]
    ParaContent(); print (the) tmp_1;! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1316; .L_SayX1288;rtrue;
];
Array TX_S_347 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_347;
[ R_TX_S_348 
    tmp_0 ! Let/loop value, e.g., 'local ceiling': object
    tmp_1 ! Let/loop value, e.g., 'target': object
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~(entering [the target])[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(entering [the target])[command clarification break]~]
    say__p=1;! [2: ~(entering ~]
    ParaContent(); print "(entering ";! [3: the target]
    ParaContent(); print (the) tmp_1;! [4: ~)~]
    ParaContent(); print ")";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1317; .L_SayX1289;rtrue;
];
Array TX_S_348 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_348;
[ R_TX_S_349 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [get] onto [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [get] onto [the noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: get]
    ConjugateVerb_32(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ onto ~]
    ParaContent(); print " onto ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1318; .L_SayX1290;rtrue;
];
Array TX_S_349 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_349;
[ R_TX_S_350 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [get] into [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [get] into [the noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: get]
    ConjugateVerb_32(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ into ~]
    ParaContent(); print " into ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1319; .L_SayX1291;rtrue;
];
Array TX_S_350 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_350;
[ R_TX_S_351 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [get] into [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [get] into [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: get]
    ConjugateVerb_32(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ into ~]
    ParaContent(); print " into ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1320; .L_SayX1292;rtrue;
];
Array TX_S_351 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_351;
[ R_TX_S_352 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [get] onto [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [get] onto [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: get]
    ConjugateVerb_32(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ onto ~]
    ParaContent(); print " onto ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1321; .L_SayX1293;rtrue;
];
Array TX_S_352 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_352;
[ R_TX_S_353 
    tmp_0 ! Let/loop value, e.g., 'local room': room
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~But [we] [aren't] in anything at the [if story tense is present
    tense]moment[otherwise]time[end if].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~But [we] [aren't] in anything at the [if story tense is present tense]moment[otherwise]time[end if].~]
    say__p=1;! [2: ~But ~]
    ParaContent(); print "But ";! [3: we]
    ParaContent(); (PHR_757_r16 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ in anything at the ~]
    ParaContent(); print " in anything at the ";! [7: if story tense is present tense]

    	if (~~((((story_tense == I112_present_tense))))) jump L_Say1322;! [8: ~moment~]
    ParaContent(); print "moment";! [9: otherwise]

    	jump L_SayX1294; .L_Say1322;! [10: ~time~]
    ParaContent(); print "time";! [11: end if]

    	.L_Say1323; .L_SayX1294;! [12: ~.~]
    ParaContent(); print "."; .L_Say1324; .L_SayX1295;rtrue;
];
Array TX_S_353 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_353;
[ R_TX_S_354 
    tmp_0 ! Let/loop value, e.g., 'cage': container
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~You can't get out of the closed [cage].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You can't get out of the closed [cage].~]
    say__p=1;! [2: ~You can't get out of the closed ~]
    ParaContent(); print "You can't get out of the closed ";! [3: cage]
    ParaContent(); PrintShortName(tmp_0);! [4: ~.~]
    ParaContent(); print "."; .L_Say1325; .L_SayX1296;rtrue;
];
Array TX_S_354 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_354;
[ R_TX_S_355 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    I7RBLK = KERNEL_118();
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_118 
    tmp_0 ! Let/loop value, e.g., 'local room': room
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[excuse for local room to outside][line break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[excuse for local room to outside][line break]~]
    say__p=1;! [2: excuse for local room to outside]
    ParaContent(); print (TEXT_TY_Say) (PHR_1105_r24 (I7SFRAME,tmp_0,out_obj));! [3: line break]
    ParaContent(); new_line; .L_Say1326; .L_SayX1297;rtrue;
];
Array TX_S_355 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_355;
[ R_TX_S_356 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [get] off [the container exited from].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [get] off [the container exited from].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: get]
    ConjugateVerb_32(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ off ~]
    ParaContent(); print " off ";! [6: the container exited from]
    ParaContent(); print (the) (MStack-->MstVO(20009,0));! [7: ~.~]
    ParaContent(); print "."; .L_Say1327; .L_SayX1298;rtrue;
];
Array TX_S_356 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_356;
[ R_TX_S_357 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [get] out of [the container exited from].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [get] out of [the container exited from].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: get]
    ConjugateVerb_32(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ out of ~]
    ParaContent(); print " out of ";! [6: the container exited from]
    ParaContent(); print (the) (MStack-->MstVO(20009,0));! [7: ~.~]
    ParaContent(); print "."; .L_Say1328; .L_SayX1299;rtrue;
];
Array TX_S_357 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_357;
[ R_TX_S_358 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [get] out of [the container exited from].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [get] out of [the container exited from].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: get]
    ConjugateVerb_32(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ out of ~]
    ParaContent(); print " out of ";! [6: the container exited from]
    ParaContent(); print (the) (MStack-->MstVO(20009,0));! [7: ~.~]
    ParaContent(); print "."; .L_Say1329; .L_SayX1300;rtrue;
];
Array TX_S_358 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_358;
[ R_TX_S_359 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~But [we] [aren't] on [the noun] at the [if story tense is present
    tense]moment[otherwise]time[end if].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~But [we] [aren't] on [the noun] at the [if story tense is present tense]moment[otherwise]time[end if].~]
    say__p=1;! [2: ~But ~]
    ParaContent(); print "But ";! [3: we]
    ParaContent(); (PHR_757_r16 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ on ~]
    ParaContent(); print " on ";! [7: the noun]
    ParaContent(); print (the) noun;! [8: ~ at the ~]
    ParaContent(); print " at the ";! [9: if story tense is present tense]

    	if (~~((((story_tense == I112_present_tense))))) jump L_Say1330;! [10: ~moment~]
    ParaContent(); print "moment";! [11: otherwise]

    	jump L_SayX1301; .L_Say1330;! [12: ~time~]
    ParaContent(); print "time";! [13: end if]

    	.L_Say1331; .L_SayX1301;! [14: ~.~]
    ParaContent(); print "."; .L_Say1332; .L_SayX1302;rtrue;
];
Array TX_S_359 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_359;
[ R_TX_S_360 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [get] off [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [get] off [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: get]
    ConjugateVerb_32(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ off ~]
    ParaContent(); print " off ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1333; .L_SayX1303;rtrue;
];
Array TX_S_360 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_360;
[ R_TX_S_361 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~in the dark~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~in the dark~]
    say__p=1;! [2: ~in the dark~]
    ParaContent(); print "in the dark"; .L_Say1334; .L_SayX1304;rtrue;
];
Array TX_S_361 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_361;
[ R_TX_S_362 
    tmp_0 ! Let/loop value, e.g., 'intermediate level': object
    tmp_1 ! Let/loop value, e.g., 'intermediate level count': number
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~ on [the intermediate level]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ on [the intermediate level]~]
    say__p=1;! [2: ~ on ~]
    ParaContent(); print " on ";! [3: the intermediate level]
    ParaContent(); print (the) tmp_0; .L_Say1335; .L_SayX1305;rtrue;
];
Array TX_S_362 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_362;
[ R_TX_S_363 
    tmp_0 ! Let/loop value, e.g., 'intermediate level': object
    tmp_1 ! Let/loop value, e.g., 'intermediate level count': number
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~ in [the intermediate level]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ in [the intermediate level]~]
    say__p=1;! [2: ~ in ~]
    ParaContent(); print " in ";! [3: the intermediate level]
    ParaContent(); print (the) tmp_0; .L_Say1336; .L_SayX1306;rtrue;
];
Array TX_S_363 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_363;
[ R_TX_S_364 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[It] [are] pitch dark, and [we] [can't see] a thing.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[It] [are] pitch dark, and [we] [can't see] a thing.~]
    say__p=1;! [2: it]
    ParaContent(); (PHR_787_r103 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ pitch dark, and ~]
    ParaContent(); print " pitch dark, and ";! [6: we]
    ParaContent(); (PHR_757_r16 ());! [7: ~ ~]
    ParaContent(); print " ";! [8: can't see]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_16); say__p=1; ! [9: ~ a thing.~]
    ParaContent(); print " a thing."; .L_Say1337; .L_SayX1307;rtrue;
];
Array TX_S_364 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_364;
[ R_TX_S_366 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [look] around.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [look] around.~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: look]
    ConjugateVerb_43(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ around.~]
    ParaContent(); print " around."; .L_Say1338; .L_SayX1308;rtrue;
];
Array TX_S_366 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_366;
[ R_TX_S_367 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [see] nothing unexpected in that direction.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [see] nothing unexpected in that direction.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: see]
    ConjugateVerb_16(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ nothing unexpected in that direction.~]
    ParaContent(); print " nothing unexpected in that direction."; .L_Say1339; .L_SayX1309;rtrue;
];
Array TX_S_367 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_367;
[ R_TX_S_368 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~In [the noun] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~In [the noun] ~]
    say__p=1;! [2: ~In ~]
    ParaContent(); print "In ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~ ~]
    ParaContent(); print " "; .L_Say1340; .L_SayX1310;rtrue;
];
Array TX_S_368 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_368;
[ R_TX_S_369 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [are] empty.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [are] empty.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ empty.~]
    ParaContent(); print " empty."; .L_Say1341; .L_SayX1311;rtrue;
];
Array TX_S_369 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_369;
[ R_TX_S_370 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~On [the noun] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~On [the noun] ~]
    say__p=1;! [2: ~On ~]
    ParaContent(); print "On ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~ ~]
    ParaContent(); print " "; .L_Say1342; .L_SayX1312;rtrue;
];
Array TX_S_370 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_370;
[ R_TX_S_371 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [are] [if story tense is present tense]currently [end if]switched
    [if the noun is switched on]on[otherwise]off[end if].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [are] [if story tense is present tense]currently [end if]switched [if the noun is switched on]on[otherwise]off[end if].~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: if story tense is present tense]

    	if (~~((((story_tense == I112_present_tense))))) jump L_Say1343;! [7: ~currently ~]
    ParaContent(); print "currently ";! [8: end if]

    	.L_Say1343; .L_SayX1313;! [9: ~switched ~]
    ParaContent(); print "switched ";! [10: if the noun is switched on]

    	if (~~(((((Adj_112_t1_v10(noun))))))) jump L_Say1344;! [11: ~on~]
    ParaContent(); print "on";! [12: otherwise]

    	jump L_SayX1314; .L_Say1344;! [13: ~off~]
    ParaContent(); print "off";! [14: end if]

    	.L_Say1345; .L_SayX1314;! [15: ~.~]
    ParaContent(); print "."; .L_Say1346; .L_SayX1315;rtrue;
];
Array TX_S_371 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_371;
[ R_TX_S_373 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [look] closely at [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [look] closely at [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: look]
    ConjugateVerb_43(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ closely at ~]
    ParaContent(); print " closely at ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1347; .L_SayX1316;rtrue;
];
Array TX_S_373 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_373;
[ R_TX_S_374 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [find] nothing of interest.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [find] nothing of interest.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: find]
    ConjugateVerb_31(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ nothing of interest.~]
    ParaContent(); print " nothing of interest."; .L_Say1348; .L_SayX1317;rtrue;
];
Array TX_S_374 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_374;
[ R_TX_S_375 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [look] under [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [look] under [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: look]
    ConjugateVerb_43(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ under ~]
    ParaContent(); print " under ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1349; .L_SayX1318;rtrue;
];
Array TX_S_375 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_375;
[ R_TX_S_376 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [find] nothing of interest.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [find] nothing of interest.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: find]
    ConjugateVerb_31(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ nothing of interest.~]
    ParaContent(); print " nothing of interest."; .L_Say1350; .L_SayX1319;rtrue;
];
Array TX_S_376 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_376;
[ R_TX_S_377 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't see] inside, since [the noun] [are] closed.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't see] inside, since [the noun] [are] closed.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't see]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_16); say__p=1; ! [5: ~ inside, since ~]
    ParaContent(); print " inside, since ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~ ~]
    ParaContent(); print " ";! [8: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [9: ~ closed.~]
    ParaContent(); print " closed."; .L_Say1351; .L_SayX1320;rtrue;
];
Array TX_S_377 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_377;
[ R_TX_S_378 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~In [the noun] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~In [the noun] ~]
    say__p=1;! [2: ~In ~]
    ParaContent(); print "In ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~ ~]
    ParaContent(); print " "; .L_Say1352; .L_SayX1321;rtrue;
];
Array TX_S_378 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_378;
[ R_TX_S_379 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [are] empty.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [are] empty.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ empty.~]
    ParaContent(); print " empty."; .L_Say1353; .L_SayX1322;rtrue;
];
Array TX_S_379 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_379;
[ R_TX_S_380 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~On [the noun] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~On [the noun] ~]
    say__p=1;! [2: ~On ~]
    ParaContent(); print "On ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~ ~]
    ParaContent(); print " "; .L_Say1354; .L_SayX1323;rtrue;
];
Array TX_S_380 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_380;
[ R_TX_S_381 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] nothing on [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[There] [are] nothing on [the noun].~]
    say__p=1;! [2: there]
    ParaContent(); (PHR_788_r104 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ nothing on ~]
    ParaContent(); print " nothing on ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1355; .L_SayX1324;rtrue;
];
Array TX_S_381 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_381;
[ R_TX_S_382 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [search] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [search] [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: search]
    ConjugateVerb_54(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1356; .L_SayX1325;rtrue;
];
Array TX_S_382 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_382;
[ R_TX_S_383 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [discover] nothing of interest in [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [discover] nothing of interest in [the noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: discover]
    ConjugateVerb_27(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ nothing of interest in ~]
    ParaContent(); print " nothing of interest in ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1357; .L_SayX1326;rtrue;
];
Array TX_S_383 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_383;
[ R_TX_S_384 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [look] at [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [look] at [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: look]
    ConjugateVerb_43(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ at ~]
    ParaContent(); print " at ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1358; .L_SayX1327;rtrue;
];
Array TX_S_384 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_384;
[ R_TX_S_385 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][Those] [don't] seem to be something [we] [can] lock.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][Those] [don't] seem to be something [we] [can] lock.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: those]
    ParaContent(); (PHR_772_r39 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: don't]
    ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ seem to be something ~]
    ParaContent(); print " seem to be something ";! [7: we]
    ParaContent(); (PHR_757_r16 ());! [8: ~ ~]
    ParaContent(); print " ";! [9: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [10: ~ lock.~]
    ParaContent(); print " lock."; .L_Say1359; .L_SayX1328;rtrue;
];
Array TX_S_385 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_385;
[ R_TX_S_386 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] locked at the [if story tense is present
    tense]moment[otherwise]time[end if].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They're] locked at the [if story tense is present tense]moment[otherwise]time[end if].~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they're]
    ParaContent(); (PHR_786_r102 ());! [4: ~ locked at the ~]
    ParaContent(); print " locked at the ";! [5: if story tense is present tense]

    	if (~~((((story_tense == I112_present_tense))))) jump L_Say1360;! [6: ~moment~]
    ParaContent(); print "moment";! [7: otherwise]

    	jump L_SayX1329; .L_Say1360;! [8: ~time~]
    ParaContent(); print "time";! [9: end if]

    	.L_Say1361; .L_SayX1329;! [10: ~.~]
    ParaContent(); print "."; .L_Say1362; .L_SayX1330;rtrue;
];
Array TX_S_386 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_386;
[ R_TX_S_387 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][Those] [don't] seem to be something [we] [can] lock.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][Those] [don't] seem to be something [we] [can] lock.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: those]
    ParaContent(); (PHR_772_r39 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: don't]
    ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ seem to be something ~]
    ParaContent(); print " seem to be something ";! [7: we]
    ParaContent(); (PHR_757_r16 ());! [8: ~ ~]
    ParaContent(); print " ";! [9: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [10: ~ lock.~]
    ParaContent(); print " lock."; .L_Say1363; .L_SayX1331;rtrue;
];
Array TX_S_387 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_387;
[ R_TX_S_388 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] locked at the [if story tense is present
    tense]moment[otherwise]time[end if].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They're] locked at the [if story tense is present tense]moment[otherwise]time[end if].~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they're]
    ParaContent(); (PHR_786_r102 ());! [4: ~ locked at the ~]
    ParaContent(); print " locked at the ";! [5: if story tense is present tense]

    	if (~~((((story_tense == I112_present_tense))))) jump L_Say1364;! [6: ~moment~]
    ParaContent(); print "moment";! [7: otherwise]

    	jump L_SayX1332; .L_Say1364;! [8: ~time~]
    ParaContent(); print "time";! [9: end if]

    	.L_Say1365; .L_SayX1332;! [10: ~.~]
    ParaContent(); print "."; .L_Say1366; .L_SayX1333;rtrue;
];
Array TX_S_388 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_388;
[ R_TX_S_389 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~First [we] [would have] to close [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~First [we] [would have] to close [the noun].~]
    say__p=1;! [2: ~First ~]
    ParaContent(); print "First ";! [3: we]
    ParaContent(); (PHR_757_r16 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: would have]
    ConjugateVerb_73(CV_POS, PNToVP(), story_tense, ConjugateVerb_2); say__p=1; ! [6: ~ to close ~]
    ParaContent(); print " to close ";! [7: the noun]
    ParaContent(); print (the) noun;! [8: ~.~]
    ParaContent(); print "."; .L_Say1367; .L_SayX1334;rtrue;
];
Array TX_S_389 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_389;
[ R_TX_S_390 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the second noun][Those] [don't] seem to fit the lock.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the second noun][Those] [don't] seem to fit the lock.~]
    say__p=1;! [2: regarding the second noun]
    ParaContent(); RegardingSingleObject(second);! [3: those]
    ParaContent(); (PHR_772_r39 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: don't]
    ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ seem to fit the lock.~]
    ParaContent(); print " seem to fit the lock."; .L_Say1368; .L_SayX1335;rtrue;
];
Array TX_S_390 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_390;
[ R_TX_S_391 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [lock] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [lock] [the noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: lock]
    ConjugateVerb_42(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1369; .L_SayX1336;rtrue;
];
Array TX_S_391 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_391;
[ R_TX_S_392 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [lock] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [lock] [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: lock]
    ConjugateVerb_42(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1370; .L_SayX1337;rtrue;
];
Array TX_S_392 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_392;
[ R_TX_S_393 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the second noun][Those] [don't] seem to be the right card.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the second noun][Those] [don't] seem to be the right card.~]
    say__p=1;! [2: regarding the second noun]
    ParaContent(); RegardingSingleObject(second);! [3: those]
    ParaContent(); (PHR_772_r39 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: don't]
    ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ seem to be the right card.~]
    ParaContent(); print " seem to be the right card."; .L_Say1371; .L_SayX1338;rtrue;
];
Array TX_S_393 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_393;
[ R_TX_S_394 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][Those] [don't] seem to be something [we] [can] unlock.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][Those] [don't] seem to be something [we] [can] unlock.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: those]
    ParaContent(); (PHR_772_r39 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: don't]
    ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ seem to be something ~]
    ParaContent(); print " seem to be something ";! [7: we]
    ParaContent(); (PHR_757_r16 ());! [8: ~ ~]
    ParaContent(); print " ";! [9: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [10: ~ unlock.~]
    ParaContent(); print " unlock."; .L_Say1372; .L_SayX1339;rtrue;
];
Array TX_S_394 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_394;
[ R_TX_S_395 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] unlocked at the [if story tense is present
    tense]moment[otherwise]time[end if].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They're] unlocked at the [if story tense is present tense]moment[otherwise]time[end if].~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they're]
    ParaContent(); (PHR_786_r102 ());! [4: ~ unlocked at the ~]
    ParaContent(); print " unlocked at the ";! [5: if story tense is present tense]

    	if (~~((((story_tense == I112_present_tense))))) jump L_Say1373;! [6: ~moment~]
    ParaContent(); print "moment";! [7: otherwise]

    	jump L_SayX1340; .L_Say1373;! [8: ~time~]
    ParaContent(); print "time";! [9: end if]

    	.L_Say1374; .L_SayX1340;! [10: ~.~]
    ParaContent(); print "."; .L_Say1375; .L_SayX1341;rtrue;
];
Array TX_S_395 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_395;
[ R_TX_S_396 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the second noun][Those] [don't] seem to fit the lock.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the second noun][Those] [don't] seem to fit the lock.~]
    say__p=1;! [2: regarding the second noun]
    ParaContent(); RegardingSingleObject(second);! [3: those]
    ParaContent(); (PHR_772_r39 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: don't]
    ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ seem to fit the lock.~]
    ParaContent(); print " seem to fit the lock."; .L_Say1376; .L_SayX1342;rtrue;
];
Array TX_S_396 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_396;
[ R_TX_S_397 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [unlock] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [unlock] [the noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: unlock]
    ConjugateVerb_20(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1377; .L_SayX1343;rtrue;
];
Array TX_S_397 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_397;
[ R_TX_S_398 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [unlock] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [unlock] [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: unlock]
    ConjugateVerb_20(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1378; .L_SayX1344;rtrue;
];
Array TX_S_398 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_398;
[ R_TX_S_400 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] already on.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They're] already on.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they're]
    ParaContent(); (PHR_786_r102 ());! [4: ~ already on.~]
    ParaContent(); print " already on."; .L_Say1379; .L_SayX1345;rtrue;
];
Array TX_S_400 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_400;
[ R_TX_S_401 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [switch] [the noun] on.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [switch] [the noun] on.~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: switch]
    ConjugateVerb_60(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~ on.~]
    ParaContent(); print " on."; .L_Say1380; .L_SayX1346;rtrue;
];
Array TX_S_401 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_401;
[ R_TX_S_402 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They] [aren't] something [we] [can] switch.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They] [aren't] something [we] [can] switch.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they]
    ParaContent(); (PHR_776_r43 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ something ~]
    ParaContent(); print " something ";! [7: we]
    ParaContent(); (PHR_757_r16 ());! [8: ~ ~]
    ParaContent(); print " ";! [9: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [10: ~ switch.~]
    ParaContent(); print " switch."; .L_Say1381; .L_SayX1347;rtrue;
];
Array TX_S_402 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_402;
[ R_TX_S_403 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] already off.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They're] already off.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they're]
    ParaContent(); (PHR_786_r102 ());! [4: ~ already off.~]
    ParaContent(); print " already off."; .L_Say1382; .L_SayX1348;rtrue;
];
Array TX_S_403 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_403;
[ R_TX_S_404 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [switch] [the noun] off.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [switch] [the noun] off.~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: switch]
    ConjugateVerb_60(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~ off.~]
    ParaContent(); print " off."; .L_Say1383; .L_SayX1349;rtrue;
];
Array TX_S_404 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_404;
[ R_TX_S_405 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They] [aren't] something [we] [can] open.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They] [aren't] something [we] [can] open.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they]
    ParaContent(); (PHR_776_r43 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ something ~]
    ParaContent(); print " something ";! [7: we]
    ParaContent(); (PHR_757_r16 ());! [8: ~ ~]
    ParaContent(); print " ";! [9: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [10: ~ open.~]
    ParaContent(); print " open."; .L_Say1384; .L_SayX1350;rtrue;
];
Array TX_S_405 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_405;
[ R_TX_S_406 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They] [seem] to be locked.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They] [seem] to be locked.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they]
    ParaContent(); (PHR_776_r43 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: seem]
    ConjugateVerb_55(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ to be locked.~]
    ParaContent(); print " to be locked."; .L_Say1385; .L_SayX1351;rtrue;
];
Array TX_S_406 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_406;
[ R_TX_S_407 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They] [aren't] something [we] [can] open.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They] [aren't] something [we] [can] open.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they]
    ParaContent(); (PHR_776_r43 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ something ~]
    ParaContent(); print " something ";! [7: we]
    ParaContent(); (PHR_757_r16 ());! [8: ~ ~]
    ParaContent(); print " ";! [9: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [10: ~ open.~]
    ParaContent(); print " open."; .L_Say1386; .L_SayX1352;rtrue;
];
Array TX_S_407 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_407;
[ R_TX_S_408 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They] [seem] to be locked.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They] [seem] to be locked.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they]
    ParaContent(); (PHR_776_r43 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: seem]
    ConjugateVerb_55(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ to be locked.~]
    ParaContent(); print " to be locked."; .L_Say1387; .L_SayX1353;rtrue;
];
Array TX_S_408 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_408;
[ R_TX_S_409 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] already open.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They're] already open.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they're]
    ParaContent(); (PHR_786_r102 ());! [4: ~ already open.~]
    ParaContent(); print " already open."; .L_Say1388; .L_SayX1354;rtrue;
];
Array TX_S_409 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_409;
[ R_TX_S_410 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [open] [the noun], revealing ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [open] [the noun], revealing ~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: open]
    ConjugateVerb_45(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~, revealing ~]
    ParaContent(); print ", revealing "; .L_Say1389; .L_SayX1355;rtrue;
];
Array TX_S_410 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_410;
[ R_TX_S_411 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [open] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [open] [the noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: open]
    ConjugateVerb_45(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1390; .L_SayX1356;rtrue;
];
Array TX_S_411 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_411;
[ R_TX_S_412 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [open] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [open] [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: open]
    ConjugateVerb_45(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1391; .L_SayX1357;rtrue;
];
Array TX_S_412 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_412;
[ R_TX_S_413 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [open].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [open].~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: open]
    ConjugateVerb_45(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~.~]
    ParaContent(); print "."; .L_Say1392; .L_SayX1358;rtrue;
];
Array TX_S_413 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_413;
[ R_TX_S_414 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They] [aren't] something [we] [can] close.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They] [aren't] something [we] [can] close.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they]
    ParaContent(); (PHR_776_r43 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ something ~]
    ParaContent(); print " something ";! [7: we]
    ParaContent(); (PHR_757_r16 ());! [8: ~ ~]
    ParaContent(); print " ";! [9: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [10: ~ close.~]
    ParaContent(); print " close."; .L_Say1393; .L_SayX1359;rtrue;
];
Array TX_S_414 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_414;
[ R_TX_S_415 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They] [aren't] something [we] [can] close.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They] [aren't] something [we] [can] close.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they]
    ParaContent(); (PHR_776_r43 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ something ~]
    ParaContent(); print " something ";! [7: we]
    ParaContent(); (PHR_757_r16 ());! [8: ~ ~]
    ParaContent(); print " ";! [9: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [10: ~ close.~]
    ParaContent(); print " close."; .L_Say1394; .L_SayX1360;rtrue;
];
Array TX_S_415 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_415;
[ R_TX_S_416 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] already closed.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They're] already closed.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they're]
    ParaContent(); (PHR_786_r102 ());! [4: ~ already closed.~]
    ParaContent(); print " already closed."; .L_Say1395; .L_SayX1361;rtrue;
];
Array TX_S_416 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_416;
[ R_TX_S_417 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [close] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [close] [the noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: close]
    ConjugateVerb_25(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1396; .L_SayX1362;rtrue;
];
Array TX_S_417 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_417;
[ R_TX_S_418 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [close] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [close] [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: close]
    ConjugateVerb_25(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1397; .L_SayX1363;rtrue;
];
Array TX_S_418 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_418;
[ R_TX_S_419 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [close].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [close].~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: close]
    ConjugateVerb_25(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~.~]
    ParaContent(); print "."; .L_Say1398; .L_SayX1364;rtrue;
];
Array TX_S_419 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_419;
[ R_TX_S_420 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't wear] [regarding the noun][those]!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't wear] [regarding the noun][those]!~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't wear]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_13); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [7: those]
    ParaContent(); (PHR_771_r91 ());! [8: ~!~]
    ParaContent(); print "!"; .L_Say1399; .L_SayX1365;rtrue;
];
Array TX_S_420 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_420;
[ R_TX_S_421 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [aren't] holding [regarding the noun][those]!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [aren't] holding [regarding the noun][those]!~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ holding ~]
    ParaContent(); print " holding ";! [6: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [7: those]
    ParaContent(); (PHR_771_r91 ());! [8: ~!~]
    ParaContent(); print "!"; .L_Say1400; .L_SayX1366;rtrue;
];
Array TX_S_421 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_421;
[ R_TX_S_422 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We]['re] already wearing [regarding the noun][those]!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We]['re] already wearing [regarding the noun][those]!~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: 're]
    ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1; ! [4: ~ already wearing ~]
    ParaContent(); print " already wearing ";! [5: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [6: those]
    ParaContent(); (PHR_771_r91 ());! [7: ~!~]
    ParaContent(); print "!"; .L_Say1401; .L_SayX1367;rtrue;
];
Array TX_S_422 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_422;
[ R_TX_S_423 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [put] on [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [put] on [the noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: put]
    ConjugateVerb_51(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ on ~]
    ParaContent(); print " on ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1402; .L_SayX1368;rtrue;
];
Array TX_S_423 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_423;
[ R_TX_S_424 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [put] on [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [put] on [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: put]
    ConjugateVerb_51(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ on ~]
    ParaContent(); print " on ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1403; .L_SayX1369;rtrue;
];
Array TX_S_424 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_424;
[ R_TX_S_425 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [aren't] wearing [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [aren't] wearing [the noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ wearing ~]
    ParaContent(); print " wearing ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1404; .L_SayX1370;rtrue;
];
Array TX_S_425 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_425;
[ R_TX_S_426 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We]['re] carrying too many things already.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We]['re] carrying too many things already.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: 're]
    ConjugateVerb_74(CV_POS, PNToVP(), story_tense); say__p=1; ! [4: ~ carrying too many things already.~]
    ParaContent(); print " carrying too many things already."; .L_Say1405; .L_SayX1371;rtrue;
];
Array TX_S_426 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_426;
[ R_TX_S_427 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [take] off [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [take] off [the noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: take]
    ConjugateVerb_61(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ off ~]
    ParaContent(); print " off ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1406; .L_SayX1372;rtrue;
];
Array TX_S_427 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_427;
[ R_TX_S_428 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [take] off [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [take] off [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: take]
    ConjugateVerb_61(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ off ~]
    ParaContent(); print " off ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1407; .L_SayX1373;rtrue;
];
Array TX_S_428 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_428;
[ R_TX_S_429 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [aren't] holding [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [aren't] holding [the noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ holding ~]
    ParaContent(); print " holding ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1408; .L_SayX1374;rtrue;
];
Array TX_S_429 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_429;
[ R_TX_S_430 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't give] [the noun] to [ourselves].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't give] [the noun] to [ourselves].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't give]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense, ConjugateVerb_33); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~ to ~]
    ParaContent(); print " to ";! [8: ourselves]
    ParaContent(); (PHR_762_r25 ());! [9: ~.~]
    ParaContent(); print "."; .L_Say1409; .L_SayX1375;rtrue;
];
Array TX_S_430 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_430;
[ R_TX_S_431 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The second noun] [aren't] able to receive things.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The second noun] [aren't] able to receive things.~]
    say__p=1;! [2: the second noun]
    ParaContent(); print (The) second;! [3: ~ ~]
    ParaContent(); print " ";! [4: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ able to receive things.~]
    ParaContent(); print " able to receive things."; .L_Say1410; .L_SayX1376;rtrue;
];
Array TX_S_431 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_431;
[ R_TX_S_432 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(first taking [the noun] off)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(first taking [the noun] off)[command clarification break]~]
    say__p=1;! [2: ~(first taking ~]
    ParaContent(); print "(first taking ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~ off)~]
    ParaContent(); print " off)";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1411; .L_SayX1377;rtrue;
];
Array TX_S_432 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_432;
[ R_TX_S_433 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The second noun] [are] carrying too many things already.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The second noun] [are] carrying too many things already.~]
    say__p=1;! [2: the second noun]
    ParaContent(); print (The) second;! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ carrying too many things already.~]
    ParaContent(); print " carrying too many things already."; .L_Say1412; .L_SayX1378;rtrue;
];
Array TX_S_433 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_433;
[ R_TX_S_434 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [aren't] holding [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [aren't] holding [the noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ holding ~]
    ParaContent(); print " holding ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1413; .L_SayX1379;rtrue;
];
Array TX_S_434 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_434;
[ R_TX_S_435 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~That [seem] unnecessary.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~That [seem] unnecessary.~]
    say__p=1;! [2: ~That ~]
    ParaContent(); print "That ";! [3: seem]
    ConjugateVerb_55(CV_POS, PNToVP(), story_tense); say__p=1; ! [4: ~ unnecessary.~]
    ParaContent(); print " unnecessary."; .L_Say1414; .L_SayX1380;rtrue;
];
Array TX_S_435 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_435;
[ R_TX_S_436 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(first taking [the noun] off)[command clarification break]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(first taking [the noun] off)[command clarification break]~]
    say__p=1;! [2: ~(first taking ~]
    ParaContent(); print "(first taking ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~ off)~]
    ParaContent(); print " off)";! [5: command clarification break]
    ParaContent(); CommandClarificationBreak(); .L_Say1415; .L_SayX1381;rtrue;
];
Array TX_S_436 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_436;
[ R_TX_S_437 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Futile.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Futile.~]
    say__p=1;! [2: ~Futile.~]
    ParaContent(); print "Futile."; .L_Say1416; .L_SayX1382;rtrue;
];
Array TX_S_437 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_437;
[ R_TX_S_438 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [lack] the nerve when it [if story tense is the past
    tense]came[otherwise]comes[end if] to the crucial moment.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [lack] the nerve when it [if story tense is the past tense]came[otherwise]comes[end if] to the crucial moment.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: lack]
    ConjugateVerb_38(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ the nerve when it ~]
    ParaContent(); print " the nerve when it ";! [6: if story tense is the past tense]

    	if (~~((((story_tense == I113_past_tense))))) jump L_Say1417;! [7: ~came~]
    ParaContent(); print "came";! [8: otherwise]

    	jump L_SayX1383; .L_Say1417;! [9: ~comes~]
    ParaContent(); print "comes";! [10: end if]

    	.L_Say1418; .L_SayX1383;! [11: ~ to the crucial moment.~]
    ParaContent(); print " to the crucial moment."; .L_Say1419; .L_SayX1384;rtrue;
];
Array TX_S_438 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_438;
[ R_TX_S_439 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There are no walls.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~There are no walls.~]
    say__p=1;! [2: ~There are no walls.~]
    ParaContent(); print "There are no walls."; .L_Say1420; .L_SayX1385;rtrue;
];
Array TX_S_439 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_439;
[ R_TX_S_440 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There is no ceiling.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~There is no ceiling.~]
    say__p=1;! [2: ~There is no ceiling.~]
    ParaContent(); print "There is no ceiling."; .L_Say1421; .L_SayX1386;rtrue;
];
Array TX_S_440 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_440;
[ R_TX_S_441 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] would just embarrass [ourselves].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] would just embarrass [ourselves].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ would just embarrass ~]
    ParaContent(); print " would just embarrass ";! [4: ourselves]
    ParaContent(); (PHR_762_r25 ());! [5: ~.~]
    ParaContent(); print "."; .L_Say1422; .L_SayX1387;rtrue;
];
Array TX_S_441 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_441;
[ R_TX_S_442 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] would just embarrass [ourselves].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] would just embarrass [ourselves].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ would just embarrass ~]
    ParaContent(); print " would just embarrass ";! [4: ourselves]
    ParaContent(); (PHR_762_r25 ());! [5: ~.~]
    ParaContent(); print "."; .L_Say1423; .L_SayX1388;rtrue;
];
Array TX_S_442 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_442;
[ R_TX_S_443 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] would just look like a nutcase.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] would just look like a nutcase.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ would just look like a nutcase.~]
    ParaContent(); print " would just look like a nutcase."; .L_Say1424; .L_SayX1389;rtrue;
];
Array TX_S_443 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_443;
[ R_TX_S_444 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Violence [aren't] the answer to this one.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Violence [aren't] the answer to this one.~]
    say__p=1;! [2: ~Violence ~]
    ParaContent(); print "Violence ";! [3: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [4: ~ the answer to this one.~]
    ParaContent(); print " the answer to this one."; .L_Say1425; .L_SayX1390;rtrue;
];
Array TX_S_444 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_444;
[ R_TX_S_445 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [don't] get much from that.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [don't] get much from that.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: don't]
    ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ get much from that.~]
    ParaContent(); print " get much from that."; .L_Say1426; .L_SayX1391;rtrue;
];
Array TX_S_445 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_445;
[ R_TX_S_446 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [might not] like that.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [might not] like that.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: might not]
    ConjugateVerb_70(CV_NEG, PNToVP(), story_tense); say__p=1; ! [5: ~ like that.~]
    ParaContent(); print " like that."; .L_Say1427; .L_SayX1392;rtrue;
];
Array TX_S_446 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_446;
[ R_TX_S_447 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [talk] to [ourselves] a while.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [talk] to [ourselves] a while.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: talk]
    ConjugateVerb_62(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ to ~]
    ParaContent(); print " to ";! [6: ourselves]
    ParaContent(); (PHR_762_r25 ());! [7: ~ a while.~]
    ParaContent(); print " a while."; .L_Say1428; .L_SayX1393;rtrue;
];
Array TX_S_447 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_447;
[ R_TX_S_449 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [wait].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [wait].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: wait]
    ConjugateVerb_65(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~.~]
    ParaContent(); print "."; .L_Say1429; .L_SayX1394;rtrue;
];
Array TX_S_449 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_449;
[ R_TX_S_450 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [achieve] nothing by this.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [achieve] nothing by this.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: achieve]
    ConjugateVerb_21(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ nothing by this.~]
    ParaContent(); print " nothing by this."; .L_Say1430; .L_SayX1395;rtrue;
];
Array TX_S_450 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_450;
[ R_TX_S_451 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [touch] [themselves].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [touch] [themselves].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: touch]
    ConjugateVerb_18(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: themselves]
    ParaContent(); (PHR_783_r99 ());! [7: ~.~]
    ParaContent(); print "."; .L_Say1431; .L_SayX1396;rtrue;
];
Array TX_S_451 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_451;
[ R_TX_S_452 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [might not like] that.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [might not like] that.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: might not like]
    ConjugateVerb_70(CV_NEG, PNToVP(), story_tense, ConjugateVerb_40); say__p=1; ! [5: ~ that.~]
    ParaContent(); print " that."; .L_Say1432; .L_SayX1397;rtrue;
];
Array TX_S_452 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_452;
[ R_TX_S_453 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [touch] [us].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [touch] [us].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: touch]
    ConjugateVerb_18(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: us]
    ParaContent(); (PHR_760_r49 ());! [7: ~.~]
    ParaContent(); print "."; .L_Say1433; .L_SayX1398;rtrue;
];
Array TX_S_453 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_453;
[ R_TX_S_454 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [touch] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [touch] [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: touch]
    ConjugateVerb_18(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1434; .L_SayX1399;rtrue;
];
Array TX_S_454 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_454;
[ R_TX_S_455 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [feel] nothing unexpected.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [feel] nothing unexpected.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: feel]
    ConjugateVerb_30(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ nothing unexpected.~]
    ParaContent(); print " nothing unexpected."; .L_Say1435; .L_SayX1400;rtrue;
];
Array TX_S_455 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_455;
[ R_TX_S_456 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [touch] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [touch] [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: touch]
    ConjugateVerb_18(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1436; .L_SayX1401;rtrue;
];
Array TX_S_456 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_456;
[ R_TX_S_457 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~But [we] [aren't] holding [regarding the noun][those].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~But [we] [aren't] holding [regarding the noun][those].~]
    say__p=1;! [2: ~But ~]
    ParaContent(); print "But ";! [3: we]
    ParaContent(); (PHR_757_r16 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ holding ~]
    ParaContent(); print " holding ";! [7: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [8: those]
    ParaContent(); (PHR_771_r91 ());! [9: ~.~]
    ParaContent(); print "."; .L_Say1437; .L_SayX1402;rtrue;
];
Array TX_S_457 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_457;
[ R_TX_S_458 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [wave] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [wave] [the noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: wave]
    ConjugateVerb_66(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1438; .L_SayX1403;rtrue;
];
Array TX_S_458 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_458;
[ R_TX_S_459 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [wave] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [wave] [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: wave]
    ConjugateVerb_66(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1439; .L_SayX1404;rtrue;
];
Array TX_S_459 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_459;
[ R_TX_S_462 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [might not like] that.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [might not like] that.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: might not like]
    ConjugateVerb_70(CV_NEG, PNToVP(), story_tense, ConjugateVerb_40); say__p=1; ! [5: ~ that.~]
    ParaContent(); print " that."; .L_Say1440; .L_SayX1405;rtrue;
];
Array TX_S_462 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_462;
[ R_TX_S_463 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Nothing obvious [happen].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Nothing obvious [happen].~]
    say__p=1;! [2: ~Nothing obvious ~]
    ParaContent(); print "Nothing obvious ";! [3: happen]
    ConjugateVerb_35(CV_POS, PNToVP(), story_tense); say__p=1; ! [4: ~.~]
    ParaContent(); print "."; .L_Say1441; .L_SayX1406;rtrue;
];
Array TX_S_463 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_463;
[ R_TX_S_464 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [pull] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [pull] [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: pull]
    ConjugateVerb_49(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1442; .L_SayX1407;rtrue;
];
Array TX_S_464 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_464;
[ R_TX_S_467 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [might not like] that.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [might not like] that.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: might not like]
    ConjugateVerb_70(CV_NEG, PNToVP(), story_tense, ConjugateVerb_40); say__p=1; ! [5: ~ that.~]
    ParaContent(); print " that."; .L_Say1443; .L_SayX1408;rtrue;
];
Array TX_S_467 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_467;
[ R_TX_S_468 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Nothing obvious [happen].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Nothing obvious [happen].~]
    say__p=1;! [2: ~Nothing obvious ~]
    ParaContent(); print "Nothing obvious ";! [3: happen]
    ConjugateVerb_35(CV_POS, PNToVP(), story_tense); say__p=1; ! [4: ~.~]
    ParaContent(); print "."; .L_Say1444; .L_SayX1409;rtrue;
];
Array TX_S_468 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_468;
[ R_TX_S_469 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [push] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [push] [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: push]
    ConjugateVerb_50(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1445; .L_SayX1410;rtrue;
];
Array TX_S_469 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_469;
[ R_TX_S_470 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They] [are] fixed in place.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They] [are] fixed in place.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they]
    ParaContent(); (PHR_776_r43 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ fixed in place.~]
    ParaContent(); print " fixed in place."; .L_Say1446; .L_SayX1411;rtrue;
];
Array TX_S_470 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_470;
[ R_TX_S_471 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [are] unable to.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [are] unable to.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ unable to.~]
    ParaContent(); print " unable to."; .L_Say1447; .L_SayX1412;rtrue;
];
Array TX_S_471 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_471;
[ R_TX_S_472 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [might not like] that.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [might not like] that.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: might not like]
    ConjugateVerb_70(CV_NEG, PNToVP(), story_tense, ConjugateVerb_40); say__p=1; ! [5: ~ that.~]
    ParaContent(); print " that."; .L_Say1448; .L_SayX1413;rtrue;
];
Array TX_S_472 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_472;
[ R_TX_S_473 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Nothing obvious [happen].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Nothing obvious [happen].~]
    say__p=1;! [2: ~Nothing obvious ~]
    ParaContent(); print "Nothing obvious ";! [3: happen]
    ConjugateVerb_35(CV_POS, PNToVP(), story_tense); say__p=1; ! [4: ~.~]
    ParaContent(); print "."; .L_Say1449; .L_SayX1414;rtrue;
];
Array TX_S_473 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_473;
[ R_TX_S_474 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [turn] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [turn] [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: turn]
    ConjugateVerb_64(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1450; .L_SayX1415;rtrue;
];
Array TX_S_474 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_474;
[ R_TX_S_475 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [cannot] be pushed from place to place.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [cannot] be pushed from place to place.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: cannot]
    ConjugateVerb_15(CV_NEG, PNToVP(), story_tense); say__p=1; ! [5: ~ be pushed from place to place.~]
    ParaContent(); print " be pushed from place to place."; .L_Say1451; .L_SayX1416;rtrue;
];
Array TX_S_475 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_475;
[ R_TX_S_476 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They] [aren't] a direction.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They] [aren't] a direction.~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they]
    ParaContent(); (PHR_776_r43 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ a direction.~]
    ParaContent(); print " a direction."; .L_Say1452; .L_SayX1417;rtrue;
];
Array TX_S_476 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_476;
[ R_TX_S_477 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [cannot] be pushed up or down.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [cannot] be pushed up or down.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: cannot]
    ConjugateVerb_15(CV_NEG, PNToVP(), story_tense); say__p=1; ! [5: ~ be pushed up or down.~]
    ParaContent(); print " be pushed up or down."; .L_Say1453; .L_SayX1418;rtrue;
];
Array TX_S_477 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_477;
[ R_TX_S_478 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [cannot] be pushed from here.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [cannot] be pushed from here.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: cannot]
    ConjugateVerb_15(CV_NEG, PNToVP(), story_tense); say__p=1; ! [5: ~ be pushed from here.~]
    ParaContent(); print " be pushed from here."; .L_Say1454; .L_SayX1419;rtrue;
];
Array TX_S_478 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_478;
[ R_TX_S_479 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [cannot] be pushed from place to place.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [cannot] be pushed from place to place.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: cannot]
    ConjugateVerb_15(CV_NEG, PNToVP(), story_tense); say__p=1; ! [5: ~ be pushed from place to place.~]
    ParaContent(); print " be pushed from place to place."; .L_Say1455; .L_SayX1420;rtrue;
];
Array TX_S_479 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_479;
[ R_TX_S_480 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [might not like] that.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [might not like] that.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: might not like]
    ConjugateVerb_70(CV_NEG, PNToVP(), story_tense, ConjugateVerb_40); say__p=1; ! [5: ~ that.~]
    ParaContent(); print " that."; .L_Say1456; .L_SayX1421;rtrue;
];
Array TX_S_480 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_480;
[ R_TX_S_481 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [achieve] nothing by this.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [achieve] nothing by this.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: achieve]
    ConjugateVerb_21(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ nothing by this.~]
    ParaContent(); print " nothing by this."; .L_Say1457; .L_SayX1422;rtrue;
];
Array TX_S_481 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_481;
[ R_TX_S_482 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [squeeze] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [squeeze] [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: squeeze]
    ConjugateVerb_59(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1458; .L_SayX1423;rtrue;
];
Array TX_S_482 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_482;
[ R_TX_S_483 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There are no walls.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~There are no walls.~]
    say__p=1;! [2: ~There are no walls.~]
    ParaContent(); print "There are no walls."; .L_Say1459; .L_SayX1424;rtrue;
];
Array TX_S_483 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_483;
[ R_TX_S_484 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There is no ceiling.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~There is no ceiling.~]
    say__p=1;! [2: ~There is no ceiling.~]
    ParaContent(); print "There is no ceiling."; .L_Say1460; .L_SayX1425;rtrue;
];
Array TX_S_484 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_484;
[ R_TX_S_485 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~That's just daft.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~That's just daft.~]
    say__p=1;! [2: ~That's just daft.~]
    ParaContent(); print "That's just daft."; .L_Say1461; .L_SayX1426;rtrue;
];
Array TX_S_485 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_485;
[ R_TX_S_486 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~That's just daft.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~That's just daft.~]
    say__p=1;! [2: ~That's just daft.~]
    ParaContent(); print "That's just daft."; .L_Say1462; .L_SayX1427;rtrue;
];
Array TX_S_486 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_486;
[ R_TX_S_487 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~That isn't possible.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~That isn't possible.~]
    say__p=1;! [2: ~That isn't possible.~]
    ParaContent(); print "That isn't possible."; .L_Say1463; .L_SayX1428;rtrue;
];
Array TX_S_487 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_487;
[ R_TX_S_488 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Cutting [regarding the noun][them] up [would achieve] little.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Cutting [regarding the noun][them] up [would achieve] little.~]
    say__p=1;! [2: ~Cutting ~]
    ParaContent(); print "Cutting ";! [3: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [4: them]
    ParaContent(); (PHR_779_r69 ());! [5: ~ up ~]
    ParaContent(); print " up ";! [6: would achieve]
    ConjugateVerb_73(CV_POS, PNToVP(), story_tense, ConjugateVerb_21); say__p=1; ! [7: ~ little.~]
    ParaContent(); print " little."; .L_Say1464; .L_SayX1429;rtrue;
];
Array TX_S_488 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_488;
[ R_TX_S_489 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There are no walls.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~There are no walls.~]
    say__p=1;! [2: ~There are no walls.~]
    ParaContent(); print "There are no walls."; .L_Say1465; .L_SayX1430;rtrue;
];
Array TX_S_489 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_489;
[ R_TX_S_490 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There is no floor.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~There is no floor.~]
    say__p=1;! [2: ~There is no floor.~]
    ParaContent(); print "There is no floor."; .L_Say1466; .L_SayX1431;rtrue;
];
Array TX_S_490 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_490;
[ R_TX_S_491 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] can't reach the ceiling.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] can't reach the ceiling.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ can't reach the ceiling.~]
    ParaContent(); print " can't reach the ceiling."; .L_Say1467; .L_SayX1432;rtrue;
];
Array TX_S_491 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_491;
[ R_TX_S_492 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There is no ceiling.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~There is no ceiling.~]
    say__p=1;! [2: ~There is no ceiling.~]
    ParaContent(); print "There is no ceiling."; .L_Say1468; .L_SayX1433;rtrue;
];
Array TX_S_492 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_492;
[ R_TX_S_493 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] [might not like] that.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] [might not like] that.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ ~]
    ParaContent(); print " ";! [4: might not like]
    ConjugateVerb_70(CV_NEG, PNToVP(), story_tense, ConjugateVerb_40); say__p=1; ! [5: ~ that.~]
    ParaContent(); print " that."; .L_Say1469; .L_SayX1434;rtrue;
];
Array TX_S_493 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_493;
[ R_TX_S_494 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [rub] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [rub] [the noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: rub]
    ConjugateVerb_52(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1470; .L_SayX1435;rtrue;
];
Array TX_S_494 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_494;
[ R_TX_S_495 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [rub] [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [rub] [the noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: rub]
    ConjugateVerb_52(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1471; .L_SayX1436;rtrue;
];
Array TX_S_495 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_495;
[ R_TX_S_496 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Nothing [are] on sale.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Nothing [are] on sale.~]
    say__p=1;! [2: ~Nothing ~]
    ParaContent(); print "Nothing ";! [3: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [4: ~ on sale.~]
    ParaContent(); print " on sale."; .L_Say1472; .L_SayX1437;rtrue;
];
Array TX_S_496 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_496;
[ R_TX_S_497 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[noun] - [if the noun is seen]seen[otherwise]unseen[end if] /
    [if the noun is familiar]familiar[otherwise]unfamiliar[end if] /
    [if the noun is known]known[otherwise]unknown[end if].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[noun] - [if the noun is seen]seen[otherwise]unseen[end if] / [if the noun is familiar]familiar[otherwise]unfamiliar[end if] / [if the noun is known]known[otherwise]unknown[end if].~]
    say__p=1;! [2: noun]
    ParaContent(); PrintShortName(noun);! [3: ~ - ~]
    ParaContent(); print " - ";! [4: if the noun is seen]

    	if (~~(((((Adj_116_t1_v10(noun))))))) jump L_Say1473;! [5: ~seen~]
    ParaContent(); print "seen";! [6: otherwise]

    	jump L_SayX1438; .L_Say1473;! [7: ~unseen~]
    ParaContent(); print "unseen";! [8: end if]

    	.L_Say1474; .L_SayX1438;! [9: ~ / ~]
    ParaContent(); print " / ";! [10: if the noun is familiar]

    	if (~~(((((Adj_118_t1_v10(noun))))))) jump L_Say1475;! [11: ~familiar~]
    ParaContent(); print "familiar";! [12: otherwise]

    	jump L_SayX1439; .L_Say1475;! [13: ~unfamiliar~]
    ParaContent(); print "unfamiliar";! [14: end if]

    	.L_Say1476; .L_SayX1439;! [15: ~ / ~]
    ParaContent(); print " / ";! [16: if the noun is known]

    	if (~~(((((Adj_42_t1_v10(noun))))))) jump L_Say1477;! [17: ~known~]
    ParaContent(); print "known";! [18: otherwise]

    	jump L_SayX1440; .L_Say1477;! [19: ~unknown~]
    ParaContent(); print "unknown";! [20: end if]

    	.L_Say1478; .L_SayX1440;! [21: ~.~]
    ParaContent(); print "."; .L_Say1479; .L_SayX1441;rtrue;
];
Array TX_S_497 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_497;
[ R_TX_S_499 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [are] already talking to [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [are] already talking to [the noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ already talking to ~]
    ParaContent(); print " already talking to ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1480; .L_SayX1442;rtrue;
];
Array TX_S_499 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_499;
[ R_TX_S_501 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [say] hello to [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [say] hello to [the noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: say]
    ConjugateVerb_53(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ hello to ~]
    ParaContent(); print " hello to ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1481; .L_SayX1443;rtrue;
];
Array TX_S_501 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_501;
[ R_TX_S_502 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [are] already talking to [the current interlocutor].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [are] already talking to [the current interlocutor].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ already talking to ~]
    ParaContent(); print " already talking to ";! [6: the current interlocutor]
    ParaContent(); print (the) (Global_Vars-->11);! [7: ~.~]
    ParaContent(); print "."; .L_Say1482; .L_SayX1444;rtrue;
];
Array TX_S_502 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_502;
[ R_TX_S_503 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(addressing [the noun])~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(addressing [the noun])~]
    say__p=1;! [2: ~(addressing ~]
    ParaContent(); print "(addressing ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~)~]
    ParaContent(); print ")"; .L_Say1483; .L_SayX1445;rtrue;
];
Array TX_S_503 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_503;
[ R_TX_S_504 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [aren't] talking to anyone.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [aren't] talking to anyone.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ talking to anyone.~]
    ParaContent(); print " talking to anyone."; .L_Say1484; .L_SayX1446;rtrue;
];
Array TX_S_504 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_504;
[ R_TX_S_505 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [aren't] talking to [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [aren't] talking to [the noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ talking to ~]
    ParaContent(); print " talking to ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~.~]
    ParaContent(); print "."; .L_Say1485; .L_SayX1447;rtrue;
];
Array TX_S_505 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_505;
[ R_TX_S_507 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[paragraph break]Please press SPACE to continue.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[paragraph break]Please press SPACE to continue.~]
    say__p=1;! [2: paragraph break]
    ParaContent(); DivideParagraphPoint(); new_line;! [3: ~Please press SPACE to continue.~]
    ParaContent(); print "Please press SPACE to continue."; .L_Say1486; .L_SayX1448;rtrue;
];
Array TX_S_507 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_507;
[ R_TX_S_514 
    tmp_0 ! Let/loop value, e.g., 'phone': phone
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The noun] isn't ringing.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The noun] isn't ringing.~]
    say__p=1;! [2: the noun]
    ParaContent(); print (The) noun;! [3: ~ isn't ringing.~]
    ParaContent(); print " isn't ringing."; .L_Say1487; .L_SayX1449;rtrue;
];
Array TX_S_514 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_514;
[ R_TX_S_515 
    tmp_0 ! Let/loop value, e.g., 'phone': phone
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~You're already talking on [the noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You're already talking on [the noun].~]
    say__p=1;! [2: ~You're already talking on ~]
    ParaContent(); print "You're already talking on ";! [3: the noun]
    ParaContent(); print (the) noun;! [4: ~.~]
    ParaContent(); print "."; .L_Say1488; .L_SayX1450;rtrue;
];
Array TX_S_515 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_515;
[ R_TX_S_516 
    tmp_0 ! Let/loop value, e.g., 'phone': phone
    tmp_1 ! Let/loop value, e.g., 'caller': thing
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Oh I get it. You think you're clever, calling yourself. Well I won't put up with that kind of shenanigans.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Oh I get it. You think you're clever, calling yourself. Well I won't put up with that kind of shenanigans.~]
    say__p=1;! [2: ~Oh I get it. You think you're clever, calling yourself. Well I won't put up with that kind of shenanigans.~]
    ParaContent(); print "Oh I get it. You think you're clever, calling yourself. Well I won't put up with that kind of shenanigans."; .L_Say1489; .L_SayX1451;rtrue;
];
Array TX_S_516 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_516;
[ R_TX_S_520 
    tmp_0 ! Let/loop value, e.g., 'phone': phone
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[Actor] answers [the phone].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[Actor] answers [the phone].~]
    say__p=1;! [2: actor]
    ParaContent(); PrintShortName(actor);! [3: ~ answers ~]
    ParaContent(); print " answers ";! [4: the phone]
    ParaContent(); print (the) tmp_0;! [5: ~.~]
    ParaContent(); print "."; .L_Say1490; .L_SayX1452;rtrue;
];
Array TX_S_520 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_520;
[ R_TX_S_521 
    tmp_0 ! Let/loop value, e.g., 'phone': phone
    tmp_1 ! Let/loop value, e.g., 'caller': thing
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~You answer [the phone].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~You answer [the phone].~]
    say__p=1;! [2: ~You answer ~]
    ParaContent(); print "You answer ";! [3: the phone]
    ParaContent(); print (the) tmp_0;! [4: ~.~]
    ParaContent(); print "."; .L_Say1491; .L_SayX1453;rtrue;
];
Array TX_S_521 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_521;
[ R_TX_S_524 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [see] nothing special about the walls.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [see] nothing special about the walls.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: see]
    ConjugateVerb_16(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ nothing special about the walls.~]
    ParaContent(); print " nothing special about the walls."; .L_Say1492; .L_SayX1454;rtrue;
];
Array TX_S_524 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_524;
[ R_TX_S_525 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There are no walls to see.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~There are no walls to see.~]
    say__p=1;! [2: ~There are no walls to see.~]
    ParaContent(); print "There are no walls to see."; .L_Say1493; .L_SayX1455;rtrue;
];
Array TX_S_525 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_525;
[ R_TX_S_526 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [feel] nothing special about the walls.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [feel] nothing special about the walls.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: feel]
    ConjugateVerb_30(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ nothing special about the walls.~]
    ParaContent(); print " nothing special about the walls."; .L_Say1494; .L_SayX1456;rtrue;
];
Array TX_S_526 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_526;
[ R_TX_S_527 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There are no walls to feel.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~There are no walls to feel.~]
    say__p=1;! [2: ~There are no walls to feel.~]
    ParaContent(); print "There are no walls to feel."; .L_Say1495; .L_SayX1457;rtrue;
];
Array TX_S_527 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_527;
[ R_TX_S_528 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [see] nothing special about the [if the location is indoors]floor[otherwise]ground[end if].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [see] nothing special about the [if the location is indoors]floor[otherwise]ground[end if].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: see]
    ConjugateVerb_16(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ nothing special about the ~]
    ParaContent(); print " nothing special about the ";! [6: if the location is indoors]

    	if (~~(((((Adj_122_t1_v10(real_location))))))) jump L_Say1496;! [7: ~floor~]
    ParaContent(); print "floor";! [8: otherwise]

    	jump L_SayX1458; .L_Say1496;! [9: ~ground~]
    ParaContent(); print "ground";! [10: end if]

    	.L_Say1497; .L_SayX1458;! [11: ~.~]
    ParaContent(); print "."; .L_Say1498; .L_SayX1459;rtrue;
];
Array TX_S_528 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_528;
[ R_TX_S_529 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There is no floor to see.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~There is no floor to see.~]
    say__p=1;! [2: ~There is no floor to see.~]
    ParaContent(); print "There is no floor to see."; .L_Say1499; .L_SayX1460;rtrue;
];
Array TX_S_529 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_529;
[ R_TX_S_530 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [feel] nothing special about the floor.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [feel] nothing special about the floor.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: feel]
    ConjugateVerb_30(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ nothing special about the floor.~]
    ParaContent(); print " nothing special about the floor."; .L_Say1500; .L_SayX1461;rtrue;
];
Array TX_S_530 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_530;
[ R_TX_S_531 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [feel] nothing special about the ground.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [feel] nothing special about the ground.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: feel]
    ConjugateVerb_30(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ nothing special about the ground.~]
    ParaContent(); print " nothing special about the ground."; .L_Say1501; .L_SayX1462;rtrue;
];
Array TX_S_531 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_531;
[ R_TX_S_532 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There is no floor to feel.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~There is no floor to feel.~]
    say__p=1;! [2: ~There is no floor to feel.~]
    ParaContent(); print "There is no floor to feel."; .L_Say1502; .L_SayX1463;rtrue;
];
Array TX_S_532 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_532;
[ R_TX_S_533 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [see] nothing special about the ceiling.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [see] nothing special about the ceiling.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: see]
    ConjugateVerb_16(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ nothing special about the ceiling.~]
    ParaContent(); print " nothing special about the ceiling."; .L_Say1503; .L_SayX1464;rtrue;
];
Array TX_S_533 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_533;
[ R_TX_S_534 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There's nothing up there but sky.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~There's nothing up there but sky.~]
    say__p=1;! [2: ~There's nothing up there but sky.~]
    ParaContent(); print "There's nothing up there but sky."; .L_Say1504; .L_SayX1465;rtrue;
];
Array TX_S_534 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_534;
[ R_TX_S_535 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There is no ceiling to see.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~There is no ceiling to see.~]
    say__p=1;! [2: ~There is no ceiling to see.~]
    ParaContent(); print "There is no ceiling to see."; .L_Say1505; .L_SayX1466;rtrue;
];
Array TX_S_535 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_535;
[ R_TX_S_536 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't] reach the ceiling.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't] reach the ceiling.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ reach the ceiling.~]
    ParaContent(); print " reach the ceiling."; .L_Say1506; .L_SayX1467;rtrue;
];
Array TX_S_536 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_536;
[ R_TX_S_537 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [feel] nothing special about the ceiling.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [feel] nothing special about the ceiling.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: feel]
    ConjugateVerb_30(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ nothing special about the ceiling.~]
    ParaContent(); print " nothing special about the ceiling."; .L_Say1507; .L_SayX1468;rtrue;
];
Array TX_S_537 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_537;
[ R_TX_S_538 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't] touch the sky.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't] touch the sky.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ touch the sky.~]
    ParaContent(); print " touch the sky."; .L_Say1508; .L_SayX1469;rtrue;
];
Array TX_S_538 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_538;
[ R_TX_S_539 
    tmp_0 ! Let/loop value, e.g., 'R': room
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There is no ceiling to feel.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~There is no ceiling to feel.~]
    say__p=1;! [2: ~There is no ceiling to feel.~]
    ParaContent(); print "There is no ceiling to feel."; .L_Say1509; .L_SayX1470;rtrue;
];
Array TX_S_539 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_539;
[ R_TX_S_540 
    tmp_0 ! Let/loop value, e.g., 'dir': direction
    tmp_1 ! Let/loop value, e.g., 'source': room
    tmp_2 ! Let/loop value: object
    tmp_3 ! Let/loop value: object
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can] neither climb walls nor fly.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can] neither climb walls nor fly.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ neither climb walls nor fly.~]
    ParaContent(); print " neither climb walls nor fly."; .L_Say1510; .L_SayX1471;rtrue;
];
Array TX_S_540 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_540;
[ R_TX_S_541 
    tmp_0 ! Let/loop value, e.g., 'dir': direction
    tmp_1 ! Let/loop value, e.g., 'source': room
    tmp_2 ! Let/loop value: object
    tmp_3 ! Let/loop value: object
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't] just dig downward.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't] just dig downward.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ just dig downward.~]
    ParaContent(); print " just dig downward."; .L_Say1511; .L_SayX1472;rtrue;
];
Array TX_S_541 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_541;
[ R_TX_S_542 
    tmp_0 ! Let/loop value, e.g., 'dir': direction
    tmp_1 ! Let/loop value, e.g., 'source': room
    tmp_2 ! Let/loop value: object
    tmp_3 ! Let/loop value: object
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't] go that way.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't] go that way.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ go that way.~]
    ParaContent(); print " go that way."; .L_Say1512; .L_SayX1473;rtrue;
];
Array TX_S_542 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_542;
[ R_TX_S_543 
    tmp_0 ! Let/loop value, e.g., 'dir': direction
    tmp_1 ! Let/loop value, e.g., 'source': room
    tmp_2 ! Let/loop value: object
    tmp_3 ! Let/loop value: object
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~What [regarding the player][do] [we] want to enter?~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~What [regarding the player][do] [we] want to enter?~]
    say__p=1;! [2: ~What ~]
    ParaContent(); print "What ";! [3: regarding the player]
    ParaContent(); RegardingSingleObject(player);! [4: do]
    ConjugateVerb_3(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: we]
    ParaContent(); (PHR_757_r16 ());! [7: ~ want to enter?~]
    ParaContent(); print " want to enter?"; .L_Say1513; .L_SayX1474;rtrue;
];
Array TX_S_543 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_543;
[ R_TX_S_545 
    tmp_0 ! Let/loop value, e.g., 'dir': direction
    tmp_1 ! Let/loop value, e.g., 'source': room
    tmp_2 ! Let/loop value: object
    tmp_3 ! Let/loop value: object
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't] go that way.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't] go that way.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ go that way.~]
    ParaContent(); print " go that way."; .L_Say1514; .L_SayX1475;rtrue;
];
Array TX_S_545 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_545;
[ R_TX_S_546 
    tmp_0 ! Let/loop value, e.g., 'T': thing
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't] take that.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't] take that.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ take that.~]
    ParaContent(); print " take that."; .L_Say1515; .L_SayX1476;rtrue;
];
Array TX_S_546 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_546;
[ R_TX_S_547 
    tmp_0 ! Let/loop value, e.g., 'T': thing
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [can't] move that.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [can't] move that.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: can't]
    ConjugateVerb_77(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ move that.~]
    ParaContent(); print " move that."; .L_Say1516; .L_SayX1477;rtrue;
];
Array TX_S_547 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_547;
[ R_TX_S_548 
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ct_0=LocalParking-->0;
ct_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[second delimiter entry]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[second delimiter entry]~]
    say__p=1;! [2: second delimiter entry]
    ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,142,ct_1); .L_Say1517; .L_SayX1478;rtrue;
];
Array TX_S_548 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_548;
[ R_TX_S_549 
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ct_0=LocalParking-->0;
ct_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[alternate second delimiter entry]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[alternate second delimiter entry]~]
    say__p=1;! [2: alternate second delimiter entry]
    ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,143,ct_1); .L_Say1518; .L_SayX1479;rtrue;
];
Array TX_S_549 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_549;
[ R_TX_S_550 
    ct_0 ! currently selected table
    ct_1 ! currently selected row
    ;
    ct_0=LocalParking-->0;
ct_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[first delimiter entry]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[first delimiter entry]~]
    say__p=1;! [2: first delimiter entry]
    ParaContent(); print (TEXT_TY_Say) TableLookUpEntry(ct_0,141,ct_1); .L_Say1519; .L_SayX1480;rtrue;
];
Array TX_S_550 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_550;
[ R_TX_S_551 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Exit listing is now on.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Exit listing is now on.~]
    say__p=1;! [2: ~Exit listing is now on.~]
    ParaContent(); print "Exit listing is now on."; .L_Say1520; .L_SayX1481;rtrue;
];
Array TX_S_551 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_551;
[ R_TX_S_552 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Exit listing is now off.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Exit listing is now off.~]
    say__p=1;! [2: ~Exit listing is now off.~]
    ParaContent(); print "Exit listing is now off."; .L_Say1521; .L_SayX1482;rtrue;
];
Array TX_S_552 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_552;
[ R_TX_S_553 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~(Use EXITS ON to enable the status line exit lister and EXITS OFF to turn it
    off.)~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~(Use EXITS ON to enable the status line exit lister and EXITS OFF to turn it off.)~]
    say__p=1;! [2: ~(Use EXITS ON to enable the status line exit lister and EXITS OFF to turn it off.)~]
    ParaContent(); print "(Use EXITS ON to enable the status line exit lister and EXITS OFF to turn it off.)"; .L_Say1522; .L_SayX1483;rtrue;
];
Array TX_S_553 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_553;
[ R_TX_S_554 
    tmp_0 ! Let/loop value, e.g., 'TSD': two-sided door
    ;
    tmp_0=LocalParking-->0;
#ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding TSD][Those] [don't] seem to be something [we] [can] unlock.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding TSD][Those] [don't] seem to be something [we] [can] unlock.~]
    say__p=1;! [2: regarding tsd]
    ParaContent(); RegardingSingleObject(tmp_0);! [3: those]
    ParaContent(); (PHR_772_r39 ());! [4: ~ ~]
    ParaContent(); print " ";! [5: don't]
    ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ! [6: ~ seem to be something ~]
    ParaContent(); print " seem to be something ";! [7: we]
    ParaContent(); (PHR_757_r16 ());! [8: ~ ~]
    ParaContent(); print " ";! [9: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [10: ~ unlock.~]
    ParaContent(); print " unlock."; .L_Say1523; .L_SayX1484;rtrue;
];
Array TX_S_554 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_554;
[ R_TX_S_555 
    tmp_0 ! Let/loop value, e.g., 'TSD': two-sided door
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the noun][They're] unlocked at the [if story tense is present
    tense]moment[otherwise]time[end if].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the noun][They're] unlocked at the [if story tense is present tense]moment[otherwise]time[end if].~]
    say__p=1;! [2: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [3: they're]
    ParaContent(); (PHR_786_r102 ());! [4: ~ unlocked at the ~]
    ParaContent(); print " unlocked at the ";! [5: if story tense is present tense]

    	if (~~((((story_tense == I112_present_tense))))) jump L_Say1524;! [6: ~moment~]
    ParaContent(); print "moment";! [7: otherwise]

    	jump L_SayX1485; .L_Say1524;! [8: ~time~]
    ParaContent(); print "time";! [9: end if]

    	.L_Say1525; .L_SayX1485;! [10: ~.~]
    ParaContent(); print "."; .L_Say1526; .L_SayX1486;rtrue;
];
Array TX_S_555 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_555;
[ R_TX_S_556 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value: thing
    tmp_3 ! Let/loop value: thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] ~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " "; .L_Say1527; .L_SayX1487;rtrue;
];
Array TX_S_556 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_556;
[ R_TX_S_557 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value: thing
    tmp_3 ! Let/loop value: thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
tmp_3=LocalParking-->3;
ct_0=LocalParking-->4;
ct_1=LocalParking-->5;
#ifdef DEBUG; if (suppress_text_substitution) { print "~On [the domain] [we] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~On [the domain] [we] ~]
    say__p=1;! [2: ~On ~]
    ParaContent(); print "On ";! [3: the domain]
    ParaContent(); print (the) tmp_0;! [4: ~ ~]
    ParaContent(); print " ";! [5: we]
    ParaContent(); (PHR_757_r16 ());! [6: ~ ~]
    ParaContent(); print " "; .L_Say1528; .L_SayX1488;rtrue;
];
Array TX_S_557 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_557;
[ R_TX_S_558 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value: thing
    tmp_3 ! Let/loop value: thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
tmp_2=LocalParking-->2;
tmp_3=LocalParking-->3;
ct_0=LocalParking-->4;
ct_1=LocalParking-->5;
#ifdef DEBUG; if (suppress_text_substitution) { print "~In [the domain] [we] ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~In [the domain] [we] ~]
    say__p=1;! [2: ~In ~]
    ParaContent(); print "In ";! [3: the domain]
    ParaContent(); print (the) tmp_0;! [4: ~ ~]
    ParaContent(); print " ";! [5: we]
    ParaContent(); (PHR_757_r16 ());! [6: ~ ~]
    ParaContent(); print " "; .L_Say1529; .L_SayX1489;rtrue;
];
Array TX_S_558 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_558;
[ R_TX_S_559 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value: thing
    tmp_3 ! Let/loop value: thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the player][can] also see ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the player][can] also see ~]
    say__p=1;! [2: regarding the player]
    ParaContent(); RegardingSingleObject(player);! [3: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [4: ~ also see ~]
    ParaContent(); print " also see "; .L_Say1530; .L_SayX1490;rtrue;
];
Array TX_S_559 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_559;
[ R_TX_S_560 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value: thing
    tmp_3 ! Let/loop value: thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[regarding the player][can] see ~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[regarding the player][can] see ~]
    say__p=1;! [2: regarding the player]
    ParaContent(); RegardingSingleObject(player);! [3: can]
    ConjugateVerb_15(CV_POS, PNToVP(), story_tense); say__p=1; ! [4: ~ see ~]
    ParaContent(); print " see "; .L_Say1531; .L_SayX1491;rtrue;
];
Array TX_S_560 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_560;
[ R_TX_S_561 
    tmp_0 ! Let/loop value, e.g., 'domain': object
    tmp_1 ! Let/loop value, e.g., 'mentionable count': number
    tmp_2 ! Let/loop value, e.g., 'common holder': object
    tmp_3 ! Let/loop value, e.g., 'contents form of list': truth state
    tmp_4 ! Let/loop value: object
    tmp_5 ! Let/loop value: thing
    ct_0 ! internal use only
    ct_1 ! internal use only
    ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~ here~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ here~]
    say__p=1;! [2: ~ here~]
    ParaContent(); print " here"; .L_Say1532; .L_SayX1492;rtrue;
];
Array TX_S_561 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_561;
[ R_TX_S_562 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Darkness~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Darkness~]
    say__p=1;! [2: ~Darkness~]
    ParaContent(); print "Darkness"; .L_Say1533; .L_SayX1493;rtrue;
];
Array TX_S_562 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_562;
[ R_TX_S_563 
    tmp_0 ! Let/loop value, e.g., 'intermediate level': object
    tmp_1 ! Let/loop value, e.g., 'intermediate level count': number
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~ (on [the intermediate level])~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ (on [the intermediate level])~]
    say__p=1;! [2: ~ (on ~]
    ParaContent(); print " (on ";! [3: the intermediate level]
    ParaContent(); print (the) tmp_0;! [4: ~)~]
    ParaContent(); print ")"; .L_Say1534; .L_SayX1494;rtrue;
];
Array TX_S_563 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_563;
[ R_TX_S_564 
    tmp_0 ! Let/loop value, e.g., 'intermediate level': object
    tmp_1 ! Let/loop value, e.g., 'intermediate level count': number
    ;
    tmp_0=LocalParking-->0;
tmp_1=LocalParking-->1;
#ifdef DEBUG; if (suppress_text_substitution) { print "~ (in [the intermediate level])~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~ (in [the intermediate level])~]
    say__p=1;! [2: ~ (in ~]
    ParaContent(); print " (in ";! [3: the intermediate level]
    ParaContent(); print (the) tmp_0;! [4: ~)~]
    ParaContent(); print ")"; .L_Say1535; .L_SayX1495;rtrue;
];
Array TX_S_564 --> CONSTANT_PERISHABLE_TEXT_STORAGE R_TX_S_564;
[ R_TX_S_565 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The second noun] [don't] seem interested.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The second noun] [don't] seem interested.~]
    say__p=1;! [2: the second noun]
    ParaContent(); print (The) second;! [3: ~ ~]
    ParaContent(); print " ";! [4: don't]
    ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ seem interested.~]
    ParaContent(); print " seem interested."; .L_Say1536; .L_SayX1496;rtrue;
];
Array TX_S_565 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_565;
[ R_TX_S_566 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [give] [the noun] to [the second noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [give] [the noun] to [the second noun].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: give]
    ConjugateVerb_33(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~ to ~]
    ParaContent(); print " to ";! [8: the second noun]
    ParaContent(); print (the) second;! [9: ~.~]
    ParaContent(); print "."; .L_Say1537; .L_SayX1497;rtrue;
];
Array TX_S_566 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_566;
[ R_TX_S_567 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [give] [the noun] to [us].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [give] [the noun] to [us].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: give]
    ConjugateVerb_33(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~ to ~]
    ParaContent(); print " to ";! [8: us]
    ParaContent(); (PHR_760_r49 ());! [9: ~.~]
    ParaContent(); print "."; .L_Say1538; .L_SayX1498;rtrue;
];
Array TX_S_567 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_567;
[ R_TX_S_568 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The actor] [give] [the noun] to [the second noun].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The actor] [give] [the noun] to [the second noun].~]
    say__p=1;! [2: the actor]
    ParaContent(); print (The) actor;! [3: ~ ~]
    ParaContent(); print " ";! [4: give]
    ConjugateVerb_33(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ ~]
    ParaContent(); print " ";! [6: the noun]
    ParaContent(); print (the) noun;! [7: ~ to ~]
    ParaContent(); print " to ";! [8: the second noun]
    ParaContent(); print (the) second;! [9: ~.~]
    ParaContent(); print "."; .L_Say1539; .L_SayX1499;rtrue;
];
Array TX_S_568 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_568;
[ R_TX_S_569 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[The second noun] [are] unimpressed.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[The second noun] [are] unimpressed.~]
    say__p=1;! [2: the second noun]
    ParaContent(); print (The) second;! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ unimpressed.~]
    ParaContent(); print " unimpressed."; .L_Say1540; .L_SayX1500;rtrue;
];
Array TX_S_569 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_569;
[ R_TX_S_570 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no reply.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[There] [are] no reply.~]
    say__p=1;! [2: there]
    ParaContent(); (PHR_788_r104 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ no reply.~]
    ParaContent(); print " no reply."; .L_Say1541; .L_SayX1501;rtrue;
];
Array TX_S_570 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_570;
[ R_TX_S_571 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~This [provoke] no reaction.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~This [provoke] no reaction.~]
    say__p=1;! [2: ~This ~]
    ParaContent(); print "This ";! [3: provoke]
    ConjugateVerb_48(CV_POS, PNToVP(), story_tense); say__p=1; ! [4: ~ no reaction.~]
    ParaContent(); print " no reaction."; .L_Say1542; .L_SayX1502;rtrue;
];
Array TX_S_571 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_571;
[ R_TX_S_572 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[There] [are] no reply.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[There] [are] no reply.~]
    say__p=1;! [2: there]
    ParaContent(); (PHR_788_r104 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: are]
    ConjugateVerb_0(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ no reply.~]
    ParaContent(); print " no reply."; .L_Say1543; .L_SayX1503;rtrue;
];
Array TX_S_572 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_572;
[ R_TX_S_573 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~That was a rhetorical question.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~That was a rhetorical question.~]
    say__p=1;! [2: ~That was a rhetorical question.~]
    ParaContent(); print "That was a rhetorical question."; .L_Say1544; .L_SayX1504;rtrue;
];
Array TX_S_573 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_573;
[ R_TX_S_574 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~That was a rhetorical question.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~That was a rhetorical question.~]
    say__p=1;! [2: ~That was a rhetorical question.~]
    ParaContent(); print "That was a rhetorical question."; .L_Say1545; .L_SayX1505;rtrue;
];
Array TX_S_574 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_574;
[ R_TX_S_575 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~Oh, don't [if American dialect option is
    active]apologize[otherwise]apologise[end if].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~Oh, don't [if American dialect option is active]apologize[otherwise]apologise[end if].~]
    say__p=1;! [2: ~Oh, don't ~]
    ParaContent(); print "Oh, don't ";! [3: if american dialect option is active]

    	if (~~(((((Adj_25_t1_v16(5))))))) jump L_Say1546;! [4: ~apologize~]
    ParaContent(); print "apologize";! [5: otherwise]

    	jump L_SayX1506; .L_Say1546;! [6: ~apologise~]
    ParaContent(); print "apologise";! [7: end if]

    	.L_Say1547; .L_SayX1506;! [8: ~.~]
    ParaContent(); print "."; .L_Say1548; .L_SayX1507;rtrue;
];
Array TX_S_575 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_575;
[ R_TX_S_588 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    @push formal_par0;
    I7RBLK = KERNEL_119();
    @pull formal_par0;
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_119 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[can't take message of the noun]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[can't take message of the noun]~]
    say__p=1;! [2: can't take message of the noun]
    ParaContent(); print (TEXT_TY_Say) 
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K2_thing) && (formal_par0 ofclass K2_thing))))) && ((
                    formal_rv = (PHR_1109_r150 (I7SFRAME,formal_par0))) | 1)
                    )|| (ArgumentTypeFailed(1))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par0 = noun)
                ))
        )

    ! Resolution complete
    ; .L_Say1549; .L_SayX1508;rtrue;
];
Array TX_S_588 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_588;
[ R_TX_S_589 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~That can't be picked up.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~That can't be picked up.~]
    say__p=1;! [2: ~That can't be picked up.~]
    ParaContent(); print "That can't be picked up."; .L_Say1550; .L_SayX1509;rtrue;
];
Array TX_S_589 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_589;
[ R_TX_S_590 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [don't] have that.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [don't] have that.~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: don't]
    ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ have that.~]
    ParaContent(); print " have that."; .L_Say1551; .L_SayX1510;rtrue;
];
Array TX_S_590 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_590;
[ R_TX_S_591 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There seems to be nothing special about [regarding the noun][them].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~There seems to be nothing special about [regarding the noun][them].~]
    say__p=1;! [2: ~There seems to be nothing special about ~]
    ParaContent(); print "There seems to be nothing special about ";! [3: regarding the noun]
    ParaContent(); RegardingSingleObject(noun);! [4: them]
    ParaContent(); (PHR_779_r69 ());! [5: ~.~]
    ParaContent(); print "."; .L_Say1552; .L_SayX1511;rtrue;
];
Array TX_S_591 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_591;
[ R_TX_S_592 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~That can't be switched on and off.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~That can't be switched on and off.~]
    say__p=1;! [2: ~That can't be switched on and off.~]
    ParaContent(); print "That can't be switched on and off."; .L_Say1553; .L_SayX1512;rtrue;
];
Array TX_S_592 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_592;
[ R_TX_S_593 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [stand] around and [wait].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [stand] around and [wait].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: stand]
    ConjugateVerb_130(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ around and ~]
    ParaContent(); print " around and ";! [6: wait]
    ConjugateVerb_65(CV_POS, PNToVP(), story_tense); say__p=1; ! [7: ~.~]
    ParaContent(); print "."; .L_Say1554; .L_SayX1513;rtrue;
];
Array TX_S_593 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_593;
[ R_TX_S_594 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    @push formal_par0;
    I7RBLK = KERNEL_120();
    @pull formal_par0;
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_120 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[can't move message of the noun]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[can't move message of the noun]~]
    say__p=1;! [2: can't move message of the noun]
    ParaContent(); print (TEXT_TY_Say) 
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K2_thing) && (formal_par0 ofclass K2_thing))))) && ((
                    formal_rv = (PHR_1111_r151 (I7SFRAME,formal_par0))) | 1)
                    )|| (ArgumentTypeFailed(1))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par0 = noun)
                ))
        )

    ! Resolution complete
    ; .L_Say1555; .L_SayX1514;rtrue;
];
Array TX_S_594 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_594;
[ R_TX_S_595 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    @push formal_par0;
    I7RBLK = KERNEL_121();
    @pull formal_par0;
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_121 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[can't move message of the noun]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[can't move message of the noun]~]
    say__p=1;! [2: can't move message of the noun]
    ParaContent(); print (TEXT_TY_Say) 
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K2_thing) && (formal_par0 ofclass K2_thing))))) && ((
                    formal_rv = (PHR_1111_r151 (I7SFRAME,formal_par0))) | 1)
                    )|| (ArgumentTypeFailed(1))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par0 = noun)
                ))
        )

    ! Resolution complete
    ; .L_Say1556; .L_SayX1515;rtrue;
];
Array TX_S_595 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_595;
[ R_TX_S_596 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    @push formal_par0;
    I7RBLK = KERNEL_122();
    @pull formal_par0;
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_122 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[can't move message of the noun]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[can't move message of the noun]~]
    say__p=1;! [2: can't move message of the noun]
    ParaContent(); print (TEXT_TY_Say) 
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K2_thing) && (formal_par0 ofclass K2_thing))))) && ((
                    formal_rv = (PHR_1111_r151 (I7SFRAME,formal_par0))) | 1)
                    )|| (ArgumentTypeFailed(1))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par0 = noun)
                ))
        )

    ! Resolution complete
    ; .L_Say1557; .L_SayX1516;rtrue;
];
Array TX_S_596 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_596;
[ R_TX_S_597 I7RBLK;
    @push I7SFRAME;
    StackFrameCreate(2);
    BlkValueCreateOnStack(0, TEXT_TY);
    @push formal_par0;
    I7RBLK = KERNEL_123();
    @pull formal_par0;
    BlkValueFreeOnStack(0);
    @pull I7SFRAME;
    return I7RBLK; ! nothing
];
[ KERNEL_123 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[can't move message of the noun]~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[can't move message of the noun]~]
    say__p=1;! [2: can't move message of the noun]
    ParaContent(); print (TEXT_TY_Say) 
    ! Resolution of run-time phrase ambiguity (deciding a value):
        (
            ! This value evaluates third (i.e., last)
            formal_rv
        +
            0*(
                ! The following condition evaluates second
                ((
                    ((((((formal_par0 ofclass K2_thing) && (formal_par0 ofclass K2_thing))))) && ((
                    formal_rv = (PHR_1111_r151 (I7SFRAME,formal_par0))) | 1)
                    )|| (ArgumentTypeFailed(1))

                ))
            +
                ! The following assignments evaluate first
                ((formal_par0 = noun)
                ))
        )

    ! Resolution complete
    ; .L_Say1558; .L_SayX1517;rtrue;
];
Array TX_S_597 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_597;
[ R_TX_S_598 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~That doesn't seem to be a topic of conversation at the moment.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~That doesn't seem to be a topic of conversation at the moment.~]
    say__p=1;! [2: ~That doesn't seem to be a topic of conversation at the moment.~]
    ParaContent(); print "That doesn't seem to be a topic of conversation at the moment."; .L_Say1559; .L_SayX1518;rtrue;
];
Array TX_S_598 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_598;
[ R_TX_S_599 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~That doesn't seem to be a topic of conversation at the moment.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~That doesn't seem to be a topic of conversation at the moment.~]
    say__p=1;! [2: ~That doesn't seem to be a topic of conversation at the moment.~]
    ParaContent(); print "That doesn't seem to be a topic of conversation at the moment."; .L_Say1560; .L_SayX1519;rtrue;
];
Array TX_S_599 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_599;
[ R_TX_S_600 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [don't] generally talk to [ourselves].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [don't] generally talk to [ourselves].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: don't]
    ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ generally talk to ~]
    ParaContent(); print " generally talk to ";! [6: ourselves]
    ParaContent(); (PHR_762_r25 ());! [7: ~.~]
    ParaContent(); print "."; .L_Say1561; .L_SayX1520;rtrue;
];
Array TX_S_600 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_600;
[ R_TX_S_601 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[We] [don't] generally talk to [ourselves].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[We] [don't] generally talk to [ourselves].~]
    say__p=1;! [2: we]
    ParaContent(); (PHR_764_r7 ());! [3: ~ ~]
    ParaContent(); print " ";! [4: don't]
    ConjugateVerb_79(CV_POS, PNToVP(), story_tense); say__p=1; ! [5: ~ generally talk to ~]
    ParaContent(); print " generally talk to ";! [6: ourselves]
    ParaContent(); (PHR_762_r25 ());! [7: ~.~]
    ParaContent(); print "."; .L_Say1562; .L_SayX1521;rtrue;
];
Array TX_S_601 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_601;
[ R_TX_S_602 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~That doesn't seem to be a topic of conversation at the moment.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~That doesn't seem to be a topic of conversation at the moment.~]
    say__p=1;! [2: ~That doesn't seem to be a topic of conversation at the moment.~]
    ParaContent(); print "That doesn't seem to be a topic of conversation at the moment."; .L_Say1563; .L_SayX1522;rtrue;
];
Array TX_S_602 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_602;
[ R_TX_S_603 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~you have run afoul of the access through barriers rule!~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~you have run afoul of the access through barriers rule!~]
    say__p=1;! [2: ~you have run afoul of the access through barriers rule!~]
    ParaContent(); print "you have run afoul of the access through barriers rule!"; .L_Say1564; .L_SayX1523;rtrue;
];
Array TX_S_603 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_603;
[ R_TX_S_604 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~[if the noun is the heating vent][Our] fingers won't fit through the openings in the vent. [We]'ll have to open it first[otherwise][The noun] [aren't] open[end if].~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~[if the noun is the heating vent][Our] fingers won't fit through the openings in the vent. [We]'ll have to open it first[otherwise][The noun] [aren't] open[end if].~]
    say__p=1;! [2: if the noun is the heating vent]

    	if (~~((((noun == I469_heating_vent))))) jump L_Say1565;! [3: our]
    ParaContent(); (PHR_770_r14 ());! [4: ~ fingers won't fit through the openings in the vent. ~]
    ParaContent(); print " fingers won't fit through the openings in the vent. ";! [5: we]
    ParaContent(); (PHR_764_r7 ());! [6: ~'ll have to open it first~]
    ParaContent(); print "~ll have to open it first";! [7: otherwise]

    	jump L_SayX1524; .L_Say1565;! [8: the noun]
    ParaContent(); print (The) noun;! [9: ~ ~]
    ParaContent(); print " ";! [10: aren't]
    ConjugateVerb_76(CV_POS, PNToVP(), story_tense); say__p=1; ! [11: ~ open~]
    ParaContent(); print " open";! [12: end if]

    	.L_Say1566; .L_SayX1524;! [13: ~.~]
    ParaContent(); print "."; .L_Say1567; .L_SayX1525;rtrue;
];
Array TX_S_604 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_604;
[ R_TX_S_605 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~There's nothing like that nearby.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~There's nothing like that nearby.~]
    say__p=1;! [2: ~There's nothing like that nearby.~]
    ParaContent(); print "There's nothing like that nearby."; .L_Say1568; .L_SayX1526;rtrue;
];
Array TX_S_605 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_605;
[ R_TX_S_606 ;
    #ifdef DEBUG; if (suppress_text_substitution) { print "~I[']m not sure what you're trying to say. I might just not recognize the words you're using.~"; rtrue; }
    #endif; ! DEBUG
    ! [1: ~I[']m not sure what you're trying to say. I might just not recognize the words you're using.~]
    say__p=1;! [2: ~I~]
    ParaContent(); print "I";! [3: ']
    ParaContent(); print "'";! [4: ~m not sure what you're trying to say. I might just not recognize the words you're using.~]
    ParaContent(); print "m not sure what you're trying to say. I might just not recognize the words you're using."; .L_Say1569; .L_SayX1527;rtrue;
];
Array TX_S_606 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_606;


Array LIST_CONST_87784 --> (85721088) LIST_OF_TY MAX_POSITIVE_NUMBER 10 1 (I190_doing_nothing) ;

Array Rel_Record_0 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "equality relation"
     RELS_TEST
     0 KD13_relation_of_values Rel_Handler_0 "is";
[ Rel_Handler_0 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == Y) rtrue; rfalse;
        default: RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record_0);
    }
    rfalse;
];
Array Rel_Record_1 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "provision relation"
     RELS_TEST
     0 KD14_relation_of_objects Rel_Handler_1 "provides";
[ Rel_Handler_1 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (false) rtrue; rfalse;
        default: RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record_1);
    }
    rfalse;
];
Array Rel_Record_3 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "universal relation"
     RELS_TEST
     0 KD14_relation_of_objects Rel_Handler_3 "relates";
[ Rel_Handler_3 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (((RlnGetF(X, RR_HANDLER))(X, RELS_TEST, Y))) rtrue; rfalse;
        default: RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record_3);
    }
    rfalse;
];
Array Rel_Record_5 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "meaning relation"
     RELS_TEST
     0 KD14_relation_of_objects Rel_Handler_5 "means";
[ Rel_Handler_5 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if ((BlkValueCompare(X(CV_MEANING), Y)==0)) rtrue; rfalse;
        default: RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record_5);
    }
    rfalse;
];
Array Rel_Record_15 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "containment relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD14_relation_of_objects Rel_Handler_15 "contains";
[ Rel_Handler_15 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == ContainerOf(Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_15(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(OBJECT_TY);
        } else {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_15(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(OBJECT_TY);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_15(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_15(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            objectloop (Z1 ofclass Object) {
                objectloop (Z3 ofclass Object) {
                    if (Rel_Handler_15(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            objectloop (Z1 ofclass Object) {
                objectloop (Z3 ofclass Object) {
                    if (Rel_Handler_15(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: MoveObject(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_17 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "support relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD15_relation_of_supporters_to Rel_Handler_17 "supports";
[ Rel_Handler_17 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == SupporterOf(Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK6_First: Z1: Z1=Z1.IK6_Link) {
                if (Rel_Handler_17(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_17(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK6_First: Z1: Z1=Z1.IK6_Link) {
                if (Rel_Handler_17(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_17(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK6_First: Z1: Z1=Z1.IK6_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_17(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK6_First: Z1: Z1=Z1.IK6_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_17(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: MoveObject(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_19 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "incorporation relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD16_relation_of_things Rel_Handler_19 "incorporates";
[ Rel_Handler_19 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == (Y.component_parent)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_19(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_19(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_19(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_19(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_19(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_19(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: MakePart(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_21 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "carrying relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD17_relation_of_people_to_thi Rel_Handler_21 "carries";
[ Rel_Handler_21 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == CarrierOf(Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_21(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_21(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_21(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_21(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_21(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_21(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: MoveObject(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_23 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "holding relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD17_relation_of_people_to_thi Rel_Handler_23 "holds";
[ Rel_Handler_23 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == HolderOf(Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_23(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_23(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_23(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_23(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_23(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_23(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: MoveObject(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_25 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "wearing relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD17_relation_of_people_to_thi Rel_Handler_25 "wears";
[ Rel_Handler_25 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == WearerOf(Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_25(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_25(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_25(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_25(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_25(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_25(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: WearObject(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_27 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "possession relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_LOOKUP_ANY
     0 KD14_relation_of_objects Rel_Handler_27 "has";
[ Rel_Handler_27 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == OwnerOf(Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            rfalse;
        } else {
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            rfalse;
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
        } else {
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
        } else if (Y == RLIST_ALL_Y) {
        }
        return X;
        RELS_ASSERT_TRUE: MoveObject(Y,X); rtrue;
        RELS_ASSERT_FALSE: rfalse; rtrue;
    }
    rfalse;
];
Array Rel_Record_31 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "visibility relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST
     0 KD16_relation_of_things Rel_Handler_31 "can-see";
[ Rel_Handler_31 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (TestVisibility(X,Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_31(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_31(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_31(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_31(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_31(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_31(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
    }
    rfalse;
];
Array Rel_Record_33 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "touchability relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST
     0 KD16_relation_of_things Rel_Handler_33 "can-touch";
[ Rel_Handler_33 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (TestTouchability(X,Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_33(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_33(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_33(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_33(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_33(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_33(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
    }
    rfalse;
];
Array Rel_Record_35 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "concealment relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST
     0 KD16_relation_of_things Rel_Handler_35 "conceals";
[ Rel_Handler_35 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (TestConcealment(X,Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_35(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_35(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_35(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_35(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_35(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_35(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
    }
    rfalse;
];
Array Rel_Record_37 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "enclosure relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST
     0 KD14_relation_of_objects Rel_Handler_37 "encloses";
[ Rel_Handler_37 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (IndirectlyContains(X,Y)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_37(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(OBJECT_TY);
        } else {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_37(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(OBJECT_TY);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_37(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            objectloop (Z1 ofclass Object) {
                if (Rel_Handler_37(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            objectloop (Z1 ofclass Object) {
                objectloop (Z3 ofclass Object) {
                    if (Rel_Handler_37(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            objectloop (Z1 ofclass Object) {
                objectloop (Z3 ofclass Object) {
                    if (Rel_Handler_37(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
    }
    rfalse;
];
Array Rel_Record_67 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "leading-through relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_X_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     door_to KD18_relation_of_rooms_to_door Rel_Handler_67 "Leading-through relates one room ( called the other side ) to various doors";
[ Rel_Handler_67 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == (RGuard_f0_0(Y))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                if (Rel_Handler_67(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK4_First: Z1: Z1=Z1.IK4_Link) {
                if (Rel_Handler_67(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                if (Rel_Handler_67(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK4_First: Z1: Z1=Z1.IK4_Link) {
                if (Rel_Handler_67(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                for (Z3=IK4_First: Z3: Z3=Z3.IK4_Link) {
                    if (Rel_Handler_67(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                for (Z3=IK4_First: Z3: Z3=Z3.IK4_Link) {
                    if (Rel_Handler_67(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_0(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_0(X,Y)); rtrue;
        RELS_SHOW: Relation_RShowOtoO(rr, false); rtrue;
        RELS_EMPTY: return Relation_EmptyOtoO(rr, false, (X == 1));
        RELS_ROUTE_FIND: return OtoVRelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(OtoVRelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_69 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "lock-fitting relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_X_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     with_key KD16_relation_of_things Rel_Handler_69 "Lock-fitting relates one thing ( called the matching key ) to various things";
[ Rel_Handler_69 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == (RGuard_f0_1(Y))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_69(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_69(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_1(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_1(X,Y)); rtrue;
        RELS_SHOW: Relation_RShowOtoO(rr, false); rtrue;
        RELS_EMPTY: return Relation_EmptyOtoO(rr, false, (X == 1));
        RELS_ROUTE_FIND: return OtoVRelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(OtoVRelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_71 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "knowledge relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     V2V_Bitmap_71 KD19_relation_of_people_to_fac Rel_Handler_71 "Knowledge relates various people to various facts";
[ Rel_Handler_71 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if ((RGuard_T_2(X,Y))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_71(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK19_First: Z1: Z1=Z1.IK19_Link) {
                if (Rel_Handler_71(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_71(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK19_First: Z1: Z1=Z1.IK19_Link) {
                if (Rel_Handler_71(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK19_First: Z3: Z3=Z3.IK19_Link) {
                    if (Rel_Handler_71(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK19_First: Z3: Z3=Z3.IK19_Link) {
                    if (Rel_Handler_71(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_2(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_2(X,Y)); rtrue;
        RELS_SHOW: Relation_ShowVtoV(rr, false); rtrue;
        RELS_EMPTY: return Relation_EmptyVtoV(rr, false, (X == 1));
        RELS_ROUTE_FIND: return VtoVRelRouteTo(rr, X, Y);
        RELS_ROUTE_FIND_COUNT: return VtoVRelRouteTo(rr, X, Y, true);
    }
    rfalse;
];
Array Rel_Record_73 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "talking on relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_Y_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     p119_talking_on_relation_sto KD20_relation_of_people_to_pho Rel_Handler_73 "Talking on relates a person to a phone";
[ Rel_Handler_73 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (Y == (RGuard_f1_3(X))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_73(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK20_First: Z1: Z1=Z1.IK20_Link) {
                if (Rel_Handler_73(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_73(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK20_First: Z1: Z1=Z1.IK20_Link) {
                if (Rel_Handler_73(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK20_First: Z3: Z3=Z3.IK20_Link) {
                    if (Rel_Handler_73(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK20_First: Z3: Z3=Z3.IK20_Link) {
                    if (Rel_Handler_73(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_3(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_3(X,Y)); rtrue;
        RELS_SHOW: Relation_ShowOtoO(rr, false); rtrue;
        RELS_EMPTY: return Relation_EmptyOtoO(rr, false, (X == 1));
        RELS_ROUTE_FIND: return VtoORelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(VtoORelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_75 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "talking with relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_SYMMETRIC+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     V2V_Bitmap_75 KD21_relation_of_people Rel_Handler_75 "Talking with relates people to each other";
[ Rel_Handler_75 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if ((RGuard_T_4(X,Y))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_75(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_75(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_75(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_75(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK8_First: Z3: Z3=Z3.IK8_Link) {
                    if (Rel_Handler_75(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK8_First: Z3: Z3=Z3.IK8_Link) {
                    if (Rel_Handler_75(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_4(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_4(X,Y)); rtrue;
        RELS_SHOW: Relation_ShowVtoV(rr, true); rtrue;
        RELS_EMPTY: return Relation_EmptyVtoV(rr, true, (X == 1));
        RELS_ROUTE_FIND: return VtoVRelRouteTo(rr, X, Y);
        RELS_ROUTE_FIND_COUNT: return VtoVRelRouteTo(rr, X, Y, true);
    }
    rfalse;
];
Array Rel_Record_77 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "calling to relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_Y_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     p121_calling_to_relation_sto KD20_relation_of_people_to_pho Rel_Handler_77 "Calling to relates a person to a phone";
[ Rel_Handler_77 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (Y == (RGuard_f1_5(X))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_77(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK20_First: Z1: Z1=Z1.IK20_Link) {
                if (Rel_Handler_77(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_77(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK20_First: Z1: Z1=Z1.IK20_Link) {
                if (Rel_Handler_77(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK20_First: Z3: Z3=Z3.IK20_Link) {
                    if (Rel_Handler_77(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK20_First: Z3: Z3=Z3.IK20_Link) {
                    if (Rel_Handler_77(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_5(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_5(X,Y)); rtrue;
        RELS_SHOW: Relation_ShowOtoO(rr, false); rtrue;
        RELS_EMPTY: return Relation_EmptyOtoO(rr, false, (X == 1));
        RELS_ROUTE_FIND: return VtoORelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(VtoORelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_79 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "reaches relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_Y_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     p122_reaches_relation_storag KD22_relation_of_phone_numbers Rel_Handler_79 "Reaches relates a phone number to a phone";
[ Rel_Handler_79 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (Y == (RGuard_f1_6(X))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK21_First: Z1: Z1=Z1.IK21_Link) {
                if (Rel_Handler_79(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK20_First: Z1: Z1=Z1.IK20_Link) {
                if (Rel_Handler_79(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK21_First: Z1: Z1=Z1.IK21_Link) {
                if (Rel_Handler_79(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK20_First: Z1: Z1=Z1.IK20_Link) {
                if (Rel_Handler_79(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK21_First: Z1: Z1=Z1.IK21_Link) {
                for (Z3=IK20_First: Z3: Z3=Z3.IK20_Link) {
                    if (Rel_Handler_79(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK21_First: Z1: Z1=Z1.IK21_Link) {
                for (Z3=IK20_First: Z3: Z3=Z3.IK20_Link) {
                    if (Rel_Handler_79(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_6(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_6(X,Y)); rtrue;
        RELS_SHOW: Relation_ShowOtoO(rr, false); rtrue;
        RELS_EMPTY: return Relation_EmptyOtoO(rr, false, (X == 1));
        RELS_ROUTE_FIND: return VtoORelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(VtoORelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_81 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "owner relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_X_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     p125_owner KD17_relation_of_people_to_thi Rel_Handler_81 "Owner relates one person ( called the owner ) to a thing";
[ Rel_Handler_81 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == (RGuard_f0_7(Y))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_81(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_81(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_81(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_81(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_81(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_81(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_7(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_7(X,Y)); rtrue;
        RELS_SHOW: Relation_RShowOtoO(rr, false); rtrue;
        RELS_EMPTY: return Relation_EmptyOtoO(rr, false, (X == 1));
        RELS_ROUTE_FIND: return OtoVRelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(OtoVRelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_83 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "vends relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_X_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     p126_vendor KD17_relation_of_people_to_thi Rel_Handler_83 "Vends relates one person ( called the vendor ) to various things";
[ Rel_Handler_83 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (X == (RGuard_f0_8(Y))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_83(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_83(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                if (Rel_Handler_83(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_83(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_83(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK8_First: Z1: Z1=Z1.IK8_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_83(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_8(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_8(X,Y)); rtrue;
        RELS_SHOW: Relation_RShowOtoO(rr, false); rtrue;
        RELS_EMPTY: return Relation_EmptyOtoO(rr, false, (X == 1));
        RELS_ROUTE_FIND: return OtoVRelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(OtoVRelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_85 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "demoing relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_Y_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     p138_demoing_relation_storag KD23_relation_of_choices_to_th Rel_Handler_85 "demoing relates choices to one thing";
[ Rel_Handler_85 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (Y == (RGuard_f1_9(X))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=nothing: false: ) {
                if (Rel_Handler_85(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_85(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=nothing: false: ) {
                if (Rel_Handler_85(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_85(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=nothing: false: ) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_85(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=nothing: false: ) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_85(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_9(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_9(X,Y)); rtrue;
        RELS_SHOW: Relation_ShowOtoO(rr, false); rtrue;
        RELS_EMPTY: return Relation_EmptyOtoO(rr, false, (X == 1));
        RELS_ROUTE_FIND: return VtoORelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(VtoORelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_87 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "behindness relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_Y_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     p140_behindness_relation_sto KD16_relation_of_things Rel_Handler_87 "Behindness relates various things to one thing";
[ Rel_Handler_87 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if (Y == (RGuard_f1_10(X))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_87(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_87(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_87(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_87(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_87(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_87(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_10(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_10(X,Y)); rtrue;
        RELS_SHOW: Relation_ShowOtoO(rr, false); rtrue;
        RELS_EMPTY: return Relation_EmptyOtoO(rr, false, (X == 1));
        RELS_ROUTE_FIND: return VtoORelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(VtoORelRouteTo(RlnGetF(rr, RR_STORAGE), X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_89 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "quip-supplying relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     V2V_Bitmap_89 KD24_relation_of_quips_to_thin Rel_Handler_89 "quip-supplying relates various quips to various things";
[ Rel_Handler_89 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if ((RGuard_T_11(X,Y))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                if (Rel_Handler_89(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_89(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                if (Rel_Handler_89(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_89(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_89(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_89(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_11(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_11(X,Y)); rtrue;
        RELS_SHOW: Relation_ShowVtoV(rr, false); rtrue;
        RELS_EMPTY: return Relation_EmptyVtoV(rr, false, (X == 1));
        RELS_ROUTE_FIND: return VtoVRelRouteTo(rr, X, Y);
        RELS_ROUTE_FIND_COUNT: return VtoVRelRouteTo(rr, X, Y, true);
    }
    rfalse;
];
Array Rel_Record_91 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "following relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     V2V_Bitmap_91 KD25_relation_of_quips Rel_Handler_91 "following relates various quips to various quips";
[ Rel_Handler_91 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if ((RGuard_T_12(X,Y))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                if (Rel_Handler_91(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                if (Rel_Handler_91(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                if (Rel_Handler_91(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                if (Rel_Handler_91(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                for (Z3=IK29_First: Z3: Z3=Z3.IK29_Link) {
                    if (Rel_Handler_91(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                for (Z3=IK29_First: Z3: Z3=Z3.IK29_Link) {
                    if (Rel_Handler_91(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_12(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_12(X,Y)); rtrue;
        RELS_SHOW: Relation_ShowVtoV(rr, false); rtrue;
        RELS_EMPTY: return Relation_EmptyVtoV(rr, false, (X == 1));
        RELS_ROUTE_FIND: return VtoVRelRouteTo(rr, X, Y);
        RELS_ROUTE_FIND_COUNT: return VtoVRelRouteTo(rr, X, Y, true);
    }
    rfalse;
];
Array Rel_Record_93 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "exclusion relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     V2V_Bitmap_93 KD25_relation_of_quips Rel_Handler_93 "exclusion relates various quips to various quips";
[ Rel_Handler_93 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if ((RGuard_T_13(X,Y))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                if (Rel_Handler_93(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                if (Rel_Handler_93(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                if (Rel_Handler_93(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                if (Rel_Handler_93(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                for (Z3=IK29_First: Z3: Z3=Z3.IK29_Link) {
                    if (Rel_Handler_93(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                for (Z3=IK29_First: Z3: Z3=Z3.IK29_Link) {
                    if (Rel_Handler_93(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_13(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_13(X,Y)); rtrue;
        RELS_SHOW: Relation_ShowVtoV(rr, false); rtrue;
        RELS_EMPTY: return Relation_EmptyVtoV(rr, false, (X == 1));
        RELS_ROUTE_FIND: return VtoVRelRouteTo(rr, X, Y);
        RELS_ROUTE_FIND_COUNT: return VtoVRelRouteTo(rr, X, Y, true);
    }
    rfalse;
];
Array Rel_Record_95 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "mentioning relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     V2V_Bitmap_95 KD24_relation_of_quips_to_thin Rel_Handler_95 "mentioning relates various quips to various things";
[ Rel_Handler_95 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if ((RGuard_T_14(X,Y))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                if (Rel_Handler_95(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_95(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                if (Rel_Handler_95(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_95(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_95(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_95(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_14(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_14(X,Y)); rtrue;
        RELS_SHOW: Relation_ShowVtoV(rr, false); rtrue;
        RELS_EMPTY: return Relation_EmptyVtoV(rr, false, (X == 1));
        RELS_ROUTE_FIND: return VtoVRelRouteTo(rr, X, Y);
        RELS_ROUTE_FIND_COUNT: return VtoVRelRouteTo(rr, X, Y, true);
    }
    rfalse;
];
Array Rel_Record_97 -->
    0 (101515264) RELATION_TY MAX_POSITIVE_NUMBER NULL NULL
    "stocking relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     V2V_Bitmap_97 KD24_relation_of_quips_to_thin Rel_Handler_97 "stocking relates various quips to various things";
[ Rel_Handler_97 
    rr ! Implied call parameter
    task ! Implied call parameter
    X ! Implied call parameter
    Y ! Implied call parameter
    Z1 ! loop counter
    Z2 ! loop counter
    Z3 ! loop counter
    Z4 ! loop counter
    ;
    switch (task) {
        RELS_TEST: if ((RGuard_T_15(X,Y))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                if (Rel_Handler_97(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_97(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(10);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                if (Rel_Handler_97(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_97(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_97(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK29_First: Z1: Z1=Z1.IK29_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_97(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (RGuard_MT_15(X,Y)); rtrue;
        RELS_ASSERT_FALSE: (RGuard_MF_15(X,Y)); rtrue;
        RELS_SHOW: Relation_ShowVtoV(rr, false); rtrue;
        RELS_EMPTY: return Relation_EmptyVtoV(rr, false, (X == 1));
        RELS_ROUTE_FIND: return VtoVRelRouteTo(rr, X, Y);
        RELS_ROUTE_FIND_COUNT: return VtoVRelRouteTo(rr, X, Y, true);
    }
    rfalse;
];
[ CreateDynamicRelations 
    i ! loop counter
    rel ! new relation
    ;
    ];
[ RProperty obj cl pr; if (obj ofclass cl) return obj.pr; return nothing; ];
! Routines guarding leading-through(L, R)
[ RGuard_f0_0 
    X ! which is related to at most one object
    ;
    if (X ofclass K4_door) return (X.door_to);
    return nothing;
];
[ RGuard_f1_0 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_T_0 
    L ! left member of pair
    R ! right member of pair
    ;
    rfalse;
];
[ RGuard_MT_0 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K1_room) && (R ofclass K4_door)) {
        R.door_to = L; rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_67);
];
[ RGuard_MF_0 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K1_room) && (R ofclass K4_door)) {
        Relation_NowN1toV(R,door_to,L); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_67);
];
! Routines guarding lock-fitting(L, R)
[ RGuard_f0_1 
    X ! which is related to at most one object
    ;
    if (X ofclass K2_thing) return (X.with_key);
    return nothing;
];
[ RGuard_f1_1 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_T_1 
    L ! left member of pair
    R ! right member of pair
    ;
    rfalse;
];
[ RGuard_MT_1 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K2_thing) && (R ofclass K2_thing)) {
        R.with_key = L; rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_69);
];
[ RGuard_MF_1 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K2_thing) && (R ofclass K2_thing)) {
        Relation_NowN1toV(R,with_key,L); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_69);
];
! Routines guarding knowledge(L, R)
[ RGuard_f0_2 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_f1_2 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_T_2 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K8_person) && (R ofclass K19_fact) && ((Relation_TestVtoV(L,Rel_Record_71,R,false)))) rtrue;
    rfalse;
];
[ RGuard_MT_2 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K8_person) && (R ofclass K19_fact)) {
        (Relation_NowVtoV(L,Rel_Record_71,R,false)); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_71);
];
[ RGuard_MF_2 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K8_person) && (R ofclass K19_fact)) {
        (Relation_NowNVtoV(L,Rel_Record_71,R,false)); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_71);
];
! Routines guarding talking(L, R)
[ RGuard_f0_3 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_f1_3 
    X ! which is related to at most one object
    ;
    if (X ofclass K8_person) return (X.p119_talking_on_relation_sto);
    return nothing;
];
[ RGuard_T_3 
    L ! left member of pair
    R ! right member of pair
    ;
    rfalse;
];
[ RGuard_MT_3 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K8_person) && (R ofclass K20_phone)) {
        L.p119_talking_on_relation_sto = R; rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_73);
];
[ RGuard_MF_3 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K8_person) && (R ofclass K20_phone)) {
        Relation_NowN1toV(L,p119_talking_on_relation_sto,R); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_73);
];
! Routines guarding talking(L, R)
[ RGuard_f0_4 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_f1_4 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_T_4 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K8_person) && (R ofclass K8_person) && ((Relation_TestVtoV(L,Rel_Record_75,R,true)))) rtrue;
    rfalse;
];
[ RGuard_MT_4 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K8_person) && (R ofclass K8_person)) {
        (Relation_NowVtoV(L,Rel_Record_75,R,true)); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_75);
];
[ RGuard_MF_4 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K8_person) && (R ofclass K8_person)) {
        (Relation_NowNVtoV(L,Rel_Record_75,R,true)); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_75);
];
! Routines guarding calling(L, R)
[ RGuard_f0_5 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_f1_5 
    X ! which is related to at most one object
    ;
    if (X ofclass K8_person) return (X.p121_calling_to_relation_sto);
    return nothing;
];
[ RGuard_T_5 
    L ! left member of pair
    R ! right member of pair
    ;
    rfalse;
];
[ RGuard_MT_5 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K8_person) && (R ofclass K20_phone)) {
        L.p121_calling_to_relation_sto = R; rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_77);
];
[ RGuard_MF_5 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K8_person) && (R ofclass K20_phone)) {
        Relation_NowN1toV(L,p121_calling_to_relation_sto,R); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_77);
];
! Routines guarding reaches(L, R)
[ RGuard_f0_6 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_f1_6 
    X ! which is related to at most one object
    ;
    if (X ofclass K21_phone_number) return (X.p122_reaches_relation_storag);
    return nothing;
];
[ RGuard_T_6 
    L ! left member of pair
    R ! right member of pair
    ;
    rfalse;
];
[ RGuard_MT_6 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K21_phone_number) && (R ofclass K20_phone)) {
        L.p122_reaches_relation_storag = R; rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_79);
];
[ RGuard_MF_6 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K21_phone_number) && (R ofclass K20_phone)) {
        Relation_NowN1toV(L,p122_reaches_relation_storag,R); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_79);
];
! Routines guarding owner(L, R)
[ RGuard_f0_7 
    X ! which is related to at most one object
    ;
    if (X ofclass K2_thing) return (X.p125_owner);
    return nothing;
];
[ RGuard_f1_7 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_T_7 
    L ! left member of pair
    R ! right member of pair
    ;
    rfalse;
];
[ RGuard_MT_7 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K8_person) && (R ofclass K2_thing)) {
        R.p125_owner = L; rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_81);
];
[ RGuard_MF_7 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K8_person) && (R ofclass K2_thing)) {
        Relation_NowN1toV(R,p125_owner,L); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_81);
];
! Routines guarding vends(L, R)
[ RGuard_f0_8 
    X ! which is related to at most one object
    ;
    if (X ofclass K2_thing) return (X.p126_vendor);
    return nothing;
];
[ RGuard_f1_8 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_T_8 
    L ! left member of pair
    R ! right member of pair
    ;
    rfalse;
];
[ RGuard_MT_8 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K8_person) && (R ofclass K2_thing)) {
        R.p126_vendor = L; rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_83);
];
[ RGuard_MF_8 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K8_person) && (R ofclass K2_thing)) {
        Relation_NowN1toV(R,p126_vendor,L); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_83);
];
! Routines guarding demoing(L, R)
[ RGuard_f0_9 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_f1_9 
    X ! which is related to at most one object
    ;
    if (X ofclass K26_choice) return (X.p138_demoing_relation_storag);
    return nothing;
];
[ RGuard_T_9 
    L ! left member of pair
    R ! right member of pair
    ;
    rfalse;
];
[ RGuard_MT_9 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K26_choice) && (R ofclass K2_thing)) {
        L.p138_demoing_relation_storag = R; rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_85);
];
[ RGuard_MF_9 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K26_choice) && (R ofclass K2_thing)) {
        Relation_NowN1toV(L,p138_demoing_relation_storag,R); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_85);
];
! Routines guarding behindness(L, R)
[ RGuard_f0_10 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_f1_10 
    X ! which is related to at most one object
    ;
    if (X ofclass K2_thing) return (X.p140_behindness_relation_sto);
    return nothing;
];
[ RGuard_T_10 
    L ! left member of pair
    R ! right member of pair
    ;
    rfalse;
];
[ RGuard_MT_10 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K2_thing) && (R ofclass K2_thing)) {
        L.p140_behindness_relation_sto = R; rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_87);
];
[ RGuard_MF_10 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K2_thing) && (R ofclass K2_thing)) {
        Relation_NowN1toV(L,p140_behindness_relation_sto,R); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_87);
];
! Routines guarding quip-supplying(L, R)
[ RGuard_f0_11 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_f1_11 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_T_11 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K29_quip) && (R ofclass K2_thing) && ((Relation_TestVtoV(L,Rel_Record_89,R,false)))) rtrue;
    rfalse;
];
[ RGuard_MT_11 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K29_quip) && (R ofclass K2_thing)) {
        (Relation_NowVtoV(L,Rel_Record_89,R,false)); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_89);
];
[ RGuard_MF_11 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K29_quip) && (R ofclass K2_thing)) {
        (Relation_NowNVtoV(L,Rel_Record_89,R,false)); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_89);
];
! Routines guarding following(L, R)
[ RGuard_f0_12 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_f1_12 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_T_12 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K29_quip) && (R ofclass K29_quip) && ((Relation_TestVtoV(L,Rel_Record_91,R,false)))) rtrue;
    rfalse;
];
[ RGuard_MT_12 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K29_quip) && (R ofclass K29_quip)) {
        (Relation_NowVtoV(L,Rel_Record_91,R,false)); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_91);
];
[ RGuard_MF_12 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K29_quip) && (R ofclass K29_quip)) {
        (Relation_NowNVtoV(L,Rel_Record_91,R,false)); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_91);
];
! Routines guarding exclusion(L, R)
[ RGuard_f0_13 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_f1_13 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_T_13 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K29_quip) && (R ofclass K29_quip) && ((Relation_TestVtoV(L,Rel_Record_93,R,false)))) rtrue;
    rfalse;
];
[ RGuard_MT_13 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K29_quip) && (R ofclass K29_quip)) {
        (Relation_NowVtoV(L,Rel_Record_93,R,false)); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_93);
];
[ RGuard_MF_13 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K29_quip) && (R ofclass K29_quip)) {
        (Relation_NowNVtoV(L,Rel_Record_93,R,false)); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_93);
];
! Routines guarding mentioning(L, R)
[ RGuard_f0_14 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_f1_14 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_T_14 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K29_quip) && (R ofclass K2_thing) && ((Relation_TestVtoV(L,Rel_Record_95,R,false)))) rtrue;
    rfalse;
];
[ RGuard_MT_14 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K29_quip) && (R ofclass K2_thing)) {
        (Relation_NowVtoV(L,Rel_Record_95,R,false)); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_95);
];
[ RGuard_MF_14 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K29_quip) && (R ofclass K2_thing)) {
        (Relation_NowNVtoV(L,Rel_Record_95,R,false)); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_95);
];
! Routines guarding stocking(L, R)
[ RGuard_f0_15 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_f1_15 
    X ! which is related to at most one object
    ;
    return nothing;
];
[ RGuard_T_15 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K29_quip) && (R ofclass K2_thing) && ((Relation_TestVtoV(L,Rel_Record_97,R,false)))) rtrue;
    rfalse;
];
[ RGuard_MT_15 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K29_quip) && (R ofclass K2_thing)) {
        (Relation_NowVtoV(L,Rel_Record_97,R,false)); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_97);
];
[ RGuard_MF_15 
    L ! left member of pair
    R ! right member of pair
    ;
    if ((L ofclass K29_quip) && (R ofclass K2_thing)) {
        (Relation_NowNVtoV(L,Rel_Record_97,R,false)); rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record_97);
];






[ Noun_Filter_0 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_1 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_2 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_3 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_112_t1_v10(noun))));
];
[ Scope_Filter_4 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K29_quip) && (noun ofclass K29_quip) && ((Adj_64_t1_v10(noun))) && ((Adj_152_t1_v10(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_5 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K8_person));
];
[ Scope_Filter_6 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K29_quip) && (noun ofclass K29_quip) && ((Adj_64_t1_v10(noun))) && ((Adj_152_t1_v10(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_7 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K29_quip) && (noun ofclass K29_quip) && ((Adj_64_t1_v10(noun))) && ((Adj_153_t1_v10(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_8 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && (noun ofclass K2_thing) && ((Adj_42_t1_v10(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_9 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K8_person));
];
[ Scope_Filter_10 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K29_quip) && (noun ofclass K29_quip) && ((Adj_64_t1_v10(noun))) && ((Adj_152_t1_v10(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_11 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && (noun ofclass K2_thing) && ((Adj_42_t1_v10(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_12 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && (noun ofclass K2_thing) && ((Adj_42_t1_v10(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_13 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && (noun ofclass K2_thing) && ((Adj_42_t1_v10(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_14 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && (noun ofclass K2_thing) && ((Adj_42_t1_v10(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_15 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K8_person));
];
[ Scope_Filter_16 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K29_quip) && (noun ofclass K29_quip) && ((Adj_64_t1_v10(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_17 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K29_quip) && (noun ofclass K29_quip) && ((Adj_64_t1_v10(noun))) && ((Adj_151_t1_v10(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_18 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Noun_Filter_19 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Noun_Filter_20 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Scope_Filter_21 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && (noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_22 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && (noun ofclass K2_thing) && ((Adj_42_t1_v10(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_23 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && (noun ofclass K2_thing) && ((Adj_42_t1_v10(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_24 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing) && (noun ofclass K2_thing) && ((Adj_42_t1_v10(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_25 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Scope_Filter_26 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K20_phone) && (noun ofclass K20_phone)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_27 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K20_phone));
];
[ Scope_Filter_28 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K8_person) && (noun ofclass K8_person)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_29 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K20_phone));
];
[ Noun_Filter_30 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K20_phone));
];
[ Noun_Filter_31 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K20_phone));
];
[ Noun_Filter_32 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Noun_Filter_33 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Noun_Filter_34 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Noun_Filter_35 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Noun_Filter_36 
    x ! saved value of noun
    ;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Scope_Filter_37 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K26_choice) && (noun ofclass K26_choice)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_38 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K29_quip) && (noun ofclass K29_quip) && ((Adj_64_t1_v10(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_39 
    obj ! object loop variable
    o2 ! saved value of noun
    ;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K28_memory) && (noun ofclass K28_memory) && ((Adj_63_t1_v10(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Chronology
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Scheme I
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Present and Past
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Chronology Point
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ChronologyPoint pt;
	for (pt=0:pt<NO_PAST_TENSE_CONDS:pt++)
		past_chronological_record-->pt = present_chronological_record-->pt;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Update Chronological Records Rule
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ UPDATE_CHRONOLOGICAL_RECORDS_R pt;
	for (pt=0: pt<NO_PAST_TENSE_CONDS: pt++) TestSinglePastState(false, pt, true, -1);
	ChronologyPoint();
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Test Single Past State
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ PAPR_0 ;
    if ((((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) == I295_the_front_office) && ((MStack-->MstVON(20007,0)) ofclass K1_room)) && (((MStack-->MstVON(20007,1)) == I452_bosh_office_hallway) && (true))))) rtrue;
    rfalse;
];
[ PAPR_1 ;
    if ((((action ==##Open) &&  (actor==player) && ((noun == I431_biff_s_desk_s_drawer) && (true))))) rtrue;
    rfalse;
];
[ PAPR_2 ;
    if ((((action ==##Open) &&  (actor==player) && ((noun == I431_biff_s_desk_s_drawer) && (true)) && (self=actor,true) && (((((Adj_106_t1_v10(I431_biff_s_desk_s_drawer))))) && ((((I431_biff_s_desk_s_drawer == ContainerOf(I432_blue_flipphone)))) && ((((Adj_133_t1_v10(I432_blue_flipphone)))))))))) rtrue;
    rfalse;
];
Array PastActionsI6Routines --> PAPR_0 PAPR_1 PAPR_2 0 0;

Constant NO_PAST_TENSE_CONDS 3;
Constant NO_PAST_TENSE_ACTIONS 3;

[ TestSinglePastState 
    past_flag ! Implied call parameter
    pt ! Implied call parameter
    turn_end ! Implied call parameter
    wanted ! Implied call parameter
    old ! internal use only
    new ! internal use only
    trips ! internal use only
    consecutives ! internal use only
    ;
    if (past_flag) {
        new = (past_chronological_record-->pt) & 1;
        trips = ((past_chronological_record-->pt) & $$11111110)/2;
        consecutives = ((past_chronological_record-->pt) & $$111111100000000)/256;
    } else {
        old = (present_chronological_record-->pt) & 1;
        trips = ((present_chronological_record-->pt) & $$11111110)/2;
        consecutives = ((present_chronological_record-->pt) & $$111111100000000)/256;
        switch(pt) {
            0: new = ((((Global_Vars-->11) == I358_margaret_chao)));
            1: new = (((real_location == I295_the_front_office)));
            2: new = ((((Adj_106_t1_v10(I367_bosh_back_door)))));
            default: print "*** No such past tense condition ***^"; new = false;
        }
        if (new) {
            if (old == false) { trips++; if (trips > 127) trips = 127; }
            if (turn_end) { consecutives++; if (consecutives > 127) consecutives = 127; }
        } else {
            consecutives = 0;
        }
        present_chronological_record-->pt = new + 2*trips + 256*consecutives;
    }
    switch(wanted) {
        0: if (new) return new;
        1: if (new) return trips;
        2: if (new) return consecutives+1; ! Plus one because we count the current turn
        4: return new;
        5: return trips;
        6: return consecutives;
    }
    return 0;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Scheme II
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Past Action Routines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Track Actions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TrackActions readjust oow i;
	for (i=0: PastActionsI6Routines-->i: i++) {
		if ((PastActionsI6Routines-->i).call()) {
			! Yes, the current action matches action pattern i:
			if (readjust) continue;
			(TimesActionHasHappened-->i)++;
			if (LastTurnActionHappenedOn-->i ~= turns + 5) {
				LastTurnActionHappenedOn-->i = turns + 5;
				ActionCurrentlyHappeningFlag->i = 1;
				if (keep_silent == false)
					(TurnsActionHasBeenHappening-->i)++;
			}
		} else {
			! No, the current action doesn't match action pattern i:
			if (oow == false) {
				if (keep_silent == false) { TurnsActionHasBeenHappening-->i = 0; }
				if (LastTurnActionHappenedOn-->i ~= turns + 5)
					ActionCurrentlyHappeningFlag->i = 0;
			}
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Chronology.i6t: Storage
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array TimesActionHasHappened-->(NO_PAST_TENSE_ACTIONS+1);
Array TurnsActionHasBeenHappening-->(NO_PAST_TENSE_ACTIONS+1);
Array LastTurnActionHappenedOn-->(NO_PAST_TENSE_ACTIONS+1);
Array ActionCurrentlyHappeningFlag->(NO_PAST_TENSE_ACTIONS+1);

Array past_chronological_record-->(NO_PAST_TENSE_CONDS+1);
Array present_chronological_record-->(NO_PAST_TENSE_CONDS+1);




! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Grammar
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


[ Parse_Name_GV1 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV2 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV3 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV4 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV5 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV6 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV7 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV8 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV9 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV10 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV11 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV12 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV94 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                if (parser_action==##TheSame) {
                    #ifdef DEBUG;
                    if (parser_trace >= 4) print "p1, p2 = ", parser_one, ", ", parser_two, "^";
                    #endif;
                    ss = self;
                    ! Distinguishing property p48_possessive
                    if (TEXT_TY_Distinguish(parser_one.p48_possessive, parser_two.p48_possessive)) return -2;
                    self = ss; return 0;
                }
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV100 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV101 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_197_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'wall') jump group_197_1_2;
                jump group_197_1_end;
                .group_197_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'walls') jump Fail_1;
                .group_197_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV102 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (Cond_Token_188() == GPR_FAIL) jump Fail_1;
                if (NextWordStopped() ~= 'ground') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV103 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (Cond_Token_189() == GPR_FAIL) jump Fail_1;
                if (NextWordStopped() ~= 'sky') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV108 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                if (parser_action==##TheSame) {
                    #ifdef DEBUG;
                    if (parser_trace >= 4) print "p1, p2 = ", parser_one, ", ", parser_two, "^";
                    #endif;
                    ss = self;
                    ! Distinguishing property p48_possessive
                    if (TEXT_TY_Distinguish(parser_one.p48_possessive, parser_two.p48_possessive)) return -2;
                    self = ss; return 0;
                }
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                ArticleDescriptors(); w = wn;
                objectloop (rv ofclass K2_thing) {
                    if (((RGuard_T_14(self,rv))) == false) continue;
                    wn = w; wn = w + TryGivenObject(rv, true);
                    if (wn > w) jump ol_mm_0;
                }
                rv = 0; jump Fail_1;
                .ol_mm_0; rv = 0;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV110 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV111 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV112 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV113 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV114 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV115 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV116 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV117 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV118 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV119 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV120 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_201_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'he') jump group_201_1_2;
                jump group_201_1_end;
                .group_201_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'she') jump group_201_1_3;
                jump group_201_1_end;
                .group_201_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'they') jump group_201_1_4;
                jump group_201_1_end;
                .group_201_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'we') jump group_201_1_5;
                jump group_201_1_end;
                .group_201_1_5; wn = group_wn;
                if (NextWordStopped() ~= 'have') jump group_201_1_6;
                jump group_201_1_end;
                .group_201_1_6; wn = group_wn;
                if (NextWordStopped() ~= 'has') jump group_201_1_7;
                jump group_201_1_end;
                .group_201_1_7; wn = group_wn;
                if (NextWordStopped() ~= 'have') jump group_201_1_8;
                jump group_201_1_end;
                .group_201_1_8; wn = group_wn;
                if (NextWordStopped() ~= 'no') jump group_201_1_9;
                jump group_201_1_end;
                .group_201_1_9; wn = group_wn;
                if (NextWordStopped() ~= 'thumb') jump group_201_1_10;
                jump group_201_1_end;
                .group_201_1_10; wn = group_wn;
                if (NextWordStopped() ~= 'drive') jump Fail_1;
                .group_201_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                ArticleDescriptors(); w = wn;
                objectloop (rv ofclass K2_thing) {
                    if (((RGuard_T_14(self,rv))) == false) continue;
                    wn = w; wn = w + TryGivenObject(rv, true);
                    if (wn > w) jump ol_mm_1;
                }
                rv = 0; jump Fail_2;
                .ol_mm_1; rv = 0;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV121 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_203_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'he') jump group_203_1_2;
                jump group_203_1_end;
                .group_203_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'she') jump group_203_1_3;
                jump group_203_1_end;
                .group_203_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'they') jump group_203_1_4;
                jump group_203_1_end;
                .group_203_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'we') jump group_203_1_5;
                jump group_203_1_end;
                .group_203_1_5; wn = group_wn;
                if (NextWordStopped() ~= 'has') jump group_203_1_6;
                jump group_203_1_end;
                .group_203_1_6; wn = group_wn;
                if (NextWordStopped() ~= 'brought') jump group_203_1_7;
                jump group_203_1_end;
                .group_203_1_7; wn = group_wn;
                if (NextWordStopped() ~= 'thumb') jump group_203_1_8;
                jump group_203_1_end;
                .group_203_1_8; wn = group_wn;
                if (NextWordStopped() ~= 'drive') jump Fail_1;
                .group_203_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                ArticleDescriptors(); w = wn;
                objectloop (rv ofclass K2_thing) {
                    if (((RGuard_T_14(self,rv))) == false) continue;
                    wn = w; wn = w + TryGivenObject(rv, true);
                    if (wn > w) jump ol_mm_2;
                }
                rv = 0; jump Fail_2;
                .ol_mm_2; rv = 0;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV123 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_205_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'end') jump group_205_1_2;
                jump group_205_1_end;
                .group_205_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'of') jump group_205_1_3;
                jump group_205_1_end;
                .group_205_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'the') jump Fail_1;
                .group_205_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV124 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_206_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'margaret') jump group_206_1_2;
                jump group_206_1_end;
                .group_206_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'chao') jump Fail_1;
                .group_206_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV125 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_207_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'angel') jump group_207_1_2;
                jump group_207_1_end;
                .group_207_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'angel^s') jump Fail_1;
                .group_207_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV126 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'new') jump Fail_1;
                if (NextWordStopped() ~= 'office') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                group_wn = wn;
                .group_209_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'office') jump group_209_1_2;
                jump group_209_1_end;
                .group_209_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'bosh') jump group_209_1_3;
                jump group_209_1_end;
                .group_209_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'hq') jump group_209_1_4;
                jump group_209_1_end;
                .group_209_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'headquarters') jump group_209_1_5;
                jump group_209_1_end;
                .group_209_1_5; wn = group_wn;
                if (NextWordStopped() ~= 'bureau') jump group_209_1_6;
                jump group_209_1_end;
                .group_209_1_6; wn = group_wn;
                if (NextWordStopped() ~= 'storefront') jump Fail_2;
                .group_209_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV127 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'car') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (NextWordStopped() ~= 'hyundai') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
                if (NextWordStopped() ~= 'automobile') jump Fail_3;
                try_from_wn = wn; f = true; continue;
                .Fail_3; wn = try_from_wn;
                if (NextWordStopped() ~= 'auto') jump Fail_4;
                try_from_wn = wn; f = true; continue;
                .Fail_4; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV128 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_214_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'car') jump group_214_1_2;
                jump group_214_1_end;
                .group_214_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'klimp^s') jump group_214_1_3;
                jump group_214_1_end;
                .group_214_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'porsche') jump group_214_1_4;
                jump group_214_1_end;
                .group_214_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'automobile') jump group_214_1_5;
                jump group_214_1_end;
                .group_214_1_5; wn = group_wn;
                if (NextWordStopped() ~= 'auto') jump Fail_1;
                .group_214_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV129 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_215_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'a-plus') jump group_215_1_2;
                jump group_215_1_end;
                .group_215_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'plus') jump group_215_1_3;
                jump group_215_1_end;
                .group_215_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'laundromat') jump Fail_1;
                .group_215_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV130 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_216_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'swamp') jump group_216_1_2;
                jump group_216_1_end;
                .group_216_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'marsh') jump group_216_1_3;
                jump group_216_1_end;
                .group_216_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'water') jump group_216_1_4;
                jump group_216_1_end;
                .group_216_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'wetland') jump group_216_1_5;
                jump group_216_1_end;
                .group_216_1_5; wn = group_wn;
                if (NextWordStopped() ~= 'wet') jump group_216_1_6;
                jump group_216_1_end;
                .group_216_1_6; wn = group_wn;
                if (NextWordStopped() ~= 'land') jump Fail_1;
                .group_216_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV131 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'dave^s') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (NextWordStopped() ~= 'dave') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
                if (NextWordStopped() ~= 'pawn') jump Fail_3;
                try_from_wn = wn; f = true; continue;
                .Fail_3; wn = try_from_wn;
                if (NextWordStopped() ~= 'shop') jump Fail_4;
                try_from_wn = wn; f = true; continue;
                .Fail_4; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV132 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_221_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'pawn') jump group_221_1_2;
                jump group_221_1_end;
                .group_221_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'shop') jump group_221_1_3;
                jump group_221_1_end;
                .group_221_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'door') jump Fail_1;
                .group_221_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV133 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_222_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'highway') jump group_222_1_2;
                jump group_222_1_end;
                .group_222_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'road') jump group_222_1_3;
                jump group_222_1_end;
                .group_222_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'expressway') jump group_222_1_4;
                jump group_222_1_end;
                .group_222_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'freeway') jump Fail_1;
                .group_222_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV134 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_223_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'end') jump group_223_1_2;
                jump group_223_1_end;
                .group_223_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'of') jump group_223_1_3;
                jump group_223_1_end;
                .group_223_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'the') jump Fail_1;
                .group_223_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                group_wn = wn;
                .group_224_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'park') jump group_224_1_2;
                jump group_224_1_end;
                .group_224_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'place') jump Fail_2;
                .group_224_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV135 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_225_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'li^l') jump group_225_1_2;
                jump group_225_1_end;
                .group_225_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'nectarine') jump group_225_1_3;
                jump group_225_1_end;
                .group_225_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'convenience') jump group_225_1_4;
                jump group_225_1_end;
                .group_225_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'store') jump Fail_1;
                .group_225_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV136 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_226_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'military') jump group_226_1_2;
                jump group_226_1_end;
                .group_226_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'recruitment') jump group_226_1_3;
                jump group_226_1_end;
                .group_226_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'center') jump Fail_1;
                .group_226_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV137 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'military') jump Fail_1;
                if (NextWordStopped() ~= 'posters') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                group_wn = wn;
                .group_228_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'poster') jump group_228_1_2;
                jump group_228_1_end;
                .group_228_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'slogan') jump group_228_1_3;
                jump group_228_1_end;
                .group_228_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'slogans') jump Fail_2;
                .group_228_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV138 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_229_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'bosh') jump group_229_1_2;
                jump group_229_1_end;
                .group_229_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'headquarters') jump group_229_1_3;
                jump group_229_1_end;
                .group_229_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'hq') jump group_229_1_4;
                jump group_229_1_end;
                .group_229_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'office') jump Fail_1;
                .group_229_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV139 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV140 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_230_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'for') jump group_230_1_2;
                jump group_230_1_end;
                .group_230_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'a//') jump group_230_1_3;
                jump group_230_1_end;
                .group_230_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'screwdriver') jump Fail_1;
                .group_230_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                ArticleDescriptors(); w = wn;
                objectloop (rv ofclass K2_thing) {
                    if (((RGuard_T_14(self,rv))) == false) continue;
                    wn = w; wn = w + TryGivenObject(rv, true);
                    if (wn > w) jump ol_mm_3;
                }
                rv = 0; jump Fail_2;
                .ol_mm_3; rv = 0;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV141 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_232_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'a-plus') jump group_232_1_2;
                jump group_232_1_end;
                .group_232_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'plus') jump group_232_1_3;
                jump group_232_1_end;
                .group_232_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'laundromat') jump Fail_1;
                .group_232_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV142 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_233_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'smokes') jump group_233_1_2;
                jump group_233_1_end;
                .group_233_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'smoke') jump group_233_1_3;
                jump group_233_1_end;
                .group_233_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'packs') jump group_233_1_4;
                jump group_233_1_end;
                .group_233_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'pack') jump Fail_1;
                .group_233_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV143 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_234_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'scratch-off') jump group_234_1_2;
                jump group_234_1_end;
                .group_234_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'scratch-offs') jump group_234_1_3;
                jump group_234_1_end;
                .group_234_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'ticket') jump Fail_1;
                .group_234_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV144 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_235_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'aisle') jump group_235_1_2;
                jump group_235_1_end;
                .group_235_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'aisles') jump group_235_1_3;
                jump group_235_1_end;
                .group_235_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'shelf') jump Fail_1;
                .group_235_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV145 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_236_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'bread') jump group_236_1_2;
                jump group_236_1_end;
                .group_236_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'ketchup') jump group_236_1_3;
                jump group_236_1_end;
                .group_236_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'catsup') jump group_236_1_4;
                jump group_236_1_end;
                .group_236_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'potato') jump group_236_1_5;
                jump group_236_1_end;
                .group_236_1_5; wn = group_wn;
                if (NextWordStopped() ~= 'chips') jump Fail_1;
                .group_236_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV146 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_237_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'light') jump group_237_1_2;
                jump group_237_1_end;
                .group_237_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'torch') jump Fail_1;
                .group_237_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV147 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_238_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'useful') jump group_238_1_2;
                jump group_238_1_end;
                .group_238_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'items') jump Fail_1;
                .group_238_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV148 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_239_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'flat') jump group_239_1_2;
                jump group_239_1_end;
                .group_239_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'head') jump group_239_1_3;
                jump group_239_1_end;
                .group_239_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'plastic') jump group_239_1_4;
                jump group_239_1_end;
                .group_239_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'handle') jump Fail_1;
                .group_239_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV149 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_240_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'notebook') jump group_240_1_2;
                jump group_240_1_end;
                .group_240_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'computer') jump Fail_1;
                .group_240_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV150 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_241_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'airpods') jump group_241_1_2;
                jump group_241_1_end;
                .group_241_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'air') jump group_241_1_3;
                jump group_241_1_end;
                .group_241_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'pods') jump group_241_1_4;
                jump group_241_1_end;
                .group_241_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'ear') jump group_241_1_5;
                jump group_241_1_end;
                .group_241_1_5; wn = group_wn;
                if (NextWordStopped() ~= 'earphones') jump group_241_1_6;
                jump group_241_1_end;
                .group_241_1_6; wn = group_wn;
                if (NextWordStopped() ~= 'headphones') jump Fail_1;
                .group_241_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV151 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_242_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'for') jump group_242_1_2;
                jump group_242_1_end;
                .group_242_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'a//') jump group_242_1_3;
                jump group_242_1_end;
                .group_242_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'screwdriver') jump Fail_1;
                .group_242_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                ArticleDescriptors(); w = wn;
                objectloop (rv ofclass K2_thing) {
                    if (((RGuard_T_14(self,rv))) == false) continue;
                    wn = w; wn = w + TryGivenObject(rv, true);
                    if (wn > w) jump ol_mm_4;
                }
                rv = 0; jump Fail_2;
                .ol_mm_4; rv = 0;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV152 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_244_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'for') jump group_244_1_2;
                jump group_244_1_end;
                .group_244_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'a//') jump group_244_1_3;
                jump group_244_1_end;
                .group_244_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'screwdriver') jump Fail_1;
                .group_244_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                ArticleDescriptors(); w = wn;
                objectloop (rv ofclass K2_thing) {
                    if (((RGuard_T_14(self,rv))) == false) continue;
                    wn = w; wn = w + TryGivenObject(rv, true);
                    if (wn > w) jump ol_mm_5;
                }
                rv = 0; jump Fail_2;
                .ol_mm_5; rv = 0;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV153 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_246_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'back') jump group_246_1_2;
                jump group_246_1_end;
                .group_246_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'door') jump Fail_1;
                .group_246_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                ArticleDescriptors(); w = wn;
                objectloop (rv ofclass K2_thing) {
                    if (((RGuard_T_14(self,rv))) == false) continue;
                    wn = w; wn = w + TryGivenObject(rv, true);
                    if (wn > w) jump ol_mm_6;
                }
                rv = 0; jump Fail_2;
                .ol_mm_6; rv = 0;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV157 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV158 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_248_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'ufo') jump group_248_1_2;
                jump group_248_1_end;
                .group_248_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'ufos') jump Fail_1;
                .group_248_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV159 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV160 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_249_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'juvenile') jump group_249_1_2;
                jump group_249_1_end;
                .group_249_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'sasquatch') jump Fail_1;
                .group_249_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                ArticleDescriptors(); w = wn;
                objectloop (rv ofclass K2_thing) {
                    if (((RGuard_T_14(self,rv))) == false) continue;
                    wn = w; wn = w + TryGivenObject(rv, true);
                    if (wn > w) jump ol_mm_7;
                }
                rv = 0; jump Fail_2;
                .ol_mm_7; rv = 0;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV161 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_251_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'lens') jump group_251_1_2;
                jump group_251_1_end;
                .group_251_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'glass') jump group_251_1_3;
                jump group_251_1_end;
                .group_251_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'glasses') jump Fail_1;
                .group_251_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                ArticleDescriptors(); w = wn;
                objectloop (rv ofclass K2_thing) {
                    if (((RGuard_T_14(self,rv))) == false) continue;
                    wn = w; wn = w + TryGivenObject(rv, true);
                    if (wn > w) jump ol_mm_8;
                }
                rv = 0; jump Fail_2;
                .ol_mm_8; rv = 0;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV162 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'desk') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV163 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_254_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'office') jump group_254_1_2;
                jump group_254_1_end;
                .group_254_1_2;
                wn = group_wn;
                .group_254_1_end;
                if (NextWordStopped() ~= 'phone') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (NextWordStopped() ~= 'landline') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV164 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV165 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_256_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'her') jump group_256_1_2;
                jump group_256_1_end;
                .group_256_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'dog') jump group_256_1_3;
                jump group_256_1_end;
                .group_256_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'pluto') jump group_256_1_4;
                jump group_256_1_end;
                .group_256_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'photo') jump group_256_1_5;
                jump group_256_1_end;
                .group_256_1_5; wn = group_wn;
                if (NextWordStopped() ~= 'picture') jump Fail_1;
                .group_256_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV166 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV167 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_257_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'room') jump group_257_1_2;
                jump group_257_1_end;
                .group_257_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'of') jump group_257_1_3;
                jump group_257_1_end;
                .group_257_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'lost') jump group_257_1_4;
                jump group_257_1_end;
                .group_257_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'time') jump Fail_1;
                .group_257_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV168 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_258_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'print') jump group_258_1_2;
                jump group_258_1_end;
                .group_258_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'hiroshige') jump group_258_1_3;
                jump group_258_1_end;
                .group_258_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'utagawa') jump group_258_1_4;
                jump group_258_1_end;
                .group_258_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'art') jump group_258_1_5;
                jump group_258_1_end;
                .group_258_1_5; wn = group_wn;
                if (NextWordStopped() ~= 'painting') jump group_258_1_6;
                jump group_258_1_end;
                .group_258_1_6; wn = group_wn;
                if (NextWordStopped() ~= 'bird') jump Fail_1;
                .group_258_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV169 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_259_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'video') jump group_259_1_2;
                jump group_259_1_end;
                .group_259_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'game') jump group_259_1_3;
                jump group_259_1_end;
                .group_259_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'cobra') jump group_259_1_4;
                jump group_259_1_end;
                .group_259_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'darius') jump group_259_1_5;
                jump group_259_1_end;
                .group_259_1_5; wn = group_wn;
                if (NextWordStopped() ~= '5200') jump Fail_1;
                .group_259_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV170 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_260_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'faraji^s') jump group_260_1_2;
                jump group_260_1_end;
                .group_260_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'their') jump Fail_1;
                .group_260_1_end;
                group_wn = wn;
                .group_260_2_1; wn = group_wn;
                if (NextWordStopped() ~= 'softball') jump group_260_2_2;
                jump group_260_2_end;
                .group_260_2_2; wn = group_wn;
                if (NextWordStopped() ~= 'team') jump Fail_1;
                .group_260_2_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV171 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_261_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'backdoor') jump group_261_1_2;
                jump group_261_1_end;
                .group_261_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'white') jump group_261_1_3;
                jump group_261_1_end;
                .group_261_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'metal') jump Fail_1;
                .group_261_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV172 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_262_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'faraji^s') jump group_262_1_2;
                jump group_262_1_end;
                .group_262_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'goldberg^s') jump group_262_1_3;
                jump group_262_1_end;
                .group_262_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'gaunt^s') jump group_262_1_4;
                jump group_262_1_end;
                .group_262_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'larch^s') jump group_262_1_5;
                jump group_262_1_end;
                .group_262_1_5; wn = group_wn;
                if (NextWordStopped() ~= 'petula^s') jump group_262_1_6;
                jump group_262_1_end;
                .group_262_1_6; wn = group_wn;
                if (NextWordStopped() ~= 'ezra^s') jump group_262_1_7;
                jump group_262_1_end;
                .group_262_1_7; wn = group_wn;
                if (NextWordStopped() ~= 'office') jump group_262_1_8;
                jump group_262_1_end;
                .group_262_1_8; wn = group_wn;
                if (NextWordStopped() ~= 'door') jump Fail_1;
                .group_262_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV173 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_263_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'old') jump group_263_1_2;
                jump group_263_1_end;
                .group_263_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'clothing') jump group_263_1_3;
                jump group_263_1_end;
                .group_263_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'rack') jump Fail_1;
                .group_263_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV174 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV175 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV176 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV177 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_264_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'flattened') jump group_264_1_2;
                jump group_264_1_end;
                .group_264_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'boxes') jump Fail_1;
                .group_264_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV178 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_265_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'flattened') jump group_265_1_2;
                jump group_265_1_end;
                .group_265_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'boxes') jump Fail_1;
                .group_265_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV179 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'computer') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV180 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_267_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'heat') jump group_267_1_2;
                jump group_267_1_end;
                .group_267_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'air') jump group_267_1_3;
                jump group_267_1_end;
                .group_267_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'conditioning') jump group_267_1_4;
                jump group_267_1_end;
                .group_267_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'register') jump Fail_1;
                .group_267_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV181 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_268_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'key') jump group_268_1_2;
                jump group_268_1_end;
                .group_268_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'allen') jump Fail_1;
                .group_268_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV182 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV183 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV184 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV185 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_269_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'waiting') jump group_269_1_2;
                jump group_269_1_end;
                .group_269_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'for') jump group_269_1_3;
                jump group_269_1_end;
                .group_269_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'aliens') jump group_269_1_4;
                jump group_269_1_end;
                .group_269_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'alton') jump group_269_1_5;
                jump group_269_1_end;
                .group_269_1_5; wn = group_wn;
                if (NextWordStopped() ~= 'cherry') jump Fail_1;
                .group_269_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV186 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'my') jump Fail_1;
                if (NextWordStopped() ~= 'travels') jump Fail_1;
                if (NextWordStopped() ~= 'in') jump Fail_1;
                if (NextWordStopped() ~= 'time') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                group_wn = wn;
                .group_271_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'debi') jump group_271_1_2;
                jump group_271_1_end;
                .group_271_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'bosworth') jump Fail_2;
                .group_271_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV187 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV188 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_272_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'glasses') jump group_272_1_2;
                jump group_272_1_end;
                .group_272_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'lens') jump group_272_1_3;
                jump group_272_1_end;
                .group_272_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'glass') jump Fail_1;
                .group_272_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV189 
    original_wn ! first word of text parsed
    group_wn ! first word matched against A/B/C/... disjunction
    try_from_wn ! position to try matching from
    n ! number of words matched
    f ! flag: sufficiently good match found to justify success
    w ! for use by individual grammar lines
    rv ! for use by individual grammar lines
    g ! temporary: success flag for parsing visibles
    ss ! temporary: saves 'self' in distinguishing visibles
    spn ! temporary: saves 'parsed_number' in parsing visibles
    pass ! pass counter (1 to 3)
    pass1_n ! value of n recorded during pass 1
    pass2_n ! value of n recorded during pass 2
    ;
    #ifdef DEBUG;
    if (parser_trace >= 3) print "Parse_name called^";
    #endif;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p48_possessive
                    wn = try_from_wn; spn = parsed_number; ss = etype; if ((TEXT_TY_ROGPR(self.p48_possessive) == GPR_PREPOSITION)){
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn; etype = ss;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_273_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'shelves') jump group_273_1_2;
                jump group_273_1_end;
                .group_273_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'books') jump Fail_1;
                .group_273_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    #ifdef DEBUG;
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    #endif;
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Consult_Grammar_191 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'restart') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_192 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'restore') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_193 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'amusing') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_194 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'quit') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_195 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'undo') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_196 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'yes') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_197 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'no') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_198 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'sorry') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_199 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'herself') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_200 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'himself') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_201 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= '1//') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_202 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= '2//') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_203 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= '3//') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_204 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'stand') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_205 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'sit') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ Consult_Grammar_206 
    range_from ! call parameter: word number of snippet start

    range_words ! call parameter: snippet length

    original_wn ! first word of text parsed

    group_wn ! first word matched against A/B/C/... disjunction

    w ! for use by individual grammar lines

    rv ! for use by individual grammar lines

    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'lie') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];
[ SlashGPR_0 
    group_wn ! first word matched against A/B/C/.../-- disjunction
    ;
    group_wn = wn;
    .group_289_1_1; wn = group_wn;
    if (NextWordStopped() ~= 'about') jump group_289_1_2;
    jump group_289_1_end;
    .group_289_1_2;
    wn = group_wn;
    .group_289_1_end;
    return GPR_PREPOSITION;
];
[ SlashGPR_1 
    group_wn ! first word matched against A/B/C/.../-- disjunction
    ;
    group_wn = wn;
    .group_289_1_1; wn = group_wn;
    if (NextWordStopped() ~= 'about') jump group_289_1_2;
    jump group_289_1_end;
    .group_289_1_2;
    wn = group_wn;
    .group_289_1_end;
    return GPR_PREPOSITION;
];
[ SlashGPR_2 
    group_wn ! first word matched against A/B/C/.../-- disjunction
    ;
    group_wn = wn;
    .group_289_1_1; wn = group_wn;
    if (NextWordStopped() ~= 'on') jump group_289_1_2;
    jump group_289_1_end;
    .group_289_1_2;
    wn = group_wn;
    .group_289_1_end;
    return GPR_PREPOSITION;
];
[ SlashGPR_3 
    group_wn ! first word matched against A/B/C/.../-- disjunction
    ;
    group_wn = wn;
    .group_289_1_1; wn = group_wn;
    if (NextWordStopped() ~= 'on') jump group_289_1_2;
    jump group_289_1_end;
    .group_289_1_2;
    wn = group_wn;
    .group_289_1_end;
    return GPR_PREPOSITION;
];
[ SlashGPR_4 
    group_wn ! first word matched against A/B/C/.../-- disjunction
    ;
    group_wn = wn;
    .group_289_1_1; wn = group_wn;
    if (NextWordStopped() ~= 'on') jump group_289_1_2;
    jump group_289_1_end;
    .group_289_1_2;
    wn = group_wn;
    .group_289_1_end;
    return GPR_PREPOSITION;
];
Verb 'take' 'carry' 'hold'
    * 'inventory'  -> Inv
    * multi  -> Take
    * 'off' noun  -> Disrobe
    * noun 'off'  -> Disrobe
    * multiinside 'from' noun  -> Remove
    * multiinside 'off' noun  -> Remove
;
Verb 'get'
    * 'out' / 'off' / 'down' / 'up'  -> Exit
    * 'in' / 'on'  -> Enter
    * multi  -> Take
    * 'in' / 'into' / 'on' / 'onto' noun  -> Enter
    * 'off' / 'down' noun  -> GetOff
    * multiinside 'from' noun  -> Remove
;
Verb 'pick'
    * 'up' multi  -> Take
    * multi 'up'  -> Take
;
Verb 'stand'
    *  -> Exit
    * 'up'  -> Exit
    * 'on' noun  -> Enter
;
Verb 'remove'
    * held  -> Disrobe
    * multiinside 'from' noun  -> Remove
;
Verb 'shed' 'doff' 'disrobe'
    * held  -> Disrobe
;
Verb 'wear' 'don'
    * held  -> Wear
;
Verb 'put'
    * 'on' held  -> Wear
    * held 'on'  -> Wear
    * 'down' multiheld  -> Drop
    * multiheld 'down'  -> Drop
    * multiexcept 'in' / 'inside' / 'into' noun  -> Insert
    * multiexcept 'on' / 'onto' noun  -> PutOn
;
Verb 'insert'
    * multiexcept 'in' / 'into' noun  -> Insert
;
Verb 'drop' 'throw' 'discard'
    * multiheld  -> Drop
    * held 'at' / 'against' noun  -> ThrowAt
    * multiexcept 'in' / 'into' / 'down' noun  -> Insert
    * multiexcept 'on' / 'onto' noun  -> PutOn
;
Verb 'give' 'pay' 'offer' 'feed'
    * creature held  -> Give reverse
    * held 'to' creature  -> Give
;
Verb 'show' 'present' 'display'
    * creature held  -> Show reverse
    * held 'to' creature  -> Show
;
Verb 'go' 'walk' 'run'
    *  -> Go
    * noun=Noun_Filter_0  -> Go
    * noun  -> Enter
    * 'into' / 'in' / 'inside' / 'through' noun  -> Enter
;
Verb 'inventory' 'i//' 'inv'
    *  -> Inv
    * 'promise'  -> A81_promising
;
Verb 'look' 'l//'
    *  -> Look
    * noun  -> Examine
    * 'at' noun  -> Examine
    * 'inside' / 'in' / 'into' / 'through' noun  -> Search
    * 'under' noun  -> LookUnder
    * 'behind' noun  -> A99_looking_behind
    * 'up' topic 'in' noun  -> Consult reverse
;
Verb 'consult'
    * noun 'on' / 'about' topic  -> Consult
;
Verb 'open' 'unwrap' 'uncover'
    * noun  -> Open
    * noun 'with' held  -> Unlock
;
Verb 'close' 'shut' 'cover'
    * noun  -> Close
    * 'up' noun  -> Close
    * 'off' noun  -> SwitchOff
;
Verb 'enter' 'cross'
    *  -> Enter
    * noun  -> Enter
;
Verb 'sit'
    * 'on' / 'in' / 'inside' noun  -> Enter
    * 'on' 'top' 'of' noun  -> Enter
;
Verb 'exit' 'leave' 'out'
    *  -> Exit
    * 'colour' / 'color'  -> A96_exit_colouring
    * 'symbol'  -> A97_exit_symboling
;
Verb 'examine' 'x//' 'watch' 'describe' 'check'
    * noun  -> Examine
;
Verb 'read'
    * noun  -> Examine
    * 'about' topic 'in' noun  -> Consult reverse
    * topic 'in' noun  -> Consult reverse
;
Verb 'yes' 'y//'
    *  -> Yes
;
Verb 'no'
    *  -> No
;
Verb 'sorry'
    *  -> Sorry
;
Verb 'search'
    * noun  -> Search
;
Verb 'wave'
    * noun  -> Wave
;
Verb 'pull' 'drag'
    * noun  -> Pull
;
Verb 'push' 'move' 'shift' 'clear' 'press'
    * noun  -> Push
    * noun noun=Noun_Filter_1  -> PushDir
    * noun 'to' noun=Noun_Filter_2  -> PushDir
    * noun 'with' noun  -> A107_moving_it_with
;
Verb 'turn' 'rotate' 'twist' 'unscrew' 'screw'
    * noun  -> Turn
    * noun 'on'  -> SwitchOn
    * 'on' noun  -> SwitchOn
    * noun 'off'  -> SwitchOff
    * 'off' noun  -> SwitchOff
;
Verb 'switch'
    * noun=Noun_Filter_3  -> SwitchOff
    * noun  -> SwitchOn
    * 'on' noun  -> SwitchOn
    * noun 'on'  -> SwitchOn
    * noun 'off'  -> SwitchOff
    * 'off' noun  -> SwitchOff
;
Verb 'lock'
    * noun 'with' held  -> Lock
;
Verb 'unlock'
    * noun 'with' held  -> Unlock
;
Verb 'attack' 'break' 'smash' 'hit' 'fight' 'torture' 'wreck' 'crack' 'destroy' 'murder' 'kill' 'punch' 'thump'
    * noun  -> Attack
;
Verb 'wait' 'z//'
    *  -> Wait
;
Verb 'speak' 'say' 'shout'
    * 'hello' / 'hi'  -> A75_hailing
    * scope=Scope_Filter_6  -> A103_discussing
    * scope=Scope_Filter_7  -> A103_discussing
    * Cond_Token_202 scope=Scope_Filter_4 'to' noun=Noun_Filter_5  -> A102_discussing_it_with
    * 'hello' / 'hi' 'to' noun  -> A74_saying_hello_to
    * 'bye' / 'goodbye' / 'farewell' / 'cheerio' 'to' creature  -> A77_saying_goodbye_to
    * topic 'to' creature  -> Answer reverse
;
Verb 'tell'
    * noun=Noun_Filter_9 scope=Scope_Filter_10  -> A102_discussing_it_with reverse
    * creature 'about' scope=Scope_Filter_8  -> A67_informing_it_about
    * creature 'about' topic  -> Tell
    * creature 'that' topic  -> Answer
    * creature topic  -> Answer
;
Verb 'ask'
    * SlashGPR_0 scope=Scope_Filter_17  -> A103_discussing
    * 'about' scope=Scope_Filter_13  -> A70_implicit_quizzing
    * 'for' scope=Scope_Filter_14  -> A72_implicit_requesting
    * noun=Noun_Filter_15 SlashGPR_1 scope=Scope_Filter_16  -> A102_discussing_it_with reverse
    * creature 'for' scope=Scope_Filter_11  -> A64_requesting_it_for
    * creature 'about' scope=Scope_Filter_12  -> A66_quizzing_it_about
    * creature 'about' topic  -> Ask
    * creature 'for' topic  -> A65_imploring_it_for
    * 'about' topic  -> A68_implicit_asking
    * 'for' topic  -> A73_implicit_imploring
;
Verb 'eat'
    * held  -> Eat
;
Verb 'purchase'
    * noun=Noun_Filter_20  -> A89_buying_it_with
    * noun=Noun_Filter_18 'with' noun=Noun_Filter_19  -> A89_buying_it_with
;
Verb 'squeeze' 'squash'
    * noun  -> Squeeze
;
Verb 'wake' 'awake' 'awaken'
    * creature  -> WakeOther
    * creature 'up'  -> WakeOther
    * 'up' creature  -> WakeOther
;
Verb 'kiss' 'embrace' 'hug'
    * creature  -> Kiss
;
Verb 'touch' 'feel'
    * noun  -> Touch
;
Verb 'rub'
    * noun  -> Rub
;
Verb 'cut'
    * noun  -> Cut
;
Verb 'score'
    *  -> Score
;
Verb 'quit'
    *  -> Quit
;
Verb 'q//'
    *  -> Quit
;
Verb 'save'
    *  -> Save
;
Verb 'restart'
    *  -> Restart
;
Verb 'restore'
    *  -> Restore
;
Verb 'verify'
    *  -> Verify
;
Verb 'version'
    *  -> Version
;
Verb 'script'
    *  -> ScriptOn
    * 'on'  -> ScriptOn
    * 'off'  -> ScriptOff
;
Verb 'transcript'
    *  -> ScriptOn
    * 'on'  -> ScriptOn
    * 'off'  -> ScriptOff
;
Verb 'superbrief'
    *  -> LMode3
;
Verb 'short'
    *  -> LMode3
;
Verb 'verbose'
    *  -> LMode2
;
Verb 'long'
    *  -> LMode2
;
Verb 'brief'
    *  -> LMode1
;
Verb 'normal'
    *  -> LMode1
;
Verb 'nouns'
    *  -> Pronouns
;
Verb 'pronouns'
    *  -> Pronouns
;
Verb 'notify'
    *  -> NotifyOn
    * 'on'  -> NotifyOn
    * 'off'  -> NotifyOff
;
Verb 'epistat'
    * scope=Scope_Filter_21  -> A63_requesting_epistemic_sta
;
Verb 'a//'
    * scope=Scope_Filter_22  -> A70_implicit_quizzing
    * topic  -> A68_implicit_asking
;
Verb 't//'
    * scope=Scope_Filter_23  -> A71_implicit_informing
    * topic  -> A69_implicit_telling
;
Verb 'talk'
    * 'about' scope=Scope_Filter_24  -> A71_implicit_informing
    * 'to' noun  -> A74_saying_hello_to
;
Verb 'greet'
    * noun  -> A74_saying_hello_to
;
Verb 'hello'
    *  -> A75_hailing
;
Verb 'hi'
    *  -> A75_hailing
;
Verb 'bye'
    *  -> A76_leavetaking
;
Verb 'goodbye'
    *  -> A76_leavetaking
;
Verb 'cheerio'
    *  -> A76_leavetaking
;
Verb 'farewell'
    *  -> A76_leavetaking
;
Verb 'help'
    *  -> A78_helping
    * 'hyperspace'  -> A105_helping_about_hyperspac
;
Verb 'who'
    * 'are' 'you'  -> A79_asking_for_identificatio
    * 'owns' noun=Noun_Filter_25  -> A92_attributing_it
;
Verb 'what'
    * 'do' 'you' 'want'  -> A80_questioning_motives
;
Verb 'promise'
    *  -> A81_promising
;
Verb 'call'
    * scope=Scope_Filter_26 'on' noun=Noun_Filter_27  -> A82_calling_it_on
    * scope=Scope_Filter_28 'on' noun=Noun_Filter_29  -> A82_calling_it_on
    * topic 'on' noun=Noun_Filter_30  -> A83_cold_calling_it_on
    * topic  -> A83_cold_calling_it_on
;
Verb 'answer'
    * noun=Noun_Filter_31  -> A84_answering
;
Verb 'hang'
    * 'up'  -> A86_ending_a_call
;
Verb 'buy'
    * noun=Noun_Filter_34  -> A89_buying_it_with
    * noun=Noun_Filter_32 'with' noun=Noun_Filter_33  -> A89_buying_it_with
;
Verb 'how'
    * 'are' 'you'  -> A108_howdeedoing
    * 'much' 'is' noun=Noun_Filter_35  -> A90_pricing_it
    * 'much' 'do' 'i//' 'have'  -> A91_accounting
    * 'much' 'does' noun=Noun_Filter_36 'cost'  -> A90_pricing_it
    * 'much' 'money' 'do' 'i//' 'have'  -> A91_accounting
;
Verb 'exits'
    *  -> A95_exitlisting
    * 'off'  -> A94_exitstopping
    * 'on'  -> A93_exitstarting
;
Verb 'no.verb'
    * scope=Scope_Filter_38  -> A103_discussing
    * scope=Scope_Filter_37  -> A98_choosing
    * creature 'how' 'are' 'you'  -> A109_howdeedoing_someone
;
Verb 'memories'
    *  -> A100_printing_memories
;
Verb 'remember'
    * scope=Scope_Filter_39  -> A101_remembering
;
Verb 'frump'
    *  -> A104_frumping
;
Verb 'swipe'
    * noun 'through' / 'in' noun  -> A106_swiping_it_through
;
Verb 'knock'
    * SlashGPR_2 noun  -> A110_knocking_on
;
Verb 'pound'
    * SlashGPR_3 noun  -> A110_knocking_on
;
Verb 'rap'
    * SlashGPR_4 noun  -> A110_knocking_on
;
Verb 'lens'
    *  -> A111_lensing
;





#IFTRUE (1 == 1);
[ UnknownVerb; verb_wordnum = 0; return 'no.verb'; ];
[ PrintVerb v;
	if (v == 'no.verb') { print "do something to"; rtrue; }
	rfalse;
];
#Ifnot;
[ UnknownVerb; rfalse; ]; [ PrintVerb v; rfalse; ];
#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Deferred Propositions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====







! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Miscellaneous Loose Ends
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====



Constant TX_PS_467 = " ";
Constant TX_PS_456 = " and ";
Constant TX_PS_469 = " or ";
Constant TX_PS_462 = "#888888";
Constant TX_PS_147 = "~Fantastic! Hand it here.~";
Constant TX_PS_305 = "~Sorry, too busy right now. What do you want back there anyway? There's only a dumpster.~ She pauses for a moment and mutters to herself. ~Which reminds me, I need to get these boxes broken down.~";
Constant TX_PS_299 = "~Sure I do -- I put it in your desk.~ She furrows her brow. ~What's the matter?~";
Constant TX_PS_357 = "~Sure! Why don't you scout the locality for astral phenomena?~";
Constant TX_PS_234 = "~Well, that's a tricky one. Laundromat's been closed for almost two weeks now, since the owner just split for some reason he didn't bother to share. Not likely to get ahold of him. If you're not averse to a little trespassing, though, see if you come across a watch. Another thing he borrowed.~";
Constant TX_PS_472 = "*";
Constant TX_PS_473 = "+";
Constant TX_PS_454 = ", ";
Constant TX_PS_455 = ", and ";
Constant TX_PS_471 = "-";
Constant TX_PS_468 = ". ";
Constant TX_PS_474 = "1, 2, or 3? > ";
Array TX_L_474 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_474;
Constant TX_PS_444 = "1.";
Constant TX_PS_445 = "2.";
Constant TX_PS_313 = "200 block of Main Street";
Constant TX_PS_466 = "; ";
Constant TX_PS_470 = "=";
Constant TX_PS_452 = ">";
Array TX_L_452 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_452;
Constant TX_PS_179 = "A coffee table and couch greet visitors to the office, as if any are expected.";
Constant TX_PS_16 = "A glass door with a lock and a pull handle.";
Constant TX_PS_17 = "A glass door with a pushbar.";
Constant TX_PS_275 = "A knockoff of a fancy gaming laptop.";
Constant TX_PS_273 = "A medium-length flat head screwdriver with a red plastic handle.";
Constant TX_PS_371 = "A print of a beautiful green pheasant in a tree, by the 19th century Japanese artist Utagawa Hiroshige.";
Constant TX_PS_439 = "A relic of the Chief's sacred geometry phase.";
Constant TX_PS_188 = "A typical air register with a grill which one would hope would stop things like, say, a hex wrench from falling through. It's set in the floor behind the front desk. The vent is held closed by four screws.";
Constant TX_PS_169 = "A ways off past the swamp, the highway carries most travelers right past this glum little village.";
Constant TX_PS_162 = "A-plus laundromat";
Constant TX_PS_151 = "About Savra";
Constant TX_PS_153 = "About the Dragon";
Constant TX_PS_446 = "About the hyperdimensional portal";
Constant TX_PS_235 = "About the laundromat owner";
Constant TX_PS_302 = "About the status of the computer";
Constant TX_PS_300 = "About the whereabouts of the desk key";
Constant TX_PS_155 = "About time travel";
Constant TX_PS_291 = "Agent Faraji ";
Constant TX_PS_287 = "Agent Gaunt's last name describes him well. He is a perpetually worried-looking individual, a look emphasized by his thinness and his thick-rimmed glasses.";
Constant TX_PS_289 = "Agent Goldberg has lots of dogs, a fact which can be inferred by the inevitable fur somewhere on her person. The last front office worker at the Bureau left due to an extreme allergic reaction to Goldberg.";
Constant TX_PS_360 = "Agent Moira Zin is the very model of a competent Bureau agent. Hard-working, serious, no-nonsense but open-minded, she's the sober counter-balance to Klimp's sometimes childish credulity. Moira would clearly be a rising star if it weren't for the Bureau's pending dissolution.";
Constant TX_PS_344 = "Aliens";
Constant TX_PS_3 = "An Interactive Phenomenon";
Constant TX_PS_241 = "An everyday blue dumpster, about six feet high.";
Constant TX_PS_382 = "An unremarkable metal door painted white. It is closed.";
Constant TX_PS_177 = "Apparently the bureau did make off with at least one piece of government furniture. A bland, institutional piece with fake leather seats, it's at least preferable to second-hand upholstery.";
Constant TX_PS_281 = "As good-looking as ever.";
Constant TX_PS_362 = "BOSH HQ";
Constant TX_PS_389 = "BOSH chief's office";
Constant TX_PS_229 = "BOSH headquarters";
Constant TX_PS_105 = "Back";
Constant TX_PS_89 = "Back-door-is-locked";
Constant TX_PS_119 = "Backeast";
Constant TX_PS_117 = "Backnorth";
Constant TX_PS_121 = "Backsouth";
Constant TX_PS_123 = "Backwest";
Constant TX_PS_251 = "Bb-light";
Constant TX_PS_216 = "Been better.";
Constant TX_PS_364 = "Biff's chair";
Constant TX_PS_379 = "Biff's desk drawer";
Constant TX_PS_352 = "Biff's mobile number";
Constant TX_PS_463 = "Black asphalt.";
Constant TX_PS_86 = "Break-in-to-laundromat";
Constant TX_PS_378 = "Bureau credit card";
Constant TX_PS_345 = "Bureau of Strange Happenings";
Constant TX_PS_263 = "CBD oil";
Constant TX_PS_346 = "Chief Klimp";
Constant TX_PS_390 = "Chief's desk";
Constant TX_PS_404 = "Chief's shelves";
Constant TX_PS_143 = "Christy";
Constant TX_PS_142 = "Christy's office";
Constant TX_PS_214 = "Dave";
Constant TX_PS_165 = "Dave's pawn shop";
Constant TX_PS_127 = "Descending Stair";
Constant TX_PS_68 = "Desk-locked";
Constant TX_PS_465 = "Dingy stained industrial carpet.";
Constant TX_PS_90 = "Doing nothing";
Constant TX_PS_145 = "Doris hardly looks up from his work. ~Go ask Maggie; she can help you.~";
Constant TX_PS_141 = "Doris is sitting cross-legged in a chair, tapping his foot lazily on the desk.";
Constant TX_PS_140 = "Doris";
Constant TX_PS_139 = "Doris's office";
Constant TX_PS_451 = "Draco";
Constant TX_PS_310 = "ELR";
Constant TX_PS_311 = "Enigma Lake town hall";
Constant TX_PS_312 = "Enigma Park";
Constant TX_PS_128 = "Ethereal Pillar";
Constant TX_PS_286 = "Ezra Gaunt";
Array TX_L_286 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_286;
Constant TX_PS_479 = "Ezra";
Array TX_L_479 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_479;
Constant TX_PS_429 = "FILL THIS IN";
Constant TX_PS_476 = "Faraji";
Array TX_L_476 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_476;
Constant TX_PS_103 = "Field office area";
Constant TX_PS_132 = "Field office reception";
Constant TX_PS_295 = "Finding the drive before";
Constant TX_PS_321 = "First Unitarian Church of Enigma Lake";
Constant TX_PS_107 = "Forth";
Constant TX_PS_111 = "Fortheast";
Constant TX_PS_109 = "Forthnorth";
Constant TX_PS_113 = "Forthsouth";
Constant TX_PS_115 = "Forthwest";
Constant TX_PS_436 = "Four plain flat head screws.";
Constant TX_PS_328 = "Fresnel's Music";
Constant TX_PS_160 = "From here one can see just how humble BOSH's state has become: the office is to the west, between a pawn shop (to the southwest) and a run-down laundromat (to the northwest) and across from an automatic car wash. To the south is a swampy area separating the lot from the interstate. The parking lot continues north.";
Constant TX_PS_480 = "Gaunt";
Array TX_L_480 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_480;
Constant TX_PS_62 = "Generic-truth";
Constant TX_PS_482 = "Goldberg";
Array TX_L_482 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_482;
Constant TX_PS_348 = "Good good good. Just fine.";
Constant TX_PS_260 = "Good, I guess.";
Constant TX_PS_370 = "Green Pheasant";
Constant TX_PS_464 = "Grungy black and white tile.";
Constant TX_PS_135 = "Hallway";
Constant TX_PS_149 = "Hand over the thumb drive";
Constant TX_PS_354 = "He looks pained for a moment. ~Uh, I'd rather you didn't. It's fragile.~";
Constant TX_PS_215 = "He's dressed in polyester, as if he were still wearing last night's bowling shirt. A bit of tattoo peeks out from his open collar.";
Constant TX_PS_335 = "He-pronoun";
Constant TX_PS_329 = "Henry's Hot Skillet";
Constant TX_PS_83 = "Hex-screws";
Constant TX_PS_326 = "Hook and Ladder Company #1";
Constant TX_PS_130 = "Hooray you made it!";
Constant TX_PS_325 = "Horton House";
Constant TX_PS_146 = "How to get home";
Constant TX_PS_347 = "Huffton Klimp, or simply ~The Chief~, who by his name and title should rightly be big and gruff, is a wiry guy with a thinning shock of red hair on top. Once the youngest and most devoted recruit in the Bureau, the years and his promotion to Bureau Head have not dulled his enthusiasm and idealism.";
Constant TX_PS_97 = "Hyperlight";
Constant TX_PS_101 = "Hyperspace";
Constant TX_PS_477 = "I promise";
Array TX_L_477 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_477;
Constant TX_PS_489 = "I";
Constant TX_PS_173 = "I'm great! Thanks!";
Constant TX_PS_332 = "I-pronoun";
Constant TX_PS_377 = "ID";
Constant TX_PS_255 = "It is featureless white, or what passes for white here. It bends ~back~ to ~forthnorth.~";
Constant TX_PS_237 = "It is featureless white, or what passes for white here. It bends ~forth~ to north.";
Constant TX_PS_242 = "It is featureless white, or what passes for white here. It bends south to ~forth.~";
Constant TX_PS_418 = "It is, like Moira herself, neat and orderly. She's clearly made the most of the meager funds she had for furnishing her office. Behind a modest yet functional desk is a modest yet functional office chair. Her bookshelves are filled with titles relating to investigative techniques, law, and skepticism. In the east wall is a closet door. The exit is to the south.";
Constant TX_PS_407 = "It looks a bit Neanderthal, actually.";
Constant TX_PS_228 = "It says ~Park Place~.";
Constant TX_PS_425 = "It's a pretty ordinary mass-produced desk, but Moira's re-stain job on it has truly transformed it. Really, is there anything she can't do?";
Constant TX_PS_284 = "It's a red plastic thumb drive, with what look like symbols scratched on the surface, but they're like no symbols you've ever seen. The metal USB end is somewhat corroded.";
Constant TX_PS_421 = "It's a small metal box affixed to the back wall of the closet. It is featureless apart from the latch.";
Constant TX_PS_427 = "It's a testament to Moira's competence and taste that she managed to acquire such a nice chair with the funds available.";
Constant TX_PS_200 = "It's a typical glass door. Taped to it is a sign that says ~Closed for renovations~.";
Constant TX_PS_210 = "It's a typical glass door. The light within is too dim to see much.";
Constant TX_PS_201 = "It's a typical glass door.";
Constant TX_PS_193 = "It's adorned with a pair of angel's wings.";
Constant TX_PS_181 = "It's an old clothing rack from the department store which formerly occupied this space.";
Constant TX_PS_198 = "It's just a piece of stationery marked up with Sharpie and taped to the door. It says ~Closed for renovations~.";
Constant TX_PS_365 = "It's just a plain old office chair. The lumbar support control is broken.";
Constant TX_PS_220 = "It's marked by a sign with a big nectarine on it.";
Constant TX_PS_363 = "It's not yet hooked up.";
Constant TX_PS_171 = "It's really a small storefront done up to resemble an office. A store sales counter serves as a front desk, behind which are located shelves of office supplies and a row of drawers. There are also a couch and coffee table here creating a makeshift seating area. An old department store clothing rack serves as a coatrack. Photos on the walls picture the Bureau in better days. A stack of used and empty cardboard boxes sits in one corner.";
Constant TX_PS_334 = "It-pronoun";
Constant TX_PS_208 = "Its flash rate is just a bit over the threshold of irritating.";
Constant TX_PS_77 = "Key-is-lost";
Constant TX_PS_195 = "Klimp drives an impeccably-maintained 2017 Porsche 911 Turbo Cabriolet.";
Constant TX_PS_392 = "Klimp's Computer";
Constant TX_PS_196 = "Klimp's Porsche takes up two spots.";
Constant TX_PS_194 = "Klimp's Porsche";
Constant TX_PS_388 = "Klimp's door";
Constant TX_PS_351 = "Klimp's mobile phone number";
Constant TX_PS_350 = "Klimp's mobile phone";
Constant TX_PS_319 = "Lake Street by the Courthouse";
Constant TX_PS_320 = "Lake Street by the Park";
Constant TX_PS_322 = "Lake at Ridge";
Constant TX_PS_290 = "Larch Faraji";
Array TX_L_290 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_290;
Constant TX_PS_475 = "Larch";
Array TX_L_475 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_475;
Constant TX_PS_158 = "Laundromat-region";
Constant TX_PS_248 = "Lb-light";
Constant TX_PS_245 = "Lbr-light";
Constant TX_PS_219 = "Li'l Nectarine Convenience Store";
Constant TX_PS_256 = "Li'l Nectarine offers great service and low prices, or so they say. This one's cluttered aisles and sparse shelves could make one wonder if that's true. Behind the counter is the typical array of cigarettes and lottery tickets. Under the counter is a glass case containing various useful items.";
Constant TX_PS_61 = "Life is hard.";
Constant TX_PS_384 = "Locking-back-door";
Constant TX_PS_413 = "Looks like it was taken out of an old library somewhere.";
Constant TX_PS_206 = "Ls-light";
Constant TX_PS_133 = "Maggie";
Constant TX_PS_314 = "Main and Solvay";
Constant TX_PS_318 = "Main at Lake";
Constant TX_PS_172 = "Margaret Chao";
Constant TX_PS_191 = "Margaret";
Constant TX_PS_98 = "Marsh Street";
Constant TX_PS_221 = "Military Recruitment Center";
Constant TX_PS_137 = "Minerva";
Constant TX_PS_136 = "Minerva's office";
Constant TX_PS_359 = "Moira Zin";
Constant TX_PS_428 = "Moira's bookshelves";
Constant TX_PS_426 = "Moira's chair";
Constant TX_PS_424 = "Moira's desk";
Constant TX_PS_416 = "Moira's door";
Constant TX_PS_440 = "Moira's drawer";
Constant TX_PS_417 = "Moira's office";
Constant TX_PS_59 = "Motives";
Constant TX_PS_167 = "Much like any other automatic car wash.";
Constant TX_PS_331 = "Municipal Courthouse";
Constant TX_PS_430 = "Native Tribes of Upstate New York";
Constant TX_PS_394 = "Nice chair. Good lumbar support.";
Constant TX_PS_222 = "Patriotic posters paper the windows.";
Constant TX_PS_223 = "Patriotic posters";
Constant TX_PS_213 = "Pawn-light";
Constant TX_PS_74 = "Pawn-shop-dave";
Constant TX_PS_71 = "Pawn-shop-screwdriver";
Constant TX_PS_373 = "Pencil on canvas, it's a fuzzy drawing of the 8-bit snake in the classic video game Pitfall.";
Constant TX_PS_288 = "Petula Goldberg";
Array TX_L_288 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_288;
Constant TX_PS_481 = "Petula";
Array TX_L_481 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_481;
Constant TX_PS_4 = "Phil Riley";
Constant TX_PS_85 = "Player needs to break in to laundromat.";
Constant TX_PS_338 = "Plural-you-pronoun";
Constant TX_PS_398 = "Plush and comfortable with a yellow and red striped design. Absolutely hideous.";
Constant TX_PS_460 = "QUIT";
Constant TX_PS_457 = "RESTART";
Constant TX_PS_458 = "RESTORE a saved game";
Constant TX_PS_327 = "Reading Room";
Constant TX_PS_330 = "Rolle's Department Store";
Constant TX_PS_279 = "Room of Stuff";
Constant TX_PS_56 = "Room of Subjects";
Constant TX_PS_453 = "Science Fiction";
Constant TX_PS_80 = "Screwdriver-in-laundromat";
Constant TX_PS_292 = "Senator Savra";
Constant TX_PS_336 = "She-pronoun";
Constant TX_PS_340 = "Singular-they-pronoun";
Constant TX_PS_337 = "Singular-you-pronoun";
Constant TX_PS_315 = "Solvay Road by the fire station";
Constant TX_PS_317 = "Solvay Road leading out of town";
Constant TX_PS_297 = "Some cardboard boxes that have been broken down flat for recycling.";
Constant TX_PS_277 = "Some no-name brand.";
Constant TX_PS_164 = "Swamp Park is, as one might expect, dotted with these little bits of wetland.";
Constant TX_PS_156 = "Swamp Park";
Constant TX_PS_230 = "The BOSH headquarters are to the south.";
Constant TX_PS_2 = "The Bureau of Strange Happenings";
Constant TX_PS_88 = "The back door to BOSH is locked.";
Constant TX_PS_423 = "The circuit breaker is a single switch, labeled `20 amps`.";
Constant TX_PS_258 = "The clerk looks as if he'd rather be anywhere else. He's wearing jeans and a white t-shirt with something inscrutable scrawled on it. His hair sticks up every which way.";
Constant TX_PS_259 = "The clerk, a scruffy man in his mid-twenties, is leaning against the counter, looking bored.";
Constant TX_PS_262 = "The counter is arrayed with displays of CBD oil, antacids, and the like.";
Constant TX_PS_82 = "The desk is held together with hex screws.";
Constant TX_PS_432 = "The front page story is an account of the disappearance of the grandson of Senate Homeland Security Committee chairman Englund Fryes. His parents, including the Senator's son, were brutally murdered in their home, but the boy, Draco Fryes, is missing and presumed kidnapped. So far there has been no ransom demand.";
Constant TX_PS_396 = "The globe is very handsome with lots of intriguing detail. Unfortunately, Klimp has marred it with thumbtacks and string marking the world's ~leylines~.";
Constant TX_PS_76 = "The key to the desk is lost.";
Constant TX_PS_226 = "The main business thoroughfare of Swamp Park.";
Constant TX_PS_224 = "The new slogan is ~Answer the Call!~";
Constant TX_PS_73 = "The pawn shop owner is named Dave.";
Constant TX_PS_70 = "The pawn shop owner may have a screwdriver.";
Constant TX_PS_67 = "The phone is locked in the desk.";
Constant TX_PS_190 = "The ubiquitous flat pack furniture tool.";
Constant TX_PS_64 = "The vent is held closed by four screws.";
Constant TX_PS_183 = "There are a number of shelves of office supplies behind the desk. There is also a heating vent on the floor here.";
Constant TX_PS_415 = "There are three prints, the most striking of which is a neon-hued abstract by Diego Ernesto Diaz, the late Mexican painter, titled ~Hora de la Muerte~.";
Constant TX_PS_79 = "There is a screwdriver in the laundromat.";
Constant TX_PS_186 = "There is a stack of boxes in the corner.";
Constant TX_PS_405 = "These shelves sport an array of oddities and memorabilia.";
Constant TX_PS_434 = "They look like some kind of language, but none you recognize.";
Constant TX_PS_339 = "They-pronoun";
Constant TX_PS_411 = "This and that piece of junk that Klimp thinks is funny or interesting.";
Constant TX_PS_391 = "This desk is a beautiful assembly of smokey glass and chrome framing. The ~legs~ form shelves where Klimp keeps yet more curios. One might wonder where Klimp gets the money.";
Constant TX_PS_175 = "This doesn't look like government-issue furniture. More like thrift store. It's scuffed, but at least it's sturdy.";
Constant TX_PS_218 = "This end is no more auspicious than the other. A convenience store lies to the east. To the west is a military recruitment center. North of here the parking lot exits onto a busy road. There is a rusty sign by the road naming the shopping center: Park Place. South is BOSH headquarters, among other things.";
Constant TX_PS_203 = "This is A-plus laundromat.";
Constant TX_PS_400 = "This is a nice piece, quite out of place in the BOSH offices. Flame mahogany with very pretty inlays.";
Constant TX_PS_239 = "This is a small area of asphalt between the building and a chain link fence looking in on an industrial property. A door to east leads into the BOSH offices, and one to the north enters the laundromat. There is a blue dumpster here.";
Constant TX_PS_211 = "This is more the seedy, gloomy stereotype of a pawn shop than the glitzy sanitized version of TV reality shows. The blinds in the windows are closed to only allow the barest slant of sunlight in, leaving the sickly fluorescent lights to illuminate the room. There is the distinct smell of cigar smoke. The glass counter is filled with a large collection of possibly valuable items. Behind it is an impressive array of firearms.";
Constant TX_PS_57 = "This is where all subjects go.";
Constant TX_PS_309 = "Throw out boxes";
Constant TX_PS_342 = "Time";
Constant TX_PS_409 = "To all appearances an ordinary pair of glasses, the astral lenses allegedly reveal the existence of extra-dimensional pathways.";
Constant TX_PS_358 = "To borrow the lenses";
Constant TX_PS_355 = "To borrow the skull";
Constant TX_PS_306 = "To unlock the backdoor";
Constant TX_PS_448 = "To wait for the report";
Constant TX_PS_403 = "Travels in Time";
Constant TX_PS_461 = "UNDO the last command";
Constant TX_PS_65 = "Vent-screws";
Constant TX_PS_361 = "Very well, thanks.";
Constant TX_PS_402 = "Waiting for the Aliens";
Constant TX_PS_386 = "Waiting-for-player";
Constant TX_PS_91 = "Walking-to";
Constant TX_PS_269 = "We're not here to go grocery shopping.";
Constant TX_PS_333 = "We-pronoun";
Constant TX_PS_488 = "You have no reception here.";
Array TX_L_488 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_488;
Constant TX_PS_483 = "You'll have to hang up first.";
Array TX_L_483 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_483;
Constant TX_PS_282 = "Yourself";
Constant TX_PS_150 = "about Savra";
Constant TX_PS_152 = "about the Dragon";
Constant TX_PS_443 = "about the hyperdimensional portal";
Constant TX_PS_233 = "about the laundromat owner";
Constant TX_PS_301 = "about the status of the computer";
Constant TX_PS_298 = "about the whereabouts of the desk key";
Constant TX_PS_154 = "about time travel";
Constant TX_PS_343 = "aliens";
Constant TX_PS_12 = "animals";
Constant TX_PS_264 = "antacids";
Constant TX_PS_412 = "antique wooden file cabinet";
Constant TX_PS_397 = "armchair";
Constant TX_PS_408 = "astral lenses";
Constant TX_PS_236 = "astral tunnel";
Constant TX_PS_487 = "at the top of";
Array TX_L_487 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_487;
Constant TX_PS_131 = "at";
Constant TX_PS_166 = "automatic car wash";
Constant TX_PS_249 = "back basement";
Constant TX_PS_238 = "back lot";
Constant TX_PS_104 = "back";
Array TX_L_104 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_104;
Constant TX_PS_87 = "back-door-is-locked";
Constant TX_PS_24 = "backdrops";
Constant TX_PS_118 = "backeast";
Constant TX_PS_116 = "backnorth";
Constant TX_PS_120 = "backsouth";
Constant TX_PS_122 = "backwest";
Constant TX_PS_250 = "bb-light";
Constant TX_PS_40 = "behaviors";
Constant TX_PS_393 = "black leather swivel chair";
Constant TX_PS_376 = "blue flipphone";
Constant TX_PS_285 = "blue screwdriver";
Constant TX_PS_401 = "bookcase";
Constant TX_PS_84 = "break-in-to-laundromat";
Constant TX_PS_420 = "breaker box";
Constant TX_PS_254 = "broken washing machine";
Constant TX_PS_225 = "busy road";
Constant TX_PS_34 = "card keys";
Constant TX_PS_185 = "cardboard boxes";
Constant TX_PS_94 = "ceiling";
Constant TX_PS_30 = "choices";
Constant TX_PS_265 = "cigarettes";
Constant TX_PS_422 = "circuit breaker";
Constant TX_PS_441 = "closet door";
Constant TX_PS_419 = "closet";
Constant TX_PS_180 = "coatrack";
Constant TX_PS_174 = "coffee table";
Constant TX_PS_20 = "containers";
Constant TX_PS_431 = "copy of the Washington Herald";
Constant TX_PS_176 = "couch";
Constant TX_PS_367 = "degree";
Constant TX_PS_192 = "department store sign";
Constant TX_PS_486 = "descending stair";
Array TX_L_486 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_486;
Constant TX_PS_437 = "desk shelves";
Constant TX_PS_66 = "desk-locked";
Constant TX_PS_7 = "desks";
Constant TX_PS_25 = "devices";
Constant TX_PS_37 = "directions";
Constant TX_PS_13 = "doors";
Constant TX_PS_53 = "down";
Constant TX_PS_23 = "drawers";
Constant TX_PS_372 = "drawing of the Pitfall snake";
Constant TX_PS_240 = "dumpster";
Constant TX_PS_50 = "east";
Array TX_L_50 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_50;
Constant TX_PS_484 = "ethereal pillar";
Array TX_L_484 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_484;
Constant TX_PS_38 = "facts";
Constant TX_PS_125 = "featureless hyperplane";
Array TX_L_125 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_125;
Constant TX_PS_102 = "field office area";
Constant TX_PS_138 = "field office chief's office";
Constant TX_PS_134 = "field office hallway";
Constant TX_PS_129 = "field office reception";
Constant TX_PS_252 = "filing cabinets";
Constant TX_PS_294 = "finding the drive before";
Constant TX_PS_207 = "flashing neon sign";
Constant TX_PS_271 = "flashlight";
Constant TX_PS_296 = "flattened boxes";
Constant TX_PS_93 = "floor";
Constant TX_PS_231 = "for a screwdriver";
Constant TX_PS_303 = "for the hex wrench";
Constant TX_PS_106 = "forth";
Array TX_L_106 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_106;
Constant TX_PS_110 = "fortheast";
Constant TX_PS_108 = "forthnorth";
Constant TX_PS_112 = "forthsouth";
Constant TX_PS_114 = "forthwest";
Constant TX_PS_182 = "front desk";
Constant TX_PS_99 = "generic quip";
Constant TX_PS_60 = "generic-truth";
Constant TX_PS_270 = "glass case";
Constant TX_PS_395 = "globe";
Constant TX_PS_380 = "green smartphone";
Constant TX_PS_268 = "groceries";
Constant TX_PS_387 = "hallway";
Constant TX_PS_148 = "hand over the thumb drive";
Constant TX_PS_204 = "handtruck";
Constant TX_PS_502 = "he";
Constant TX_PS_187 = "heating vent";
Constant TX_PS_507 = "her";
Constant TX_PS_508 = "hers";
Constant TX_PS_509 = "herself";
Constant TX_PS_189 = "hex wrench";
Constant TX_PS_81 = "hex-screws";
Constant TX_PS_503 = "him";
Constant TX_PS_505 = "himself";
Constant TX_PS_504 = "his";
Constant TX_PS_278 = "how are you";
Constant TX_PS_144 = "how to get home";
Constant TX_PS_5 = "in";
Constant TX_PS_54 = "inside";
Constant TX_PS_168 = "interstate";
Constant TX_PS_341 = "isolation booth";
Constant TX_PS_499 = "it";
Constant TX_PS_500 = "its";
Constant TX_PS_501 = "itself";
Constant TX_PS_406 = "juvenile sasquatch skull";
Constant TX_PS_75 = "key-is-lost";
Constant TX_PS_349 = "klimp's mobile phone";
Constant TX_PS_323 = "lake shore north of the park";
Constant TX_PS_274 = "laptop computer";
Constant TX_PS_381 = "laundromat back door";
Constant TX_PS_243 = "laundromat back room";
Constant TX_PS_246 = "laundromat basement";
Constant TX_PS_199 = "laundromat door";
Constant TX_PS_197 = "laundromat sign";
Constant TX_PS_202 = "laundromat";
Constant TX_PS_157 = "laundromat-region";
Constant TX_PS_247 = "lb-light";
Constant TX_PS_244 = "lbr-light";
Constant TX_PS_31 = "light sources";
Constant TX_PS_253 = "light switch";
Constant TX_PS_95 = "light-meter";
Constant TX_PS_375 = "little grey key";
Constant TX_PS_383 = "locking-back-door";
Constant TX_PS_266 = "lottery tickets";
Constant TX_PS_205 = "ls-light";
Constant TX_PS_399 = "mahogany side table";
Constant TX_PS_490 = "me";
Constant TX_PS_32 = "memories";
Constant TX_PS_9 = "men";
Constant TX_PS_491 = "mine";
Constant TX_PS_29 = "money cards";
Constant TX_PS_368 = "movie poster";
Constant TX_PS_493 = "my";
Constant TX_PS_492 = "myself";
Constant TX_PS_450 = "mysterious phone";
Constant TX_PS_124 = "mystic compass";
Constant TX_PS_485 = "next to";
Array TX_L_485 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_485;
Constant TX_PS_11 = "nonbinaries";
Constant TX_PS_478 = "none";
Array TX_L_478 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_478;
Constant TX_PS_217 = "north end of the strip mall parking lot";
Constant TX_PS_43 = "north";
Array TX_L_43 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_43;
Constant TX_PS_45 = "northeast";
Constant TX_PS_46 = "northwest";
Constant TX_PS_410 = "oddities";
Constant TX_PS_161 = "office";
Constant TX_PS_126 = "on";
Array TX_L_126 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_126;
Constant TX_PS_498 = "our";
Constant TX_PS_496 = "ours";
Constant TX_PS_497 = "ourselves";
Constant TX_PS_55 = "outside";
Constant TX_PS_209 = "pawn shop door";
Constant TX_PS_212 = "pawn-light";
Constant TX_PS_72 = "pawn-shop-dave";
Constant TX_PS_69 = "pawn-shop-screwdriver";
Constant TX_PS_8 = "people";
Constant TX_PS_39 = "phone numbers";
Constant TX_PS_28 = "phones";
Constant TX_PS_366 = "photo of Pluto";
Constant TX_PS_374 = "photo of softball team";
Constant TX_PS_22 = "player's holdalls";
Constant TX_PS_438 = "polished orange marble dodecahedron";
Constant TX_PS_414 = "prints";
Constant TX_PS_41 = "pronouns";
Constant TX_PS_15 = "pushbar doors";
Constant TX_PS_33 = "quips";
Constant TX_PS_272 = "red screwdriver";
Constant TX_PS_36 = "regions";
Constant TX_PS_96 = "room of choices";
Constant TX_PS_100 = "room of quips";
Constant TX_PS_227 = "rusty sign";
Constant TX_PS_232 = "screwdriver";
Constant TX_PS_78 = "screwdriver-in-laundromat";
Constant TX_PS_435 = "screws";
Constant TX_PS_178 = "seating area";
Constant TX_PS_459 = "see some suggestions for AMUSING things to do";
Constant TX_PS_506 = "she";
Constant TX_PS_184 = "shelves of office supplies";
Constant TX_PS_261 = "shop counter";
Constant TX_PS_18 = "shop-doors";
Constant TX_PS_159 = "south end of the strip mall parking lot";
Constant TX_PS_47 = "south";
Array TX_L_47 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_47;
Constant TX_PS_48 = "southeast";
Constant TX_PS_49 = "southwest";
Constant TX_PS_257 = "store clerk";
Constant TX_PS_267 = "store shelves";
Constant TX_PS_433 = "strange symbols";
Constant TX_PS_26 = "subjects";
Constant TX_PS_6 = "supporters";
Constant TX_PS_163 = "swamp";
Constant TX_PS_19 = "swipe doors";
Constant TX_PS_35 = "swipe locks";
Constant TX_PS_170 = "the front office";
Constant TX_PS_44 = "the";
Constant TX_PS_518 = "their";
Constant TX_PS_516 = "theirs";
Constant TX_PS_515 = "them";
Constant TX_PS_519 = "themself";
Constant TX_PS_517 = "themselves";
Constant TX_PS_514 = "they";
Constant TX_PS_42 = "third-person-personal-pronouns";
Constant TX_PS_308 = "throw out boxes";
Constant TX_PS_283 = "thumb drive";
Constant TX_PS_356 = "to borrow the lenses";
Constant TX_PS_353 = "to borrow the skull";
Constant TX_PS_304 = "to unlock the backdoor";
Constant TX_PS_447 = "to wait for the report";
Constant TX_PS_369 = "trivia competition award";
Constant TX_PS_14 = "two-sided doors";
Constant TX_PS_27 = "unenterable rooms";
Constant TX_PS_449 = "unknown voice";
Constant TX_PS_52 = "up";
Constant TX_PS_495 = "us";
Constant TX_PS_442 = "utility closet";
Constant TX_PS_21 = "vehicles";
Constant TX_PS_63 = "vent-screws";
Constant TX_PS_385 = "waiting-for-player";
Constant TX_PS_316 = "walking on";
Constant TX_PS_92 = "wall";
Constant TX_PS_494 = "we";
Constant TX_PS_58 = "weather";
Constant TX_PS_324 = "west end of the town's lake shore";
Constant TX_PS_51 = "west";
Array TX_L_51 --> CONSTANT_PACKED_TEXT_STORAGE TX_PS_51;
Constant TX_PS_293 = "white key";
Constant TX_PS_307 = "white metal door";
Constant TX_PS_276 = "wireless earbuds";
Constant TX_PS_10 = "women";
Constant TX_PS_510 = "you";
Constant TX_PS_512 = "your";
Constant TX_PS_511 = "yours";
Constant TX_PS_280 = "yourself";
Constant TX_PS_513 = "yourselves";

#ifndef p0_specification; Constant p0_specification = 0; #endif;
#ifndef p1_indefinite_appearance_tex; Constant p1_indefinite_appearance_tex = 0; #endif;
#ifndef p2_variable_initial_value; Constant p2_variable_initial_value = 0; #endif;
#ifndef list_together; Constant list_together = 0; #endif;
#ifndef short_name; Constant short_name = 0; #endif;
#ifndef plural; Constant plural = 0; #endif;
#ifndef article; Constant article = 0; #endif;
#ifndef description; Constant description = 0; #endif;
#ifndef map_region; Constant map_region = 0; #endif;
#ifndef initial; Constant initial = 0; #endif;
#ifndef p10_opposite; Constant p10_opposite = 0; #endif;
#ifndef door_to; Constant door_to = 0; #endif;
#ifndef capacity; Constant capacity = 0; #endif;
#ifndef with_key; Constant with_key = 0; #endif;
#ifndef p14_adaptive_text_viewpoint; Constant p14_adaptive_text_viewpoint = 0; #endif;
#ifndef p15_dark_description; Constant p15_dark_description = 0; #endif;
#ifndef p16_hearability; Constant p16_hearability = 0; #endif;
#ifndef p17_volume; Constant p17_volume = 0; #endif;
#ifndef p18_reception; Constant p18_reception = 0; #endif;
#ifndef p19_balance; Constant p19_balance = 0; #endif;
#ifndef p20_price; Constant p20_price = 0; #endif;
#ifndef p21_preposition; Constant p21_preposition = 0; #endif;
#ifndef p22_behavior_stack; Constant p22_behavior_stack = 0; #endif;
#ifndef p23_target_location; Constant p23_target_location = 0; #endif;
#ifndef p24_destination_name; Constant p24_destination_name = 0; #endif;
#ifndef p25_behind_description; Constant p25_behind_description = 0; #endif;
#ifndef p26_remembrances; Constant p26_remembrances = 0; #endif;
#ifndef p27_comment; Constant p27_comment = 0; #endif;
#ifndef p28_reply; Constant p28_reply = 0; #endif;
#ifndef p29_queue; Constant p29_queue = 0; #endif;
#ifndef p30_frontside; Constant p30_frontside = 0; #endif;
#ifndef p31_close_delay; Constant p31_close_delay = 0; #endif;
#ifndef p32_time_lock_delay; Constant p32_time_lock_delay = 0; #endif;
#ifndef p33_front_description; Constant p33_front_description = 0; #endif;
#ifndef p34_back_description; Constant p34_back_description = 0; #endif;
#ifndef p35_description_policy; Constant p35_description_policy = 0; #endif;
#ifndef p36_lock_countdown; Constant p36_lock_countdown = 0; #endif;
#ifndef p37_close_countdown; Constant p37_close_countdown = 0; #endif;
#ifndef p38_how_are_you_reply; Constant p38_how_are_you_reply = 0; #endif;
#ifndef most_recent_reference; Constant most_recent_reference = 0; #endif;
#ifndef p40_grammatical_person; Constant p40_grammatical_person = 0; #endif;
#ifndef p41_declensions; Constant p41_declensions = 0; #endif;
#ifndef third_singular_pronoun; Constant third_singular_pronoun = 0; #endif;
#ifndef p43_third_plural_pronoun; Constant p43_third_plural_pronoun = 0; #endif;
#ifndef p44_first_singular_pronoun; Constant p44_first_singular_pronoun = 0; #endif;
#ifndef p45_first_plural_pronoun; Constant p45_first_plural_pronoun = 0; #endif;
#ifndef p46_second_singular_pronoun; Constant p46_second_singular_pronoun = 0; #endif;
#ifndef p47_second_plural_pronoun; Constant p47_second_plural_pronoun = 0; #endif;
#ifndef p48_possessive; Constant p48_possessive = 0; #endif;
#ifndef p49_portrait; Constant p49_portrait = 0; #endif;
#ifndef pluralname; Constant pluralname = 0; #endif;
#ifndef proper; Constant proper = 0; #endif;
#ifndef ambigpluralname; Constant ambigpluralname = 0; #endif;
#ifndef privately_named; Constant privately_named = 0; #endif;
#ifndef light; Constant light = 0; #endif;
#ifndef visited; Constant visited = 0; #endif;
#ifndef light; Constant light = 0; #endif;
#ifndef edible; Constant edible = 0; #endif;
#ifndef static; Constant static = 0; #endif;
#ifndef scenery; Constant scenery = 0; #endif;
#ifndef clothing; Constant clothing = 0; #endif;
#ifndef pushable; Constant pushable = 0; #endif;
#ifndef moved; Constant moved = 0; #endif;
#ifndef concealed; Constant concealed = 0; #endif;
#ifndef workflag; Constant workflag = 0; #endif;
#ifndef mentioned; Constant mentioned = 0; #endif;
#ifndef enterable; Constant enterable = 0; #endif;
#ifndef transparent; Constant transparent = 0; #endif;
#ifndef open; Constant open = 0; #endif;
#ifndef openable; Constant openable = 0; #endif;
#ifndef lockable; Constant lockable = 0; #endif;
#ifndef locked; Constant locked = 0; #endif;
#ifndef neuter; Constant neuter = 0; #endif;
#ifndef male; Constant male = 0; #endif;
#ifndef female; Constant female = 0; #endif;
#ifndef nomale; Constant nomale = 0; #endif;
#ifndef on; Constant on = 0; #endif;
#ifndef p93_recurring; Constant p93_recurring = 0; #endif;
#ifndef p95_seen; Constant p95_seen = 0; #endif;
#ifndef p97_familiar; Constant p97_familiar = 0; #endif;
#ifndef p99_powered; Constant p99_powered = 0; #endif;
#ifndef p100_dimly_lit; Constant p100_dimly_lit = 0; #endif;
#ifndef p102_room_condition; Constant p102_room_condition = 0; #endif;
#ifndef p103_rainy; Constant p103_rainy = 0; #endif;
#ifndef p105_outdoor_adjacent; Constant p105_outdoor_adjacent = 0; #endif;
#ifndef p106_summary; Constant p106_summary = 0; #endif;
#ifndef p107_knowledge_relation_stor; Constant p107_knowledge_relation_stor = 0; #endif;
#ifndef p108_audible; Constant p108_audible = 0; #endif;
#ifndef p109_noisy; Constant p109_noisy = 0; #endif;
#ifndef p111_insistent; Constant p111_insistent = 0; #endif;
#ifndef p113_phone_condition; Constant p113_phone_condition = 0; #endif;
#ifndef p114_caller_id; Constant p114_caller_id = 0; #endif;
#ifndef p115_mobile; Constant p115_mobile = 0; #endif;
#ifndef p117_identifiable; Constant p117_identifiable = 0; #endif;
#ifndef p119_talking_on_relation_sto; Constant p119_talking_on_relation_sto = 0; #endif;
#ifndef p120_talking_with_relation_s; Constant p120_talking_with_relation_s = 0; #endif;
#ifndef p121_calling_to_relation_sto; Constant p121_calling_to_relation_sto = 0; #endif;
#ifndef p122_reaches_relation_storag; Constant p122_reaches_relation_storag = 0; #endif;
#ifndef p123_mc_enabled; Constant p123_mc_enabled = 0; #endif;
#ifndef p125_owner; Constant p125_owner = 0; #endif;
#ifndef p126_vendor; Constant p126_vendor = 0; #endif;
#ifndef p127_always_indefinite; Constant p127_always_indefinite = 0; #endif;
#ifndef p128_activated; Constant p128_activated = 0; #endif;
#ifndef p129_marked_for_special_list; Constant p129_marked_for_special_list = 0; #endif;
#ifndef p131_first_delimiter; Constant p131_first_delimiter = 0; #endif;
#ifndef p132_second_delimiter; Constant p132_second_delimiter = 0; #endif;
#ifndef p133_alternate_second_delimi; Constant p133_alternate_second_delimi = 0; #endif;
#ifndef p134_indefinite_name_phrase; Constant p134_indefinite_name_phrase = 0; #endif;
#ifndef p135_definite_name_phrase; Constant p135_definite_name_phrase = 0; #endif;
#ifndef p136_available; Constant p136_available = 0; #endif;
#ifndef p137_exhausted; Constant p137_exhausted = 0; #endif;
#ifndef p138_demoing_relation_storag; Constant p138_demoing_relation_storag = 0; #endif;
#ifndef p139_fluorescent; Constant p139_fluorescent = 0; #endif;
#ifndef p140_behindness_relation_sto; Constant p140_behindness_relation_sto = 0; #endif;
#ifndef p141_one_shot; Constant p141_one_shot = 0; #endif;
#ifndef p143_quip_condition; Constant p143_quip_condition = 0; #endif;
#ifndef p144_quip_condition_2; Constant p144_quip_condition_2 = 0; #endif;
#ifndef p145_universal; Constant p145_universal = 0; #endif;
#ifndef p146_always_available; Constant p146_always_available = 0; #endif;
#ifndef p147_quip_supplying_relation; Constant p147_quip_supplying_relation = 0; #endif;
#ifndef p148_following_relation_stor; Constant p148_following_relation_stor = 0; #endif;
#ifndef p149_exclusion_relation_stor; Constant p149_exclusion_relation_stor = 0; #endif;
#ifndef p150_mentioning_relation_sto; Constant p150_mentioning_relation_sto = 0; #endif;
#ifndef p151_stocking_relation_stora; Constant p151_stocking_relation_stora = 0; #endif;
#ifndef p152_hyperspatial; Constant p152_hyperspatial = 0; #endif;
#ifndef p153_front_locked; Constant p153_front_locked = 0; #endif;
#ifndef p154_back_locked; Constant p154_back_locked = 0; #endif;
#ifndef p155_front_openable; Constant p155_front_openable = 0; #endif;
#ifndef p156_back_openable; Constant p156_back_openable = 0; #endif;
#ifndef p157_front_closable; Constant p157_front_closable = 0; #endif;
#ifndef p158_back_closable; Constant p158_back_closable = 0; #endif;
#ifndef p159_front_locks_the_back; Constant p159_front_locks_the_back = 0; #endif;
#ifndef p160_front_locks_the_front; Constant p160_front_locks_the_front = 0; #endif;
#ifndef p161_back_locks_the_back; Constant p161_back_locks_the_back = 0; #endif;
#ifndef p162_back_locks_the_front; Constant p162_back_locks_the_front = 0; #endif;
#ifndef p163_close_lock_the_back; Constant p163_close_lock_the_back = 0; #endif;
#ifndef p164_close_lock_the_front; Constant p164_close_lock_the_front = 0; #endif;
#ifndef p165_autolock_the_back; Constant p165_autolock_the_back = 0; #endif;
#ifndef p166_autolock_the_front; Constant p166_autolock_the_front = 0; #endif;
#ifndef p167_auto_closable; Constant p167_auto_closable = 0; #endif;
#ifndef p168_time_locked; Constant p168_time_locked = 0; #endif;
#ifndef p169_swipable; Constant p169_swipable = 0; #endif;
#ifndef vector; Constant vector = 0; #endif;
#ifndef room_index; Constant room_index = 0; #endif;
#ifndef door_dir; Constant door_dir = 0; #endif;
#ifndef door_to; Constant door_to = 0; #endif;
#ifndef found_in; Constant found_in = 0; #endif;
#ifndef absent; Constant absent = 0; #endif;
#ifndef cap_short_name; Constant cap_short_name = 0; #endif;
#ifndef mark_as_room; Constant mark_as_room = 0; #endif;
#ifndef mark_as_thing; Constant mark_as_thing = 0; #endif;
#ifndef component_parent; Constant component_parent = 0; #endif;
#ifndef component_child; Constant component_child = 0; #endif;
#ifndef component_sibling; Constant component_sibling = 0; #endif;
#ifndef regional_found_in; Constant regional_found_in = 0; #endif;
#ifndef IK1_Count; Constant IK1_Count = 0; #endif;
#ifndef IK1_Link; Constant IK1_Link = 0; #endif;
#ifndef IK2_Count; Constant IK2_Count = 0; #endif;
#ifndef IK2_Link; Constant IK2_Link = 0; #endif;
#ifndef IK3_Count; Constant IK3_Count = 0; #endif;
#ifndef IK3_Link; Constant IK3_Link = 0; #endif;
#ifndef IK4_Count; Constant IK4_Count = 0; #endif;
#ifndef IK4_Link; Constant IK4_Link = 0; #endif;
#ifndef IK5_Count; Constant IK5_Count = 0; #endif;
#ifndef IK5_Link; Constant IK5_Link = 0; #endif;
#ifndef IK6_Count; Constant IK6_Count = 0; #endif;
#ifndef IK6_Link; Constant IK6_Link = 0; #endif;
#ifndef IK7_Count; Constant IK7_Count = 0; #endif;
#ifndef IK7_Link; Constant IK7_Link = 0; #endif;
#ifndef IK8_Count; Constant IK8_Count = 0; #endif;
#ifndef IK8_Link; Constant IK8_Link = 0; #endif;
#ifndef IK9_Count; Constant IK9_Count = 0; #endif;
#ifndef IK9_Link; Constant IK9_Link = 0; #endif;
#ifndef IK10_Count; Constant IK10_Count = 0; #endif;
#ifndef IK10_Link; Constant IK10_Link = 0; #endif;
#ifndef IK11_Count; Constant IK11_Count = 0; #endif;
#ifndef IK11_Link; Constant IK11_Link = 0; #endif;
#ifndef IK12_Count; Constant IK12_Count = 0; #endif;
#ifndef IK12_Link; Constant IK12_Link = 0; #endif;
#ifndef IK13_Count; Constant IK13_Count = 0; #endif;
#ifndef IK13_Link; Constant IK13_Link = 0; #endif;
#ifndef IK14_Count; Constant IK14_Count = 0; #endif;
#ifndef IK14_Link; Constant IK14_Link = 0; #endif;
#ifndef IK15_Count; Constant IK15_Count = 0; #endif;
#ifndef IK15_Link; Constant IK15_Link = 0; #endif;
#ifndef IK16_Count; Constant IK16_Count = 0; #endif;
#ifndef IK16_Link; Constant IK16_Link = 0; #endif;
#ifndef IK17_Count; Constant IK17_Count = 0; #endif;
#ifndef IK17_Link; Constant IK17_Link = 0; #endif;
#ifndef IK18_Count; Constant IK18_Count = 0; #endif;
#ifndef IK18_Link; Constant IK18_Link = 0; #endif;
#ifndef IK19_Count; Constant IK19_Count = 0; #endif;
#ifndef IK19_Link; Constant IK19_Link = 0; #endif;
#ifndef IK20_Count; Constant IK20_Count = 0; #endif;
#ifndef IK20_Link; Constant IK20_Link = 0; #endif;
#ifndef IK21_Count; Constant IK21_Count = 0; #endif;
#ifndef IK21_Link; Constant IK21_Link = 0; #endif;
#ifndef IK22_Count; Constant IK22_Count = 0; #endif;
#ifndef IK22_Link; Constant IK22_Link = 0; #endif;
#ifndef IK23_Count; Constant IK23_Count = 0; #endif;
#ifndef IK23_Link; Constant IK23_Link = 0; #endif;
#ifndef IK24_Count; Constant IK24_Count = 0; #endif;
#ifndef IK24_Link; Constant IK24_Link = 0; #endif;
#ifndef IK25_Count; Constant IK25_Count = 0; #endif;
#ifndef IK25_Link; Constant IK25_Link = 0; #endif;
#ifndef IK26_Count; Constant IK26_Count = 0; #endif;
#ifndef IK26_Link; Constant IK26_Link = 0; #endif;
#ifndef IK27_Count; Constant IK27_Count = 0; #endif;
#ifndef IK27_Link; Constant IK27_Link = 0; #endif;
#ifndef IK28_Count; Constant IK28_Count = 0; #endif;
#ifndef IK28_Link; Constant IK28_Link = 0; #endif;
#ifndef IK29_Count; Constant IK29_Count = 0; #endif;
#ifndef IK29_Link; Constant IK29_Link = 0; #endif;
#ifndef IK30_Count; Constant IK30_Count = 0; #endif;
#ifndef IK30_Link; Constant IK30_Link = 0; #endif;
#ifndef IK31_Count; Constant IK31_Count = 0; #endif;
#ifndef IK31_Link; Constant IK31_Link = 0; #endif;
#ifndef IK32_Count; Constant IK32_Count = 0; #endif;
#ifndef IK32_Link; Constant IK32_Link = 0; #endif;
#ifndef IK33_Count; Constant IK33_Count = 0; #endif;
#ifndef IK33_Link; Constant IK33_Link = 0; #endif;
#ifndef IK34_Count; Constant IK34_Count = 0; #endif;
#ifndef IK34_Link; Constant IK34_Link = 0; #endif;
#ifndef IK35_Count; Constant IK35_Count = 0; #endif;
#ifndef IK35_Link; Constant IK35_Link = 0; #endif;
#ifndef IK36_Count; Constant IK36_Count = 0; #endif;
#ifndef IK36_Link; Constant IK36_Link = 0; #endif;
#ifndef IK37_Count; Constant IK37_Count = 0; #endif;
#ifndef IK37_Link; Constant IK37_Link = 0; #endif;
#ifndef KD_Count; Constant KD_Count = 0; #endif;
#ifndef name; Constant name = 0; #endif;
#ifndef parse_name; Constant parse_name = 0; #endif;
#ifndef action_bitmap; Constant action_bitmap = 0; #endif;

#IFNDEF cap_short_name;
Constant cap_short_name = short_name;
#ENDIF;
Array I7_ST_say_one_of --> 7;
Array I7_ST_say_one_flag --> 7;
Array I7_ST_say_first_time --> 4;

Array Runtime_Quotations_Displayed --> 1;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Block Values
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifdef TARGET_ZCODE;
Constant MEMORY_HEAP_SIZE = 8192;
#ifnot;
Constant MEMORY_HEAP_SIZE = 32768;
#endif;

Array Closure_0 -->
    KD26_phrase_real_number_to_rea ! phrase real number -> real number
    REAL_NUMBER_TY_Abs ! routine to call
    "abs function" ! name
;
Array Closure_1 -->
    KD26_phrase_real_number_to_rea ! phrase real number -> real number
    REAL_NUMBER_TY_Root ! routine to call
    "root function" ! name
;
Array Closure_2 -->
    KD26_phrase_real_number_to_rea ! phrase real number -> real number
    PHR_414_r76  ! routine to call
    "rsqr function" ! name
;
Array Closure_3 -->
    KD26_phrase_real_number_to_rea ! phrase real number -> real number
    REAL_NUMBER_TY_Ceiling ! routine to call
    "ceiling function" ! name
;
Array Closure_4 -->
    KD26_phrase_real_number_to_rea ! phrase real number -> real number
    REAL_NUMBER_TY_Floor ! routine to call
    "floor function" ! name
;
Array Closure_5 -->
    KD27_phrase_real_number_to_num ! phrase real number -> number
    REAL_NUMBER_TY_to_NUMBER_TY ! routine to call
    "int function" ! name
;
Array Closure_6 -->
    KD26_phrase_real_number_to_rea ! phrase real number -> real number
    REAL_NUMBER_TY_Log ! routine to call
    "log function" ! name
;
Array Closure_7 -->
    KD26_phrase_real_number_to_rea ! phrase real number -> real number
    REAL_NUMBER_TY_Exp ! routine to call
    "exp function" ! name
;
Array Closure_8 -->
    KD26_phrase_real_number_to_rea ! phrase real number -> real number
    REAL_NUMBER_TY_Sin ! routine to call
    "sin function" ! name
;
Array Closure_9 -->
    KD26_phrase_real_number_to_rea ! phrase real number -> real number
    REAL_NUMBER_TY_Cos ! routine to call
    "cos function" ! name
;
Array Closure_10 -->
    KD26_phrase_real_number_to_rea ! phrase real number -> real number
    REAL_NUMBER_TY_Tan ! routine to call
    "tan function" ! name
;
Array Closure_11 -->
    KD26_phrase_real_number_to_rea ! phrase real number -> real number
    REAL_NUMBER_TY_Arcsin ! routine to call
    "arcsin function" ! name
;
Array Closure_12 -->
    KD26_phrase_real_number_to_rea ! phrase real number -> real number
    REAL_NUMBER_TY_Arccos ! routine to call
    "arccos function" ! name
;
Array Closure_13 -->
    KD26_phrase_real_number_to_rea ! phrase real number -> real number
    REAL_NUMBER_TY_Arctan ! routine to call
    "arctan function" ! name
;
Array Closure_14 -->
    KD26_phrase_real_number_to_rea ! phrase real number -> real number
    REAL_NUMBER_TY_Sinh ! routine to call
    "sinh function" ! name
;
Array Closure_15 -->
    KD26_phrase_real_number_to_rea ! phrase real number -> real number
    REAL_NUMBER_TY_Cosh ! routine to call
    "cosh function" ! name
;
Array Closure_16 -->
    KD26_phrase_real_number_to_rea ! phrase real number -> real number
    REAL_NUMBER_TY_Tanh ! routine to call
    "tanh function" ! name
;
Array Closure_17 -->
    KD26_phrase_real_number_to_rea ! phrase real number -> real number
    PHR_432_r77  ! routine to call
    "arcsinh function" ! name
;
Array Closure_18 -->
    KD26_phrase_real_number_to_rea ! phrase real number -> real number
    PHR_433_r78  ! routine to call
    "arccosh function" ! name
;
Array Closure_19 -->
    KD26_phrase_real_number_to_rea ! phrase real number -> real number
    PHR_434_r79  ! routine to call
    "arctanh function" ! name
;
Array Closure_20 -->
    KD28_phrase_nothing_to_number ! phrase nothing -> number
    PHR_1291_r0  ! routine to call
    "the handle glk event rule" ! name
;

Array KD0_list_of_memories --> ! list of memories
    LIST_OF_TY 1 10;
Array Default_Value_0 -->
(85721088) LIST_OF_TY MAX_POSITIVE_NUMBER 10 0;
Array KD1_list_of_quips --> ! list of quips
    LIST_OF_TY 1 10;
Array Default_Value_1 -->
(85721088) LIST_OF_TY MAX_POSITIVE_NUMBER 10 0;
Array KD2_list_of_texts --> ! list of texts
    LIST_OF_TY 1 TEXT_TY;
Array Default_Value_2 -->
(85721088) LIST_OF_TY MAX_POSITIVE_NUMBER TEXT_TY 0;
Array KD3_list_of_things --> ! list of things
    LIST_OF_TY 1 10;
Array Default_Value_3 -->
(85721088) LIST_OF_TY MAX_POSITIVE_NUMBER 10 0;
Array KD4_list_of_figure_names --> ! list of figure names
    LIST_OF_TY 1 FIGURE_NAME_TY;
Array Default_Value_4 -->
(85721088) LIST_OF_TY MAX_POSITIVE_NUMBER FIGURE_NAME_TY 0;
Array KD5_rule --> ! rule
    RULE_TY 2 ACTION_NAME_TY NIL_TY;
Array KD6_activity --> ! activity
    ACTIVITY_TY 1 NIL_TY;
Array KD7_list_of_directions --> ! list of directions
    LIST_OF_TY 1 10;
Array Default_Value_7 -->
(85721088) LIST_OF_TY MAX_POSITIVE_NUMBER 10 0;
Array KD8_list_of_people --> ! list of people
    LIST_OF_TY 1 10;
Array KD9_list_of_numbers --> ! list of numbers
    LIST_OF_TY 1 NUMBER_TY;
Array Default_Value_9 -->
(85721088) LIST_OF_TY MAX_POSITIVE_NUMBER NUMBER_TY 0;
Array KD10_list_of_money_cards --> ! list of money cards
    LIST_OF_TY 1 10;
Array KD11_list_of_objects --> ! list of objects
    LIST_OF_TY 1 OBJECT_TY;
Array Default_Value_11 -->
(85721088) LIST_OF_TY MAX_POSITIVE_NUMBER OBJECT_TY 0;
Array KD12_list_of_choices --> ! list of choices
    LIST_OF_TY 1 10;
Array KD13_relation_of_values --> ! relation of values
    RELATION_TY 2 VALUE_TY VALUE_TY;
Array KD14_relation_of_objects --> ! relation of objects
    RELATION_TY 2 OBJECT_TY OBJECT_TY;
Array KD15_relation_of_supporters_to --> ! relation of supporters to things
    RELATION_TY 2 10 10;
Array KD16_relation_of_things --> ! relation of things
    RELATION_TY 2 10 10;
Array KD17_relation_of_people_to_thi --> ! relation of people to things
    RELATION_TY 2 10 10;
Array KD18_relation_of_rooms_to_door --> ! relation of rooms to doors
    RELATION_TY 2 10 10;
Array KD19_relation_of_people_to_fac --> ! relation of people to facts
    RELATION_TY 2 10 10;
Array KD20_relation_of_people_to_pho --> ! relation of people to phones
    RELATION_TY 2 10 10;
Array KD21_relation_of_people --> ! relation of people
    RELATION_TY 2 10 10;
Array KD22_relation_of_phone_numbers --> ! relation of phone numbers to phones
    RELATION_TY 2 10 10;
Array KD23_relation_of_choices_to_th --> ! relation of choices to things
    RELATION_TY 2 10 10;
Array KD24_relation_of_quips_to_thin --> ! relation of quips to things
    RELATION_TY 2 10 10;
Array KD25_relation_of_quips --> ! relation of quips
    RELATION_TY 2 10 10;
Array KD26_phrase_real_number_to_rea --> ! phrase real number -> real number
    PHRASE_TY 2    REAL_NUMBER_TY;
Array KD27_phrase_real_number_to_num --> ! phrase real number -> number
    PHRASE_TY 2    NUMBER_TY;
Array KD28_phrase_nothing_to_number --> ! phrase nothing -> number
    PHRASE_TY 1    NUMBER_TY;
[ DefaultValueFinder 
    K ! Implied call parameter
    ;
    if (K == KD0_list_of_memories) return Default_Value_0;
    if (K == KD1_list_of_quips) return Default_Value_1;
    if (K == KD2_list_of_texts) return Default_Value_2;
    if (K == KD3_list_of_things) return Default_Value_3;
    if (K == KD4_list_of_figure_names) return Default_Value_4;
    if (K == KD7_list_of_directions) return Default_Value_7;
    if (K == KD9_list_of_numbers) return Default_Value_9;
    if (K == KD11_list_of_objects) return Default_Value_11;
    return 0;
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Blocks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant BLK_HEADER_N = 0;
Constant BLK_HEADER_FLAGS = 1;
Constant BLK_FLAG_MULTIPLE = $$00000001;
Constant BLK_FLAG_16_BIT   = $$00000010;
Constant BLK_FLAG_WORD     = $$00000100;
Constant BLK_FLAG_RESIDENT = $$00001000;
Constant BLK_FLAG_TRUNCMULT = $$00010000;
Constant BLK_HEADER_KOV = 1;
Constant BLK_HEADER_RCOUNT = 2;

Constant BLK_DATA_OFFSET = 3*WORDSIZE;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Multiple Blocks
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant BLK_DATA_MULTI_OFFSET = BLK_DATA_OFFSET + 2*WORDSIZE;
Constant BLK_NEXT 3;
Constant BLK_PREV 4;

! Constant BLKVALUE_TRACE = 1; ! Uncomment this for debugging purposes


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: The Heap
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array Flex_Heap -> MEMORY_HEAP_SIZE + 16; ! Plus 16 to allow room for head-free-block


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Initialisation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ HeapInitialise n bsize blk2;
	blk2 = Flex_Heap + 16;
	Flex_Heap->BLK_HEADER_N = 4;
	Flex_Heap-->BLK_HEADER_KOV = 0;
	Flex_Heap-->BLK_HEADER_RCOUNT = MAX_POSITIVE_NUMBER;
	Flex_Heap->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	Flex_Heap-->BLK_NEXT = blk2;
	Flex_Heap-->BLK_PREV = NULL;
	for (bsize=1: bsize < MEMORY_HEAP_SIZE: bsize=bsize*2) n++;
	blk2->BLK_HEADER_N = n;
	blk2-->BLK_HEADER_KOV = 0;
	blk2-->BLK_HEADER_RCOUNT = 0;
	blk2->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	blk2-->BLK_NEXT = NULL;
	blk2-->BLK_PREV = Flex_Heap;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Net Free Space
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ HeapNetFreeSpace multiple txb asize;
	for (txb=Flex_Heap-->BLK_NEXT: txb~=NULL: txb=txb-->BLK_NEXT) {
		asize = asize + FlexSize(txb);
		if (multiple) asize = asize - BLK_DATA_MULTI_OFFSET;
		else asize = asize - BLK_DATA_OFFSET;
	}
	return asize;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Make Space
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant SMALLEST_BLK_WORTH_ALLOCATING = 12; ! i.e. 2^12 = 4096 bytes

[ HeapMakeSpace size multiple  newblocksize newblock B n;
	for (::) {
		if (multiple) {
			if (HeapNetFreeSpace(multiple) >= size) rtrue;
		} else {
			if (HeapLargestFreeBlock(0) >= size) rtrue;
		}
		newblocksize = 1;
		for (n=0: (n<SMALLEST_BLK_WORTH_ALLOCATING) || (newblocksize<size): n++)
			newblocksize = newblocksize*2;
		while (newblocksize < size+16) newblocksize = newblocksize*2;
		newblock = VM_AllocateMemory(newblocksize);
		if (newblock == 0) rfalse;
		newblock->BLK_HEADER_N = n;
		newblock-->BLK_HEADER_KOV = 0;
		newblock-->BLK_HEADER_RCOUNT = 0;
		newblock->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
		newblock-->BLK_NEXT = NULL;
		newblock-->BLK_PREV = NULL;
		for (B = Flex_Heap-->BLK_NEXT:B ~= NULL:B = B-->BLK_NEXT)
			if (B-->BLK_NEXT == NULL) {
				B-->BLK_NEXT = newblock;
				newblock-->BLK_PREV = B;
				jump Linked;
			}
		Flex_Heap-->BLK_NEXT = newblock;
		newblock-->BLK_PREV = Flex_Heap;
		.Linked; ;
		#ifdef BLKVALUE_TRACE;
		print "Increasing heap to free space map: "; FlexDebugDecomposition(Flex_Heap, 0);
		#endif;
	}
	rtrue;
];

[ HeapLargestFreeBlock multiple txb asize best;
	best = 0;
	for (txb=Flex_Heap-->BLK_NEXT: txb~=NULL: txb=txb-->BLK_NEXT) {
		asize = FlexSize(txb);
		if (multiple) asize = asize - BLK_DATA_MULTI_OFFSET;
		else asize = asize - BLK_DATA_OFFSET;
		if (asize > best) best = asize;
	}
	return best;
];

[ HeapDebug full;
	if (full) {
		print "Managing a heap of initially ", MEMORY_HEAP_SIZE+16, " bytes.^";
		print HeapNetFreeSpace(false), " bytes currently free.^";
		print "Free space decomposition: "; FlexDebugDecomposition(Flex_Heap);
		print "Free space map: "; FlexDebug(Flex_Heap);
	} else {
		print HeapNetFreeSpace(false), " of ", MEMORY_HEAP_SIZE+16, " bytes free.^";
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Block Allocation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexAllocate size kov flags
	dsize n m free_block min_m max_m smallest_oversized_block secondhalf i hsize head tail;
	
	if (HeapMakeSpace(size, flags & BLK_FLAG_MULTIPLE) == false) FlexError("ran out");

	! Calculate the header size for a block of this KOV
	if (flags & BLK_FLAG_MULTIPLE) hsize = BLK_DATA_MULTI_OFFSET;
	else hsize = BLK_DATA_OFFSET;
	! Calculate the data size
	n=0; for (dsize=1: ((dsize < hsize+size) || (n<3+(WORDSIZE/2))): dsize=dsize*2) n++;

	! Seek a free block closest to the correct size, but starting from the
	! block after the fixed head-free-block, which we can't touch
	min_m = 10000; max_m = 0;
	for (free_block = Flex_Heap-->BLK_NEXT:
		free_block ~= NULL:
		free_block = free_block-->BLK_NEXT) {
		m = free_block->BLK_HEADER_N;
		! Current block the ideal size
		if (m == n) jump CorrectSizeFound;
		! Current block too large: find the smallest which is larger than needed
		if (m > n) {
			if (min_m > m) {
				min_m = m;
				smallest_oversized_block = free_block;
			}
		}
		! Current block too small: find the largest which is smaller than needed
		if (m < n) {
			if (max_m < m) {
				max_m = m;
			}
		}
	}

	if (min_m == 10000) {
		! Case I: No block is large enough to hold the entire size
		if (flags & BLK_FLAG_MULTIPLE == 0) FlexError("too fragmented");
		! Set dsize to the size in bytes if the largest block available
		for (dsize=1: max_m > 0: dsize=dsize*2) max_m--;
		! Split as a head (dsize-hsize), which we can be sure fits into one block,
		! plus a tail (size-(dsize-hsize), which might be a list of blocks
		head = FlexAllocate(dsize-hsize, kov, flags);
		if (head == 0) FlexError("for head block not available");
		tail = FlexAllocate(size-(dsize-hsize), kov, flags);
		if (tail == 0) FlexError("for tail block not available");
		head-->BLK_NEXT = tail;
		tail-->BLK_PREV = head;
		return head;
	}

	! Case II: No block is the right size, but some exist which are too big
	! Set dsize to the size in bytes of the smallest oversized block
	for (dsize=1,m=1: m<=min_m: dsize=dsize*2) m++;
	free_block = smallest_oversized_block;
	while (min_m > n) {
		! Repeatedly halve free_block at the front until the two smallest
		! fragments left are the correct size: then take the frontmost
		dsize = dsize/2;
		! print "Halving size to ", dsize, "^";
		secondhalf = free_block + dsize;
		secondhalf-->BLK_NEXT = free_block-->BLK_NEXT;
		if (secondhalf-->BLK_NEXT ~= NULL)
			(secondhalf-->BLK_NEXT)-->BLK_PREV = secondhalf;
		secondhalf-->BLK_PREV = free_block;
		free_block-->BLK_NEXT = secondhalf;
		free_block->BLK_HEADER_N = (free_block->BLK_HEADER_N) - 1;
		secondhalf->BLK_HEADER_N = free_block->BLK_HEADER_N;
		secondhalf-->BLK_HEADER_KOV = free_block-->BLK_HEADER_KOV;
		secondhalf-->BLK_HEADER_RCOUNT = 0;
		secondhalf->BLK_HEADER_FLAGS = free_block->BLK_HEADER_FLAGS;
		min_m--;
	}
	
	! Once that is done, free_block points to a block which is exactly the
	! right size, so we can fall into...
	
	! Case III: There is a free block which has the correct size.
	.CorrectSizeFound;
	! Delete the free block from the double linked list of free blocks: note
	! that it cannot be the head of this list, which is fixed
	if (free_block-->BLK_NEXT == NULL) {
		! We remove final block, so previous is now final
		(free_block-->BLK_PREV)-->BLK_NEXT = NULL;
	} else {
		! We remove a middle block, so join previous to next
		(free_block-->BLK_PREV)-->BLK_NEXT = free_block-->BLK_NEXT;
		(free_block-->BLK_NEXT)-->BLK_PREV = free_block-->BLK_PREV;
	}
	free_block-->BLK_HEADER_KOV = KindAtomic(kov);
	free_block-->BLK_HEADER_RCOUNT = 1;
	free_block->BLK_HEADER_FLAGS = flags;
	if (flags & BLK_FLAG_MULTIPLE) {
		free_block-->BLK_NEXT = NULL;
		free_block-->BLK_PREV = NULL;
	}
	
	! Zero out the data bytes in the memory allocated
	for (i=hsize:i<dsize:i++) free_block->i=0;
	return free_block;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Errors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexError reason;
	print "*** Memory ", (string) reason, " ***^";
	RunTimeProblem(RTP_HEAPERROR);
	@quit;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Merging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexMergeInternal block first last pv nx;
	first = block; last = block;
	while (last-->BLK_NEXT == last+FlexSize(last))
		last = last-->BLK_NEXT;
	while ((first-->BLK_PREV + FlexSize(first-->BLK_PREV) == first) &&
		(first-->BLK_PREV ~= Flex_Heap))
		first = first-->BLK_PREV;
	pv = first-->BLK_PREV;
	nx = last-->BLK_NEXT;
	#ifdef BLKVALUE_TRACE;
	print "Merging: "; FlexDebugDecomposition(pv-->BLK_NEXT, nx); print "^";
	#endif;
	if (FlexRecutInternal(first, last)) {
		#ifdef BLKVALUE_TRACE;
		print " --> "; FlexDebugDecomposition(pv-->BLK_NEXT, nx); print "^";
		#endif;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Recutting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexRecutInternal first last tsize backsize mfrom mto bnext backend n dsize fine_so_far;
	if (first == last) rfalse;
	mfrom = first; mto = last + FlexSize(last);
	bnext = last-->BLK_NEXT;
	fine_so_far = true;
	for (:mto>mfrom: mto = mto - backsize) {
		for (n=0, backsize=1: backsize*2 <= mto-mfrom: n++) backsize=backsize*2;
		if ((fine_so_far) && (backsize == FlexSize(last))) {
			bnext = last; last = last-->BLK_PREV;
			bnext-->BLK_PREV = last;
			last-->BLK_NEXT = bnext;
			continue;
		}
		fine_so_far = false; ! From this point, "last" is meaningless
		backend = mto - backsize;
		backend->BLK_HEADER_N = n;
		backend-->BLK_HEADER_KOV = 0;
		backend-->BLK_HEADER_RCOUNT = 0;
		backend->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
		backend-->BLK_NEXT = bnext;
		if (bnext ~= NULL) {
			bnext-->BLK_PREV = backend;
			bnext = backend;
		}
	}
	if (fine_so_far) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Deallocation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexFree block fromtxb ptxb;
	if (block == 0) return;
	if ((block->BLK_HEADER_FLAGS) & BLK_FLAG_RESIDENT) return;
	if ((block->BLK_HEADER_N) & $80) return; ! not a flexible block at all
	if ((block->BLK_HEADER_FLAGS) & BLK_FLAG_MULTIPLE) {
		if (block-->BLK_PREV ~= NULL) (block-->BLK_PREV)-->BLK_NEXT = NULL;
		fromtxb = block;
		for (:(block-->BLK_NEXT)~=NULL:block = block-->BLK_NEXT) ;
		while (block ~= fromtxb) {
			ptxb = block-->BLK_PREV; FlexFreeSingleBlockInternal(block); block = ptxb;
		}
	}
	FlexFreeSingleBlockInternal(block);
];

[ FlexFreeSingleBlockInternal block free nx;
	block-->BLK_HEADER_KOV = 0;
	block-->BLK_HEADER_RCOUNT = 0;
	block->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	for (free = Flex_Heap:free ~= NULL:free = free-->BLK_NEXT) {
		nx = free-->BLK_NEXT;
		if (nx == NULL) {
			free-->BLK_NEXT = block;
			block-->BLK_PREV = free;
			block-->BLK_NEXT = NULL;
			FlexMergeInternal(block);
			return;
		}
		if (UnsignedCompare(nx, block) == 1) {
			free-->BLK_NEXT = block;
			block-->BLK_PREV = free;
			block-->BLK_NEXT = nx;
			nx-->BLK_PREV = block;
			FlexMergeInternal(block);
			return;
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Resizing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexResize block req newsize dsize newblk kov n i otxb flags;
	if (block == 0) FlexError("failed resizing null block");
	kov = block-->BLK_HEADER_KOV;
	flags = block->BLK_HEADER_FLAGS;
	if (flags & BLK_FLAG_MULTIPLE == 0) FlexError("failed resizing inextensible block");
	otxb = block;
	newsize = req;
	for (:: block = block-->BLK_NEXT) {
		n = block->BLK_HEADER_N;
		for (dsize=1: n>0: n--) dsize = dsize*2;
		i = dsize - BLK_DATA_MULTI_OFFSET;
		newsize = newsize - i;
		if (newsize > 0) {
			if (block-->BLK_NEXT ~= NULL) continue;
			newblk = FlexAllocate(newsize, kov, flags);
			if (newblk == 0) rfalse;
			block-->BLK_NEXT = newblk;
			newblk-->BLK_PREV = block;
			return;
		}
		if (block-->BLK_NEXT ~= NULL) {
			FlexFree(block-->BLK_NEXT);
			block-->BLK_NEXT = NULL;
		}
		return;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Block Size
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexSize txb bsize n; ! Size of an individual block, including header
	if (txb == 0) return 0;
	for (bsize=1: n<txb->BLK_HEADER_N: bsize=bsize*2) n++;
	return bsize;
];

[ FlexTotalSize txb size_in_bytes; ! Combined size of multiple-blocks for a value
	if (txb == 0) return 0;
	if ((txb->BLK_HEADER_FLAGS) & BLK_FLAG_MULTIPLE == 0)
		return FlexSize(txb) - BLK_DATA_OFFSET;
	for (:txb~=NULL:txb=txb-->BLK_NEXT) {
		size_in_bytes = size_in_bytes + FlexSize(txb) - BLK_DATA_MULTI_OFFSET;
	}
	return size_in_bytes;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Flex.i6t: Debugging Routines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ FlexDebug txb n k i bsize tot dtot kov;
	if (txb == 0) "Block never created.";
	kov = txb-->BLK_HEADER_KOV;
	print "Block ", txb, " (kov ", kov, "): ";
	for (:txb~=NULL:txb = txb-->BLK_NEXT) {
		if (k++ == 100) " ... and so on.";
		if (txb-->BLK_HEADER_KOV ~= kov)
			print "*Wrong kov=", txb-->BLK_HEADER_KOV, "* ";
		n = txb->BLK_HEADER_N;
		for (bsize=1:n>0:n--) bsize=bsize*2;
		i = bsize - BLK_DATA_OFFSET;
		dtot = dtot+i;
		tot = tot+bsize;
		print txb, "(", bsize, ") > ";
	}
	print dtot, " data in ", tot, " bytes^";
];

[ FlexDebugDecomposition from to txb pf;
	if (to==0) to = NULL;
	for (txb=from:(txb~=to) && (txb~=NULL):txb=txb-->BLK_NEXT) {
		if (pf) print "+";
		print FlexSize(txb);
		pf = true;
	}
	print "^";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Overview
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RC_INFINITY = MAX_POSITIVE_NUMBER;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Short Block Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant BLK_BVBITMAP           = $ff;

Constant BLK_BVBITMAP_LONGBLOCK = $10; ! Word 1 of SB is pointer to LB
Constant BLK_BVBITMAP_TEXT      = $20; ! BV holds a TEXT_TY value
Constant BLK_BVBITMAP_CONSTANT  = $40; ! BV holds a TEXT_TY value

#IFTRUE WORDSIZE == 4;
Constant BLK_BVBITMAP_LONGBLOCKMASK = $ffffff10;
Constant BLK_BVBITMAP_TEXTMASK      = $ffffff20;
Constant BLK_BVBITMAP_CONSTANTMASK  = $ffffff40;
#IFNOT;
Constant BLK_BVBITMAP_LONGBLOCKMASK = $ff10;
Constant BLK_BVBITMAP_TEXTMASK      = $ff20;
Constant BLK_BVBITMAP_CONSTANTMASK  = $ff40;
#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Long Block Access
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueGetLongBlock bv o;
	if (bv) {
		o = bv-->0;
		if (o == 0) return bv + WORDSIZE;
		if (o & BLK_BVBITMAP == o) {
			if (o & BLK_BVBITMAP_LONGBLOCK) return bv-->1;
			return 0;
		}
		return o;
	}
	return bv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Weak Kind
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueWeakKind bv o;
	if (bv) {
		o = bv-->0;
		if (o == 0) return bv-->(BLK_HEADER_KOV+1);
		if (o & BLK_BVBITMAP == o) {
			if (o & BLK_BVBITMAP_TEXT) return TEXT_TY;
			o = bv-->1;
		}
		return o-->BLK_HEADER_KOV;
	}
	return NIL_TY;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Reference counting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueGetRefCountPrimitive bv long_block;
	long_block = BlkValueGetLongBlock(bv);
	if (long_block) return long_block-->BLK_HEADER_RCOUNT;
	return RC_INFINITY;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Changing Reference Counts
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueIncRefCountPrimitive bv long_block refc;
	long_block = BlkValueGetLongBlock(bv);
	if (long_block) {
		refc = long_block-->BLK_HEADER_RCOUNT;
		if (refc < RC_INFINITY) long_block-->BLK_HEADER_RCOUNT = refc + 1;
	}
];

[ BlkValueDecRefCountPrimitive bv long_block refc;
	long_block = BlkValueGetLongBlock(bv);
	if (long_block) {
		refc = long_block-->BLK_HEADER_RCOUNT;
		if (refc < RC_INFINITY) {
			refc--;
			if (refc < 0) BlkValueError("reference count negative");
			long_block-->BLK_HEADER_RCOUNT = refc;
		}
		return refc;
	}
	return RC_INFINITY;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Long Block Capacity
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueLBCapacity bv  long_block array_size_in_bytes entry_size_in_bytes flags;
	long_block = BlkValueGetLongBlock(bv);
	if (long_block == 0) return 0;

	array_size_in_bytes = FlexTotalSize(long_block);

	flags = long_block->BLK_HEADER_FLAGS;
	entry_size_in_bytes = 1;
	if (flags & BLK_FLAG_16_BIT) entry_size_in_bytes = 2;
	else if (flags & BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;

	return array_size_in_bytes / entry_size_in_bytes;
];

[ BlkValueSetLBCapacity bv new_capacity  long_block flags entry_size_in_bytes;
	if (bv == 0) rfalse;
	BlkMakeMutable(bv);
	long_block = BlkValueGetLongBlock(bv);
	if (long_block == 0) rfalse;

	flags = long_block->BLK_HEADER_FLAGS;
	entry_size_in_bytes = 1;
	if (flags & BLK_FLAG_16_BIT) entry_size_in_bytes = 2;
	else if (flags & BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;

	FlexResize(long_block, new_capacity*entry_size_in_bytes);
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Long Block Array Access
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueRead from pos do_not_indirect
	long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes seek_byte_position;
	if (from == 0) rfalse;
	if (do_not_indirect)
		long_block = from;
	else
		long_block = BlkValueGetLongBlock(from);

	flags = long_block->BLK_HEADER_FLAGS;
	entry_size_in_bytes = 1;
	if (flags & BLK_FLAG_16_BIT) entry_size_in_bytes = 2;
	else if (flags & BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;

	if (flags & BLK_FLAG_MULTIPLE) header_size_in_bytes = BLK_DATA_MULTI_OFFSET;
	else header_size_in_bytes = BLK_DATA_OFFSET;

	seek_byte_position = pos*entry_size_in_bytes;
	for (: long_block~=NULL: long_block=long_block-->BLK_NEXT) {
		chunk_size_in_bytes = FlexSize(long_block) - header_size_in_bytes;
		if ((seek_byte_position >= 0) && (seek_byte_position<chunk_size_in_bytes)) {
			long_block = long_block + header_size_in_bytes + seek_byte_position;
			switch(entry_size_in_bytes) {
				1: return long_block->0;
				2:	#Iftrue (WORDSIZE == 2); return long_block-->0;
					#ifnot; return (long_block->0)*256 + (long_block->1);
					#endif;
				4: return long_block-->0;
			}
		}
		seek_byte_position = seek_byte_position - chunk_size_in_bytes;
	}
	"*** BlkValueRead: reading from index out of range: ", pos, " in ", from, " ***";
];

[ BlkValueWrite to pos val do_not_indirect
	long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes seek_byte_position;
	if (to == 0) rfalse;
	if (do_not_indirect)
		long_block = to;
	else {
		BlkMakeMutable(to);
		long_block = BlkValueGetLongBlock(to);
	}

	flags = long_block->BLK_HEADER_FLAGS;
	entry_size_in_bytes = 1;
	if (flags & BLK_FLAG_16_BIT) entry_size_in_bytes = 2;
	else if (flags & BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;

	if (flags & BLK_FLAG_MULTIPLE) header_size_in_bytes = BLK_DATA_MULTI_OFFSET;
	else header_size_in_bytes = BLK_DATA_OFFSET;

	seek_byte_position = pos*entry_size_in_bytes;
	for (:long_block~=NULL:long_block=long_block-->BLK_NEXT) {
		chunk_size_in_bytes = FlexSize(long_block) - header_size_in_bytes;
		if ((seek_byte_position >= 0) && (seek_byte_position<chunk_size_in_bytes)) {
			long_block = long_block + header_size_in_bytes + seek_byte_position;
			switch(entry_size_in_bytes) {
				1: long_block->0 = val;
				2:	#Iftrue (WORDSIZE == 2); long_block-->0 = val;
					#ifnot; long_block->0 = (val/256)%256; long_block->1 = val%256;
					#endif;
				4: long_block-->0 = val;
			}
			return;
		}
		seek_byte_position = seek_byte_position - chunk_size_in_bytes;
	}
	"*** BlkValueWrite: writing to index out of range: ", pos, " in ", to, " ***";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: First Zero Entry
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueSeekZeroEntry from
	long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes
	byte_position addr from_addr to_addr;
	if (from == 0) return -1;
	long_block = BlkValueGetLongBlock(from);

	flags = long_block->BLK_HEADER_FLAGS;
	entry_size_in_bytes = 1;
	if (flags & BLK_FLAG_16_BIT) entry_size_in_bytes = 2;
	else if (flags & BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;

	if (flags & BLK_FLAG_MULTIPLE) header_size_in_bytes = BLK_DATA_MULTI_OFFSET;
	else header_size_in_bytes = BLK_DATA_OFFSET;

	byte_position = 0;
	for (: long_block~=NULL: long_block=long_block-->BLK_NEXT) {
		chunk_size_in_bytes = FlexSize(long_block) - header_size_in_bytes;
		from_addr = long_block + header_size_in_bytes;
		to_addr = from_addr + chunk_size_in_bytes;
		switch(entry_size_in_bytes) {
			1:
				for (addr = from_addr: addr < to_addr: addr++)
					if (addr->0 == 0)
						return byte_position + addr - from_addr;
			2:
				#iftrue (WORDSIZE == 2);
				for (addr = from_addr: addr < to_addr: addr=addr+2)
					if (addr-->0 == 0)
						return (byte_position + addr - from_addr)/2;
				#ifnot;
				for (addr = from_addr: addr < to_addr: addr=addr+2)
					if ((addr->0 == 0) && (addr->1 == 0))
						return (byte_position + addr - from_addr)/2;
				#endif;
			4:
				for (addr = from_addr: addr < to_addr: addr=addr+4)
					if (addr-->0 == 0)
						return (byte_position + addr - from_addr)/4;
		}
		byte_position = byte_position + chunk_size_in_bytes;
	}
	return -1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Mass Copy Entries
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueMassCopyEntries to_bv from_bv no_entries_to_copy
	from_long_block from_addr from_bytes_left from_header_size_in_bytes
	to_long_block to_addr to_bytes_left to_header_size_in_bytes
	bytes_to_copy flags entry_size_in_bytes min;

	BlkMakeMutable(to_bv);

	from_long_block = BlkValueGetLongBlock(from_bv);
	to_long_block = BlkValueGetLongBlock(to_bv);

	flags = from_long_block->BLK_HEADER_FLAGS;
	entry_size_in_bytes = 1;
	if (flags & BLK_FLAG_16_BIT) entry_size_in_bytes = 2;
	else if (flags & BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;

	if ((flags & (BLK_FLAG_MULTIPLE + BLK_FLAG_TRUNCMULT)) &&
		(BlkValueSetLBCapacity(to_bv, no_entries_to_copy) == false))
		BlkValueError("copy resizing failed");

	if (flags & BLK_FLAG_MULTIPLE) from_header_size_in_bytes = BLK_DATA_MULTI_OFFSET;
	else from_header_size_in_bytes = BLK_DATA_OFFSET;
	flags = to_long_block->BLK_HEADER_FLAGS;
	if (flags & BLK_FLAG_MULTIPLE) to_header_size_in_bytes = BLK_DATA_MULTI_OFFSET;
	else to_header_size_in_bytes = BLK_DATA_OFFSET;

	from_addr = from_long_block + from_header_size_in_bytes;
	from_bytes_left = FlexSize(from_long_block) - from_header_size_in_bytes;
	to_addr = to_long_block + to_header_size_in_bytes;
	to_bytes_left = FlexSize(to_long_block) - to_header_size_in_bytes;

	bytes_to_copy = entry_size_in_bytes*no_entries_to_copy;
	while (true) {
		if (from_bytes_left == 0) {
			from_long_block = from_long_block-->BLK_NEXT;
			if (from_long_block == 0) BlkValueError("copy destination exhausted");
			from_addr = from_long_block + from_header_size_in_bytes;
			from_bytes_left = FlexSize(from_long_block) - from_header_size_in_bytes;
		} else if (to_bytes_left == 0) {
			to_long_block = to_long_block-->BLK_NEXT;
			if (to_long_block == 0) BlkValueError("copy source exhausted");
			to_addr = to_long_block + to_header_size_in_bytes;
			to_bytes_left = FlexSize(to_long_block) - to_header_size_in_bytes;
		} else {
			min = from_bytes_left; if (to_bytes_left < min) min = to_bytes_left;
			if (bytes_to_copy <= min) {
				Memcpy(to_addr, from_addr, bytes_to_copy);
				return;
			}
			Memcpy(to_addr, from_addr, min);
			bytes_to_copy = bytes_to_copy - min;
			from_addr = from_addr + min;
			from_bytes_left = from_bytes_left - min;
			to_addr = to_addr + min;
			to_bytes_left = to_bytes_left - min;
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Mass Copy From Array
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueMassCopyFromArray to_bv from_array from_entry_size no_entries_to_copy
	to_long_block to_addr to_entries_left to_header_size to_entry_size
	flags;

	BlkMakeMutable(to_bv);

	to_long_block = BlkValueGetLongBlock(to_bv);

	flags = to_long_block->BLK_HEADER_FLAGS;
	to_entry_size = 1;
	if (flags & BLK_FLAG_16_BIT) to_entry_size = 2;
	else if (flags & BLK_FLAG_WORD) to_entry_size = WORDSIZE;

	if ((flags & (BLK_FLAG_MULTIPLE + BLK_FLAG_TRUNCMULT)) &&
		(BlkValueSetLBCapacity(to_bv, no_entries_to_copy) == false))
		BlkValueError("copy resizing failed");

	if (flags & BLK_FLAG_MULTIPLE) to_header_size = BLK_DATA_MULTI_OFFSET;
	else to_header_size = BLK_DATA_OFFSET;

	to_addr = to_long_block + to_header_size;
	to_entries_left = (FlexSize(to_long_block) - to_header_size)/to_entry_size;

	while (no_entries_to_copy > to_entries_left) {
		Arrcpy(to_addr, to_entry_size, from_array, from_entry_size, to_entries_left);
		no_entries_to_copy = no_entries_to_copy - to_entries_left;
		from_array = from_array + to_entries_left*from_entry_size;
		to_long_block = to_long_block-->BLK_NEXT;
		if (to_long_block == 0) BlkValueError("copy source exhausted");
		to_addr = to_long_block + to_header_size;
		to_entries_left = (FlexSize(to_long_block) - to_header_size)/to_entry_size;
	}
	if (no_entries_to_copy > 0) {
		Arrcpy(to_addr, to_entry_size, from_array, from_entry_size, no_entries_to_copy);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: KOVS Routines
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant CREATE_KOVS      = 1;
Constant CAST_KOVS        = 2;
Constant DESTROY_KOVS     = 3;
Constant MAKEMUTABLE_KOVS = 4;
Constant COPYKIND_KOVS    = 5;
Constant EXTENT_KOVS      = 6;
Constant COPYQUICK_KOVS   = 7;
Constant COPYSB_KOVS      = 8;
Constant KINDDATA_KOVS    = 9;
Constant COPY_KOVS        = 10;
Constant COMPARE_KOVS     = 11;
Constant READ_FILE_KOVS   = 12;
Constant WRITE_FILE_KOVS  = 13;
Constant HASH_KOVS        = 14;
Constant DEBUG_KOVS       = 15;

! Constant BLKVALUE_TRACE; ! Uncomment this to expose masses of tracery


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Creation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueCreate strong_kind short_block  kovs;

	kovs = KOVSupportFunction(strong_kind, "impossible allocation");
	short_block = kovs(CREATE_KOVS, strong_kind, short_block);

	#ifdef BLKVALUE_TRACE; print "Created: ", (BlkValueDebug) short_block, "^"; #endif;

	! The new value is represented in I6 as the pointer to its short block:
	return short_block;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Errors
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueError reason;
	print "*** Value handling failed: ", (string) reason, " ***^";
	RunTimeProblem(RTP_HEAPERROR);
	@quit;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Short Block Allocation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueCreateSB1 short_block val;
	if (short_block == 0)
		short_block = FlexAllocate(WORDSIZE, 0, BLK_FLAG_WORD) + BLK_DATA_OFFSET;
	short_block-->0 = val;
	return short_block;
];

[ BlkValueCreateSB2 short_block val1 val2;
	if (short_block == 0)
		short_block = FlexAllocate(2*WORDSIZE, 0, BLK_FLAG_WORD) + BLK_DATA_OFFSET;
	short_block-->0 = val1; short_block-->1 = val2;
	return short_block;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Block Values On Stack
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ StackFramingInitialise;
	I7SFRAME = blockv_stack + WORDSIZE*BLOCKV_STACK_SIZE;
];

[ StackFrameCreate size new;
	new = I7SFRAME - WORDSIZE*size;
	if (new < blockv_stack) { RunTimeProblem(RTP_HEAPERROR); @quit; }
	I7SFRAME = new;
];

[ BlkValueCreateOnStack offset strong_kind;
	BlkValueCreate(strong_kind, I7SFRAME + WORDSIZE*offset);
];

[ BlkValueFreeOnStack offset;
    BlkValueFree(I7SFRAME + WORDSIZE*offset);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Freeing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueFree bv kovs d;
	if (bv == 0) return;

	! Dispose of any data in the long block
	kovs = KOVSupportFunction(BlkValueWeakKind(bv), "impossible deallocation");
	BlkValueDestroyPrimitive(bv, kovs);

	! Free any heap memory occupied by the short block
	d = bv - Flex_Heap;
	if ((d >= 0) && (d < MEMORY_HEAP_SIZE + 16))
		FlexFree(bv - BLK_DATA_OFFSET);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Quick Copy
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueQuickCopyPrimitive to_bv from_bv kovs;
	BlkValueDestroyPrimitive(to_bv, kovs);
	kovs(COPYSB_KOVS, to_bv, from_bv);
	BlkValueIncRefCountPrimitive(from_bv);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Short Block Copy
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueCopySB1 to_bv from_bv;
	to_bv-->0 = from_bv-->0;
	if (to_bv-->0 == 0) to_bv-->0 = from_bv + WORDSIZE;
];

[ BlkValueCopySB2 to_bv from_bv;
	to_bv-->0 = from_bv-->0;
	to_bv-->1 = from_bv-->1;
	if (to_bv-->1 == 0) to_bv-->1 = from_bv + 2*WORDSIZE;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Slow Copy
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueSlowCopyPrimitive to_bv from_bv kovs recycling
	k from_long_block no_entries_to_copy;
	k = kovs(KINDDATA_KOVS, to_bv, from_bv);

	from_long_block = BlkValueGetLongBlock(from_bv);
	if (from_long_block) {
		if (recycling) BlkValueRecyclePrimitive(to_bv, kovs);
		no_entries_to_copy = kovs(EXTENT_KOVS, from_bv);
		if (no_entries_to_copy == -1) no_entries_to_copy = BlkValueLBCapacity(from_bv);
		BlkValueMassCopyEntries(to_bv, from_bv, no_entries_to_copy);
!print "So to: "; BlkValueDebug(to_bv); print "^";

	}

	kovs(COPY_KOVS, to_bv, from_bv, k);
!print "Whence to: "; BlkValueDebug(to_bv); print "^";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Copy
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueCopy to_bv from_bv  to_kind from_kind kovs;
	if (to_bv == 0) BlkValueError("copy to null value");
	if (from_bv == 0) BlkValueError("copy from null value");
	if (to_bv == from_bv) return;

	#ifdef BLKVALUE_TRACE;
	print "Copy: ", (BlkValueDebug) to_bv, " to equal ", (BlkValueDebug) from_bv, "^";
	#endif;

	to_kind = BlkValueWeakKind(to_bv);
	from_kind = BlkValueWeakKind(from_bv);
	if (to_kind ~= from_kind) BlkValueError("copy incompatible kinds");

	kovs = KOVSupportFunction(to_kind, "impossible copy");
	
	if (kovs(COPYQUICK_KOVS, to_bv, from_bv))
		BlkValueQuickCopyPrimitive(to_bv, from_bv, kovs);
	else
		BlkValueSlowCopyPrimitive(to_bv, from_bv, kovs, true);

	return to_bv;
];

[ BlkValueCopyAZ to_bv from_bv;
	if (from_bv) return BlkValueCopy(to_bv, from_bv);
	return to_bv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Destruction
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueDestroyPrimitive bv kovs long_block;
	#ifdef BLKVALUE_TRACE; print "Destroying ", (BlkValueDebug) bv, "^"; #endif;
	if (BlkValueDecRefCountPrimitive(bv) == 0) {
		kovs(DESTROY_KOVS, bv);
		long_block = BlkValueGetLongBlock(bv);
		if (long_block) FlexFree(long_block);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Recycling
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueRecyclePrimitive bv kovs;
	#ifdef BLKVALUE_TRACE; print "Recycling ", (BlkValueDebug) bv, "^"; #endif;
	if (BlkValueDecRefCountPrimitive(bv) == 0) {
		kovs(DESTROY_KOVS, bv);
		BlkValueIncRefCountPrimitive(bv);
	} else {
		BlkValueCreate(BlkValueWeakKind(bv), bv);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Mutability
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkMakeMutable bv block bv_kind kovs sb_size;
	if (bv == 0) BlkValueError("tried to make null block mutable");

	if (BlkValueGetRefCountPrimitive(bv) > 1) {
		#ifdef BLKVALUE_TRACE; print "Make mutable: ", (BlkValueDebug) bv, "^"; #endif;

		BlkValueDecRefCountPrimitive(bv);

		bv_kind = BlkValueWeakKind(bv);
		kovs = KOVSupportFunction(bv_kind, "impossible mutability");

		sb_size = kovs(MAKEMUTABLE_KOVS, bv);
		if (sb_size > 0) {
			@push I7SFRAME;
			StackFrameCreate(sb_size);
			BlkValueCreateOnStack(0, bv_kind);
			kovs(COPYKIND_KOVS, I7SFRAME, bv);
			BlkValueSlowCopyPrimitive(I7SFRAME, bv, kovs, false);
			kovs(COPYSB_KOVS, bv, I7SFRAME);
			@pull I7SFRAME;
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Casting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueCast to_bv original_kind original_value  kovs;
	kovs = KOVSupportFunction(BlkValueWeakKind(to_bv), "impossible cast");
	kovs(CAST_KOVS, to_bv, original_kind, original_value);
	return to_bv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Comparison
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueCompare bv_left bv_right  kind_left kind_right kovs;
	if ((bv_left == 0) && (bv_right == 0)) return 0;
	if (bv_left == 0) return 1;
	if (bv_right == 0) return -1;

	kind_left = BlkValueWeakKind(bv_left);
	kind_right = BlkValueWeakKind(bv_right);
	if (kind_left ~= kind_right) return kind_left - kind_right;

	kovs = KOVSupportFunction(kind_left, "impossible comparison");
	return kovs(COMPARE_KOVS, bv_left, bv_right);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Hashing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ GetHashValue kind value;
	if (KOVIsBlockValue(kind)) return BlkValueHash(value);
	return value;
];

[ BlkValueHash bv  bv_kind kovs;
	if (bv == 0) return 0;
	bv_kind = BlkValueWeakKind(bv);
	kovs = KOVSupportFunction(bv_kind, "impossible hashing");
	return kovs(HASH_KOVS, bv);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Serialisation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueReadFromFile bv auxf ch bv_kind  kovs;
	kovs = KOVSupportFunction(bv_kind);
	if (kovs) return kovs(READ_FILE_KOVS, bv, auxf, ch);
	rfalse;
];

[ BlkValueWriteToFile bv bv_kind  kovs;
	kovs = KOVSupportFunction(bv_kind);
	if (kovs) return kovs(WRITE_FILE_KOVS, bv);
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Debugging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkValueDebug bv flag refc long_block kovs;
	print "(BV";
	if (bv) {
		BlkDebugAddress(bv, flag);
		long_block = BlkValueGetLongBlock(bv);
		if (long_block) {
			if (bv-->0 == 0) print "..."; else print "-->";
			print "L"; BlkDebugAddress(long_block, flag);
			print " 2**", long_block->BLK_HEADER_N;
			refc = BlkValueGetRefCountPrimitive(bv);
			if (refc == RC_INFINITY) print " resident";
			else { print " ", refc, " ref"; if (refc ~= 1) print "s"; }
		}
		kovs = KOVSupportFunction(BlkValueWeakKind(bv));
		if (kovs) kovs(DEBUG_KOVS, bv);
	}
	print ")";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Printing Memory Addresses
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkDebugAddress addr flag d;
	if (flag) { print "###"; return; }

	d = addr - blockv_stack;
	if ((d >= 0) && (d <= WORDSIZE*BLOCKV_STACK_SIZE)) {
		print "s+", (BlkPrintHexadecimal) d;
		d = addr - I7SFRAME;
		print "=f"; if (d >= 0) print "+"; print d;
		return;
	}
	
	d = addr - Flex_Heap;
	if ((d >= 0) && (d < MEMORY_HEAP_SIZE + 16)) {
		print "h+", (BlkPrintHexadecimal) d;
		return;
	}

	print (BlkPrintHexadecimal) addr;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! BlockValues.i6t: Hexadecimal Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ BlkPrintHexadecimal v;
	#iftrue WORDSIZE == 4;
	if (v & $ffff0000) {
		if (v & $ff000000) {
			BlkPrintHexDigit(v / $10000000);
			BlkPrintHexDigit(v / $1000000);
		}
		BlkPrintHexDigit(v / $100000);
		BlkPrintHexDigit(v / $10000);
	}
	#endif;
	BlkPrintHexDigit(v / $1000);
	BlkPrintHexDigit(v / $100);
	BlkPrintHexDigit(v / $10);
	BlkPrintHexDigit(v);
];

[ BlkPrintHexDigit v;
	v = v & $F;
	if (v < 10) print v; else print (char) 'A' + v - 10;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Block Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant CONSTANT_PACKED_TEXT_STORAGE     = BLK_BVBITMAP_TEXT + BLK_BVBITMAP_CONSTANT + 1;
Constant CONSTANT_PERISHABLE_TEXT_STORAGE = BLK_BVBITMAP_TEXT + BLK_BVBITMAP_CONSTANT + 2;
Constant PACKED_TEXT_STORAGE              = BLK_BVBITMAP_TEXT + 3;
Constant UNPACKED_TEXT_STORAGE            = BLK_BVBITMAP_TEXT + BLK_BVBITMAP_LONGBLOCK + 4;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Extent Of Long Block
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Extent arg1 x;
	x = BlkValueSeekZeroEntry(arg1);
	if (x < 0) return -1; ! should not happen, of course
	return x+1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Character Set
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF TARGET_ZCODE;
Constant TEXT_TY_Storage_Flags = BLK_FLAG_MULTIPLE;
Constant ZSCII_Tables;
#IFNOT;
Constant TEXT_TY_Storage_Flags = BLK_FLAG_MULTIPLE + BLK_FLAG_16_BIT;
Constant Large_Unicode_Tables;
#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! UnicodeData.i6t: Source
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant UNIC_NCT = 10000; ! Safe as highest case-change delta is 8383


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! UnicodeData.i6t: ZSCII Casing Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF ZSCII_Tables;
Array CharCasingChart0 -->
    $0061 (  26) (     -32) $009b (   3) (       3) $00a1 (   1) (UNIC_NCT)
    $00a4 (   2) (       3) $00a6 (   1) (UNIC_NCT) $00a9 (   6) (       6)
    $00b5 (   5) (       5) $00bf (   5) (       5) $00c9 (  -3) (       1)
    $00cd (   3) (       3) $00d3 (  -3) (       1) $00d7 (   2) (       2)
    $00dc (   1) (       1) $0000
;

Array CharCasingChart1 -->
    $0041 (  26) (      32) $009e (   3) (      -3) $00a7 (   2) (      -3)
    $00af (   6) (      -6) $00ba (   5) (      -5) $00c4 (   5) (      -5)
    $00ca (  -3) (      -1) $00d0 (   3) (      -3) $00d4 (  -3) (      -1)
    $00d9 (   2) (      -2) $00dd (   1) (      -1) $0000
;
#ENDIF; ! ZSCII_Tables


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! UnicodeData.i6t: Small Unicode Casing Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF Small_Unicode_Tables;
Array CharCasingChart0 -->
    $0061 (  26) (     -32) $00aa (   1) (UNIC_NCT) $00b5 (   1) (UNIC_NCT) $00ba (   1) (UNIC_NCT)
    $00df (   1) (UNIC_NCT) $00e0 (  23) (     -32) $00f8 (   7) (     -32) $00ff (   1) (UNIC_NCT)
    $0000
;

Array CharCasingChart1 -->
    $0041 (  26) (      32) $00c0 (  23) (      32) $00d8 (   7) (      32) $0000
;

#ENDIF; ! Small_Unicode_Tables


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! UnicodeData.i6t: Large Unicode Casing Tables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF Large_Unicode_Tables;
Array CharCasingChart0 -->
    $0061 (  26) (     -32) $00aa (   1) (UNIC_NCT) $00b5 (   1) (     743) $00ba (   1) (UNIC_NCT)
    $00df (   1) (UNIC_NCT) $00e0 (  23) (     -32) $00f8 (   7) (     -32) $00ff (   1) (     121)
    $0101 ( -47) (      -1) $0131 (   1) (    -232) $0133 (  -5) (      -1) $0138 (   1) (UNIC_NCT)
    $013a ( -15) (      -1) $0149 (   1) (UNIC_NCT) $014b ( -45) (      -1) $017a (  -5) (      -1)
    $017f (   1) (    -300) $0180 (   1) (UNIC_NCT) $0183 (  -3) (      -1) $0188 (   1) (      -1)
    $018c (   1) (      -1) $018d (   1) (UNIC_NCT) $0192 (   1) (      -1) $0195 (   1) (      97)
    $0199 (   1) (      -1) $019a (   2) (UNIC_NCT) $019e (   1) (     130) $01a1 (  -5) (      -1)
    $01a8 (   1) (      -1) $01aa (   2) (UNIC_NCT) $01ad (   1) (      -1) $01b0 (   1) (      -1)
    $01b4 (  -3) (      -1) $01b9 (   1) (      -1) $01ba (   1) (UNIC_NCT) $01bd (   1) (      -1)
    $01be (   1) (UNIC_NCT) $01bf (   1) (      56) $01c6 (   1) (      -2) $01c9 (   1) (      -2)
    $01cc (   1) (      -2) $01ce ( -15) (      -1) $01dd (   1) (     -79) $01df ( -17) (      -1)
    $01f0 (   1) (UNIC_NCT) $01f3 (   1) (      -2) $01f5 (   1) (      -1) $01f9 ( -39) (      -1)
    $0221 (   1) (UNIC_NCT) $0223 ( -17) (      -1) $0234 (   3) (UNIC_NCT) $0250 (   3) (UNIC_NCT)
    $0253 (   1) (    -210) $0254 (   1) (    -206) $0255 (   1) (UNIC_NCT) $0256 (   2) (    -205)
    $0258 (   1) (UNIC_NCT) $0259 (   1) (    -202) $025a (   1) (UNIC_NCT) $025b (   1) (    -203)
    $025c (   4) (UNIC_NCT) $0260 (   1) (    -205) $0261 (   2) (UNIC_NCT) $0263 (   1) (    -207)
    $0264 (   4) (UNIC_NCT) $0268 (   1) (    -209) $0269 (   1) (    -211) $026a (   5) (UNIC_NCT)
    $026f (   1) (    -211) $0270 (   2) (UNIC_NCT) $0272 (   1) (    -213) $0273 (   2) (UNIC_NCT)
    $0275 (   1) (    -214) $0276 (  10) (UNIC_NCT) $0280 (   1) (    -218) $0281 (   2) (UNIC_NCT)
    $0283 (   1) (    -218) $0284 (   4) (UNIC_NCT) $0288 (   1) (    -218) $0289 (   1) (UNIC_NCT)
    $028a (   2) (    -217) $028c (   6) (UNIC_NCT) $0292 (   1) (    -219) $0293 (  29) (UNIC_NCT)
    $0390 (   1) (UNIC_NCT) $03ac (   1) (     -38) $03ad (   3) (     -37) $03b0 (   1) (UNIC_NCT)
    $03b1 (  17) (     -32) $03c2 (   1) (     -31) $03c3 (   9) (     -32) $03cc (   1) (     -64)
    $03cd (   2) (     -63) $03d0 (   1) (     -62) $03d1 (   1) (     -57) $03d5 (   1) (     -47)
    $03d6 (   1) (     -54) $03d7 (   1) (UNIC_NCT) $03d9 ( -23) (      -1) $03f0 (   1) (     -86)
    $03f1 (   1) (     -80) $03f2 (   1) (       7) $03f3 (   1) (UNIC_NCT) $03f5 (   1) (     -96)
    $03f8 (   1) (      -1) $03fb (   1) (      -1) $0430 (  32) (     -32) $0450 (  16) (     -80)
    $0461 ( -33) (      -1) $048b ( -53) (      -1) $04c2 ( -13) (      -1) $04d1 ( -37) (      -1)
    $04f9 (   1) (      -1) $0501 ( -15) (      -1) $0561 (  38) (     -48) $0587 (   1) (UNIC_NCT)
    $1d00 (  44) (UNIC_NCT) $1d62 (  10) (UNIC_NCT) $1e01 (-149) (      -1) $1e96 (   5) (UNIC_NCT)
    $1e9b (   1) (     -59) $1ea1 ( -89) (      -1) $1f00 (   8) (       8) $1f10 (   6) (       8)
    $1f20 (   8) (       8) $1f30 (   8) (       8) $1f40 (   6) (       8) $1f50 (   1) (UNIC_NCT)
    $1f51 (   1) (       8) $1f52 (   1) (UNIC_NCT) $1f53 (   1) (       8) $1f54 (   1) (UNIC_NCT)
    $1f55 (   1) (       8) $1f56 (   1) (UNIC_NCT) $1f57 (   1) (       8) $1f60 (   8) (       8)
    $1f70 (   2) (      74) $1f72 (   4) (      86) $1f76 (   2) (     100) $1f78 (   2) (     128)
    $1f7a (   2) (     112) $1f7c (   2) (     126) $1f80 (   8) (       8) $1f90 (   8) (       8)
    $1fa0 (   8) (       8) $1fb0 (   2) (       8) $1fb2 (   1) (UNIC_NCT) $1fb3 (   1) (       9)
    $1fb4 (  -3) (UNIC_NCT) $1fb7 (   1) (UNIC_NCT) $1fbe (   1) (   -7205) $1fc2 (   1) (UNIC_NCT)
    $1fc3 (   1) (       9) $1fc4 (  -3) (UNIC_NCT) $1fc7 (   1) (UNIC_NCT) $1fd0 (   2) (       8)
    $1fd2 (   2) (UNIC_NCT) $1fd6 (   2) (UNIC_NCT) $1fe0 (   2) (       8) $1fe2 (   3) (UNIC_NCT)
    $1fe5 (   1) (       7) $1fe6 (   2) (UNIC_NCT) $1ff2 (   1) (UNIC_NCT) $1ff3 (   1) (       9)
    $1ff4 (  -3) (UNIC_NCT) $1ff7 (   1) (UNIC_NCT) $2071 (   1) (UNIC_NCT) $207f (   1) (UNIC_NCT)
    $210a (   1) (UNIC_NCT) $210e (   2) (UNIC_NCT) $2113 (   1) (UNIC_NCT) $212f (   1) (UNIC_NCT)
    $2134 (   1) (UNIC_NCT) $2139 (   1) (UNIC_NCT) $213d (   1) (UNIC_NCT) $2146 (   4) (UNIC_NCT)
    $fb00 (   7) (UNIC_NCT) $fb13 (   5) (UNIC_NCT) $ff41 (  26) (     -32) $0000
;

Array CharCasingChart1 -->
    $0041 (  26) (      32) $00c0 (  23) (      32) $00d8 (   7) (      32) $0100 ( -47) (       1)
    $0130 (   1) (    -199) $0132 (  -5) (       1) $0139 ( -15) (       1) $014a ( -45) (       1)
    $0178 (   1) (    -121) $0179 (  -5) (       1) $0181 (   1) (     210) $0182 (  -3) (       1)
    $0186 (   1) (     206) $0187 (   1) (       1) $0189 (   2) (     205) $018b (   1) (       1)
    $018e (   1) (      79) $018f (   1) (     202) $0190 (   1) (     203) $0191 (   1) (       1)
    $0193 (   1) (     205) $0194 (   1) (     207) $0196 (   1) (     211) $0197 (   1) (     209)
    $0198 (   1) (       1) $019c (   1) (     211) $019d (   1) (     213) $019f (   1) (     214)
    $01a0 (  -5) (       1) $01a6 (   1) (     218) $01a7 (   1) (       1) $01a9 (   1) (     218)
    $01ac (   1) (       1) $01ae (   1) (     218) $01af (   1) (       1) $01b1 (   2) (     217)
    $01b3 (  -3) (       1) $01b7 (   1) (     219) $01b8 (   1) (       1) $01bc (   1) (       1)
    $01c4 (   1) (       2) $01c7 (   1) (       2) $01ca (   1) (       2) $01cd ( -15) (       1)
    $01de ( -17) (       1) $01f1 (   1) (       2) $01f4 (   1) (       1) $01f6 (   1) (     -97)
    $01f7 (   1) (     -56) $01f8 ( -39) (       1) $0220 (   1) (    -130) $0222 ( -17) (       1)
    $0386 (   1) (      38) $0388 (   3) (      37) $038c (   1) (      64) $038e (   2) (      63)
    $0391 (  17) (      32) $03a3 (   9) (      32) $03d2 (   3) (UNIC_NCT) $03d8 ( -23) (       1)
    $03f4 (   1) (     -60) $03f7 (   1) (       1) $03f9 (   1) (      -7) $03fa (   1) (       1)
    $0400 (  16) (      80) $0410 (  32) (      32) $0460 ( -33) (       1) $048a ( -53) (       1)
    $04c0 (   1) (UNIC_NCT) $04c1 ( -13) (       1) $04d0 ( -37) (       1) $04f8 (   1) (       1)
    $0500 ( -15) (       1) $0531 (  38) (      48) $10a0 (  38) (UNIC_NCT) $1e00 (-149) (       1)
    $1ea0 ( -89) (       1) $1f08 (   8) (      -8) $1f18 (   6) (      -8) $1f28 (   8) (      -8)
    $1f38 (   8) (      -8) $1f48 (   6) (      -8) $1f59 (  -7) (      -8) $1f68 (   8) (      -8)
    $1fb8 (   2) (      -8) $1fba (   2) (     -74) $1fc8 (   4) (     -86) $1fd8 (   2) (      -8)
    $1fda (   2) (    -100) $1fe8 (   2) (      -8) $1fea (   2) (    -112) $1fec (   1) (      -7)
    $1ff8 (   2) (    -128) $1ffa (   2) (    -126) $2102 (   1) (UNIC_NCT) $2107 (   1) (UNIC_NCT)
    $210b (   3) (UNIC_NCT) $2110 (   3) (UNIC_NCT) $2115 (   1) (UNIC_NCT) $2119 (   5) (UNIC_NCT)
    $2124 (   1) (UNIC_NCT) $2126 (   1) (   -7517) $2128 (   1) (UNIC_NCT) $212a (   1) (   -8383)
    $212b (   1) (   -8262) $212c (   2) (UNIC_NCT) $2130 (   2) (UNIC_NCT) $2133 (   1) (UNIC_NCT)
    $213e (   2) (UNIC_NCT) $2145 (   1) (UNIC_NCT) $ff21 (  26) (      32) $0000
;

#ENDIF; ! Large_Unicode_Tables


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Char.i6t: Char Is Of Case
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CharIsOfCase c case
	i tab min max len par;
	if (c<'A') rfalse;
	if (case == 0) {
		if ((c >= 'a') && (c <= 'z')) rtrue;
		tab = CharCasingChart0;
	} else {
		if ((c >= 'A') && (c <= 'Z')) rtrue;
		tab = CharCasingChart1;
	}
	if (c<128) rfalse;
	while (tab-->i) {
		min = tab-->i; i++;
		len = tab-->i; i++;
		i++;
		par = 0;
		if (len<0) { par = 1; len = -len; }
		if (c < min) rfalse;
		if (c < min+len) {
			if (par) { if ((c-min) % 2 == 0) rtrue; }
			else { rtrue; }
		}
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Char.i6t: Char To Case
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CharToCase c case
	i tab min max len par del f;
	if (c<'A') return c;
	if (case == 1) {
		if ((c >= 'a') && (c <= 'z')) return c-32;
		tab = CharCasingChart0;
	} else {
		if ((c >= 'A') && (c <= 'Z')) return c+32;
		tab = CharCasingChart1;
	}
	if (c<128) return c;
	while (tab-->i) {
		min = tab-->i; i++;
		len = tab-->i; i++;
		del = tab-->i; i++;
		par = 0;
		if (len<0) { par = 1; len = -len; }
		if (c < min) return c;
		if (c < min+len) {
			f = false;
			if (par) { if ((c-min) % 2 == 0) f = true; }
			else { f = true; }
			if (f) {
				if (del == UNIC_NCT) return c;
				return c+del;
			}
		}
	}
	return c;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Char.i6t: Reversing Case
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#IFDEF TARGET_ZCODE;
[ TEXT_TY_RevCase ch;
	if (ch<'A') return ch;
	if ((ch >= 'a') && (ch <= 'z')) return ch-'a'+'A';
	if ((ch >= 'A') && (ch <= 'Z')) return ch-'A'+'a';
	if (ch<128) return ch;
	if ((ch >= 155) && (ch <= 157)) return ch+3; ! a, o, u umlaut in ZSCII
	if ((ch >= 158) && (ch <= 160)) return ch-3; ! A, O, U umlaut
	if ((ch >= 164) && (ch <= 165)) return ch+3; ! e, i umlaut
	if ((ch >= 167) && (ch <= 168)) return ch-3; ! E, I umlaut
	if ((ch >= 169) && (ch <= 174)) return ch+6; ! a, e, i, o, u, y acute
	if ((ch >= 175) && (ch <= 180)) return ch-6; ! A, E, I, O, U, Y acute
	if ((ch >= 181) && (ch <= 185)) return ch+5; ! a, e, i, o, u grave
	if ((ch >= 186) && (ch <= 190)) return ch-5; ! A, E, I, O, U grave
	if ((ch >= 191) && (ch <= 195)) return ch+5; ! a, e, i, o, u circumflex
	if ((ch >= 196) && (ch <= 200)) return ch-5; ! A, E, I, O, U circumflex
	if (ch == 201) return 202; ! a circle
	if (ch == 202) return 201; ! A circle
	if (ch == 203) return 204; ! o slash
	if (ch == 204) return 203; ! O slash
	if ((ch >= 205) && (ch <= 207)) return ch+3; ! a, n, o tilde
	if ((ch >= 208) && (ch <= 210)) return ch-3; ! A, N, O tilde
	if (ch == 211) return 212; ! ae ligature
	if (ch == 212) return 211; ! AE ligature
	if (ch == 213) return 214; ! c cedilla
	if (ch == 214) return 213; ! C cedilla
	if (ch == 215 or 216) return ch+2; ! thorn, eth
	if (ch == 217 or 218) return ch-2; ! Thorn, Eth
	if (ch == 220) return 221; ! oe ligature
	if (ch == 221) return 220; ! OE ligature
	return ch;
];
#IFNOT;
[ TEXT_TY_RevCase ch;
	if (ch<'A') return ch;
	if ((ch >= 'a') && (ch <= 'z')) return ch-'a'+'A';
	if ((ch >= 'A') && (ch <= 'Z')) return ch-'A'+'a';
	if (ch<128) return ch;
	if (CharIsOfCase(ch, 0)) return CharToCase(ch, 1);
	if (CharIsOfCase(ch, 1)) return CharToCase(ch, 0);
	return ch;
];
#ENDIF;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Char.i6t: Testing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ CharTestCases case i j;
	for (i=32: i<$E0; i++) {
		if ((i>=127) && (i<155)) continue;
		print i, " - ", (char) i, " -";
		if (CharIsOfCase(i, 0)) print "  lower";
		if (CharIsOfCase(i, 1)) print "  upper";
		j = CharToCase(i, 0); if (j ~= i) print "  tolower: ", (char) j;
		j = CharToCase(i, 1); if (j ~= i) print "  toupper: ", (char) j;
		print "^";
	}
];



! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: KOV Support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:      return TEXT_TY_Create(arg2);
		CAST_KOVS:        TEXT_TY_Cast(arg1, arg2, arg3);
		MAKEMUTABLE_KOVS: return TEXT_TY_Mutable(arg1);
		COPYQUICK_KOVS:   rtrue;
		COPYSB_KOVS:	  TEXT_TY_CopySB(arg1, arg2);
		KINDDATA_KOVS:    return 0;
		EXTENT_KOVS:      return TEXT_TY_Extent(arg1);
		COMPARE_KOVS:     return TEXT_TY_Compare(arg1, arg2);
		READ_FILE_KOVS:   if (arg3 == -1) rtrue;
			              return TEXT_TY_ReadFile(arg1, arg2, arg3);
		WRITE_FILE_KOVS:  return TEXT_TY_WriteFile(arg1);
		HASH_KOVS:        return TEXT_TY_Hash(arg1);
		DEBUG_KOVS:       TEXT_TY_Debug(arg1);
	}
	! We choose not to respond to: DESTROY_KOVS, COPYKIND_KOVS, COPY_KOVS
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Debugging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Debug txt;
	switch (txt-->0) {
		CONSTANT_PACKED_TEXT_STORAGE:     print " = cp~", (PrintI6Text) txt-->1, "~";
		CONSTANT_PERISHABLE_TEXT_STORAGE: print " = cp~", (PrintI6Text) txt-->1, "~";
		PACKED_TEXT_STORAGE:              print " = p~", (PrintI6Text) txt-->1, "~";
		UNPACKED_TEXT_STORAGE:            print " = ~", (TEXT_TY_Say) txt, "~";
		default:                          print " broken?";
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Creation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Create short_block x;
	return BlkValueCreateSB2(short_block, PACKED_TEXT_STORAGE, EMPTY_TEXT_PACKED);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Copy Short Block
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_CopySB to_bv from_bv;
	BlkValueCopySB2(to_bv, from_bv);
	if (to_bv-->0 & BLK_BVBITMAP_CONSTANTMASK) to_bv-->0 = PACKED_TEXT_STORAGE;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Transmutation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Transmute txt;
	TEXT_TY_Temporarily_Transmute(txt);
];

[ TEXT_TY_Temporarily_Transmute txt  x;
	if ((txt) && (txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0)) {
		x = txt-->1; ! The old value was a packed string
		
		txt-->0 = UNPACKED_TEXT_STORAGE;
		txt-->1 = FlexAllocate(32, TEXT_TY, TEXT_TY_Storage_Flags);
		if (x ~= EMPTY_TEXT_PACKED) TEXT_TY_CastPrimitive(txt, false, x);
		
		return x;
	}
	return 0;
];

[ TEXT_TY_Untransmute txt pk cp x;
	if ((pk) && (txt-->0 == UNPACKED_TEXT_STORAGE)) {
		x = txt-->1; ! The old value was an unpacked string
		FlexFree(x);
		txt-->0 = cp;
		txt-->1 = pk; ! The value earlier returned by TEXT_TY_Temporarily_Transmute
	}
	return txt;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Mutability
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Mutable txt;
	if (txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0) {
		TEXT_TY_Transmute(txt);
		return 0;
	}
	return 2; ! Tell BlockValue there's a long block pointer
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Casting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Cast to_txt from_kind from_value;
	if (from_kind == TEXT_TY) {
		BlkValueCopy(to_txt, from_value);
	} else if (from_kind == SNIPPET_TY) {
		TEXT_TY_Transmute(to_txt);
		TEXT_TY_CastPrimitive(to_txt, true, from_value);
	} else BlkValueError("impossible cast to text");
];

[ SNIPPET_TY_to_TEXT_TY to_txt snippet;
	return BlkValueCast(to_txt, SNIPPET_TY, snippet);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Data Conversion
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifndef TEXT_TY_BufferSize;
Constant TEXT_TY_BufferSize = 512;
#endif;
Constant TEXT_TY_NoBuffers = 2;

#ifdef TARGET_ZCODE;
Array TEXT_TY_Buffers -> TEXT_TY_BufferSize*TEXT_TY_NoBuffers; ! Where characters are bytes
#ifnot;
Array TEXT_TY_Buffers --> (TEXT_TY_BufferSize+2)*TEXT_TY_NoBuffers; ! Where characters are words
#endif;

Global RawBufferAddress = TEXT_TY_Buffers;
Global RawBufferSize = TEXT_TY_BufferSize;

Global TEXT_TY_CastPrimitiveNesting = 0;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Z Version
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifdef TARGET_ZCODE;
[ TEXT_TY_CastPrimitive to_txt from_snippet from_value  len news buffer;
	if (to_txt == 0) BlkValueError("no destination for cast");
	SuspendRTP();
	buffer = RawBufferAddress + TEXT_TY_CastPrimitiveNesting*TEXT_TY_BufferSize;
	TEXT_TY_CastPrimitiveNesting++;
	if (TEXT_TY_CastPrimitiveNesting > TEXT_TY_NoBuffers)
		FlexError("ran out with too many simultaneous text conversions");

	@push say__p; @push say__pc;
	ClearParagraphing(6);
	@output_stream 3 buffer;
	if (from_value) {
		if (from_snippet) print (PrintSnippet) from_value;
		else print (PrintI6Text) from_value;
	}
	@output_stream -3;
	@pull say__pc; @pull say__p;
	ResumeRTP();

	len = buffer-->0;
	if (len > RawBufferSize-1) len = RawBufferSize-1;
	buffer->(len+2) = 0;

	TEXT_TY_CastPrimitiveNesting--;
	BlkValueMassCopyFromArray(to_txt, buffer+2, 1, len+1);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Glulx Version
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

#ifnot; ! TARGET_ZCODE
[ TEXT_TY_CastPrimitive to_txt from_snippet from_value
	len i stream saved_stream news buffer buffer_size memory_to_free results;

	if (to_txt == 0) BlkValueError("no destination for cast");

	buffer_size = (TEXT_TY_BufferSize + 2)*WORDSIZE;
	
	RawBufferSize = TEXT_TY_BufferSize;
	buffer = RawBufferAddress + TEXT_TY_CastPrimitiveNesting*buffer_size;
	TEXT_TY_CastPrimitiveNesting++;
	if (TEXT_TY_CastPrimitiveNesting > TEXT_TY_NoBuffers) {
		buffer = VM_AllocateMemory(buffer_size); memory_to_free = buffer;
		if (buffer == 0)
			FlexError("ran out with too many simultaneous text conversions");
	}

	if (unicode_gestalt_ok) {
		SuspendRTP();
		.RetryWithLargerBuffer;
		saved_stream = glk_stream_get_current();
		stream = glk_stream_open_memory_uni(buffer, RawBufferSize, filemode_Write, 0);
		glk_stream_set_current(stream);

		@push say__p; @push say__pc;
		ClearParagraphing(7);
		if (from_snippet) print (PrintSnippet) from_value;
		else print (PrintI6Text) from_value;
		@pull say__pc; @pull say__p;

		results = buffer + buffer_size - 2*WORDSIZE;
		glk_stream_close(stream, results);
		if (saved_stream) glk_stream_set_current(saved_stream);
		ResumeRTP();

		len = results-->1;
		if (len > RawBufferSize-1) {
			! Glulx had to truncate text output because the buffer ran out:
			! len is the number of characters which it tried to print
			news = RawBufferSize;
			while (news < len) news=news*2;
			i = VM_AllocateMemory(news*WORDSIZE);
			if (i ~= 0) {
				if (memory_to_free) VM_FreeMemory(memory_to_free);
				memory_to_free = i;
				buffer = i;
				RawBufferSize = news;
				buffer_size = (RawBufferSize + 2)*WORDSIZE;
				jump RetryWithLargerBuffer;
			}
			! Memory allocation refused: all we can do is to truncate the text
			len = RawBufferSize-1;
		}
		buffer-->(len) = 0;

		TEXT_TY_CastPrimitiveNesting--;
		BlkValueMassCopyFromArray(to_txt, buffer, 4, len+1);
	} else {
		RunTimeProblem(RTP_NOGLULXUNICODE);
	}
	if (memory_to_free) VM_FreeMemory(memory_to_free);
];
#endif; 


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Comparison
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Compare left_txt right_txt rv;
	@push say__comp;
	say__comp = true;
	rv = TEXT_TY_Compare_Inner(left_txt, right_txt);
	@pull say__comp;
	return rv;
];

[ TEXT_TY_Compare_Inner left_txt right_txt
	pos ch1 ch2 capacity_left capacity_right fl fr cl cr cpl cpr;
	if (left_txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0) fl = true;
	if (right_txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0) fr = true;

	if (fl && fr) {
		if ((left_txt-->1 ofclass String) && (right_txt-->1 ofclass String))
			return left_txt-->1 - right_txt-->1;
		if ((left_txt-->1 ofclass Routine) && (right_txt-->1 ofclass Routine))
			return left_txt-->1 - right_txt-->1;
		cpl = left_txt-->0; cl = TEXT_TY_Temporarily_Transmute(left_txt);
		cpr = right_txt-->0; cr = TEXT_TY_Temporarily_Transmute(right_txt);		
	} else if (fl) {
		cpl = left_txt-->0; cl = TEXT_TY_Temporarily_Transmute(left_txt);
	} else if (fr) {
		cpr = right_txt-->0; cr = TEXT_TY_Temporarily_Transmute(right_txt);
	}
	if ((cl) || (cr)) {
		pos = TEXT_TY_Compare(left_txt, right_txt);
		TEXT_TY_Untransmute(left_txt, cl, cpl);
		TEXT_TY_Untransmute(right_txt, cr, cpr);
		return pos;
	}
	capacity_left = BlkValueLBCapacity(left_txt);
	capacity_right = BlkValueLBCapacity(right_txt);
	for (pos=0:(pos<capacity_left) && (pos<capacity_right):pos++) {
		ch1 = BlkValueRead(left_txt, pos);
		ch2 = BlkValueRead(right_txt, pos);
		if (ch1 ~= ch2) return ch1-ch2;
		if (ch1 == 0) return 0;
	}
	if (pos == capacity_left) return -1;
	return 1;
];

[ TEXT_TY_Distinguish left_txt right_txt;
	if (TEXT_TY_Compare(left_txt, right_txt) == 0) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Hashing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Hash txt  rv len i p cp;
	cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt);
	rv = 0;
	len = BlkValueLBCapacity(txt);
	for (i=0: i<len: i++)
		rv = rv * 33 + BlkValueRead(txt, i);
	TEXT_TY_Untransmute(txt, p, cp);
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Say txt  ch i dsize;
	if (txt==0) rfalse;
	if (txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0) return PrintI6Text(txt-->1);
	dsize = BlkValueLBCapacity(txt);
	for (i=0: i<dsize: i++) {
		ch = BlkValueRead(txt, i);
		if (ch == 0) break;
		#ifdef TARGET_ZCODE;
		print (char) ch;
		#ifnot; ! TARGET_ZCODE
		@streamunichar ch;
		#endif;
	}
	if (i == 0) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Capitalised printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Say_Capitalised txt mod rc;
	mod = BlkValueCreate(TEXT_TY);
	TEXT_TY_SubstitutedForm(mod, txt);
	if (TEXT_TY_CharacterLength(mod) > 0) {
		BlkValueWrite(mod, 0, CharToCase(BlkValueRead(mod, 0), 1));
		TEXT_TY_Say(mod);
		rc = true;
		say__p = 1;
	}
	BlkValueFree(mod);
	return rc;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Serialisation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_WriteFile txt len pos ch p cp;
	cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt);
	len = BlkValueLBCapacity(txt);
	print "S";
	for (pos=0: pos<=len: pos++) {
		if (pos == len) ch = 0; else ch = BlkValueRead(txt, pos);
		if (ch == 0) {
			print "0;"; break;
		} else {
			print ch, ",";
		}
	}
	TEXT_TY_Untransmute(txt, p, cp);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Unserialisation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_ReadFile txt auxf ch i v dg pos tsize p;
	TEXT_TY_Transmute(txt);
	tsize = BlkValueLBCapacity(txt);
	while (ch ~= 32 or 9 or 10 or 13 or 0 or -1) {
		ch = FileIO_GetC(auxf);
		if (ch == ',' or ';') {
			if (pos+1 >= tsize) {
				if (BlkValueSetLBCapacity(txt, 2*pos) == false) break;
				tsize = BlkValueLBCapacity(txt);
			}
			BlkValueWrite(txt, pos++, v);
			v = 0;
			if (ch == ';') break;
		} else {
			dg = ch - '0';
			v = v*10 + dg;
		}
	}
	BlkValueWrite(txt, pos, 0);
	return txt;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Substitution
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_SubstitutedForm to txt;
	if (txt) {
		BlkValueCopy(to, txt);
		TEXT_TY_Transmute(to);
	}
	return to;
];

[ TEXT_TY_IsSubstituted txt;
	if ((txt) &&
		(txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0) &&
		(txt-->1 ofclass Routine)) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Perishability
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_ExpandIfPerishable to from;
	if ((from) && (from-->0 == CONSTANT_PERISHABLE_TEXT_STORAGE))
		return TEXT_TY_SubstitutedForm(to, from);
	return from;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Recognition-only-GPR
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_ROGPR txt p cp r;
	if (txt == 0) return GPR_FAIL;
	cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt);
	r = TEXT_TY_ROGPRI(txt);
	TEXT_TY_Untransmute(txt, p, cp);
	return r;
];
[ TEXT_TY_ROGPRI txt
	pos len wa wl wpos bdm ch own;
	bdm = true; own = wn;
	len = BlkValueLBCapacity(txt);
	for (pos=0: pos<=len: pos++) {
		if (pos == len) ch = 0; else ch = BlkValueRead(txt, pos);
		if (ch == 32 or 9 or 10 or 0) {
			if (bdm) continue;
			bdm = true;
			if (wpos ~= wl) return GPR_FAIL;
			if (ch == 0) break;
		} else {
			if (bdm) {
				bdm = false;
				if (NextWordStopped() == -1) return GPR_FAIL;
				wa = WordAddress(wn-1);
				wl = WordLength(wn-1);
				wpos = 0;
			}
			if (wa->wpos ~= ch or TEXT_TY_RevCase(ch)) return GPR_FAIL;
			wpos++;
		}
	}
	if (wn == own) return GPR_FAIL; ! Progress must be made to avoid looping
	return GPR_PREPOSITION;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Blobs
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant CHR_BLOB = 1; ! Construe as an array of characters
Constant WORD_BLOB = 2; ! Of words
Constant PWORD_BLOB = 3; ! Of punctuated words
Constant UWORD_BLOB = 4; ! Of unpunctuated words
Constant PARA_BLOB = 5; ! Of paragraphs
Constant LINE_BLOB = 6; ! Of lines

Constant REGEXP_BLOB = 7; ! Not a blob type as such, but needed as a distinct value


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Blob Access
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant WS_BRM = 1;
Constant SKIPPED_BRM = 2;
Constant ACCEPTED_BRM = 3;
Constant ACCEPTEDP_BRM = 4;
Constant ACCEPTEDN_BRM = 5;
Constant ACCEPTEDPN_BRM = 6;

[ TEXT_TY_BlobAccess txt blobtype ctxt wanted rtxt
	p1 p2 cp1 cp2 r;
	if (txt==0) return 0;
	if (blobtype == CHR_BLOB) return TEXT_TY_CharacterLength(txt);
	cp1 = txt-->0; p1 = TEXT_TY_Temporarily_Transmute(txt);
	cp2 = rtxt-->0; p2 = TEXT_TY_Temporarily_Transmute(rtxt);
	TEXT_TY_Transmute(ctxt);
	r = TEXT_TY_BlobAccessI(txt, blobtype, ctxt, wanted, rtxt);
	TEXT_TY_Untransmute(txt, p1, cp1);
	TEXT_TY_Untransmute(rtxt, p2, cp2);
	return r;
];
[ TEXT_TY_BlobAccessI txt blobtype ctxt wanted rtxt
	brm oldbrm ch i dsize csize blobcount gp cl j;
	dsize = BlkValueLBCapacity(txt);
	if (ctxt) csize = BlkValueLBCapacity(ctxt);
	else if (rtxt) "*** rtxt without ctxt ***";
	brm = WS_BRM;
	for (i=0:i<dsize:i++) {
		ch = BlkValueRead(txt, i);
		if (ch == 0) break;
		oldbrm = brm;
		if (ch == 10 or 13 or 32 or 9) {
			if (oldbrm ~= WS_BRM) {
				gp = 0;
				for (j=i:j<dsize:j++) {
					ch = BlkValueRead(txt, j);
					if (ch == 0) { brm = WS_BRM; break; }
					if (ch == 10 or 13) { gp++; continue; }
					if (ch ~= 32 or 9) break;
				}
				ch = BlkValueRead(txt, i);
				if (j == dsize) brm = WS_BRM;
				switch (blobtype) {
					PARA_BLOB: if (gp >= 2) brm = WS_BRM;
					LINE_BLOB: if (gp >= 1) brm = WS_BRM;
					default: brm = WS_BRM;
				}
			}
		} else {
			gp = false;
			if ((blobtype == WORD_BLOB or PWORD_BLOB or UWORD_BLOB) &&
				(ch == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}'))
				gp = true;
			switch (oldbrm) {
				WS_BRM:
					brm = ACCEPTED_BRM;
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				SKIPPED_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
					}
				ACCEPTED_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				ACCEPTEDP_BRM:
					if (blobtype == PWORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
						else {
							if ((ch == BlkValueRead(txt, i-1)) &&
								(ch == '-' or '.')) blobcount--;
							blobcount++;
						}
					}
				ACCEPTEDN_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				ACCEPTEDPN_BRM:
					if (blobtype == PWORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
						else {
							if ((ch == BlkValueRead(txt, i-1)) &&
								(ch == '-' or '.')) blobcount--;
							blobcount++;
						}
					}
			}
		}
		if (brm == ACCEPTED_BRM or ACCEPTEDP_BRM) {
			if (oldbrm ~= brm) blobcount++;
			if ((ctxt) && (blobcount == wanted)) {
				if (rtxt) {
					BlkValueWrite(ctxt, cl, 0);
					TEXT_TY_Concatenate(ctxt, rtxt, CHR_BLOB);
					csize = BlkValueLBCapacity(ctxt);
					cl = TEXT_TY_CharacterLength(ctxt);
					if (brm == ACCEPTED_BRM) brm = ACCEPTEDN_BRM;
					if (brm == ACCEPTEDP_BRM) brm = ACCEPTEDPN_BRM;
				} else {
					if (cl+1 >= csize) {
						if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
						csize = BlkValueLBCapacity(ctxt);
					}
					BlkValueWrite(ctxt, cl++, ch);
				}
			} else {
				if (rtxt) {
					if (cl+1 >= csize) {
						if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
						csize = BlkValueLBCapacity(ctxt);
					}
					BlkValueWrite(ctxt, cl++, ch);
				}
			}
		} else {
			if ((rtxt) && (brm ~= ACCEPTEDN_BRM or ACCEPTEDPN_BRM)) {
				if (cl+1 >= csize) {
					if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
					csize = BlkValueLBCapacity(ctxt);
				}
				BlkValueWrite(ctxt, cl++, ch);
			}
		}
	}
	if (ctxt) BlkValueWrite(ctxt, cl++, 0);
	return blobcount;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Get Blob
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_GetBlob ctxt txt wanted blobtype;
	if (txt==0) return;
	if (blobtype == CHR_BLOB) return TEXT_TY_GetCharacter(ctxt, txt, wanted);
	TEXT_TY_BlobAccess(txt, blobtype, ctxt, wanted);
	return ctxt;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Replace Blob
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_ReplaceBlob blobtype txt wanted rtxt ctxt ilen rlen i p cp;
	TEXT_TY_Transmute(txt);
	cp = rtxt-->0; p = TEXT_TY_Temporarily_Transmute(rtxt);
	if (blobtype == CHR_BLOB) {
		ilen = TEXT_TY_CharacterLength(txt);
		rlen = TEXT_TY_CharacterLength(rtxt);
		wanted--;
		if ((wanted >= 0) && (wanted<ilen)) {
			if (rlen == 1) {
				BlkValueWrite(txt, wanted, BlkValueRead(rtxt, 0));
			} else {
				ctxt = BlkValueCreate(TEXT_TY);
				TEXT_TY_Transmute(ctxt);
				if (BlkValueSetLBCapacity(ctxt, ilen+rlen+1)) {
					for (i=0:i<wanted:i++)
						BlkValueWrite(ctxt, i, BlkValueRead(txt, i));
					for (i=0:i<rlen:i++)
						BlkValueWrite(ctxt, wanted+i, BlkValueRead(rtxt, i));
					for (i=wanted+1:i<ilen:i++)
						BlkValueWrite(ctxt, rlen+i-1, BlkValueRead(txt, i));
					BlkValueWrite(ctxt, rlen+ilen, 0);
					BlkValueCopy(txt, ctxt);
				}
				BlkValueFree(ctxt);
			}
		}
	} else {
		ctxt = BlkValueCreate(TEXT_TY);
		TEXT_TY_BlobAccess(txt, blobtype, ctxt, wanted, rtxt);
		BlkValueCopy(txt, ctxt);
		BlkValueFree(ctxt);
	}
	TEXT_TY_Untransmute(rtxt, p, cp);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Replace Text
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_ReplaceText blobtype txt ftxt rtxt
	r p1 p2 cp1 cp2;
	TEXT_TY_Transmute(txt);
	cp1 = ftxt-->0; p1 = TEXT_TY_Temporarily_Transmute(ftxt);
	cp2 = rtxt-->0; p2 = TEXT_TY_Temporarily_Transmute(rtxt);
	r = TEXT_TY_ReplaceTextI(blobtype, txt, ftxt, rtxt);
	TEXT_TY_Untransmute(ftxt, p1, cp1);
	TEXT_TY_Untransmute(rtxt, p2, cp2);
	return r;
];

[ TEXT_TY_ReplaceTextI blobtype txt ftxt rtxt
	ctxt csize ilen flen i cl mpos ch chm whitespace punctuation;
	if (blobtype == REGEXP_BLOB or CHR_BLOB) 
		return TEXT_TY_Replace_RE(blobtype, txt, ftxt, rtxt);
	
	ilen = TEXT_TY_CharacterLength(txt);
	flen = TEXT_TY_CharacterLength(ftxt);
	ctxt = BlkValueCreate(TEXT_TY);
	TEXT_TY_Transmute(ctxt);
	csize = BlkValueLBCapacity(ctxt);
	mpos = 0;

	whitespace = true; punctuation = false;
	for (i=0:i<=ilen:i++) {
		ch = BlkValueRead(txt, i);
		.MoreMatching;
		chm = BlkValueRead(ftxt, mpos++);
		if (mpos == 1) {
			switch (blobtype) {
				WORD_BLOB:
					if ((whitespace == false) && (punctuation == false)) chm = -1;
			}
		}
		whitespace = false;
		if (ch == 10 or 13 or 32 or 9) whitespace = true;
		punctuation = false;
		if (ch == '.' or ',' or '!' or '?'
			or '-' or '/' or '"' or ':' or ';'
			or '(' or ')' or '[' or ']' or '{' or '}') {
			if (blobtype == WORD_BLOB) chm = -1;
			punctuation = true;
		}
		if (ch == chm) {
			if (mpos == flen) {
				if (i == ilen) chm = 0;
				else chm = BlkValueRead(txt, i+1);
				if ((blobtype == CHR_BLOB) ||
					(chm == 0 or 10 or 13 or 32 or 9) ||
					(chm == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) {
					mpos = 0;
					cl = cl - (flen-1);
					BlkValueWrite(ctxt, cl, 0);
					TEXT_TY_Concatenate(ctxt, rtxt, CHR_BLOB);
					csize = BlkValueLBCapacity(ctxt);
					cl = TEXT_TY_CharacterLength(ctxt);
					continue;
				}
			}
		} else {
			mpos = 0;
		}
		if (cl+1 >= csize) {
			if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
			csize = BlkValueLBCapacity(ctxt);
		}
		BlkValueWrite(ctxt, cl++, ch);
	}
	BlkValueCopy(txt, ctxt);	
	BlkValueFree(ctxt);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Character Length
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_CharacterLength txt ch i dsize p cp r;
	if (txt==0) return 0;
	cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt);
	dsize = BlkValueLBCapacity(txt); r = dsize;
	for (i=0:i<dsize:i++) {
		ch = BlkValueRead(txt, i);
		if (ch == 0) { r = i; break; }
	}
	TEXT_TY_Untransmute(txt, p, cp);
	return r;
];

[ TEXT_TY_Empty txt;
	if (txt==0) rtrue;
	if (txt-->0 & BLK_BVBITMAP_LONGBLOCKMASK == 0) {
		if (txt-->1 == EMPTY_TEXT_PACKED) rtrue;
		rfalse;
	}
	if (TEXT_TY_CharacterLength(txt) == 0) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Get Character
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_GetCharacter ctxt txt i ch p cp;
	if (txt==0) return 0;
	cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt);
	TEXT_TY_Transmute(ctxt);
	if ((i<=0) || (i>TEXT_TY_CharacterLength(txt))) ch = 0;
	else ch = BlkValueRead(txt, i-1);
	BlkValueWrite(ctxt, 0, ch);
	BlkValueWrite(ctxt, 1, 0);
	TEXT_TY_Untransmute(txt, p, cp);
	return ctxt;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Casing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_CharactersOfCase txt case i ch len p cp r;
	if (txt==0) return 0;
	cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt);
	len = TEXT_TY_CharacterLength(txt);
	r = true;
	for (i=0:i<len:i++) {
		ch = BlkValueRead(txt, i);
		if ((ch) && (CharIsOfCase(ch, case) == false)) { r = false; break; }
	}
	TEXT_TY_Untransmute(txt, p, cp);
	return r;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Change Case
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_CharactersToCase ctxt txt case i ch len bnd pk cp;
	if (txt==0) return 0;
	cp = txt-->0; pk = TEXT_TY_Temporarily_Transmute(txt);
	TEXT_TY_Transmute(ctxt);
	len = TEXT_TY_CharacterLength(txt);
	if (BlkValueSetLBCapacity(ctxt, len+1)) {
		bnd = 1;
		for (i=0:i<len:i++) {
			ch = BlkValueRead(txt, i);
			if (case < 2) {
				BlkValueWrite(ctxt, i, CharToCase(ch, case));
			} else {
				BlkValueWrite(ctxt, i, CharToCase(ch, bnd));
				if (case == 2) {
					bnd = 0;
					if (ch == 0 or 10 or 13 or 32 or 9
						or '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}') bnd = 1;
				}
				if (case == 3) {
					if (ch ~= 0 or 10 or 13 or 32 or 9) {
						if (bnd == 1) bnd = 0;
						else {
							if (ch == '.' or '!' or '?') bnd = 1;
						}
					}
				}
			}
		}
		BlkValueWrite(ctxt, len, 0);
	}
	TEXT_TY_Untransmute(txt, pk, cp);
	return ctxt;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Concatenation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Concatenate to_txt from_txt blobtype ref_txt
	p cp r;
	if (to_txt==0) rfalse;
	if (from_txt==0) return to_txt;
	TEXT_TY_Transmute(to_txt);
	cp = from_txt-->0; p = TEXT_TY_Temporarily_Transmute(from_txt);
	r = TEXT_TY_ConcatenateI(to_txt, from_txt, blobtype, ref_txt);
	TEXT_TY_Untransmute(from_txt, p, cp);
	return r;
];

[ TEXT_TY_ConcatenateI to_txt from_txt blobtype ref_txt
	pos len ch i tosize x y case;
	switch(blobtype) {
		CHR_BLOB, 0:
			pos = TEXT_TY_CharacterLength(to_txt);
			len = TEXT_TY_CharacterLength(from_txt);
			if (BlkValueSetLBCapacity(to_txt, pos+len+1) == false) return to_txt;
			for (i=0:i<len:i++) {
				ch = BlkValueRead(from_txt, i);
				BlkValueWrite(to_txt, i+pos, ch);
			}
			BlkValueWrite(to_txt, len+pos, 0);
			return to_txt;
		REGEXP_BLOB:
			return TEXT_TY_RE_Concatenate(to_txt, from_txt, blobtype, ref_txt);
	}
	print "*** TEXT_TY_Concatenate used on impossible blob type ***^";
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Text.i6t: Setting the Player's Command
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SetPlayersCommand from_txt i len at p cp;
	cp = from_txt-->0; p = TEXT_TY_Temporarily_Transmute(from_txt);
	len = TEXT_TY_CharacterLength(from_txt);
	if (len > 118) len = 118;
	#ifdef TARGET_ZCODE;
	buffer->1 = len; at = 2;
	#ifnot;
	buffer-->0 = len; at = 4;
	#endif;
	for (i=0:i<len:i++) buffer->(i+at) = CharToCase(BlkValueRead(from_txt, i), 0);
	for (:at+i<120:i++) buffer->(at+i) = ' ';
	VM_Tokenise(buffer, parse);
	players_command = 100 + WordCount(); ! The snippet variable "player's command"
	TEXT_TY_Untransmute(from_txt, p, cp);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Debugging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global TEXT_TY_RE_Trace = false; ! Change to true for (a lot of) debugging data in use
[ TEXT_TY_RE_SetTrace F; TEXT_TY_RE_Trace = F; ];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Algorithm
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Class Codes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! Character classes

Constant NEWLINE_RE_CC = -1;
Constant TAB_RE_CC = -2;
Constant DIGIT_RE_CC = -3;
Constant NONDIGIT_RE_CC = -4;
Constant WHITESPACE_RE_CC = -5;
Constant NONWHITESPACE_RE_CC = -6;
Constant PUNCTUATION_RE_CC = -7;
Constant NONPUNCTUATION_RE_CC = -8;
Constant WORD_RE_CC = -9;
Constant NONWORD_RE_CC = -10;
Constant ANYTHING_RE_CC = -11;
Constant NOTHING_RE_CC = -12;
Constant RANGE_RE_CC = -13;
Constant LCASE_RE_CC = -14;
Constant NONLCASE_RE_CC = -15;
Constant UCASE_RE_CC = -16;
Constant NONUCASE_RE_CC = -17;

! Control structures

Constant SUBEXP_RE_CC = -20;
Constant DISJUNCTION_RE_CC = -21;
Constant CHOICE_RE_CC = -22;
Constant QUANTIFIER_RE_CC = -23;
Constant IF_RE_CC = -24;
Constant CONDITION_RE_CC = -25;
Constant THEN_RE_CC = -26;
Constant ELSE_RE_CC = -27;

! Substring matchers

Constant VARIABLE_RE_CC = -30;
Constant LITERAL_RE_CC = -31;

! Positional matchers

Constant START_RE_CC = -40;
Constant END_RE_CC = -41;
Constant BOUNDARY_RE_CC = -42;
Constant NONBOUNDARY_RE_CC = -43;
Constant ALWAYS_RE_CC = -44;
Constant NEVER_RE_CC = -45;

! Mode switches

Constant SENSITIVITY_RE_CC = -50;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Packets
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RE_MAX_PACKETS = 32;

Constant RE_PACKET_SIZE = 14; ! Words of memory used per packet
Constant RE_PACKET_SIZE_IN_BYTES = WORDSIZE*RE_PACKET_SIZE; ! Bytes used per packet

Array RE_PACKET_space --> RE_MAX_PACKETS*RE_PACKET_SIZE;

Constant RE_CCLASS = 0;      ! One of the class codes defined above
Constant RE_PAR1 = 1;        ! Three parameters whose meaning depends on class code
Constant RE_PAR2 = 2;
Constant RE_PAR3 = 3;
Constant RE_NEXT = 4;        ! Younger sibling in the compiled tree
Constant RE_PREVIOUS = 5;    ! Elder sibling
Constant RE_DOWN = 6;        ! Child
Constant RE_UP = 7;          ! Parent
Constant RE_DATA1 = 8;       ! Backtracking data
Constant RE_DATA2 = 9;
Constant RE_CONSTRAINT = 10;
Constant RE_CACHE1 = 11;
Constant RE_CACHE2 = 12;
Constant RE_MODES = 13;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Nodes
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_Node n cc par1 par2 par3  offset;
	if ((n<0) || (n >= RE_MAX_PACKETS)) rfalse;
	offset = RE_PACKET_space + n*RE_PACKET_SIZE_IN_BYTES;
	offset-->RE_CCLASS = cc;
	offset-->RE_PAR1 = par1;
	offset-->RE_PAR2 = par2;
	offset-->RE_PAR3 = par3;
	offset-->RE_NEXT = NULL;
	offset-->RE_PREVIOUS = NULL;
	offset-->RE_DOWN = NULL;
	offset-->RE_UP = NULL;
	offset-->RE_DATA1 = -1; ! Match start
	offset-->RE_DATA2 = -1; ! Match end
	offset-->RE_CONSTRAINT = -1; ! Rewind edge
	return offset;
];

[ TEXT_TY_RE_NodeAddress n;
	if ((n<0) || (n >= RE_MAX_PACKETS)) return -1;
	return RE_PACKET_space + n*RE_PACKET_SIZE_IN_BYTES;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Match Variables
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array RE_Subexpressions --> 11; ! Address of node for this subexpression
Array Allocated_Match_Vars --> 10; ! Indexed text to hold values of the variables

[ TEXT_TY_RE_DebugMatchVars txt
	offset n i;
	print RE_Subexpressions-->10, " collecting subexps^";
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++) {
		offset = RE_Subexpressions-->n;
		print "Subexp ", offset-->RE_PAR1,
			" = [", offset-->RE_DATA1, ",", offset-->RE_DATA2, "] = ";
		for (i=offset-->RE_DATA1:i<offset-->RE_DATA2:i++)
			print (char) BlkValueRead(txt, i);
		print "^";
	}
];

[ TEXT_TY_RE_CreateMatchVars txt
	offset n i ch ctxt cl csize;
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++) {
		offset = RE_Subexpressions-->n;
		if (Allocated_Match_Vars-->n) BlkValueFree(Allocated_Match_Vars-->n);
		Allocated_Match_Vars-->n = BlkValueCreate(TEXT_TY);
		TEXT_TY_Transmute(Allocated_Match_Vars-->n);
		ctxt = Allocated_Match_Vars-->n;
		csize = BlkValueLBCapacity(ctxt);
		cl = 0;
		for (i=offset-->RE_DATA1:i<offset-->RE_DATA2:i++) {
			ch = BlkValueRead(txt, i);
			if (cl+1 >= csize) {
				if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
				csize = BlkValueLBCapacity(ctxt);
			}
			BlkValueWrite(ctxt, cl++, ch);
		}
		BlkValueWrite(ctxt, cl, 0);
	}
];

[ TEXT_TY_RE_EmptyMatchVars txt
	n;
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++)
		if (Allocated_Match_Vars-->n ~= 0)
			BlkValueWrite(Allocated_Match_Vars-->n, 0, 0);
];

[ TEXT_TY_RE_GetMatchVar vn
	offset;
	if ((vn<0) || (vn>=10) || (vn >= RE_Subexpressions-->10)) return EMPTY_TEXT_VALUE;
	offset = RE_Subexpressions-->vn;
	if (offset == 0) return EMPTY_TEXT_VALUE;
	if (offset-->RE_DATA1 < 0) return EMPTY_TEXT_VALUE;
	if (Allocated_Match_Vars-->vn == 0) {
		print "*** ", vn, " unallocated! ***^";
		return EMPTY_TEXT_VALUE;
	}
	return Allocated_Match_Vars-->vn;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Markers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_MV_End n end
	offset;
	offset = RE_Subexpressions-->n;
	if (end==0) return offset-->RE_DATA1;
	return offset-->RE_DATA2;
];

[ TEXT_TY_RE_Clear_Markers token;
	for (: token ~= NULL: token = token-->RE_NEXT) {
		if (token-->RE_DOWN ~= NULL) TEXT_TY_RE_Clear_Markers(token-->RE_DOWN);
		token-->RE_DATA1 = -1;
		token-->RE_DATA2 = -1;
		token-->RE_CONSTRAINT = -1;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Debugging
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_DebugTree ftxt detail;
	print "Pattern: ", (TEXT_TY_Say) ftxt, "^";
	TEXT_TY_RE_DebugSubtree(ftxt, 1, RE_PACKET_space, detail);
];

[ TEXT_TY_RE_DebugSubtree ftxt depth offset detail
	cup;
	if (offset ~= NULL) {
		cup = offset-->RE_UP;
		if (offset-->RE_PREVIOUS ~= NULL) print "*** broken initial previous ***^";
	}
	while (offset ~= NULL) {
		if (offset-->RE_UP ~= cup) print "*** broken up matching ***^";
		spaces(depth*2);
		TEXT_TY_RE_DebugNode(offset, ftxt, detail);
		if (offset-->RE_DOWN ~= NULL) {
			if ((offset-->RE_DOWN)-->RE_UP ~= offset)
				print "*** broken down/up ***^";
			TEXT_TY_RE_DebugSubtree(ftxt, depth+1, offset-->RE_DOWN, detail);
		}
		if (offset-->RE_NEXT ~= NULL) {
			if ((offset-->RE_NEXT)-->RE_PREVIOUS ~= offset)
				print "*** broken next/previous ***^";
		}
		offset = offset-->RE_NEXT;
	}
];

[ TEXT_TY_RE_DebugNode offset ftxt detail
	i par1 par2 par3;
	if (offset == NULL) "[NULL]";
	print "[", (offset-RE_PACKET_space)/(RE_PACKET_SIZE_IN_BYTES), "] ";
	! for (i=0:i<RE_PACKET_SIZE:i++) print offset-->i, " ";
	par1 = offset-->RE_PAR1;
	par2 = offset-->RE_PAR2;
	par3 = offset-->RE_PAR3;
	switch (offset-->RE_CCLASS) {
		DIGIT_RE_CC: print "DIGIT";
		NONDIGIT_RE_CC: print "NONDIGIT";
		UCASE_RE_CC: print "UCASE";
		NONUCASE_RE_CC: print "NONUCASE";
		LCASE_RE_CC: print "LCASE";
		NONLCASE_RE_CC: print "NONLCASE";
		WHITESPACE_RE_CC: print "WHITESPACE";
		NONWHITESPACE_RE_CC: print "NONWHITESPACE";
		PUNCTUATION_RE_CC: print "PUNCTUATION";
		NONPUNCTUATION_RE_CC: print "NONPUNCTUATION";
		WORD_RE_CC: print "WORD";
		NONWORD_RE_CC: print "NONWORD";
		ALWAYS_RE_CC: print "ALWAYS";
		NEVER_RE_CC: print "NEVER";
		START_RE_CC: print "START";
		END_RE_CC: print "END";
		BOUNDARY_RE_CC: print "BOUNDARY";
		NONBOUNDARY_RE_CC: print "NONBOUNDARY";
		ANYTHING_RE_CC: print "ANYTHING";
		NOTHING_RE_CC: print "NOTHING";
		RANGE_RE_CC: print "RANGE"; if (par3 == true) print " (negated)";
			print " ";
			for (i=par1:i<par2:i++) print (char) BlkValueRead(ftxt, i);
		VARIABLE_RE_CC: print "VARIABLE ", par1;
		SUBEXP_RE_CC:
			if (par1 == 0) print "EXP";
			else print "SUBEXP ";
			if (par1 >= 0) print "= V", par1;
			if (par2 == 1) {
				if (par3 == 0) print " (?=...) lookahead";
				else print " (?<=...) lookbehind of width ", par3;
			}
			if (par2 == 2) {
				if (par3 == 0) print " (?!...) negated lookahead";
				else print " (?<!...) negated lookbehind of width ", par3;
			}
			if (par2 == 3) print " uncollecting";
			if (par2 == 0 or 3) {
				if (par3 == 1) print " forcing case sensitivity";
				if (par3 == 2) print " forcing case insensitivity";
			}
			if (par2 == 4) print " (?>...) possessive";
		NEWLINE_RE_CC: print "NEWLINE";
		TAB_RE_CC: print "TAB";
		QUANTIFIER_RE_CC: print "QUANTIFIER min=", par1, " max=", par2;
			if (par3) print " (lazy)"; else print " (greedy)";
		LITERAL_RE_CC: print "LITERAL";
			print " ";
			for (i=par1:i<par2:i++) print (char) BlkValueRead(ftxt, i);
		DISJUNCTION_RE_CC: print "DISJUNCTION of ", par1, " choices";
		CHOICE_RE_CC: print "CHOICE no ", par1;
		SENSITIVITY_RE_CC: print "SENSITIVITY";
			if (par1) print " off"; else print " on";
		IF_RE_CC: print "IF"; if (par1 >= 1) print " = V", par1;
		CONDITION_RE_CC: print "CONDITION"; if (par1 >= 1) print " = V", par1;
		THEN_RE_CC: print "THEN";
		ELSE_RE_CC: print "ELSE";
	}
	if (detail)
		print ": ", offset-->RE_DATA1, ", ", offset-->RE_DATA2, ", ", offset-->RE_CONSTRAINT;
	print "^";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Compiling Tree For Substring Search
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_CHR_CompileTree ftxt exactly
	root literal fto no_packets token attach_to;

	fto = TEXT_TY_CharacterLength(ftxt);

	root = TEXT_TY_RE_Node(0, SUBEXP_RE_CC, 0, 0, 0);
	literal = TEXT_TY_RE_Node(1, LITERAL_RE_CC, 0, fto, 0);
	
	root-->RE_DOWN = literal;
	literal-->RE_UP = root;

	if (exactly) {
		no_packets = 2;
		if (no_packets+3 > RE_MAX_PACKETS) return "regexp too complex";
		exactly = RE_PACKET_space-->RE_DOWN;
		token = TEXT_TY_RE_Node(no_packets++, START_RE_CC, 0, 0, 0);
		RE_PACKET_space-->RE_DOWN = token; token-->RE_UP = RE_PACKET_space;
		attach_to = TEXT_TY_RE_Node(no_packets++, SUBEXP_RE_CC, -1, 3, 0);
		token-->RE_NEXT = attach_to; attach_to-->RE_PREVIOUS = token;
		attach_to-->RE_UP = RE_PACKET_space;
		attach_to-->RE_NEXT = TEXT_TY_RE_Node(no_packets++, END_RE_CC, 0, 0, 0);
		(attach_to-->RE_NEXT)-->RE_PREVIOUS = attach_to;
		(attach_to-->RE_NEXT)-->RE_UP = RE_PACKET_space;
		attach_to-->RE_DOWN = exactly;
		while (exactly ~= NULL) {
			exactly-->RE_UP = attach_to; exactly = exactly-->RE_NEXT;
		}
	}
	
	no_packets = TEXT_TY_RE_ExpandChoices(RE_PACKET_space, no_packets);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Compiling Tree For Regexp Search
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array Subexp_Posns --> 20;
[ TEXT_TY_RE_CompileTree ftxt exactly
	no_packets ffrom fto cc par1 par2 par3
	quantifiable token attach_to no_subs blevel bits;

	fto = TEXT_TY_CharacterLength(ftxt);
	if (fto == 0) {
		TEXT_TY_RE_Node(no_packets++, NEVER_RE_CC, 0, 0, 0); ! Empty regexp never matches
		return 1;
	}

	attach_to = TEXT_TY_RE_Node(no_packets++, SUBEXP_RE_CC, 0, 0, 0);
	RE_Subexpressions-->0 = attach_to; RE_Subexpressions-->10 = 1; no_subs = 1;

	quantifiable = false; blevel = 0;
	
	for (ffrom = 0: ffrom < fto: ) {
		cc = BlkValueRead(ftxt, ffrom++); par1 = 0; par2 = 0; par3 = 0;
		if (cc == '\') {
			if (ffrom == fto) return "Search pattern not terminated";
			cc = BlkValueRead(ftxt, ffrom++);
			switch (cc) {
				'b': cc = BOUNDARY_RE_CC;
				'B': cc = NONBOUNDARY_RE_CC;
				'd': cc = DIGIT_RE_CC;
				'D': cc = NONDIGIT_RE_CC;
				'l': cc = LCASE_RE_CC;
				'L': cc = NONLCASE_RE_CC;
				'n': cc = NEWLINE_RE_CC;
				'p': cc = PUNCTUATION_RE_CC;
				'P': cc = NONPUNCTUATION_RE_CC;
				's': cc = WHITESPACE_RE_CC;
				'S': cc = NONWHITESPACE_RE_CC;
				't': cc = TAB_RE_CC;
				'u': cc = UCASE_RE_CC;
				'U': cc = NONUCASE_RE_CC;
				'w': cc = WORD_RE_CC;
				'W': cc = NONWORD_RE_CC;
				default:
					if ((cc >= '1') && (cc <= '9')) {
						par1 = cc-'0';
						cc = VARIABLE_RE_CC;
					} else {
						if (((cc >= 'a') && (cc <= 'z')) ||
							((cc >= 'A') && (cc <= 'Z'))) return "unknown escape";
						cc = LITERAL_RE_CC;
						par1 = ffrom-1; par2 = ffrom;
					}
			}
			quantifiable = true;
		} else {
			switch (cc) {
				'(': par2 = 0;
					!if (BlkValueRead(ftxt, ffrom) == ')') return "empty subexpression";
					if (BlkValueRead(ftxt, ffrom) == '?') {
						ffrom++;
						bits = true;
						if (BlkValueRead(ftxt, ffrom) == '-') { ffrom++; bits = false; }
						else if (BlkValueRead(ftxt, ffrom) == '<') { ffrom++; bits = false; }
						switch (cc = BlkValueRead(ftxt, ffrom++)) {
							'#': while (BlkValueRead(ftxt, ffrom++) ~= 0 or ')') ;
								if (BlkValueRead(ftxt, ffrom-1) == 0)
									return "comment never ends";
								continue;
							'(': cc = BlkValueRead(ftxt, ffrom);
								if ((cc == '1' or '2' or '3' or '4' or
									'5' or '6' or '7' or '8' or '9') &&
									(BlkValueRead(ftxt, ffrom+1) ==')')) {
									ffrom = ffrom + 2;
									par1 = cc - '0';
								} else ffrom--;
								cc = IF_RE_CC; ! (?(...)...) conditional
								quantifiable = false;
								if (blevel == 20) return "subexpressions too deep";
								Subexp_Posns-->(blevel++) = TEXT_TY_RE_NodeAddress(no_packets);
								jump CClassKnown;
							'=': par2 = 1; ! (?=...) lookahead/behind
								par3 = 0; if (bits == false) par3 = -1;
							'!': par2 = 2; ! (?!...) negated lookahead/behind
								par3 = 0; if (bits == false) par3 = -1;
							':': par2 = 3; ! (?:...) uncollecting subexpression
							'>': par2 = 4; ! (?>...) possessive
							default:
								if (BlkValueRead(ftxt, ffrom) == ')') {
									if (cc == 'i') {
										cc = SENSITIVITY_RE_CC; par1 = bits; ffrom++;
										jump CClassKnown;
									}
								}
								if (BlkValueRead(ftxt, ffrom) == ':') {
									if (cc == 'i') {
										par1 = bits; par2 = 3; par3 = bits+1; ffrom++;
										jump AllowForm;
									}
								}
								return "unknown (?...) form";
						}
					}
					.AllowForm;
					if (par2 == 0) par1 = no_subs++; else par1 = -1;
					cc = SUBEXP_RE_CC; 
					quantifiable = false;
					if (blevel == 20) return "subexpressions too deep";
					Subexp_Posns-->(blevel++) = TEXT_TY_RE_NodeAddress(no_packets);
				')': if (blevel == 0) return "subexpression bracket mismatch";
					blevel--;
					attach_to = Subexp_Posns-->blevel;
					if (attach_to-->RE_DOWN == NULL) {
						if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
						attach_to-->RE_DOWN =
							TEXT_TY_RE_Node(no_packets++, ALWAYS_RE_CC, 0, 0, 0);
						(attach_to-->RE_DOWN)-->RE_UP = attach_to;
					}
					quantifiable = true;
					continue;
				'.': cc = ANYTHING_RE_CC; quantifiable = true;
				'|': cc = CHOICE_RE_CC; quantifiable = false;
				'^': cc = START_RE_CC; quantifiable = false;
				'$': cc = END_RE_CC; quantifiable = false;
				'{': if (quantifiable == false) return "quantifier misplaced";
					par1 = 0; par2 = -1; bits = 1;
					while ((cc=BlkValueRead(ftxt, ffrom++)) ~= 0 or '}') {
						if (cc == ',') {
							bits++;
							if (bits >= 3) return "too many colons in ?{...}";
							continue;
						}
						if ((cc >= '0') || (cc <= '9')) {
							if (bits == 1) {
								if (par1 < 0) par1 = 0;
								par1 = par1*10 + (cc-'0');
							} else {
								if (par2 < 0) par2 = 0;
								par2 = par2*10 + (cc-'0');
							}
						} else return "non-digit in ?{...}";
					}
					if (cc ~= '}') return "{x,y} quantifier never ends";
					cc = QUANTIFIER_RE_CC;
					if (par2 == -1) {
						if (bits == 2) par2 = 30000;
						else par2 = par1;
					}
					if (par1 > par2) return "{x,y} with x greater than y";
					if (BlkValueRead(ftxt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'<', '[': par3 = false; if (cc == '<') bits = '>'; else bits = ']';
					if (BlkValueRead(ftxt, ffrom) == '^') { ffrom++; par3 = true; }
					par1 = ffrom;
					if (BlkValueRead(ftxt, ffrom) == bits) { ffrom++; }
					while (cc ~= bits or 0) {
						cc = BlkValueRead(ftxt, ffrom++);
						if (cc == '\') {
							cc = BlkValueRead(ftxt, ffrom++);
							if (cc ~= 0) cc = BlkValueRead(ftxt, ffrom++);
						}
					}
					if (cc == 0) return "Character range never ends";
					par2 = ffrom-1;
					if ((par2 > par1 + 1) &&
						(BlkValueRead(ftxt, par1) == ':') &&
						(BlkValueRead(ftxt, par2-1) == ':') &&
						(BlkValueRead(ftxt, par2-2) ~= '\'))
						return "POSIX named character classes unsupported";
					bits = TEXT_TY_RE_RangeSyntaxCorrect(ftxt, par1, par2);
					if (bits) return bits;
					if (par1 < par2) cc = RANGE_RE_CC;
					else cc = NOTHING_RE_CC;
					quantifiable = true;
				'*': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 0; par2 = 30000;
					if (BlkValueRead(ftxt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'+': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 1; par2 = 30000;
					if (BlkValueRead(ftxt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'?': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 0; par2 = 1;
					if (BlkValueRead(ftxt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
			}
		}
		
		.CClassKnown;
		
		if (cc >= 0) {
			quantifiable = true;
			if ((attach_to-->RE_CCLASS == LITERAL_RE_CC) &&
				(BlkValueRead(ftxt, ffrom) ~= '*' or '+' or '?' or '{')) {
				(attach_to-->RE_PAR2)++;
				if (TEXT_TY_RE_Trace == 2) {
					print "Extending literal by ", cc, "=", (char) cc, "^";
				}
				continue;
			}
			cc = LITERAL_RE_CC; par1 = ffrom-1; par2 = ffrom;
		}
		
		if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";

		if (TEXT_TY_RE_Trace == 2) {
			print "Attaching packet ", no_packets+1, " to ";
			TEXT_TY_RE_DebugNode(attach_to, ftxt);
			TEXT_TY_RE_DebugTree(ftxt);
		}

		token = TEXT_TY_RE_Node(no_packets++, cc, par1, par2, par3);

		if ((token-->RE_CCLASS == SUBEXP_RE_CC) && (token-->RE_PAR2 == 0)) {
			RE_Subexpressions-->(token-->RE_PAR1) = token;
			(RE_Subexpressions-->10)++;
		}
		
		if ((attach_to-->RE_CCLASS == SUBEXP_RE_CC or CHOICE_RE_CC or IF_RE_CC) &&
			(attach_to-->RE_DOWN == NULL)) {
			attach_to-->RE_DOWN = token; token-->RE_UP = attach_to;
		} else {
			if ((token-->RE_CCLASS == CHOICE_RE_CC) &&
				((attach_to-->RE_UP)-->RE_CCLASS == CHOICE_RE_CC)) {
				no_packets--; token = attach_to-->RE_UP;
			} else {
				if (token-->RE_CCLASS == CHOICE_RE_CC) {
					while (attach_to-->RE_PREVIOUS ~= NULL)
						attach_to = attach_to-->RE_PREVIOUS;
				}
				if (token-->RE_CCLASS == QUANTIFIER_RE_CC or CHOICE_RE_CC) {
					token-->RE_PREVIOUS = attach_to-->RE_PREVIOUS;
					token-->RE_UP = attach_to-->RE_UP;
					if ((attach_to-->RE_UP ~= NULL) && (attach_to-->RE_PREVIOUS == NULL))
						(attach_to-->RE_UP)-->RE_DOWN = token;
					token-->RE_DOWN = attach_to;
					bits = attach_to;
					while (bits ~= NULL) {
						bits-->RE_UP = token;
						bits = bits-->RE_NEXT;
					}
					attach_to-->RE_PREVIOUS = NULL;
					if (token-->RE_PREVIOUS ~= NULL)
						(token-->RE_PREVIOUS)-->RE_NEXT = token;
				} else {
					attach_to-->RE_NEXT = token; token-->RE_PREVIOUS = attach_to;
					token-->RE_UP = attach_to-->RE_UP;
				}
			}
		}
		
		if (token-->RE_CCLASS == CHOICE_RE_CC) {
			if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
			token-->RE_NEXT = TEXT_TY_RE_Node(no_packets++, CHOICE_RE_CC, 0, 0, 0);
			(token-->RE_NEXT)-->RE_PREVIOUS = token;
			(token-->RE_NEXT)-->RE_UP = token-->RE_UP;
			token = token-->RE_NEXT;
		}

		attach_to = token;

		if (TEXT_TY_RE_Trace == 2) {
			print "Result:^";
			TEXT_TY_RE_DebugTree(ftxt);
		}

	}
	
	if (blevel ~= 0) return "subexpression bracket mismatch";

	if (exactly) {
		if (no_packets+3 > RE_MAX_PACKETS) return "regexp too complex";
		exactly = RE_PACKET_space-->RE_DOWN;
		token = TEXT_TY_RE_Node(no_packets++, START_RE_CC, 0, 0, 0);
		RE_PACKET_space-->RE_DOWN = token; token-->RE_UP = RE_PACKET_space;
		attach_to = TEXT_TY_RE_Node(no_packets++, SUBEXP_RE_CC, -1, 3, 0);
		token-->RE_NEXT = attach_to; attach_to-->RE_PREVIOUS = token;
		attach_to-->RE_UP = RE_PACKET_space;
		attach_to-->RE_NEXT = TEXT_TY_RE_Node(no_packets++, END_RE_CC, 0, 0, 0);
		(attach_to-->RE_NEXT)-->RE_PREVIOUS = attach_to;
		(attach_to-->RE_NEXT)-->RE_UP = RE_PACKET_space;
		attach_to-->RE_DOWN = exactly;
		while (exactly ~= NULL) {
			exactly-->RE_UP = attach_to; exactly = exactly-->RE_NEXT;
		}
	}
	
	no_packets = TEXT_TY_RE_ExpandChoices(RE_PACKET_space, no_packets);

	if (TEXT_TY_RE_Trace) {
		print "Compiled pattern:^";
		TEXT_TY_RE_DebugTree(ftxt);
	}
	
	bits = TEXT_TY_RE_CheckTree(RE_PACKET_space, no_subs); if (bits) return bits;
	
	return no_packets;
];

[ TEXT_TY_RE_RangeSyntaxCorrect ftxt rf rt
	i chm;
	for (i=rf: i<rt: i++) {
		chm = BlkValueRead(ftxt, i);
		if ((chm == '\') && (i+1<rt)) {
			chm = BlkValueRead(ftxt, ++i);
			if (((chm >= 'a') && (chm <= 'z')) ||
				((chm >= 'A') && (chm <= 'Z'))) {
				if (chm ~= 's' or 'S' or 'p' or 'P' or 'w' or 'W' or 'd'
					or 'D' or 'n' or 't' or 'l' or 'L' or 'u' or 'U')
					return "Invalid escape in {} range";
			}
		}
		if ((i+2<rt) && (BlkValueRead(ftxt, i+1) == '-')) {
			if (chm > BlkValueRead(ftxt, i+2)) return "Invalid {} range";
			i=i+2;
		}
	}
	rfalse;
];

[ TEXT_TY_RE_ExpandChoices token no_packets
	rv prev nex holder new ct n cond_node then_node else_node;
	while (token ~= NULL) {
		if (token-->RE_CCLASS == IF_RE_CC) {
			if ((token-->RE_DOWN)-->RE_CCLASS == CHOICE_RE_CC) {
				for (nex=token-->RE_DOWN, n=0: nex~=NULL: nex=nex-->RE_NEXT) n++;
				if (n~=2) return "conditional has too many clauses";
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				cond_node = TEXT_TY_RE_Node(no_packets++, CONDITION_RE_CC, 0, 0, 0);
				if (token-->RE_PAR1 >= 1) {
					cond_node-->RE_PAR1 = token-->RE_PAR1;
				}
				then_node = token-->RE_DOWN;
				then_node-->RE_CCLASS = THEN_RE_CC;
				else_node = then_node-->RE_NEXT;
				else_node-->RE_CCLASS = ELSE_RE_CC;
				if (cond_node-->RE_PAR1 < 1) {
					cond_node-->RE_DOWN = then_node-->RE_DOWN;
					then_node-->RE_DOWN = (then_node-->RE_DOWN)-->RE_NEXT;
					if (then_node-->RE_DOWN ~= NULL)
						(then_node-->RE_DOWN)-->RE_PREVIOUS = NULL;
					(cond_node-->RE_DOWN)-->RE_NEXT = NULL;
					(cond_node-->RE_DOWN)-->RE_UP = cond_node;
				}
				token-->RE_DOWN = cond_node; cond_node-->RE_UP = token;
				cond_node-->RE_NEXT = then_node; then_node-->RE_PREVIOUS = cond_node;
			} else {
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				cond_node = TEXT_TY_RE_Node(no_packets++, CONDITION_RE_CC, 0, 0, 0);
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				then_node = TEXT_TY_RE_Node(no_packets++, THEN_RE_CC, 0, 0, 0);
				if (token-->RE_PAR1 >= 1) {
					cond_node-->RE_PAR1 = token-->RE_PAR1;
					then_node-->RE_DOWN = token-->RE_DOWN;
				} else {
					cond_node-->RE_DOWN = token-->RE_DOWN;
					then_node-->RE_DOWN = (token-->RE_DOWN)-->RE_NEXT;
					(cond_node-->RE_DOWN)-->RE_NEXT = NULL;
					(cond_node-->RE_DOWN)-->RE_UP = cond_node;
				}
				token-->RE_DOWN = cond_node;
				cond_node-->RE_UP = token; cond_node-->RE_NEXT = then_node;
				then_node-->RE_PREVIOUS = cond_node; then_node-->RE_UP = token;
				then_node-->RE_NEXT = NULL;
				if (then_node-->RE_DOWN ~= NULL)
					(then_node-->RE_DOWN)-->RE_PREVIOUS = NULL;
				for (nex = then_node-->RE_DOWN: nex ~= NULL: nex = nex-->RE_NEXT) {
					nex-->RE_UP = then_node;
				}
			}
			
			if (cond_node-->RE_DOWN ~= NULL) {
				nex = cond_node-->RE_DOWN;
				if ((nex-->RE_CCLASS ~= SUBEXP_RE_CC) ||
					(nex-->RE_NEXT ~= NULL) ||
					(nex-->RE_PAR2 ~= 1 or 2)) {
					!TEXT_TY_RE_DebugSubtree(0, 0, nex, true);
					return "condition not lookahead/behind";
				}
			}
		}
		if ((token-->RE_CCLASS == CHOICE_RE_CC) && (token-->RE_PAR1 < 1)) {
			prev = token-->RE_PREVIOUS;
			nex = token-->RE_NEXT;
			while ((nex ~= NULL) && (nex-->RE_CCLASS == CHOICE_RE_CC))
				nex = nex-->RE_NEXT;
			holder = token-->RE_UP; if (holder == NULL) return "bang";
			if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
			new = TEXT_TY_RE_Node(no_packets++, DISJUNCTION_RE_CC, 0, 0, 0);
			holder-->RE_DOWN = new; new-->RE_UP = holder;
			if (prev ~= NULL) {
				prev-->RE_NEXT = new; new-->RE_PREVIOUS = prev;
			}
			if (nex ~= NULL) {
				nex-->RE_PREVIOUS = new; new-->RE_NEXT = nex;
			}
			new-->RE_DOWN = token;
			token-->RE_PREVIOUS = NULL;
			ct = 1;
			while (token ~= NULL) {
				token-->RE_PAR1 = ct++;
				token-->RE_UP = new;
				if ((token-->RE_NEXT ~= NULL) &&
					((token-->RE_NEXT)-->RE_CCLASS ~= CHOICE_RE_CC))
					token-->RE_NEXT = NULL;
				token = token-->RE_NEXT;
			}
			new-->RE_PAR1 = ct-1;
			if (token ~= NULL) token-->RE_NEXT = NULL;
			token = new; continue;
		}
		if (token-->RE_DOWN ~= NULL) {
			no_packets = TEXT_TY_RE_ExpandChoices(token-->RE_DOWN, no_packets);
			if ((no_packets<0) || (no_packets >= RE_MAX_PACKETS)) break;
		}
		token = token-->RE_NEXT;
	}
	return no_packets;
];

[ TEXT_TY_RE_CheckTree token no_subs
	rv;
	while (token ~= NULL) {
		if (token-->RE_CCLASS == VARIABLE_RE_CC) {
			if (token-->RE_PAR1 >= no_subs) return "reference to nonexistent group";
		}
		if ((token-->RE_CCLASS == SUBEXP_RE_CC) &&
			(token-->RE_PAR2 == 1 or 2) &&
			(token-->RE_PAR3 == -1)) {
			token-->RE_PAR3 = TEXT_TY_RE_Width(token-->RE_DOWN);
			if (token-->RE_PAR3 == -1) return "variable length lookbehind not implemented";
		}
		if (token-->RE_DOWN ~= NULL) {
			rv = TEXT_TY_RE_CheckTree(token-->RE_DOWN, no_subs);
			if (rv) return rv;
		}
		token = token-->RE_NEXT;
	}
	rfalse;
];

[ TEXT_TY_RE_Width token downwards
	w rv aw choice;
	while (token ~= NULL) {
		switch (token-->RE_CCLASS) {
			DIGIT_RE_CC, NONDIGIT_RE_CC, WHITESPACE_RE_CC, NONWHITESPACE_RE_CC,
			PUNCTUATION_RE_CC, NONPUNCTUATION_RE_CC, WORD_RE_CC, NONWORD_RE_CC,
			ANYTHING_RE_CC, NOTHING_RE_CC, RANGE_RE_CC, NEWLINE_RE_CC, TAB_RE_CC,
			UCASE_RE_CC, NONUCASE_RE_CC, LCASE_RE_CC, NONLCASE_RE_CC:
				w++;
			START_RE_CC, END_RE_CC, BOUNDARY_RE_CC, NONBOUNDARY_RE_CC, ALWAYS_RE_CC:
				;
			LITERAL_RE_CC:
				w = w + token-->RE_PAR2 - token-->RE_PAR1;
			VARIABLE_RE_CC:
				return -1;
			IF_RE_CC:
				rv = TEXT_TY_RE_Width((token-->RE_DOWN)-->RE_NEXT);
				if (rv == -1) return -1;
				if (rv ~= TEXT_TY_RE_Width(((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT))
					return -1;
				w = w + rv;
			SUBEXP_RE_CC:
				if (token-->RE_PAR2 == 1 or 2) rv = 0;
				else {
					rv = TEXT_TY_RE_Width(token-->RE_DOWN);
					if (rv == -1) return -1;
				}
				w = w + rv;
			QUANTIFIER_RE_CC:
				if (token-->RE_PAR1 ~= token-->RE_PAR2) return -1;
				rv = TEXT_TY_RE_Width(token-->RE_DOWN);
				if (rv == -1) return -1;
				w = w + rv*(token-->RE_PAR1);				
			DISJUNCTION_RE_CC:
				aw = -1;
				for (choice = token-->RE_DOWN: choice ~= NULL: choice = choice-->RE_NEXT) {
					rv = TEXT_TY_RE_Width(choice-->RE_DOWN);
					!print "Option found ", rv, "^";
					if (rv == -1) return -1;
					if ((aw >= 0) && (aw ~= rv)) return -1;
					aw = rv;
				}
				w = w + aw;
			SENSITIVITY_RE_CC:
				;
		}
		if (downwards) return w;
		if (token ~= NULL) token = token-->RE_NEXT;
	}
	return w;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Parser
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global TEXT_TY_RE_RewindCount;
[ TEXT_TY_RE_PrintNoRewinds; print TEXT_TY_RE_RewindCount; ];

Constant CIS_MFLAG = 1;
Constant ACCUM_MFLAG = 2;

[ TEXT_TY_RE_Parse ftxt txt ipos insens
	ilen rv root i initial_mode;

	ilen = TEXT_TY_CharacterLength(txt);
	if ((ipos<0) || (ipos>ilen)) return -1;
	
	root = RE_PACKET_space;
	
	initial_mode = 0; if (insens) initial_mode = CIS_MFLAG;
	
	TEXT_TY_RE_Clear_Markers(RE_PACKET_space);
	
	for (:ipos<=ilen:ipos++) {
		if ((RE_PACKET_space-->RE_DOWN ~= NULL) &&
			((RE_PACKET_space-->RE_DOWN)-->RE_CCLASS == START_RE_CC) &&
			(ipos>0)) { rv = -1; break; }
		if (ipos > 0) TEXT_TY_RE_EraseConstraints(RE_PACKET_space, initial_mode);
		TEXT_TY_RE_RewindCount = 0;
		rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ilen, RE_PACKET_space, initial_mode);
		if (rv >= 0) break;
	}

	if (rv == -1) {
		root-->RE_DATA1 = -1;
		root-->RE_DATA2 = -1;
	} else {
		root-->RE_DATA1 = ipos;
		root-->RE_DATA2 = ipos+rv;
	}
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Parse At Position
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_ParseAtPosition ftxt txt ifrom ito token mode_flags
	outcome ipos npos rv i ch edge rewind_this;

	if (ifrom > ito) return -1;

	ipos = ifrom;

	.Rewind;
	while (token ~= NULL) {
		outcome = false;
		if (TEXT_TY_RE_Trace) {
			print "Matching at ", ipos, ": ";
			TEXT_TY_RE_DebugNode(token, ftxt, true);
		}

		if (ipos<ito) ch = BlkValueRead(txt, ipos); else ch = 0;

		token-->RE_MODES = mode_flags; ! Save in case of backtrack

		switch (token-->RE_CCLASS) {
			
			! Should never happen
			
			CHOICE_RE_CC: return "internal error";
			
			! Mode switches
			
			SENSITIVITY_RE_CC:
				if (token-->RE_PAR1) mode_flags = mode_flags | CIS_MFLAG;
				else mode_flags = mode_flags & (~CIS_MFLAG);
				outcome = true;
		
			! Zero-length positional markers
			
			ALWAYS_RE_CC:
				outcome = true;
			NEVER_RE_CC:
			START_RE_CC:
				if (ipos == 0) outcome = true;
			END_RE_CC:
				if (BlkValueRead(txt, ipos) == 0) outcome = true;
			BOUNDARY_RE_CC:
				rv = 0;
				if (BlkValueRead(txt, ipos) == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (ipos == 0) ch = 0;
				else ch = BlkValueRead(txt, ipos-1);
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (rv == 1) outcome = true;
			NONBOUNDARY_RE_CC:
				rv = 0;
				if (BlkValueRead(txt, ipos) == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (ipos == 0) ch = 0;
				else ch = BlkValueRead(txt, ipos-1);
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (rv ~= 1) outcome = true;

			! Control constructs
		
			IF_RE_CC:
				i = token-->RE_PAR1; ch = false;
				if (TEXT_TY_RE_Trace) {
					print "Trying conditional from ", ipos, ": ";
					TEXT_TY_RE_DebugNode(token, ftxt, true);
				}
				if (i >= 1) {
					 if ((i<RE_Subexpressions-->10) &&
					 	((RE_Subexpressions-->i)-->RE_DATA1 >= 0)) ch = true;
				} else {					 	
					rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito,
						(token-->RE_DOWN)-->RE_DOWN, mode_flags);
					if (rv >= 0) ch = true;
				}
				if (TEXT_TY_RE_Trace) {
					print "Condition found to be ", ch, "^";
				}
				if (ch) {
					rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito,
						((token-->RE_DOWN)-->RE_NEXT)-->RE_DOWN, mode_flags);
					!print "Then clause returned ", rv, "^";
				} else {
					if ((((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT) == NULL)
						rv = 0; ! The empty else clause matches
					else rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito,
						(((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT)-->RE_DOWN, mode_flags);
					!print "Else clause returned ", rv, "^";
				}
				if (rv >= 0) {
					outcome = true;
					ipos = ipos + rv;
				}
			DISJUNCTION_RE_CC:
				if (TEXT_TY_RE_Trace) {
					print "Trying disjunction from ", ipos, ": ";
					TEXT_TY_RE_DebugNode(token, ftxt, true);
				}
				for (ch = token-->RE_DOWN: ch ~= NULL: ch = ch-->RE_NEXT) {
					if (ch-->RE_PAR1 <= token-->RE_CONSTRAINT) continue;
					if (TEXT_TY_RE_Trace) {
						print "Trying choice at ", ipos, ": ";
						TEXT_TY_RE_DebugNode(ch, ftxt, true);
					}
					rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito,
						ch-->RE_DOWN, mode_flags);
					if (rv >= 0) {
						token-->RE_DATA1 = ipos; ! Where match was made
						token-->RE_DATA2 = ch-->RE_PAR1; ! Option taken
						ipos = ipos + rv;
						outcome = true;
						if (TEXT_TY_RE_Trace) {
							print "Choice worked with width ", rv, ": ";
							TEXT_TY_RE_DebugNode(ch, ftxt, true);
						}
						break;
					} else {
						if (mode_flags & ACCUM_MFLAG == false)
							TEXT_TY_RE_FailSubexpressions(ch-->RE_DOWN);
					}						
				}
				if (outcome == false) {
					if (TEXT_TY_RE_Trace) {
						print "Failed disjunction from ", ipos, ": ";
						TEXT_TY_RE_DebugNode(token, ftxt, true);
					}
					token-->RE_DATA1 = ipos; ! Where match was tried
					token-->RE_DATA2 = -1; ! No option was taken
				}
			SUBEXP_RE_CC:
				if (token-->RE_PAR2 == 1 or 2) {
					npos = ipos - token-->RE_PAR3;
					if (npos<0) rv = -1; ! Lookbehind fails: nothing behind
					else rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, token-->RE_DOWN,
						mode_flags);
				} else {
					switch (token-->RE_PAR3) {
						0: rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, token-->RE_DOWN,
							mode_flags);
						1: rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, token-->RE_DOWN,
							mode_flags & (~CIS_MFLAG));
						2: rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, token-->RE_DOWN,
							mode_flags | CIS_MFLAG);
					}
				}
				npos = ipos;
				if (rv >= 0) npos = ipos + rv;
				switch (token-->RE_PAR2) {
					1: if (rv >= 0) rv = 0;
					2: if (rv >= 0) rv = -1; else rv = 0;
				}
				if (rv >= 0) {
					token-->RE_DATA1 = ipos;
					ipos = ipos + rv;
					token-->RE_DATA2 = npos;
					outcome = true;
				} else {
					if (mode_flags & ACCUM_MFLAG == false) {
						token-->RE_DATA1 = -1;
						token-->RE_DATA2 = -1;
					}
				}
				if (token-->RE_PAR2 == 2) TEXT_TY_RE_FailSubexpressions(token, true);
			QUANTIFIER_RE_CC:
				token-->RE_DATA1 = ipos;
				if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
					(token-->RE_DOWN)-->RE_CACHE1 = -1;
					(token-->RE_DOWN)-->RE_CACHE2 = -1;	
				}
				if (TEXT_TY_RE_Trace) {
					print "Trying quantifier from ", ipos, ": ";
					TEXT_TY_RE_DebugNode(token, ftxt, true);
				}
				if (token-->RE_PAR3 == false) { ! Greedy quantifier
					!edge = ito; if (token-->RE_CONSTRAINT >= 0) edge = token-->RE_CONSTRAINT;
					edge = token-->RE_PAR2;
					if (token-->RE_CONSTRAINT >= 0) edge = token-->RE_CONSTRAINT;
					rv = -1;
					for (i=0, npos=ipos: i<edge: i++) {
						if (TEXT_TY_RE_Trace) {
							print "Trying quant rep ", i+1, " at ", npos, ": ";
							TEXT_TY_RE_DebugNode(token, ftxt, true);
						}
						rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, token-->RE_DOWN,
							mode_flags | ACCUM_MFLAG);
						if (rv < 0) break;
						if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
							(token-->RE_DOWN)-->RE_CACHE1 = (token-->RE_DOWN)-->RE_DATA1;
							(token-->RE_DOWN)-->RE_CACHE2 = (token-->RE_DOWN)-->RE_DATA2;	
						}
						if ((rv == 0) && (token-->RE_PAR2 == 30000) && (i>=1)) { i++; break; }
						npos = npos + rv;
					}
					if ((i >= token-->RE_PAR1) && (i <= token-->RE_PAR2))
						outcome = true;
				} else { ! Lazy quantifier
					edge = token-->RE_PAR1;
					if (token-->RE_CONSTRAINT > edge) edge = token-->RE_CONSTRAINT;
					for (i=0, npos=ipos: (npos<ito) && (i < token-->RE_PAR2): i++) {
						if (i >= edge) break;
						if (TEXT_TY_RE_Trace) {
							print "Trying quant rep ", i+1, " at ", npos, ": ";
							TEXT_TY_RE_DebugNode(token, ftxt, true);
						}
						rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, token-->RE_DOWN,
							mode_flags | ACCUM_MFLAG);
						if (rv < 0) break;
						if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
							(token-->RE_DOWN)-->RE_CACHE1 = (token-->RE_DOWN)-->RE_DATA1;
							(token-->RE_DOWN)-->RE_CACHE2 = (token-->RE_DOWN)-->RE_DATA2;	
						}
						if ((rv == 0) && (token-->RE_PAR2 == 30000) && (i>=1)) { i++; break; }
						npos = npos + rv;
					}
					if ((i >= edge) && (i <= token-->RE_PAR2))
						outcome = true;
				}
				if (outcome) {
					if (token-->RE_PAR3 == false) { ! Greedy quantifier
						if (i > token-->RE_PAR1) { ! I.e., if we have been greedy
							token-->RE_DATA2 = i-1; ! And its edge limitation
						} else {
							token-->RE_DATA2 = -1;
						}
					} else { ! Lazy quantifier
						if (i < token-->RE_PAR2) { ! I.e., if we have been lazy
							token-->RE_DATA2 = i+1; ! And its edge limitation
						} else {
							token-->RE_DATA2 = -1;
						}
					}
					ipos = npos;
					if ((i == 0) && (mode_flags & ACCUM_MFLAG == false))
						TEXT_TY_RE_FailSubexpressions(token-->RE_DOWN);
					if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
						(token-->RE_DOWN)-->RE_DATA1 = (token-->RE_DOWN)-->RE_CACHE1;
						(token-->RE_DOWN)-->RE_DATA2 = (token-->RE_DOWN)-->RE_CACHE2;	
					}
					if (TEXT_TY_RE_Trace) {
						print "Successful quant reps ", i, ": ";
						TEXT_TY_RE_DebugNode(token, ftxt, true);
					}
				} else {
					!token-->RE_DATA2 = -1;
					if (mode_flags & ACCUM_MFLAG == false)
						TEXT_TY_RE_FailSubexpressions(token-->RE_DOWN);
					if (TEXT_TY_RE_Trace) {
						print "Failed quant reps ", i, ": ";
						TEXT_TY_RE_DebugNode(token, ftxt, true);
					}
				}
				
			! Character classes
				
			NOTHING_RE_CC: ;
			ANYTHING_RE_CC: if (ch) outcome = true; ipos++;
			WHITESPACE_RE_CC:
				if (ch == 10 or 13 or 32 or 9) { outcome = true; ipos++; }
			NONWHITESPACE_RE_CC:
				if ((ch) && (ch ~= 10 or 13 or 32 or 9)) { outcome = true; ipos++; }
			PUNCTUATION_RE_CC:
				if (ch == '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') { outcome = true; ipos++; }
			NONPUNCTUATION_RE_CC:
				if ((ch) && (ch ~= '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}')) { outcome = true; ipos++; }
			WORD_RE_CC:
				if ((ch) && (ch ~= 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}')) { outcome = true; ipos++; }
			NONWORD_RE_CC:
				if (ch == 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') { outcome = true; ipos++; }
			DIGIT_RE_CC:
				if (ch == '0' or '1' or '2' or '3' or '4'
					or '5' or '6' or '7' or '8' or '9') { outcome = true; ipos++; }
			NONDIGIT_RE_CC:
				if ((ch) && (ch ~= '0' or '1' or '2' or '3' or '4'
					or '5' or '6' or '7' or '8' or '9')) { outcome = true; ipos++; }
			LCASE_RE_CC:
				if (CharIsOfCase(ch, 0)) { outcome = true; ipos++; }
			NONLCASE_RE_CC:
				if ((ch) && (CharIsOfCase(ch, 0) == false)) { outcome = true; ipos++; }
			UCASE_RE_CC:
				if (CharIsOfCase(ch, 1)) { outcome = true; ipos++; }
			NONUCASE_RE_CC:
				if ((ch) && (CharIsOfCase(ch, 1) == false)) { outcome = true; ipos++; }
			NEWLINE_RE_CC: if (ch == 10) { outcome = true; ipos++; }
			TAB_RE_CC: if (ch == 9) { outcome = true; ipos++; }
			RANGE_RE_CC:
				if (TEXT_TY_RE_Range(ch, ftxt,
					token-->RE_PAR1, token-->RE_PAR2, token-->RE_PAR3, mode_flags & CIS_MFLAG))
					{ outcome = true; ipos++; }
			
			! Substring matches
			
			LITERAL_RE_CC:
				rv = TEXT_TY_RE_MatchSubstring(txt, ipos,
					ftxt, token-->RE_PAR1, token-->RE_PAR2, mode_flags & CIS_MFLAG);
				if (rv >= 0) { ipos = ipos + rv; outcome = true; }
			VARIABLE_RE_CC:
				i = token-->RE_PAR1;
				if ((RE_Subexpressions-->i)-->RE_DATA1 >= 0) {
					rv = TEXT_TY_RE_MatchSubstring(txt, ipos,
						txt, (RE_Subexpressions-->i)-->RE_DATA1,
						(RE_Subexpressions-->i)-->RE_DATA2, mode_flags & CIS_MFLAG);
					if (rv >= 0) { ipos = ipos + rv; outcome = true; }
				}
				.NeverMatchIncompleteVar;
		}
		
		if (outcome == false) {
			if (TEXT_TY_RE_RewindCount++ >= 10000) {
				if (TEXT_TY_RE_RewindCount == 10001) {
					style bold; print "OVERFLOW^"; style roman;
				}
				return -1;
			}
			if (TEXT_TY_RE_Trace) {
				print "Rewind sought from failure at pos ", ipos, " with: ";
					TEXT_TY_RE_DebugNode(token, ftxt, true);
			}
			if ((token-->RE_CCLASS == QUANTIFIER_RE_CC) &&
				(TEXT_TY_RE_SeekBacktrack(token-->RE_DOWN, ftxt, false, ito, false)))
				jump RewindFound;
			if (mode_flags & ACCUM_MFLAG == false) TEXT_TY_RE_FailSubexpressions(token);
			token = token-->RE_PREVIOUS;
			while (token ~= NULL) {
				if (TEXT_TY_RE_SeekBacktrack(token, ftxt, true, ito, false)) {
					.RewindFound;
					ipos = token-->RE_DATA1;
					mode_flags = token-->RE_MODES;
					if (mode_flags & ACCUM_MFLAG == false)
						TEXT_TY_RE_FailSubexpressions(token, true);
					if (ipos == -1)
						TEXT_TY_RE_DebugTree(ftxt, true);
					if (TEXT_TY_RE_Trace) {
						print "^[", ifrom, ",", ito, "] rewinding to ", ipos, " at ";
						TEXT_TY_RE_DebugNode(token, ftxt, true);
					}
					jump Rewind;
				}
				token = token-->RE_PREVIOUS;
			}
			if (TEXT_TY_RE_Trace)
				print "^Rewind impossible^";
			return -1;
		}

		token = token-->RE_NEXT;
	}
	return ipos - ifrom;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Backtracking
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_SeekBacktrack token ftxt downwards ito report_only
	untried;
	for (: token ~= NULL: token = token-->RE_NEXT) {
		if ((TEXT_TY_RE_Trace) && (report_only == false)) {
			print "Scan for rewind: ";
			TEXT_TY_RE_DebugNode(token, ftxt, true);
		}
		if ((token-->RE_CCLASS == SUBEXP_RE_CC) &&
			(token-->RE_PAR2 == 1 or 2 or 4)) {
			if (downwards) rfalse;
			continue;
		}
		if (token-->RE_DOWN ~= NULL) {
			if ((TEXT_TY_RE_Trace) && (report_only == false)) print "Descend^";
			if (TEXT_TY_RE_SeekBacktrack(token-->RE_DOWN, ftxt, false, ito, report_only)) rtrue;
		}
		untried = false;
		switch (token-->RE_CCLASS) {
			DISJUNCTION_RE_CC:
				if ((token-->RE_DATA2 >= 1) &&
					(token-->RE_DATA2 < token-->RE_PAR1) &&
					(token-->RE_CONSTRAINT < token-->RE_PAR1)) { ! Matched but earlier than last
					if (report_only) rtrue;
					if (token-->RE_CONSTRAINT == -1)
						token-->RE_CONSTRAINT = 1;
					else
						(token-->RE_CONSTRAINT)++;
					untried = true;
				}
			QUANTIFIER_RE_CC:
				if (token-->RE_CONSTRAINT ~= -2) {
					if ((TEXT_TY_RE_Trace) && (report_only == false)) {
						print "Quant with cons not -2: ";
						TEXT_TY_RE_DebugNode(token, ftxt, true);
					}
					if (token-->RE_DATA2 >= 0) {
						if (report_only) rtrue;
						token-->RE_CONSTRAINT = token-->RE_DATA2;
						untried = true;
					}
				}
		}
		if (untried) {
			if (TEXT_TY_RE_Trace) {
				print "Grounds for rewind at: ";
				TEXT_TY_RE_DebugNode(token, ftxt, true);
			}
			TEXT_TY_RE_EraseConstraints(token-->RE_NEXT);
			TEXT_TY_RE_EraseConstraints(token-->RE_DOWN);
			rtrue;
		}
		if (downwards) rfalse;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Fail Subexpressions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_FailSubexpressions token downwards;
	for (: token ~= NULL: token = token-->RE_NEXT) {
		if (token-->RE_DOWN ~= NULL) TEXT_TY_RE_FailSubexpressions(token-->RE_DOWN);
		if (token-->RE_CCLASS == SUBEXP_RE_CC) {
			token-->RE_DATA1 = -1;
			token-->RE_DATA2 = -1;
		}
		if (downwards) break;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Erasing Constraints
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_EraseConstraints token;
	while (token ~= NULL) {
		switch (token-->RE_CCLASS) {
			DISJUNCTION_RE_CC: token-->RE_CONSTRAINT = -1;
			QUANTIFIER_RE_CC: token-->RE_CONSTRAINT = -1;
		}
		if (token-->RE_DOWN) TEXT_TY_RE_EraseConstraints(token-->RE_DOWN);
		token = token-->RE_NEXT;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Matching Literal Text
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_MatchSubstring txt ipos mtxt mfrom mto insens
	i ch;
	if (mfrom < 0) return 0;
	if (insens)
		for (i=mfrom:i<mto:i++) {
			ch = BlkValueRead(mtxt, i);
			if (BlkValueRead(txt, ipos++) ~= ch or TEXT_TY_RevCase(ch))
				return -1;
		}
	else
		for (i=mfrom:i<mto:i++)
			if (BlkValueRead(txt, ipos++) ~= BlkValueRead(mtxt, i))
				return -1;
	return mto-mfrom;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Matching Character Range
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_Range ch ftxt rf rt negate insens
	i chm upper crev;
	if (ch == 0) rfalse;
	if (negate == true) {
		if (TEXT_TY_RE_Range(ch, ftxt, rf, rt, false, insens)) rfalse;
		rtrue;
	}
	for (i=rf: i<rt: i++) {
		chm = BlkValueRead(ftxt, i);
		if ((chm == '\') && (i+1<rt)) {
			chm = BlkValueRead(ftxt, ++i);
			switch (chm) {
				's':
					if (ch == 10 or 13 or 32 or 9) rtrue;
				'S':
					if ((ch) && (ch ~= 10 or 13 or 32 or 9)) rtrue;
				'p':
					if (ch == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}') rtrue;
				'P':
					if ((ch) && (ch ~= '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) rtrue;
				'w':
					if ((ch) && (ch ~= 10 or 13 or 32 or 9
						or '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) rtrue;
				'W':
					if (ch == 10 or 13 or 32 or 9
						or '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}') rtrue;
				'd':
					if (ch == '0' or '1' or '2' or '3' or '4'
						or '5' or '6' or '7' or '8' or '9') rtrue;
				'D':
					if ((ch) && (ch ~= '0' or '1' or '2' or '3' or '4'
						or '5' or '6' or '7' or '8' or '9')) rtrue;
				'l': if (CharIsOfCase(ch, 0)) rtrue;
				'L': if (CharIsOfCase(ch, 0) == false) rtrue;
				'u': if (CharIsOfCase(ch, 1)) rtrue;
				'U': if (CharIsOfCase(ch, 1) == false) rtrue;
				'n': if (ch == 10) rtrue;
				't': if (ch == 9) rtrue;
			}
		} else {
			if ((i+2<rt) && (BlkValueRead(ftxt, i+1) == '-')) {
				upper = BlkValueRead(ftxt, i+2);
				if ((ch >= chm) && (ch <= upper)) rtrue;
				if (insens) {
					crev = TEXT_TY_RevCase(ch);
					if ((crev >= chm) && (crev <= upper)) rtrue;
				}
				i=i+2;
			} else {
				if (chm == ch) rtrue;
				if ((insens) && (chm == TEXT_TY_RevCase(ch))) rtrue;
			}
		}
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Search And Replace
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_Replace_RE ftxtype txt ftxt rtxt insens exactly
	r p p1 p2 cp cp1 cp2;
	!print "Find: "; BlkValueDebug(ftxt); print "^";
	!print "Rep: "; BlkValueDebug(rtxt); print "^";
	!print "In: "; BlkValueDebug(txt); print "^";
	if (rtxt == 0 or 1) { cp = txt-->0; p = TEXT_TY_Temporarily_Transmute(txt); }
	else TEXT_TY_Transmute(txt);
	cp1 = ftxt-->0; p1 = TEXT_TY_Temporarily_Transmute(ftxt);
	cp2 = rtxt-->0; p2 = TEXT_TY_Temporarily_Transmute(rtxt);
	r = TEXT_TY_Replace_REI(ftxtype, txt, ftxt, rtxt, insens, exactly);
	TEXT_TY_Untransmute(ftxt, p1, cp1);
	TEXT_TY_Untransmute(rtxt, p2, cp2);
	if (rtxt == 0 or 1) TEXT_TY_Untransmute(txt, p, cp);
	return r;
];

[ TEXT_TY_Replace_REI ftxtype txt ftxt rtxt insens exactly
	ctxt csize ilen i cl mpos cpos ch chm;

	ilen = TEXT_TY_CharacterLength(txt);

	TEXT_TY_RE_Err = 0;
	switch (ftxtype) {
		REGEXP_BLOB: i = TEXT_TY_RE_CompileTree(ftxt, exactly);
		CHR_BLOB: i = TEXT_TY_CHR_CompileTree(ftxt, exactly);
		default: "*** bad ftxtype ***";
	}
	
	if ((i<0) || (i>RE_MAX_PACKETS)) {
		TEXT_TY_RE_Err = i;
		print "*** Regular expression error: ", (string) TEXT_TY_RE_Err, " ***^";
		RunTimeProblem(RTP_REGEXPSYNTAXERROR);
		return 0;
	}

	if (TEXT_TY_RE_Trace) {
		TEXT_TY_RE_DebugTree(ftxt);
		print "(compiled to ", i, " packets)^";
	}
	
	if (ftxtype == REGEXP_BLOB) TEXT_TY_RE_EmptyMatchVars();
	mpos = 0; chm = 0; cpos = 0;
	while (TEXT_TY_RE_Parse(ftxt, txt, mpos, insens) >= 0) {
		chm++;
		
		if (TEXT_TY_RE_Trace) {
			print "^*** Match ", chm, " found (", RE_PACKET_space-->RE_DATA1, ",",
				RE_PACKET_space-->RE_DATA2, "): ";
			if (RE_PACKET_space-->RE_DATA1 == RE_PACKET_space-->RE_DATA2) {
				print "<empty>";
			}
			for (i=RE_PACKET_space-->RE_DATA1:i<RE_PACKET_space-->RE_DATA2:i++) {
				print (char) BlkValueRead(txt, i);
			}
			print " ***^";
		}
		
		if (rtxt == 0) break; ! Accept only one match, replace nothing
		
		if (rtxt ~= 0 or 1) {
			if (chm == 1) {
				ctxt = BlkValueCreate(TEXT_TY);
				TEXT_TY_Transmute(ctxt);
				csize = BlkValueLBCapacity(ctxt);
			}

			for (i=cpos:i<RE_PACKET_space-->RE_DATA1:i++) {
				ch = BlkValueRead(txt, i);
				if (cl+1 >= csize) {
					if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
					csize = BlkValueLBCapacity(ctxt);
				}
				BlkValueWrite(ctxt, cl++, ch);
			}
			BlkValueWrite(ctxt, cl, 0);
	
			TEXT_TY_Concatenate(ctxt, rtxt, ftxtype, txt);
			csize = BlkValueLBCapacity(ctxt);
			cl = TEXT_TY_CharacterLength(ctxt);			
		}

		mpos = RE_PACKET_space-->RE_DATA2; cpos = mpos;
		if (RE_PACKET_space-->RE_DATA1 == RE_PACKET_space-->RE_DATA2)
			mpos++;

		if (TEXT_TY_RE_Trace) {
			if (chm == 100) { ! Purely to keep the output from being excessive
				print "(Stopping after 100 matches.)^"; break;
			}
		}
	}
	if (chm > 0) {
		if (rtxt ~= 0 or 1) {
			for (i=cpos:i<ilen:i++) {
				ch = BlkValueRead(txt, i);
				if (cl+1 >= csize) {
					if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;
					csize = BlkValueLBCapacity(ctxt);
				}
				BlkValueWrite(ctxt, cl++, ch);
			}
		}
		
		if (ftxtype == REGEXP_BLOB) {
			TEXT_TY_RE_CreateMatchVars(txt);
			if (TEXT_TY_RE_Trace)
				TEXT_TY_RE_DebugMatchVars(txt);
		}

		if (rtxt ~= 0 or 1) {
			BlkValueWrite(ctxt, cl, 0);
			BlkValueCopy(txt, ctxt);	
			BlkValueFree(ctxt);
		}
	}
	return chm;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RegExp.i6t: Concatenation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TEXT_TY_RE_Concatenate txt_to txt_from blobtype txt_ref
	pos len ch i tosize x y case;
	if ((txt_to==0) || (BlkValueWeakKind(txt_to) ~= TEXT_TY)) rfalse;
	if ((txt_from==0) || (BlkValueWeakKind(txt_from) ~= TEXT_TY)) return txt_to;
	pos = TEXT_TY_CharacterLength(txt_to);
	tosize = BlkValueLBCapacity(txt_to);
	len = TEXT_TY_CharacterLength(txt_from);
	for (i=0:i<len:i++) {
		ch = BlkValueRead(txt_from, i);
		if ((ch == '\') && (i < len-1)) {
			ch = BlkValueRead(txt_from, ++i);
			if (ch == 'n') ch = 10;
			if (ch == 't') ch = 9;
			case = -1;
			if (ch == 'l') case = 0;
			if (ch == 'u') case = 1;
			if (case >= 0) ch = BlkValueRead(txt_from, ++i);
			if ((ch >= '0') && (ch <= '9')) {
				ch = ch - '0';
				if (ch < RE_Subexpressions-->10) {
					x = (RE_Subexpressions-->ch)-->RE_DATA1;
					y = (RE_Subexpressions-->ch)-->RE_DATA2;
					if (x >= 0) {
						for (:x<y:x++) {
							ch = BlkValueRead(txt_ref, x);
							if (pos+1 >= tosize) {
								if (BlkValueSetLBCapacity(txt_to, 2*tosize) == false) break;
								tosize = BlkValueLBCapacity(txt_to);
							}
							if (case >= 0)
								BlkValueWrite(txt_to, pos++, CharToCase(ch, case));
							else
								BlkValueWrite(txt_to, pos++, ch);
						}
					}
				}
				continue;
			}
			
		}
		if (pos+1 >= tosize) {
			if (BlkValueSetLBCapacity(txt_to, 2*tosize) == false) break;
			tosize = BlkValueLBCapacity(txt_to);
		}
		BlkValueWrite(txt_to, pos++, ch);
	}
	BlkValueWrite(txt_to, pos, 0);
	return txt_to;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Block Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant STORA_ACTION_F = 0;
Constant STORA_NOUN_F = 1;
Constant STORA_SECOND_F = 2;
Constant STORA_ACTOR_F = 3;
Constant STORA_REQUEST_F = 4;
Constant STORA_COMMAND_TEXT_F = 5;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: KOV Support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:      return STORED_ACTION_TY_Create(arg2);
		DESTROY_KOVS:     STORED_ACTION_TY_Destroy(arg1);
		MAKEMUTABLE_KOVS: return 1;
		COPYQUICK_KOVS:   rtrue;
		COPYSB_KOVS:	  BlkValueCopySB1(arg1, arg2);
		KINDDATA_KOVS:    return 0;
		EXTENT_KOVS:      return 6;
		COPY_KOVS:        STORED_ACTION_TY_Copy(arg1, arg2);
		COMPARE_KOVS:     return STORED_ACTION_TY_Compare(arg1, arg2);
		HASH_KOVS:        return STORED_ACTION_TY_Hash(arg1);
		DEBUG_KOVS:       print " = ", (STORED_ACTION_TY_Say) arg1;
	}
	! We choose not to respond to: CAST_KOVS, COPYKIND_KOVS, READ_FILE_KOVS, WRITE_FILE_KOVS
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Creation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Create sb stora;
	stora = FlexAllocate(6*WORDSIZE, STORED_ACTION_TY, BLK_FLAG_WORD);
	BlkValueWrite(stora, STORA_ACTION_F, ##Wait, true); ! action
	BlkValueWrite(stora, STORA_NOUN_F, 0, true); ! noun
	BlkValueWrite(stora, STORA_SECOND_F, 0, true); ! second
	BlkValueWrite(stora, STORA_ACTOR_F, player, true); ! actor
	BlkValueWrite(stora, STORA_REQUEST_F, false, true); ! whether a request
	BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0, true); ! text of command if necessary, 0 if not
	return BlkValueCreateSB1(sb, stora);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Setting Up
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_New a n s ac req  stora;
	if (stora == 0) stora = BlkValueCreate(STORED_ACTION_TY);
	BlkValueWrite(stora, STORA_ACTION_F, a);
	BlkValueWrite(stora, STORA_NOUN_F, n);
	BlkValueWrite(stora, STORA_SECOND_F, s);
	BlkValueWrite(stora, STORA_ACTOR_F, ac);
	BlkValueWrite(stora, STORA_REQUEST_F, req);
	BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0);
	return stora;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Destruction
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Destroy stora toc;
	toc = BlkValueRead(stora, STORA_COMMAND_TEXT_F);
	if (toc) BlkValueFree(toc);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Copying
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Copy storato storafrom tocfrom tocto;
	tocfrom = BlkValueRead(storafrom, STORA_COMMAND_TEXT_F);
	if (tocfrom == 0) return;
	tocto = BlkValueCreate(TEXT_TY);
	BlkValueCopy(tocto, tocfrom);
	BlkValueWrite(storato, STORA_COMMAND_TEXT_F, tocto);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Comparison
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Compare storaleft storaright delta itleft itright;
	delta = BlkValueRead(storaleft, STORA_ACTION_F) - BlkValueRead(storaright, STORA_ACTION_F);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, STORA_NOUN_F) - BlkValueRead(storaright, STORA_NOUN_F);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, STORA_SECOND_F) - BlkValueRead(storaright, STORA_SECOND_F);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, STORA_ACTOR_F) - BlkValueRead(storaright, STORA_ACTOR_F);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, STORA_REQUEST_F) - BlkValueRead(storaright, STORA_REQUEST_F);
	if (delta) return delta;
	itleft = BlkValueRead(storaleft, STORA_COMMAND_TEXT_F);
	itright = BlkValueRead(storaright, STORA_COMMAND_TEXT_F);
	if ((itleft ~= 0) && (itright ~= 0))
		return TEXT_TY_Support(COMPARE_KOVS, itleft, itright);
	return itleft - itright;
];

[ STORED_ACTION_TY_Distinguish stora1 stora2;
	if (STORED_ACTION_TY_Compare(stora1, stora2) == 0) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Hashing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Hash stora  rv it;
	rv = BlkValueRead(stora, STORA_ACTION_F);
	rv = rv * 33 + BlkValueRead(stora, STORA_NOUN_F);
	rv = rv * 33 + BlkValueRead(stora, STORA_SECOND_F);
	rv = rv * 33 + BlkValueRead(stora, STORA_ACTOR_F);
	rv = rv * 33 + BlkValueRead(stora, STORA_REQUEST_F);
	it = BlkValueRead(stora, STORA_COMMAND_TEXT_F);
	if (it ~= 0)
		rv = rv * 33 + TEXT_TY_Support(HASH_KOVS, it);
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Say stora text_of_command saved_command saved_pn saved_action K1 K2 at cf cw;
	if ((stora==0) || (BlkValueWeakKind(stora) ~= STORED_ACTION_TY)) return;
	text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F);
	if (text_of_command) {
		saved_command = BlkValueCreate(TEXT_TY);
		BlkValueCast(saved_command, SNIPPET_TY, players_command);
		SetPlayersCommand(text_of_command);
	}
	saved_pn = parsed_number; saved_action = action;
	action = BlkValueRead(stora, STORA_ACTION_F);
	cf = consult_from; cw = consult_words;
	at = FindAction(-1);
	K1 = ActionData-->(at+AD_NOUN_KOV);
	K2 = ActionData-->(at+AD_SECOND_KOV);
	if (K1 ~= OBJECT_TY) {
		parsed_number = BlkValueRead(stora, STORA_NOUN_F);
		if ((K1 == UNDERSTANDING_TY) && (text_of_command == 0)) {
			if (saved_command == 0) saved_command = BlkValueCreate(TEXT_TY);
			BlkValueCast(saved_command, SNIPPET_TY, players_command);
			text_of_command = BlkValueCreate(TEXT_TY);
			BlkValueCopy(text_of_command, parsed_number);
			SetPlayersCommand(text_of_command);
			parsed_number = players_command;
			consult_from = parsed_number/100; consult_words = parsed_number%100;
		}
	}
	if (K2 ~= OBJECT_TY) {
		parsed_number = BlkValueRead(stora, STORA_SECOND_F);
		if ((K2 == UNDERSTANDING_TY) && (text_of_command == 0)) {
			if (saved_command == 0) saved_command = BlkValueCreate(TEXT_TY);
			BlkValueCast(saved_command, SNIPPET_TY, players_command);
			text_of_command = BlkValueCreate(TEXT_TY);
			BlkValueCopy(text_of_command, parsed_number);
			SetPlayersCommand(text_of_command);
			parsed_number = players_command;
			consult_from = parsed_number/100; consult_words = parsed_number%100;
		}
	}	
	DB_Action(
		BlkValueRead(stora, STORA_ACTOR_F),
		BlkValueRead(stora, STORA_REQUEST_F),
		BlkValueRead(stora, STORA_ACTION_F),
		BlkValueRead(stora, STORA_NOUN_F),
		BlkValueRead(stora, STORA_SECOND_F), true);
	parsed_number = saved_pn; action = saved_action;
	consult_from = cf; consult_words = cw;
	if (text_of_command) {
		SetPlayersCommand(saved_command);
		BlkValueFree(saved_command);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Involvement
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Involves stora item at;
	at = FindAction(BlkValueRead(stora, STORA_ACTION_F));
	if (at) {
		if ((ActionData-->(at+AD_NOUN_KOV) == OBJECT_TY) &&
			(BlkValueRead(stora, STORA_NOUN_F) == item)) rtrue;
		if ((ActionData-->(at+AD_SECOND_KOV) == OBJECT_TY) &&
			(BlkValueRead(stora, STORA_SECOND_F) == item)) rtrue;
	}
	if (BlkValueRead(stora, STORA_ACTOR_F) == item) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Nouns
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Part stora ind at ado;
	if (ind == STORA_NOUN_F or STORA_SECOND_F) {
		if (ind == STORA_NOUN_F) ado = AD_NOUN_KOV; else ado = AD_SECOND_KOV;
		at = FindAction(BlkValueRead(stora, STORA_ACTION_F));
		if ((at) && (ActionData-->(at+ado) == OBJECT_TY)) return BlkValueRead(stora, ind);
		return nothing;
	}
	return BlkValueRead(stora, ind);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Pattern Matching
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Array SAT_Tmp-->7;
[ STORED_ACTION_TY_Adopt stora at;
	SAT_Tmp-->1 = action;
	SAT_Tmp-->2 = noun;
	SAT_Tmp-->3 = second;
	SAT_Tmp-->4 = actor;
	SAT_Tmp-->5 = act_requester;
	SAT_Tmp-->6 = parsed_number;
	action = BlkValueRead(stora, STORA_ACTION_F);
	at = FindAction(-1);
	if (ActionData-->(at+AD_NOUN_KOV) == OBJECT_TY)
		noun = BlkValueRead(stora, STORA_NOUN_F);
	else {
		parsed_number = BlkValueRead(stora, STORA_NOUN_F);
		noun = nothing;
	}
	if (ActionData-->(at+AD_SECOND_KOV) == OBJECT_TY)
		second = BlkValueRead(stora, STORA_SECOND_F);
	else {
		parsed_number = BlkValueRead(stora, STORA_SECOND_F);
		second = nothing;
	}
	actor = BlkValueRead(stora, STORA_ACTOR_F);
	if (BlkValueRead(stora, STORA_REQUEST_F)) act_requester = player; else act_requester = nothing;
];

[ STORED_ACTION_TY_Unadopt;
	action = SAT_Tmp-->1;
	noun = SAT_Tmp-->2;
	second = SAT_Tmp-->3;	
	actor = SAT_Tmp-->4;	
	act_requester = SAT_Tmp-->5;
	parsed_number = SAT_Tmp-->6;
	return SAT_Tmp-->0;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Current Action
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Current stora at text_of_command;
	if ((stora==0) || (BlkValueWeakKind(stora) ~= STORED_ACTION_TY)) return 0;
	BlkValueWrite(stora, STORA_ACTION_F, action);
	at = FindAction(-1);

	if (ActionData-->(at+AD_NOUN_KOV) == OBJECT_TY)
		BlkValueWrite(stora, STORA_NOUN_F, noun);
	else
		BlkValueWrite(stora, STORA_NOUN_F, parsed_number);
	if (ActionData-->(at+AD_SECOND_KOV) == OBJECT_TY)
		BlkValueWrite(stora, STORA_SECOND_F, second);
	else
		BlkValueWrite(stora, STORA_SECOND_F, parsed_number);
	BlkValueWrite(stora, STORA_ACTOR_F, actor);
	if (act_requester) BlkValueWrite(stora, STORA_REQUEST_F, true);
	else BlkValueWrite(stora, STORA_REQUEST_F, false);

	if ((at) && ((ActionData-->(at+AD_NOUN_KOV) == UNDERSTANDING_TY) ||
			(ActionData-->(at+AD_SECOND_KOV) == UNDERSTANDING_TY))) {
		text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F);
		if (text_of_command == 0) {
			text_of_command = BlkValueCreate(TEXT_TY);
			BlkValueWrite(stora, STORA_COMMAND_TEXT_F, text_of_command);
		}
		BlkValueCast(text_of_command, SNIPPET_TY, players_command);
	} else BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0);

	return stora;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! StoredAction.i6t: Trying
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ STORED_ACTION_TY_Try stora ks  text_of_command saved_command;
	if ((stora==0) || (BlkValueWeakKind(stora) ~= STORED_ACTION_TY)) return;
	if (ks) { @push keep_silent; keep_silent=1; }
	text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F);
	if (text_of_command) {
		saved_command = BlkValueCreate(TEXT_TY);
		BlkValueCast(saved_command, SNIPPET_TY, players_command);
		SetPlayersCommand(text_of_command);
	}
	TryAction(
		BlkValueRead(stora, STORA_REQUEST_F),
		BlkValueRead(stora, STORA_ACTOR_F),
		BlkValueRead(stora, STORA_ACTION_F),
		BlkValueRead(stora, STORA_NOUN_F),
		BlkValueRead(stora, STORA_SECOND_F));
	if (text_of_command) {
		SetPlayersCommand(saved_command);
		BlkValueFree(saved_command);
	}
	if (ks) { @pull keep_silent; }
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Block Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant LIST_ITEM_KOV_F = 0; ! The kind of the items
Constant LIST_LENGTH_F = 1;   ! The number of items
Constant LIST_ITEM_BASE = 2;  ! List items begin at this entry


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: KOV Support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:      return LIST_OF_TY_Create(arg1, arg2);
		DESTROY_KOVS:     LIST_OF_TY_Destroy(arg1);
		MAKEMUTABLE_KOVS: return 1;
		COPYKIND_KOVS:    return LIST_OF_TY_CopyKind(arg1, arg2);
		COPYQUICK_KOVS:   return LIST_OF_TY_QuickCopy(arg1, arg2);
		COPYSB_KOVS:	  BlkValueCopySB1(arg1, arg2);
		KINDDATA_KOVS:    return LIST_OF_TY_KindData(arg1, arg2);
		EXTENT_KOVS:      return BlkValueRead(arg1, LIST_LENGTH_F) + LIST_ITEM_BASE;
		COPY_KOVS:        LIST_OF_TY_Copy(arg1, arg2, arg3);
		COMPARE_KOVS:     return LIST_OF_TY_Compare(arg1, arg2);
		HASH_KOVS:        return LIST_OF_TY_Hash(arg1);
		DEBUG_KOVS:       print " = {", (LIST_OF_TY_Say) arg1, "} of kind ",
                              BlkValueRead(arg1, LIST_ITEM_KOV_F);
	}
	! We choose not to respond to: CAST_KOVS, READ_FILE_KOVS, WRITE_FILE_KOVS
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Creation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Create skov sb list;
	skov = KindBaseTerm(skov, 0);
	list = FlexAllocate(27*WORDSIZE, LIST_OF_TY, BLK_FLAG_MULTIPLE + BLK_FLAG_WORD);
	BlkValueWrite(list, LIST_ITEM_KOV_F, skov, true);
	BlkValueWrite(list, LIST_LENGTH_F, 0, true);
	sb = BlkValueCreateSB1(sb, list);
	return sb;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Destruction
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Destroy list no_items i k;
	k = BlkValueRead(list, LIST_ITEM_KOV_F);
	if (KOVIsBlockValue(k)) {
		no_items = BlkValueRead(list, LIST_LENGTH_F);
		for (i=0: i<no_items: i++) BlkValueFree(BlkValueRead(list, i+LIST_ITEM_BASE));
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Copying
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_CopyKind to from;
	BlkValueWrite(to, LIST_ITEM_KOV_F, BlkValueRead(from, LIST_ITEM_KOV_F));
];

[ LIST_OF_TY_QuickCopy to from;
	if (BlkValueRead(to, LIST_ITEM_KOV_F) ~= BlkValueRead(from, LIST_ITEM_KOV_F))
		rfalse;
	rtrue;
];

[ LIST_OF_TY_KindData list;
	return BlkValueRead(list, LIST_ITEM_KOV_F);
];

[ LIST_OF_TY_Copy lto lfrom  precopied_list_kov no_items i nv bk val splk;
	no_items = BlkValueRead(lfrom, LIST_LENGTH_F);
	bk = BlkValueRead(lfrom, LIST_ITEM_KOV_F);
	if (precopied_list_kov ~= 0 or UNKNOWN_TY)
		BlkValueWrite(lto, LIST_ITEM_KOV_F, precopied_list_kov);
	else BlkValueWrite(lto, LIST_ITEM_KOV_F, bk);
	if (KOVIsBlockValue(bk)) {
		for (i=0: i<no_items: i++) {
			val = BlkValueRead(lfrom, i+LIST_ITEM_BASE);
			if (precopied_list_kov ~= 0 or UNKNOWN_TY)
				nv = BlkValueCreate(precopied_list_kov);
			else
				nv = BlkValueCreate(bk);
			BlkValueCopy(nv, val);
			BlkValueWrite(lto, i+LIST_ITEM_BASE, nv);
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Comparison
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Compare listleft listright delta no_items i cf;
	delta = BlkValueRead(listleft, LIST_LENGTH_F) - BlkValueRead(listright, LIST_LENGTH_F);
	if (delta) return delta;
	no_items = BlkValueRead(listleft, LIST_LENGTH_F);
	if (no_items == 0) return 0;
	delta = BlkValueRead(listleft, LIST_ITEM_KOV_F) - BlkValueRead(listright, LIST_ITEM_KOV_F);
	if (delta) return delta;
	cf = LIST_OF_TY_ComparisonFn(listleft);
	if (cf == 0 or UnsignedCompare) {
		for (i=0: i<no_items: i++) {
			delta = BlkValueRead(listleft, i+LIST_ITEM_BASE) -
				BlkValueRead(listright, i+LIST_ITEM_BASE);
			if (delta) return delta;
		}
	} else {
		for (i=0: i<no_items: i++) {
			delta = cf(BlkValueRead(listleft, i+LIST_ITEM_BASE),
				BlkValueRead(listright, i+LIST_ITEM_BASE));
			if (delta) return delta;
		}
	}
	return 0;
];

[ LIST_OF_TY_ComparisonFn list;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	return KOVComparisonFunction(BlkValueRead(list, LIST_ITEM_KOV_F));
];

[ LIST_OF_TY_Distinguish txb1 txb2;
	if (LIST_OF_TY_Compare(txb1, txb2) == 0) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Hashing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Hash list  len kov rv i;
	rv = 0;
	len = BlkValueRead(list, LIST_LENGTH_F);
	kov = BlkValueRead(list, LIST_ITEM_KOV_F);
	for (i=0: i<len: i++)
		rv = rv * 33 + GetHashValue(kov, BlkValueRead(list, i+LIST_ITEM_BASE));
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Say list format no_items v i bk;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	bk = KindAtomic(BlkValueRead(list, LIST_ITEM_KOV_F));
	! print no_items, " of kov=", BlkValueRead(list, LIST_ITEM_KOV_F), ":";
	if (format == 1) print "{";
	for (i=0:i<no_items:i++) {
		v = BlkValueRead(list, i+LIST_ITEM_BASE);
		switch (format) {
			2: print (the) v;
			3: print (a) v;
			default:
				if (bk == LIST_OF_TY) LIST_OF_TY_Say(v, 1);
				else if ((bk == TEXT_TY) && (format == 1)) {
					print "~"; PrintKindValuePair(bk, v); print "~";
				}
				else PrintKindValuePair(bk, v);
		}
		if (i<no_items-2) print ", ";
		if (i==no_items-2) {
			if (format == 1) print ", "; else {
				#ifdef SERIAL_COMMA; if (no_items ~= 2) print ","; #endif;
				LIST_WRITER_INTERNAL_RM('C');
			}
		}
	}
	if (format == 1) print "}";
	prior_named_list = no_items; prior_named_list_gender = -1;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: List From Description
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Desc list desc kov obj no_items ex len i;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;
	ex = BlkValueLBCapacity(list);
	len = desc(-3);
	if (len+LIST_ITEM_BASE > ex) {
		if (BlkValueSetLBCapacity(list, len+LIST_ITEM_BASE) == false)
			return 0;
	}
	if (kov) BlkValueWrite(list, LIST_ITEM_KOV_F, kov);
	else BlkValueWrite(list, LIST_ITEM_KOV_F, OBJECT_TY);
	BlkValueWrite(list, LIST_LENGTH_F, len);
	obj = 0;
	for (i=0: i<len: i++) {
		obj = desc(-2, obj, i);
		! print "i = ", i, " and obj = ", obj, "^";
		BlkValueWrite(list, i+LIST_ITEM_BASE, obj);
	}
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Find Item
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_FindItem list v i no_items cf;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;
	cf = LIST_OF_TY_ComparisonFn(list);
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (cf == 0 or UnsignedCompare) {
		for (i=0: i<no_items: i++)
			if (v == BlkValueRead(list, i+LIST_ITEM_BASE)) rtrue;
	} else {
		for (i=0: i<no_items: i++)
			if (cf(v, BlkValueRead(list, i+LIST_ITEM_BASE)) == 0) rtrue;
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Insert Item
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_InsertItem list v posnflag posn nodups i no_items ex nv contents_kind;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;
	if (nodups && (LIST_OF_TY_FindItem(list, v))) return list;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	BlkValueWrite(list, LIST_LENGTH_F, no_items); ! Forces the list to be mutable
	contents_kind = BlkValueRead(list, LIST_ITEM_KOV_F);
	if ((posnflag) && ((posn<1) || (posn > no_items+1))) {
		print "*** Couldn't add at entry ", posn, " in the list ";
		LIST_OF_TY_Say(list, true);
		print ", which has entries in the range 1 to ", no_items, " ***^";
		RunTimeProblem(RTP_LISTRANGEERROR);
		rfalse;
	}
	ex = BlkValueLBCapacity(list);
	if (no_items+LIST_ITEM_BASE+1 > ex) {
		if (BlkValueSetLBCapacity(list, ex+16) == false) return 0;
	}
	if (KOVIsBlockValue(contents_kind)) {
		nv = BlkValueCreate(contents_kind);
		BlkValueCopy(nv, v);
		v = nv;
	}
	if (posnflag) {
		posn--;
		for (i=no_items:i>posn:i--) {
			BlkValueWrite(list, i+LIST_ITEM_BASE,
				BlkValueRead(list, i-1+LIST_ITEM_BASE));			
		}
		BlkValueWrite(list, posn+LIST_ITEM_BASE, v);
	} else {
		BlkValueWrite(list, no_items+LIST_ITEM_BASE, v);
	}
	BlkValueWrite(list, LIST_LENGTH_F, no_items+1);
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Append List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_AppendList list more posnflag posn nodups v i j no_items msize ex nv;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;
	if ((more==0) || (BlkValueWeakKind(more) ~= LIST_OF_TY)) return list;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	BlkValueWrite(list, LIST_LENGTH_F, no_items); ! Forces the list to be mutable
	if ((posnflag) && ((posn<1) || (posn > no_items+1))) {
		print "*** Couldn't add at entry ", posn, " in the list ";
		LIST_OF_TY_Say(list, true);
		print ", which has entries in the range 1 to ", no_items, " ***^";
		RunTimeProblem(RTP_LISTRANGEERROR);
		rfalse;
	}
	msize = BlkValueRead(more, LIST_LENGTH_F);
	ex = BlkValueLBCapacity(list);
	if (no_items+msize+LIST_ITEM_BASE > ex) {
		if (BlkValueSetLBCapacity(list, no_items+msize+LIST_ITEM_BASE+8) == false)
			return 0;
	}
	if (posnflag) {
		posn--;
		for (i=no_items+msize:i>=posn+msize:i--) {
			BlkValueWrite(list, i+LIST_ITEM_BASE,
				BlkValueRead(list, i-msize+LIST_ITEM_BASE));			
		}
		! BlkValueWrite(list, posn, v);
		for (j=0: j<msize: j++) {
			v = BlkValueRead(more, j+LIST_ITEM_BASE);
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
				nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
				BlkValueCopy(nv, v);
				v = nv;
			}
			BlkValueWrite(list, posn+j+LIST_ITEM_BASE, v);
		}
	} else {
		for (i=0, j=0: i<msize: i++) {
			v = BlkValueRead(more, i+LIST_ITEM_BASE);
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
				nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
				BlkValueCopy(nv, v);
				v = nv;
			}
			if ((nodups == 0) || (LIST_OF_TY_FindItem(list, v) == false)) {
				BlkValueWrite(list, no_items+j+LIST_ITEM_BASE, v);
				j++;
			}
		}
	}
	BlkValueWrite(list, LIST_LENGTH_F, no_items+j);
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Remove Value
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_RemoveValue list v forgive i j no_items odsize f cf delendum;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;
	cf = LIST_OF_TY_ComparisonFn(list);
	no_items = BlkValueRead(list, LIST_LENGTH_F); odsize = no_items;
	BlkValueWrite(list, LIST_LENGTH_F, no_items); ! Forces the list to be mutable
	for (i=0: i<no_items: i++) {
		delendum = BlkValueRead(list, i+LIST_ITEM_BASE);
		if (cf == 0 or UnsignedCompare)
			f = (v == delendum);
		else
			f = (cf(v, delendum) == 0);
		if (f) {
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
				BlkValueFree(delendum);
			for (j=i+1: j<no_items: j++)
				BlkValueWrite(list, j-1+LIST_ITEM_BASE,
					BlkValueRead(list, j+LIST_ITEM_BASE));
			no_items--; i--;
			BlkValueWrite(list, LIST_LENGTH_F, no_items);
		}
	}
	if (odsize ~= no_items) rfalse;
	if (forgive) rfalse;
	print "*** Couldn't remove: the value ";
	PrintKindValuePair(BlkValueRead(list, LIST_ITEM_KOV_F), v);
	print " was not present in the list ";
	LIST_OF_TY_Say(list, true);
	print " ***^";
	RunTimeProblem(RTP_LISTRANGEERROR);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Remove Item Range
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_RemoveItemRange list from to forgive i d no_items;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((from > to) || (from <= 0) || (to > no_items)) {
		if (forgive) {
			if (from <= 0) from = 1;
			if (to >= no_items) to = no_items;
			if (from > to) return list;
		} else {
			print "*** Couldn't remove entries ", from, " to ", to, " from the list ";
			LIST_OF_TY_Say(list, true);
			print ", which has entries in the range 1 to ", no_items, " ***^";
			RunTimeProblem(RTP_LISTRANGEERROR);
			rfalse;
		}
	}
	to--; from--;
	d = to-from+1;
	if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
		for (i=0: i<d: i++)
			BlkValueFree(BlkValueRead(list, from+i+LIST_ITEM_BASE));
	for (i=from: i<no_items-d: i++)
		BlkValueWrite(list, i+LIST_ITEM_BASE,
			BlkValueRead(list, i+d+LIST_ITEM_BASE));
	BlkValueWrite(list, LIST_LENGTH_F, no_items-d);
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Remove List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Remove_List list rlist i j k v w no_items odsize rsize cf f;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;
	no_items = BlkValueRead(list, LIST_LENGTH_F); odsize = no_items;
	rsize = BlkValueRead(rlist, LIST_LENGTH_F);
	cf = LIST_OF_TY_ComparisonFn(list);
	for (i=0: i<no_items: i++) {
		v = BlkValueRead(list, i+LIST_ITEM_BASE);
		for (k=0: k<rsize: k++) {
			w = BlkValueRead(rlist, k+LIST_ITEM_BASE);
			if (cf == 0 or UnsignedCompare)
				f = (v == w);
			else
				f = (cf(v, w) == 0);
			if (f) {
				if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
					BlkValueFree(v);
				for (j=i+1: j<no_items: j++)
					BlkValueWrite(list, j+LIST_ITEM_BASE-1, 
						BlkValueRead(list, j+LIST_ITEM_BASE));
				no_items--; i--;
				BlkValueWrite(list, LIST_LENGTH_F, no_items);
				break;
			}
		}
	}
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Get Length
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_GetLength list;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	return BlkValueRead(list, LIST_LENGTH_F);
];

[ LIST_OF_TY_Empty list;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;
	if (BlkValueRead(list, LIST_LENGTH_F) == 0) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Set Length
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_SetLength list newsize this_way_only truncation_end no_items ex i dv;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	if (newsize < 0) return RunTimeProblem(RTP_LISTSIZENEGATIVE, newsize);
	BlkMakeMutable(list);
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (no_items < newsize) {
		if (this_way_only == -1) return list;
		ex = BlkValueLBCapacity(list);
		if (newsize+LIST_ITEM_BASE > ex) {
			if (BlkValueSetLBCapacity(list, newsize+LIST_ITEM_BASE) == false)
				return 0;
		}
		dv = DefaultValueOfKOV(BlkValueRead(list, LIST_ITEM_KOV_F));
		for (i=no_items: i<newsize: i++)
			BlkValueWrite(list, LIST_ITEM_BASE+i, dv);
		BlkValueWrite(list, LIST_LENGTH_F, newsize);
	}
	if (no_items > newsize) {
		if (this_way_only == 1) return list;
		if (truncation_end == -1) {
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
				for (i=0: i<no_items-newsize: i++)
					BlkValueFree(BlkValueRead(list, LIST_ITEM_BASE+i));
			for (i=0: i<newsize: i++)
				BlkValueWrite(list, LIST_ITEM_BASE+i,
					BlkValueRead(list, LIST_ITEM_BASE+no_items-newsize+i));
		} else {
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
				for (i=newsize: i<no_items: i++)
					BlkValueFree(BlkValueRead(list, LIST_ITEM_BASE+i));
		}
		BlkValueWrite(list, LIST_LENGTH_F, newsize);
	}
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Get Item
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_GetItem list i forgive no_items;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((i<=0) || (i>no_items)) {
		if (forgive) return false;
		print "*** Couldn't read from entry ", i, " of a list which";
		switch (no_items) {
			0: print " is empty ***^";
			1: print " has only one entry, numbered 1 ***^";
			default: print " has entries numbered from 1 to ", no_items, " ***^";
		}
		RunTimeProblem(RTP_LISTRANGEERROR);
		if (no_items >= 1) i = 1;
		else return false;
	}
	return BlkValueRead(list, LIST_ITEM_BASE+i-1);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Write Item
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ WriteLIST_OF_TY_GetItem list i val no_items;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((i<=0) || (i>no_items)) {
		print "*** Couldn't write to list entry ", i, " of a list which";
		switch (no_items) {
			0: print " is empty ***^";
			1: print " has only one entry, numbered 1 ***^";
			default: print " has entries numbered from 1 to ", no_items, " ***^";
		}
		return RunTimeProblem(RTP_LISTRANGEERROR);
	}
	BlkValueWrite(list, LIST_ITEM_BASE+i-1, val);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Put Item
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_PutItem list i v  no_items nv;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
		nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
		BlkValueCopy(nv, v);
		v = nv;
	}
	if ((i<=0) || (i>no_items)) return false;
	BlkValueWrite(list, LIST_ITEM_BASE+i-1, v);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Multiple Object List
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Mol list len i;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	len = multiple_object-->0;
	LIST_OF_TY_SetLength(list, len);
	for (i=1: i<=len: i++)
		LIST_OF_TY_PutItem(list, i, multiple_object-->i);
	return list;
];

[ LIST_OF_TY_Set_Mol list len i;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	len = BlkValueRead(list, LIST_LENGTH_F);
	if (len > 63) len = 63;
	multiple_object-->0 = len;
	for (i=1: i<=len: i++)
		multiple_object-->i = BlkValueRead(list, LIST_ITEM_BASE+i-1);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Reversing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Reverse list no_items i v;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (no_items < 2) return list;
	for (i=0:i*2<no_items:i++) {
		v = BlkValueRead(list, LIST_ITEM_BASE+i);
		BlkValueWrite(list, LIST_ITEM_BASE+i,
			BlkValueRead(list, LIST_ITEM_BASE+no_items-1-i));
		BlkValueWrite(list, LIST_ITEM_BASE+no_items-1-i, v);
	}
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Rotation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ LIST_OF_TY_Rotate list backwards  no_items i v;
	if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (no_items < 2) return list;
	if (backwards) {
		v = BlkValueRead(list, LIST_ITEM_BASE);
		for (i=0:i<no_items-1:i++)
			BlkValueWrite(list, LIST_ITEM_BASE+i,
				BlkValueRead(list, LIST_ITEM_BASE+i+1));
		BlkValueWrite(list, no_items-1+LIST_ITEM_BASE, v);
	} else {
		v = BlkValueRead(list, no_items-1+LIST_ITEM_BASE);
		for (i=no_items-1:i>0:i--)
			BlkValueWrite(list, LIST_ITEM_BASE+i,
				BlkValueRead(list, LIST_ITEM_BASE+i-1));
		BlkValueWrite(list, LIST_ITEM_BASE, v);
	}
	return list;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Lists.i6t: Sorting
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Global LIST_OF_TY_Sort_cf;

[ LIST_OF_TY_Sort list dir prop cf  i j no_items v;
	BlkMakeMutable(list);
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (dir == 2) {
		if (no_items < 2) return;
		for (i=1:i<no_items:i++) {
			j = random(i+1) - 1;
			v = BlkValueRead(list, LIST_ITEM_BASE+i);
			BlkValueWrite(list, LIST_ITEM_BASE+i, BlkValueRead(list, LIST_ITEM_BASE+j));
			BlkValueWrite(list, LIST_ITEM_BASE+j, v);
		}
		return;
	}
	SetSortDomain(ListSwapEntries, ListCompareEntries);
	if (cf) LIST_OF_TY_Sort_cf = BlkValueCompare;
	else LIST_OF_TY_Sort_cf = 0;
	SortArray(list, prop, dir, no_items, false, 0);
];

[ ListSwapEntries list i j v;
	if (i==j) return;
	v = BlkValueRead(list, LIST_ITEM_BASE+i-1);
	BlkValueWrite(list, LIST_ITEM_BASE+i-1, BlkValueRead(list, LIST_ITEM_BASE+j-1));
	BlkValueWrite(list, LIST_ITEM_BASE+j-1, v);
];

[ ListCompareEntries list col i j d cf;
	if (i==j) return 0;
	i = BlkValueRead(list, LIST_ITEM_BASE+i-1);
	j = BlkValueRead(list, LIST_ITEM_BASE+j-1);
	if (I7S_Col) {
		if (i provides I7S_Col) i=i.I7S_Col; else i=0;
		if (j provides I7S_Col) j=j.I7S_Col; else j=0;
		cf = LIST_OF_TY_Sort_cf;
	} else {
		cf = LIST_OF_TY_ComparisonFn(list);
	}
	if (cf == 0) {
		if (i > j) return 1;
		if (i < j) return -1;
		return 0;
	} else
		return cf(i, j);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Block Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant COMBINATION_KIND_F = 0;    ! Strong kind ID
Constant COMBINATION_ITEM_BASE = 1; ! List items begin at this entry


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: KOV Support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:      return COMBINATION_TY_Create(arg1, arg2);
		DESTROY_KOVS:     COMBINATION_TY_Destroy(arg1);
		MAKEMUTABLE_KOVS: return 1;
		COPYKIND_KOVS:    return COMBINATION_TY_CopyKind(arg1, arg2);
		COPYQUICK_KOVS:   rtrue;
		COPYSB_KOVS:	  BlkValueCopySB1(arg1, arg2);
		KINDDATA_KOVS:    return COMBINATION_TY_KindData(arg1);
		EXTENT_KOVS:      return -1;
		COPY_KOVS:        COMBINATION_TY_Copy(arg1, arg2, arg3);
		COMPARE_KOVS:     return COMBINATION_TY_Compare(arg1, arg2);
		HASH_KOVS:        return COMBINATION_TY_Hash(arg1);
		DEBUG_KOVS:       print " = ", (COMBINATION_TY_Say) arg1;
	}
	! We choose not to respond to: CAST_KOVS, READ_FILE_KOVS, WRITE_FILE_KOVS
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Creation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_Create kind sb long_block N i bk v;
	N = KindBaseArity(kind);
	long_block = FlexAllocate(
		(COMBINATION_ITEM_BASE+N)*WORDSIZE, COMBINATION_TY, BLK_FLAG_WORD);
	BlkValueWrite(long_block, COMBINATION_KIND_F, kind, true);
	for (i=0: i<N: i++) {
		bk = KindBaseTerm(kind, i);
		if (KOVIsBlockValue(bk)) v = BlkValueCreate(bk);
		else v = DefaultValueOfKOV(bk);
		BlkValueWrite(long_block, COMBINATION_ITEM_BASE+i, v, true);
	}
	return BlkValueCreateSB1(sb, long_block);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Destruction
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_Destroy comb kind no_items i bk;
	kind = BlkValueRead(comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	for (i=0: i<no_items: i++) {
		bk = KindBaseTerm(kind, i);
		if (KOVIsBlockValue(bk))
			BlkValueFree(BlkValueRead(comb, i+COMBINATION_ITEM_BASE));
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Copying
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_CopyKind to from;
	BlkValueWrite(to, COMBINATION_KIND_F, BlkValueRead(from, COMBINATION_KIND_F));
];

[ COMBINATION_TY_CopySB to from;
	BlkValueCopySB1(to, from);
];

[ COMBINATION_TY_KindData comb;
	return BlkValueRead(comb, COMBINATION_KIND_F);
];

[ COMBINATION_TY_Copy to_comb from_comb precopied_comb_kov  no_items i nv kind bk;
	! kind = BlkValueRead(to_comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(precopied_comb_kov);
	BlkValueWrite(to_comb, COMBINATION_KIND_F, precopied_comb_kov);
	for (i=0: i<no_items: i++) {
		bk = KindBaseTerm(kind, i);
		if (KOVIsBlockValue(bk)) {
			nv = BlkValueCreate(bk);
			BlkValueCopy(nv, BlkValueRead(from_comb, i+COMBINATION_ITEM_BASE));
			BlkValueWrite(to_comb, i+COMBINATION_ITEM_BASE, nv);
		}
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Comparison
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_Compare left_comb right_comb delta no_items i cf kind bk;
	kind = BlkValueRead(left_comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	for (i=0: i<no_items: i++) {
		bk = KindBaseTerm(kind, i);
		cf = KOVComparisonFunction(bk);
		if (cf == 0 or UnsignedCompare) {
			delta = BlkValueRead(left_comb, i+COMBINATION_ITEM_BASE) -
				BlkValueRead(right_comb, i+COMBINATION_ITEM_BASE);
			if (delta) return delta;
		} else {
			delta = cf(BlkValueRead(left_comb, i+COMBINATION_ITEM_BASE),
				BlkValueRead(right_comb, i+COMBINATION_ITEM_BASE));
			if (delta) return delta;
		}
	}
	return 0;
];

[ COMBINATION_TY_Distinguish left_comb right_comb;
	if (COMBINATION_TY_Compare(left_comb, right_comb) == 0) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Hashing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_Hash comb  kind rv no_items i bk;
	rv = 0;
	kind = BlkValueRead(comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	for (i=0: i<no_items: i++) {
		bk = KindBaseTerm(kind, i);
		rv = rv * 33 + GetHashValue(bk, BlkValueRead(comb, i+COMBINATION_ITEM_BASE));
	}
	return rv;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Combinations.i6t: Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ COMBINATION_TY_Say comb format no_items v i kind bk;
	if ((comb==0) || (BlkValueWeakKind(comb) ~= COMBINATION_TY)) return;
	kind = BlkValueRead(comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	print "(";
	for (i=0: i<no_items: i++) {
		if (i>0) print ", ";
		bk = KindBaseTerm(kind, i);
		v = BlkValueRead(comb, i+COMBINATION_ITEM_BASE);
		if (bk == LIST_OF_TY) LIST_OF_TY_Say(v, 1);
		else PrintKindValuePair(bk, v);
	}
	print ")";
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Block Format
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RRV_NAME     		RR_NAME-5;        ! Packed string, e.g. "containment relation"
Constant RRV_PERMISSIONS	RR_PERMISSIONS-5; ! A bitmap of what operations this supports
Constant RRV_STORAGE		RR_STORAGE-5;     ! Data location, depending on format
Constant RRV_KIND			RR_KIND-5;        ! Strong kind ID of the relation
Constant RRV_HANDLER		RR_HANDLER-5;     ! Routine to perform operations on this
Constant RRV_DESCRIPTION	RR_DESCRIPTION-5; ! Packed string, e.g. "contains"
Constant RRV_USED			6;
Constant RRV_FILLED			7;
Constant RRV_DATA_BASE		8;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: KOV Support
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:      return RELATION_TY_Create(arg1, 0, arg2);
		DESTROY_KOVS:     RELATION_TY_Destroy(arg1);
		MAKEMUTABLE_KOVS: return 1;
		COPYQUICK_KOVS:   rtrue;
		COPYSB_KOVS:	  BlkValueCopySB1(arg1, arg2);
		KINDDATA_KOVS:    return 0;
		EXTENT_KOVS:      return -1;
		COPY_KOVS:        RELATION_TY_Copy(arg1, arg2);
		COMPARE_KOVS:     return RELATION_TY_Compare(arg1, arg2);
		HASH_KOVS:        return arg1;
		DEBUG_KOVS:       print " = ", (RELATION_TY_Say) arg1;
	}
	! We choose not to respond to: CAST_KOVS, COPYKIND_KOVS, READ_FILE_KOVS, WRITE_FILE_KOVS
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Other Definitions
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! valencies
Constant RRVAL_V_TO_V		0;
Constant RRVAL_V_TO_O		RELS_Y_UNIQUE;
Constant RRVAL_O_TO_V		RELS_X_UNIQUE;
Constant RRVAL_O_TO_O		RELS_X_UNIQUE+RELS_Y_UNIQUE;
Constant RRVAL_EQUIV		RELS_EQUIVALENCE+RELS_SYMMETRIC;
Constant RRVAL_SYM_V_TO_V	RELS_SYMMETRIC;
Constant RRVAL_SYM_O_TO_O	RELS_SYMMETRIC+RELS_X_UNIQUE+RELS_Y_UNIQUE;

! dictionary entry flags
Constant RRF_USED		$0001;	! entry contains a value
Constant RRF_DELETED	$0002;	! entry used to contain a value
Constant RRF_SINGLE		$0004;	! entry's Y is a value, not a list
Constant RRF_HASX		$0010;	! 2-in-1 entry contains a corresponding key
Constant RRF_HASY		$0020;	! 2-in-1 entry contains a corresponding value
Constant RRF_ENTKEYX	$0040;	! 2-in-1 entry key is left side KOV
Constant RRF_ENTKEYY	$0080;	! 2-in-1 entry key is right side KOV

! permission/task constants (those commented out here are generated by I7)
!Constant RELS_SYMMETRIC $8000;
!Constant RELS_EQUIVALENCE $4000;
!Constant RELS_X_UNIQUE $2000;
!Constant RELS_Y_UNIQUE $1000;
!Constant RELS_TEST $0800;
!Constant RELS_ASSERT_TRUE $0400;
!Constant RELS_ASSERT_FALSE $0200;
!Constant RELS_SHOW $0100;
!Constant RELS_ROUTE_FIND $0080;
!Constant RELS_ROUTE_FIND_COUNT $0040;
Constant RELS_COPY $0020;
Constant RELS_DESTROY $0010;
!Constant RELS_LOOKUP_ANY $0008;
!Constant RELS_LOOKUP_ALL_X $0004;
!Constant RELS_LOOKUP_ALL_Y $0002;
!Constant RELS_LIST $0001;

Constant RELS_EMPTY $0003;
Constant RELS_SET_VALENCY $0005;

! RELS_LOOKUP_ANY mode selection constants
Constant RLANY_GET_X 1;
Constant RLANY_GET_Y 2;
Constant RLANY_CAN_GET_X 3;
Constant RLANY_CAN_GET_Y 4;

! RELS_LIST mode selection constant
Constant RLIST_ALL_X 1;
Constant RLIST_ALL_Y 2;
Constant RLIST_ALL_PAIRS 3;


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Tunable Parameters
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

Constant RRP_MIN_SIZE      8;   ! minimum number of entries (DO NOT CHANGE)
Constant RRP_PERTURB_SHIFT 5;   ! affects the probe sequence
Constant RRP_RESIZE_SMALL  4;   ! resize factor for small tables
Constant RRP_RESIZE_LARGE  2;   ! resize factor for large tables
Constant RRP_LARGE_IS      256; ! how many entries make a table "large"?
Constant RRP_CROWDED_IS    2;   ! when filled entries outnumber unfilled by _ to 1


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Abstract Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RelationTest relation task X Y  handler rv;
	handler = RlnGetF(relation, RR_HANDLER);
	return handler(relation, task, X, Y);
];

[ RlnGetF rel fld i;
	rel = BlkValueGetLongBlock(rel);
	return rel-->fld;
];

[ RlnSetF rel fld v;
	rel = BlkValueGetLongBlock(rel);
	rel-->fld = v;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Empty Relations
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ EmptyRelationHandler relation task X Y;
	if (task == RELS_EMPTY) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Creation
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Create kov from sb rel i skov handler;
	rel = FlexAllocate((RRV_DATA_BASE + 3*RRP_MIN_SIZE)*WORDSIZE,
		RELATION_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
	if ((from == 0) && (kov ~= 0)) from = DefaultValueFinder(kov);
	if (from) {
		for (i=0: i<RRV_DATA_BASE: i++) BlkValueWrite(rel, i, BlkValueRead(from, i), true);
		if (BlkValueRead(from, RRV_HANDLER) == EmptyRelationHandler) {
			handler = ChooseRelationHandler(BlkValueRead(rel, RRV_KIND, true));
			BlkValueWrite(rel, RRV_NAME, "anonymous relation", true);
			BlkValueWrite(rel, RRV_PERMISSIONS,
				RELS_TEST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW, true);
			BlkValueWrite(rel, RRV_HANDLER, handler, true);
			BlkValueWrite(rel, RRV_STORAGE, RRP_MIN_SIZE-1, true);
			BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation", true);
			BlkValueWrite(rel, RRV_USED, 0, true);
			BlkValueWrite(rel, RRV_FILLED, 0, true);
		}
	} else {
		handler = ChooseRelationHandler(kov);
		BlkValueWrite(rel, RRV_NAME, "anonymous relation", true);
		BlkValueWrite(rel, RRV_PERMISSIONS,
			RELS_TEST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW, true);
		BlkValueWrite(rel, RRV_STORAGE, RRP_MIN_SIZE-1, true);
		BlkValueWrite(rel, RRV_KIND, kov, true);
		BlkValueWrite(rel, RRV_HANDLER, handler, true);
		BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation", true);
		BlkValueWrite(rel, RRV_USED, 0, true);
		BlkValueWrite(rel, RRV_FILLED, 0, true);
	}

	return BlkValueCreateSB1(sb, rel);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Destruction
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Destroy rel  handler;
	handler = BlkValueRead(rel, RRV_HANDLER);
	handler(rel, RELS_DESTROY);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Copying
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Copy lto lfrom  handler;
	handler = BlkValueRead(lto, RRV_HANDLER);
	handler(lto, RELS_COPY);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Comparison
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Compare rleft rright ind1 ind2;
	ind1 = BlkValueRead(rleft, RRV_HANDLER);
	ind2 = BlkValueRead(rright, RRV_HANDLER);
	if (ind1 ~= ind2) return ind1 - ind2;
	if (IsMutableRelationHandler(ind1) == false) return 0;
	return rleft - rright;
];

[ RELATION_TY_Distinguish rleft rright;
	if (RELATION_TY_Compare(rleft, rright) == 0) rfalse;
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Printing
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Say rel;
	if (rel == 0) print "(null relation)"; ! shouldn't happen
	else print (string) RlnGetF(rel, RR_NAME);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Naming
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Name rel txt;
	if (rel) {
		BlkValueWrite(rel, RRV_NAME, txt);
		BlkValueWrite(rel, RRV_DESCRIPTION, txt);
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Choose Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ChooseRelationHandler kov sym;
	if (KOVIsBlockValue(KindBaseTerm(kov, 0))) {
		if (sym) return SymHashListRelationHandler;
		return HashListRelationHandler;
	}
	if (sym) return SymDoubleHashSetRelationHandler;
	return DoubleHashSetRelationHandler;
];

[ IsMutableRelationHandler h;
	if (h == SymHashListRelationHandler or HashListRelationHandler or
		SymDoubleHashSetRelationHandler or DoubleHashSetRelationHandler) rtrue;
	rfalse;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Valency
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_SetValency rel val  kov filled cur handler ext;
	filled = BlkValueRead(rel, RRV_FILLED);
	if (filled) { RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE); rfalse; }
	kov = BlkValueRead(rel, RRV_KIND);
	if (val == RRVAL_EQUIV or RRVAL_SYM_V_TO_V or RRVAL_SYM_O_TO_O) {
		if (KindBaseTerm(kov, 0) ~= KindBaseTerm(kov, 1)) {
			RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE); rfalse;
		}
	}
	cur = BlkValueRead(rel, RRV_HANDLER);
	switch (val) {
		RRVAL_V_TO_V:		handler = ChooseRelationHandler(kov, false);
		RRVAL_V_TO_O:		handler = HashTableRelationHandler;
		RRVAL_O_TO_V:		handler = ReversedHashTableRelationHandler;
		RRVAL_O_TO_O:		handler = TwoInOneHashTableRelationHandler;
		RRVAL_EQUIV:		handler = EquivHashTableRelationHandler;
		RRVAL_SYM_V_TO_V:	handler = ChooseRelationHandler(kov, true);
		RRVAL_SYM_O_TO_O:	handler = Sym2in1HashTableRelationHandler;
		default:			RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE); rfalse;
	}
	if (cur == handler) rtrue;
	! adjust size when going to or from 2-in-1
	if (cur == TwoInOneHashTableRelationHandler) {
		ext = BlkValueRead(rel, RRV_STORAGE) + 1;
		BlkValueSetLBCapacity(rel, RRV_DATA_BASE + 3*ext);
	} else if (handler == TwoInOneHashTableRelationHandler) {
		ext = BlkValueRead(rel, RRV_STORAGE) + 1;
		BlkValueSetLBCapacity(rel, RRV_DATA_BASE + 4*ext);
	}
	BlkValueWrite(rel, RRV_HANDLER, handler);
];

[ RELATION_TY_GetValency rel  handler;
	return BlkValueRead(rel, RRV_PERMISSIONS) & VALENCY_MASK;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Double Hash Set Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ DoubleHashSetRelationHandler rel task X Y sym  kov kx ky at tmp v;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);
		if (~~(kx || ky)) return;
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (tmp & RRF_USED) {
				if (kx) BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				if (ky) BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
			}
			at--;
		}
		return;
	} else if (task == RELS_COPY) {
		X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);
		if (~~(X || Y)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (tmp & RRF_USED) {
				if (X) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
					tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, tmp);
				}
				if (Y) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
					tmp = BlkValueCopy(BlkValueCreate(ky), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
				}
			}
			at--;
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		if (sym) {
			kov = KOVComparisonFunction(kx);
			if (~~kov) kov = UnsignedCompare;
		}
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (tmp & RRF_USED) {
				X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
				Y = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
				if (sym && (kov(X, Y) > 0)) continue;
				print "  ";
				PrintKindValuePair(kx, X);
				if (sym) print " <=> "; else print " >=> ";
				PrintKindValuePair(ky, Y);
				print "^";
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		if (BlkValueRead(rel, RRV_USED) == 0) rtrue;
		if (X == 1) {
			DoubleHashSetRelationHandler(rel, RELS_DESTROY);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				BlkValueWrite(rel, tmp, 0);
				BlkValueWrite(rel, tmp + 1, 0);
				BlkValueWrite(rel, tmp + 2, 0);
			}
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
			rtrue;
		}
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			if (BlkValueRead(rel, tmp) & RRF_USED) {
				if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
					v = BlkValueRead(rel, tmp + 2);
					if (KOVIsBlockValue(ky)) {
						if (BlkValueCompare(v, X) ~= 0) continue;
					} else {
						if (v ~= X) continue;
					}
					if (Y == RLANY_CAN_GET_X) rtrue;
					return BlkValueRead(rel, tmp + 1);
				} else {
					v = BlkValueRead(rel, tmp + 1);
					if (KOVIsBlockValue(kx)) {
						if (BlkValueCompare(v, X) ~= 0) continue;
					} else {
						if (v ~= X) continue;
					}
					if (Y == RLANY_CAN_GET_Y) rtrue;
					return BlkValueRead(rel, tmp + 2);
				}
			}
		}
		if (Y == RLANY_GET_X or RLANY_GET_Y)
			print "*** Lookup failed: value not found ***^";
		rfalse;
	} else if (task == RELS_LOOKUP_ALL_X) {
		if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			if (BlkValueRead(rel, tmp) & RRF_USED) {
				v = BlkValueRead(rel, tmp + 2);
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(v, X) ~= 0) continue;
				} else {
					if (v ~= X) continue;
				}
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));
			}
		}
		return Y;
	} else if (task == RELS_LOOKUP_ALL_Y) {
		if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			if (BlkValueRead(rel, tmp) & RRF_USED) {
				v = BlkValueRead(rel, tmp + 1);
				if (KOVIsBlockValue(kx)) {
					if (BlkValueCompare(v, X) ~= 0) continue;
				} else {
					if (v ~= X) continue;
				}
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 2));
			}
		}
		return Y;
	} else if (task == RELS_LIST) {
		if (X == 0 || BlkValueWeakKind(X) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(X, 0);
		switch (Y) {
			RLIST_ALL_X, RLIST_ALL_Y:
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					if (BlkValueRead(rel, tmp) & RRF_USED) {
						tmp++;
						if (Y == RLIST_ALL_Y) tmp++;
						v = BlkValueRead(rel, tmp);
						LIST_OF_TY_InsertItem(X, v, false, 0, true);
					}
				}
				return X;
			RLIST_ALL_PAIRS:
				! LIST_OF_TY_InsertItem will make a deep copy of the item,
				! so we can reuse a single combination value here
				
				Y = BlkValueCreate(kov);
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					if (BlkValueRead(rel, tmp) & RRF_USED) {
						v = BlkValueRead(rel, tmp + 1);
						BlkValueWrite(Y, COMBINATION_ITEM_BASE, v);
						v = BlkValueRead(rel, tmp + 2);
						BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, v);
						LIST_OF_TY_InsertItem(X, Y);
					}
				}
				BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
				BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);
				BlkValueFree(Y);
				return X;
		}
		rfalse;
	}
	at = DoubleHashSetLookUp(rel, kx, ky, X, Y);
	switch(task) {
		RELS_TEST:
			if (at >= 0) rtrue;
			rfalse;
		RELS_ASSERT_TRUE:
			if (at >= 0) rtrue;
			at = ~at;
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
			if (BlkValueRead(rel, RRV_DATA_BASE + 3*at) == 0)
				BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
			if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
			if (KOVIsBlockValue(ky)) { Y = BlkValueCopy(BlkValueCreate(ky), Y); }
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
			DoubleHashSetCheckResize(rel);
			rtrue;
		RELS_ASSERT_FALSE:
			if (at < 0) rtrue;
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
			if (KOVIsBlockValue(kx))
				BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
			if (KOVIsBlockValue(ky))
				BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);
			rtrue;
	}
];

[ DoubleHashSetLookUp rel kx ky X Y  hashv i free mask perturb flags;
	! calculate a hash value for the pair
	hashv = GetHashValue(kx, x) + GetHashValue(ky, y);
	! look in the first expected slot
	mask = BlkValueRead(rel, RRV_STORAGE);
	i = hashv & mask;
	flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
	if (flags == 0) return ~i;
	if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y)) return i;
	! not here, keep looking in sequence
	free = -1;
	if (flags & RRF_DELETED) free = i;
	perturb = hashv;
	hashv = i;
	for (::) {
		hashv = hashv*5 + perturb + 1;
		i = hashv & mask;
		flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
		if (flags == 0) {
			if (free >= 0) return ~free;
			return ~i;
		}
		if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y))
			return i;
		if ((free < 0) && (flags & RRF_DELETED)) free = i;
		#ifdef TARGET_ZCODE;
		@log_shift perturb (-RRP_PERTURB_SHIFT) -> perturb;
		#ifnot;
		@ushiftr perturb RRP_PERTURB_SHIFT perturb;
		#endif;
	}
];

[ DoubleHashSetCheckResize rel  filled ext newext temp i at kov kx ky F X Y;
	filled = BlkValueRead(rel, RRV_FILLED);
	ext = BlkValueRead(rel, RRV_STORAGE) + 1;
	if (filled >= (ext - filled) * RRP_CROWDED_IS) {
		! copy entries to temporary space
		temp = FlexAllocate(ext * (3*WORDSIZE), TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
		for (i=0: i<ext*3: i++)
			BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i), true);
		! resize and clear our data
		if (ext >= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;
		else newext = ext * RRP_RESIZE_SMALL;
		BlkValueSetLBCapacity(rel, RRV_DATA_BASE + newext*3);
		BlkValueWrite(rel, RRV_STORAGE, newext - 1);
		BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
		for (i=0: i<newext*3: i++)
			BlkValueWrite(rel, RRV_DATA_BASE+i, 0);
		! copy entries back from temporary space
		kov = BlkValueRead(rel, RRV_KIND);
		kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
		for (i=0: i<ext: i++) {
			F = BlkValueRead(temp, 3*i, true);
			if (F == 0 || (F & RRF_DELETED)) continue;
			X = BlkValueRead(temp, 3*i + 1, true);
			Y = BlkValueRead(temp, 3*i + 2, true);
			at = DoubleHashSetLookUp(rel, kx, ky, X, Y);
			if (at >= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }
			at = ~at;
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, F);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
		}
		! done with temporary space
		FlexFree(temp);
	}
];

[ DoubleHashSetEntryMatches rel at kx ky X Y  cx cy;
	cx = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
	if (KOVIsBlockValue(kx)) {
		if (BlkValueCompare(cx, X) ~= 0) rfalse;
	} else {
		if (cx ~= X) rfalse;
	}
	cy = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
	if (KOVIsBlockValue(ky)) {
		if (BlkValueCompare(cy, Y) ~= 0) rfalse;
	} else {
		if (cy ~= Y) rfalse;
	}
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Hash List Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ HashListRelationHandler rel task X Y  sym kov kx ky;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 1);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Hash Table Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ HashTableRelationHandler rel task X Y  kov kx ky;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Reversed Hash Table Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ ReversedHashTableRelationHandler rel task X Y  kov kx ky swap;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	switch (task) {
		RELS_SET_VALENCY:
			return RELATION_TY_SetValency(rel, X);
		RELS_TEST, RELS_ASSERT_TRUE, RELS_ASSERT_FALSE:
			return HashCoreRelationHandler(rel, task, ky, kx, Y, X, 0);
		RELS_LOOKUP_ANY:
			switch (Y) {
				RLANY_GET_X: Y = RLANY_GET_Y;
				RLANY_GET_Y: Y = RLANY_GET_X;
				RLANY_CAN_GET_X: Y = RLANY_CAN_GET_Y;
				RLANY_CAN_GET_Y: Y = RLANY_CAN_GET_X;
			}
		RELS_LOOKUP_ALL_X:
			task = RELS_LOOKUP_ALL_Y;
		RELS_LOOKUP_ALL_Y:
			task = RELS_LOOKUP_ALL_X;
		RELS_SHOW:
			swap=X; X=Y; Y=swap;
			swap=kx; kx=ky; ky=swap;
 		RELS_LIST:
			switch (Y) {
				RLIST_ALL_X: Y = RLIST_ALL_Y;
				RLIST_ALL_Y: Y = RLIST_ALL_X;
			}
	}
	return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Symmetric Relation Handlers
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ SymDoubleHashSetRelationHandler rel task X Y;
	if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)
		DoubleHashSetRelationHandler(rel, task, Y, X);
	return DoubleHashSetRelationHandler(rel, task, X, Y, 1);
];

[ SymHashListRelationHandler rel task X Y;
	if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)
		HashListRelationHandler(rel, task, Y, X);
	return HashListRelationHandler(rel, task, X, Y);
];

[ Sym2in1HashTableRelationHandler rel task X Y;
	if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)
		TwoInOneHashTableRelationHandler(rel, task, Y, X);
	return TwoInOneHashTableRelationHandler(rel, task, X, Y, 1);
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Hash Core Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ HashCoreRelationHandler rel task kx ky X Y mult  sym rev at tmp fl;
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);
		if (~~(kx || ky)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (fl & RRF_USED) {
				if (kx) BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				if (ky || ~~(fl & RRF_SINGLE))
					BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
			}
			at--;
		}
		return;
	} else if (task == RELS_COPY) {
		X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);
		if (~~(X || Y)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (fl & RRF_USED) {
				if (X) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
					tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, tmp);
				}
				if (Y || ~~(fl & RRF_SINGLE)) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
					tmp = BlkValueCopy(BlkValueCreate(BlkValueWeakKind(tmp)), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
				}
			}
			at--;
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		! Z-machine doesn't have the room to let us pass sym/rev as parameters
		switch (RELATION_TY_GetValency(rel)) {
			RRVAL_SYM_V_TO_V:
				sym = 1;
				tmp = KOVComparisonFunction(kx);
				if (~~tmp) tmp = UnsignedCompare;
			RRVAL_O_TO_V:
				rev = 1;
		}
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (fl & RRF_USED) {
				X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
				Y = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
				if (fl & RRF_SINGLE) {
					if (sym && tmp(X, Y) > 0) continue;
					print "  ";
					if (rev) PrintKindValuePair(ky, Y);
					else PrintKindValuePair(kx, X);
					if (sym) print " <=> "; else print " >=> ";
					if (rev) PrintKindValuePair(kx, X);
					else PrintKindValuePair(ky, Y);
					print "^";
				} else {
					for (mult=1: mult<=LIST_OF_TY_GetLength(Y): mult++) {
						fl = LIST_OF_TY_GetItem(Y, mult);
						if (sym && tmp(X, fl) > 0) continue;
						print "  ";
						if (rev) PrintKindValuePair(ky, fl);
						else PrintKindValuePair(kx, X);
						if (sym) print " <=> "; else print " >=> ";
						if (rev) PrintKindValuePair(kx, X);
						else PrintKindValuePair(ky, fl);
						print "^";
					}
				}
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		if (BlkValueRead(rel, RRV_USED) == 0) rtrue;
		if (X == 1) {
			HashCoreRelationHandler(rel, RELS_DESTROY);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				BlkValueWrite(rel, tmp, 0);
				BlkValueWrite(rel, tmp + 1, 0);
				BlkValueWrite(rel, tmp + 2, 0);
			}
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
			rtrue;
		}
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		if (Y == RLANY_GET_Y or RLANY_CAN_GET_Y) {
			at = HashCoreLookUp(rel, kx, X);
			if (at >= 0) {
				if (Y == RLANY_CAN_GET_Y) rtrue;
				tmp = RRV_DATA_BASE + 3*at;
				fl = BlkValueRead(rel, tmp);
				tmp = BlkValueRead(rel, tmp + 2);
				if (fl & RRF_SINGLE) return tmp;
				return LIST_OF_TY_GetItem(tmp, 1);
			}
		} else {
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				fl = BlkValueRead(rel, tmp);
				if (fl & RRF_USED) {
					sym = BlkValueRead(rel, tmp + 2);
					if (fl & RRF_SINGLE) {
						if (KOVIsBlockValue(ky)) {
							if (BlkValueCompare(X, sym) ~= 0) continue;
						} else {
							if (X ~= sym) continue;
						}
					} else {
						if (LIST_OF_TY_FindItem(sym, X) == 0) continue;
					}
					if (Y == RLANY_CAN_GET_X) rtrue;
					return BlkValueRead(rel, tmp + 1);
				}
			}
		}
		if (Y == RLANY_GET_X or RLANY_GET_Y)
			print "*** Lookup failed: value not found ***^";
		rfalse;
	} else if (task == RELS_LOOKUP_ALL_X) {
		if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			fl = BlkValueRead(rel, tmp);
			if (fl & RRF_USED) {
				sym = BlkValueRead(rel, tmp + 2);
				if (fl & RRF_SINGLE) {
					if (KOVIsBlockValue(ky)) {
						if (BlkValueCompare(X, sym) ~= 0) continue;
					} else {
						if (X ~= sym) continue;
					}
				} else {
					if (LIST_OF_TY_FindItem(sym, X) == 0) continue;
				}
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));
			}
		}
		return Y;
	} else if (task == RELS_LOOKUP_ALL_Y) {
		if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		at = HashCoreLookUp(rel, kx, X);
		if (at >= 0) {
			tmp = RRV_DATA_BASE + 3*at;
			fl = BlkValueRead(rel, tmp);
			tmp = BlkValueRead(rel, tmp + 2);
			if (fl & RRF_SINGLE)
				LIST_OF_TY_InsertItem(Y, tmp);
			else
				LIST_OF_TY_AppendList(Y, tmp);
		}
		return Y;
	} else if (task == RELS_LIST) {
		if (BlkValueWeakKind(X) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(X, 0);
		switch (Y) {
			RLIST_ALL_X:
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					fl = BlkValueRead(rel, tmp);
					if (fl & RRF_USED)
						LIST_OF_TY_InsertItem(X, BlkValueRead(rel, tmp + 1));
				}
				return X;
			RLIST_ALL_Y:
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					fl = BlkValueRead(rel, tmp);
					if (fl & RRF_USED) {
						tmp = BlkValueRead(rel, tmp + 2);
						if (fl & RRF_SINGLE)
							LIST_OF_TY_InsertItem(X, tmp, false, 0, true);
						else
							LIST_OF_TY_AppendList(X, tmp, false, 0, true);
					}
				}
				return X;
			RLIST_ALL_PAIRS:
				if (RELATION_TY_GetValency(rel) == RRVAL_O_TO_V) rev = 1;
				! LIST_OF_TY_InsertItem will make a deep copy of the item,
				! so we can reuse a single combination value here
				Y = BlkValueCreate(COMBINATION_TY, tmp);
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					fl = BlkValueRead(rel, tmp);
					if (fl & RRF_USED) {
						BlkValueWrite(Y, COMBINATION_ITEM_BASE + rev, BlkValueRead(rel, tmp + 1));
						tmp = BlkValueRead(rel, tmp + 2);
						if (fl & RRF_SINGLE) {
							BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1 - rev, tmp);
							LIST_OF_TY_InsertItem(X, Y);
						} else {
							for (mult = LIST_OF_TY_GetLength(tmp): mult > 0: mult--) {
								BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1 - rev,
									LIST_OF_TY_GetItem(tmp, mult));
								LIST_OF_TY_InsertItem(X, Y);
							}
						}
					}
				}
				BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
				BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);
				BlkValueFree(Y);
				return X;
		}
		rfalse;
	}
	at = HashCoreLookUp(rel, kx, X);
	switch(task) {
		RELS_TEST:
			if (at < 0) rfalse;
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			if (fl & RRF_SINGLE) {
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(tmp, Y) == 0) rtrue;
				} else {
					if (tmp == Y) rtrue;
				}
				rfalse;
			} else {
				return LIST_OF_TY_FindItem(tmp, Y);
			}
		RELS_ASSERT_TRUE:
			if (at < 0) {
				! no entry exists for this key, just add one
				at = ~at;
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				if (BlkValueRead(rel, RRV_DATA_BASE + 3*at) == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
				if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
				if (KOVIsBlockValue(ky)) { Y = BlkValueCopy(BlkValueCreate(ky), Y); }
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
				HashCoreCheckResize(rel);
				break;
			}
			! an entry exists: could be a list or a single value
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);		! flags
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! value or list
			if (fl & RRF_SINGLE) {
				! if Y is the same as the stored key, we have nothing to do
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(tmp, Y) == 0) rtrue;
				} else {
					if (tmp == Y) rtrue;
				}
				! it's different: either replace it or expand into a list,
				! depending on the value of mult
				if (mult) {
					fl = BlkValueCreate(LIST_OF_TY);	! new list
					BlkValueWrite(fl, LIST_ITEM_KOV_F, ky);
					LIST_OF_TY_SetLength(fl, 2);
					BlkValueWrite(fl, LIST_ITEM_BASE, tmp);	! do not copy
					LIST_OF_TY_PutItem(fl, 2, Y);		! copy if needed
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, fl);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED);
				} else {
					if (KOVIsBlockValue(ky)) {
						BlkValueFree(tmp);
						Y = BlkValueCopy(BlkValueCreate(ky), Y);
					}
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
				}
			} else {
				! if Y is present already, do nothing. otherwise add it.
				LIST_OF_TY_InsertItem(tmp, Y, 0, 0, 1);
			}
			rtrue;
		RELS_ASSERT_FALSE:
			if (at < 0) rtrue;
			! an entry exists: could be a list or a single value
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);		! flags
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! value or list
			if (fl & RRF_SINGLE) {
				! if the stored key isn't Y, we have nothing to do
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(tmp, Y) ~= 0) rtrue;
				} else {
					if (tmp ~= Y) rtrue;
				}
				! delete the entry
				if (KOVIsBlockValue(ky))
					BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
				.DeleteEntryIgnoringY;
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
				if (KOVIsBlockValue(kx))
					BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);
			} else {
				! remove Y from the list if present
				LIST_OF_TY_RemoveValue(tmp, Y, 1);
				! if the list is now empty, delete the whole entry
				if (LIST_OF_TY_GetLength(tmp) == 0) {
					BlkValueFree(tmp);
					jump DeleteEntryIgnoringY;
				}
			}
			rtrue;
	}
	rtrue;
];

[ HashCoreLookUp rel kx X  hashv i free mask perturb flags;
!print "[HCLU rel=", rel, " kx=", kx, " X=", X, ": ";
	! calculate a hash value for the key
	hashv = GetHashValue(kx, x);
	! look in the first expected slot
	mask = BlkValueRead(rel, RRV_STORAGE);
	i = hashv & mask;
!print "hv=", hashv, ", trying ", i;
	flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
	if (flags == 0) {
!print " - not found]^";
		return ~i;
	}
	if (HashCoreEntryMatches(rel, i, kx, X)) {
!print " - found]^";
		return i;
	}
	! not here, keep looking in sequence
	free = -1;
	if (flags & RRF_DELETED) free = i;
	perturb = hashv;
	hashv = i;
	for (::) {
		hashv = hashv*5 + perturb + 1;
		i = hashv & mask;
!print ", ", i;
		flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
		if (flags == 0) {
!print " - not found]^";
			if (free >= 0) return ~free;
			return ~i;
		}
		if (HashCoreEntryMatches(rel, i, kx, X)) {
!print " - found]^";
			return i;
		}
		if ((free < 0) && (flags & RRF_DELETED)) free = i;
		#ifdef TARGET_ZCODE;
		@log_shift perturb (-RRP_PERTURB_SHIFT) -> perturb;
		#ifnot;
		@ushiftr perturb RRP_PERTURB_SHIFT perturb;
		#endif;
	}
];

[ HashCoreCheckResize rel  filled ext newext temp i at kov kx F X Y;
	filled = BlkValueRead(rel, RRV_FILLED);
	ext = BlkValueRead(rel, RRV_STORAGE) + 1;
	if (filled >= (ext - filled) * RRP_CROWDED_IS) {
		! copy entries to temporary space
		temp = FlexAllocate(ext * (3*WORDSIZE), TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
		for (i=0: i<ext*3: i++)
			BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i), true);
		! resize and clear our data
		if (ext >= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;
		else newext = ext * RRP_RESIZE_SMALL;
		BlkValueSetLBCapacity(rel, RRV_DATA_BASE + newext*3);
		BlkValueWrite(rel, RRV_STORAGE, newext - 1);
		BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
		for (i=0: i<newext*3: i++)
			BlkValueWrite(rel, RRV_DATA_BASE+i, 0);
		! copy entries back from temporary space
		kov = BlkValueRead(rel, RRV_KIND);
		kx = KindBaseTerm(kov, 0);
		for (i=0: i<ext: i++) {
			F = BlkValueRead(temp, 3*i, true);
			if (F == 0 || (F & RRF_DELETED)) continue;
			X = BlkValueRead(temp, 3*i + 1, true);
			Y = BlkValueRead(temp, 3*i + 2, true);
			at = HashCoreLookUp(rel, kx, X);
			if (at >= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }
			at = ~at;
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, F);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
		}
		! done with temporary space
		FlexFree(temp);
	}
];

[ HashCoreEntryMatches rel at kx X  cx cy;
	cx = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
	if (KOVIsBlockValue(kx)) {
		if (BlkValueCompare(cx, X) ~= 0) rfalse;
	} else {
		if (cx ~= X) rfalse;
	}
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Equivalence Hash Table Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ EquivHashTableRelationHandler rel task X Y  kx at at2 tmp fl i ext;
	kx = KindBaseTerm(BlkValueRead(rel, RRV_KIND), 0);
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		if (KOVIsBlockValue(kx)) {
			at = BlkValueRead(rel, RRV_STORAGE);
			while (at >= 0) {
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
				if (fl & RRF_USED) {
					BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				}
				at--;
			}
		}
		return;
	} else if (task == RELS_COPY) {
		if (KOVIsBlockValue(kx)) {
			at = BlkValueRead(rel, RRV_STORAGE);
			while (at >= 0) {
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
				if (fl & RRF_USED) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
					tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1);
				}
				at--;
			}
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		ext = BlkValueRead(rel, RRV_STORAGE);
		! flag all items by negating their group numbers
		for (at=0, X=RRV_DATA_BASE: at<=ext: at++, X=X+3)
			if (BlkValueRead(rel, X) & RRF_USED)
				BlkValueWrite(rel, X + 2, -(BlkValueRead(rel, X + 2)));
		! display groups, unflagging them as we go
		for (at=0, X=RRV_DATA_BASE, fl=0: at<=ext: at++, X=X+3, fl=0) {
			if (BlkValueRead(rel, X) & RRF_USED) {
				fl = BlkValueRead(rel, X + 2);
				if (fl > 0) continue;		! already visited
				BlkValueWrite(rel, X + 2, -fl);	! unflag it
				! display the group starting with this member, but only
				! if there are more members in the group
				tmp = BlkValueRead(rel, X + 1);
				i = 0;
				for (at2=at+1, Y=RRV_DATA_BASE+3*at2: at2<=ext: at2++, Y=Y+3) {
					if (BlkValueRead(rel, Y) & RRF_USED) {
						if (BlkValueRead(rel, Y + 2) ~= fl) continue;
						BlkValueWrite(rel, Y + 2, -fl);
						if (~~i) {
							! print the saved first member
							print "  { ";
							PrintKindValuePair(kx, tmp);
							i = 1;
						}
						print ", ";
						PrintKindValuePair(kx, BlkValueRead(rel, Y + 1));
					}
				}
				if (i) print " }^";
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		! never empty since R(x,x) is always true
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		! kind of a cheat, but it's faster than searching for a better value to return
		if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
		return X;
	} else if (task == RELS_LOOKUP_ALL_X or RELS_LOOKUP_ALL_Y) {
		if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		BlkValueWrite(Y, LIST_ITEM_KOV_F, kx);
		at = HashCoreLookUp(rel, kx, X);
		if (at < 0) {
			LIST_OF_TY_InsertItem(Y, X);
		} else {
			X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				fl = BlkValueRead(rel, tmp);
				if (fl & RRF_USED) {
					if (BlkValueRead(rel, tmp + 2) ~= X) continue;
					LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));
				}
			}
		}
		return Y;
	} else if (task == RELS_LIST) {
		print "*** Domains of equivalence relations cannot be listed ***^";
		return X;
	}
	at = HashCoreLookUp(rel, kx, X);
	at2 = HashCoreLookUp(rel, kx, Y);
	switch(task) {
		RELS_TEST:
			if (at < 0) {
				! X is a loner, but could still be true if X == Y
				if (KOVIsBlockValue(kx)) {
					if (BlkValueCompare(X, Y) == 0) rtrue;
				} else {
					if (X == Y) rtrue;
				}
				rfalse;
			}
			if (at2 < 0) rfalse;
			if (at == at2) rtrue;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			if (BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2) == tmp) rtrue;
			rfalse;
		RELS_ASSERT_TRUE:
			! if X and Y are the same, we have nothing to do
			if (KOVIsBlockValue(kx)) {
				if (BlkValueCompare(X, Y) == 0) rtrue;
			} else {
				if (X == Y) rtrue;
			}
			if (at < 0) {
				if (at2 < 0) {
					! X and Y both missing: find a new group number and add both entries
					tmp = 0;		! candidate group number
					ext = BlkValueRead(rel, RRV_STORAGE);
					for (i=0: i<=ext: i++) {
						fl = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
						if (fl & RRF_USED) {
							fl = BlkValueRead(rel, RRV_DATA_BASE + 3*i + 2);
							if (fl > tmp) tmp = fl;
						}
					}
					tmp++;			! new group number
					BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 2);
					! add X entry
					at = ~at;
					if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
					fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
					if (fl == 0)
						BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
					! add Y entry. at2 might change if X and Y have the same hash code.
					at2 = ~(HashCoreLookUp(rel, kx, Y));
					if (KOVIsBlockValue(kx)) { Y = BlkValueCopy(BlkValueCreate(kx), Y); }
					fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2);
					if (fl == 0)
						BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at2, RRF_USED+RRF_SINGLE);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 1, Y);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 2, tmp);
					jump CheckResize;
				}
				! X missing, Y present: add a new X entry
				at = ~at;
				if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
				if (fl == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
				tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
				jump CheckResize;
			}
			if (at2 < 0) {
				! X present, Y missing: add a new Y entry
				at2 = ~at2;
				if (KOVIsBlockValue(kx)) { Y = BlkValueCopy(BlkValueCreate(kx), Y); }
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2);
				if (fl == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at2, RRF_USED+RRF_SINGLE);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 1, Y);
				tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 2, tmp);
				jump CheckResize;
			}
			! X and Y both present: merge higher group into lower group
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! higher group
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2);	! lower group
			if (tmp < fl) { i = tmp; tmp = fl; fl = i; }
			ext = BlkValueRead(rel, RRV_STORAGE);
			for (at=0: at<=ext: at++) {
				i = RRV_DATA_BASE + 3*at + 2;
				if (BlkValueRead(rel, i) == tmp)
					BlkValueWrite(rel, i, fl);
			}
			.CheckResize;
			HashCoreCheckResize(rel);
			rtrue;
		RELS_ASSERT_FALSE:
			! if X and Y are already in different groups, we have nothing to do
			if (at < 0 || at2 < 0) rtrue;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			if (BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2) ~= tmp) rtrue;
			! delete the entry for X
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
			if (KOVIsBlockValue(kx))
				BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);
			rtrue;
	}
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Two-In-One Hash Table Relation Handler
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ TwoInOneHashTableRelationHandler rel task X Y sym  kov kx ky at at2 tmp fl;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);
		if (~~(kx || ky)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if (fl & RRF_USED)
				if ((kx && (fl & RRF_ENTKEYX)) || (ky && (fl & RRF_ENTKEYY))) {
					BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1));
				}
			at--;
		}
		return;
	} else if (task == RELS_COPY) {
		X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);
		if (~~(X || Y)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if (fl & RRF_USED) {
				if ((X && (fl & RRF_ENTKEYX)) || (Y && (fl & RRF_ENTKEYY))) {
					! copy the entry key
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
					if (fl & RRF_ENTKEYX)
						tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					else
						tmp = BlkValueCopy(BlkValueCreate(ky), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, tmp);
					! update references in X/Y fields pointing here
					if (fl & RRF_HASX) {
						at2 = TwoInOneLookUp(rel, kx,
							BlkValueRead(rel, RRV_DATA_BASE + 4*at + 2),
							RRF_ENTKEYX);
						if (at2 >= 0)
							BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 3, tmp);
					}
					if (fl & RRF_HASY) {
						at2 = TwoInOneLookUp(rel, ky,
							BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3),
							RRF_ENTKEYY);
						if (at2 >= 0)
							BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 2, tmp);
					}
				}
			}
			at--;
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		if (sym) {
			kov = KOVComparisonFunction(kx);
			if (~~kov) kov = UnsignedCompare;
		}
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if ((fl & (RRF_USED+RRF_ENTKEYX+RRF_HASY)) ==
				(RRF_USED+RRF_ENTKEYX+RRF_HASY)) {
				X = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
				Y = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
				if (sym && kov(X, Y) > 0) continue;
				print "  ";
				PrintKindValuePair(kx, X);
				if (sym) print " <=> "; else print " >=> ";
				PrintKindValuePair(ky, Y);
				print "^";
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		if (BlkValueRead(rel, RRV_USED) == 0) rtrue;
		if (X == 1) {
			TwoInOneHashTableRelationHandler(rel, RELS_DESTROY);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 4*at;
				BlkValueWrite(rel, tmp, 0);
				BlkValueWrite(rel, tmp + 1, 0);
				BlkValueWrite(rel, tmp + 2, 0);
				BlkValueWrite(rel, tmp + 3, 0);
			}
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
			rtrue;
		}
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		switch (Y) {
			RLANY_GET_X, RLANY_CAN_GET_X:
				at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY);
				if (at >= 0) {
					tmp = RRV_DATA_BASE + 4*at;
					if (BlkValueRead(rel, tmp) & RRF_HASX) {
						if (Y == RLANY_CAN_GET_X) rtrue;
						return BlkValueRead(rel, tmp + 2);
					}
				}
			RLANY_GET_Y, RLANY_CAN_GET_Y:
				at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);
				if (at >= 0) {
					tmp = RRV_DATA_BASE + 4*at;
					if (BlkValueRead(rel, tmp) & RRF_HASY) {
						if (Y == RLANY_CAN_GET_Y) rtrue;
						return BlkValueRead(rel, tmp + 3);
					}
				}
		}
		if (Y == RLANY_GET_X or RLANY_GET_Y)
			print "*** Lookup failed: value not found ***^";
		rfalse;
	} else if (task == RELS_LOOKUP_ALL_X) {
		at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY);
		if (at >= 0) {
			tmp = RRV_DATA_BASE + 4*at;
			if (BlkValueRead(rel, tmp) & RRF_HASX)
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 2));
		}
		return Y;
	} else if (task == RELS_LOOKUP_ALL_Y) {
		at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);
		if (at >= 0) {
			tmp = RRV_DATA_BASE + 4*at;
			if (BlkValueRead(rel, tmp) & RRF_HASY)
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 3));
		}
		return Y;
	} else if (task == RELS_LIST) {
		switch (Y) {
			RLIST_ALL_X:
				fl = RRF_USED+RRF_ENTKEYX+RRF_HASY;
				jump ListEntryKeys;
			RLIST_ALL_Y:
				fl = RRF_USED+RRF_ENTKEYY+RRF_HASX;
				.ListEntryKeys;
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 4*at;
					if ((BlkValueRead(rel, tmp) & fl) == fl)
						LIST_OF_TY_InsertItem(X, BlkValueRead(rel, tmp + 1), false, 0, true);
				}
			RLIST_ALL_PAIRS:
				tmp = BlkValueRead(X, LIST_ITEM_KOV_F);
				if (KindAtomic(tmp) ~= COMBINATION_TY) rfalse;
				! LIST_OF_TY_InsertItem will make a deep copy of the item,
				! so we can reuse a single combination value here
				Y = BlkValueCreate(tmp);
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 4*at;
					fl = BlkValueRead(rel, tmp);
					if ((fl & (RRF_USED+RRF_ENTKEYX+RRF_HASY)) ==
						(RRF_USED+RRF_ENTKEYX+RRF_HASY)) {
						BlkValueWrite(Y, COMBINATION_ITEM_BASE, BlkValueRead(rel, tmp + 1));
						BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, BlkValueRead(rel, tmp + 3));
						LIST_OF_TY_InsertItem(X, Y);
					}
				}
				BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
				BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);
				BlkValueFree(Y);
				return X;
		}
		return X;
	}
	at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);
	switch(task) {
		RELS_TEST:
			if (at < 0) rfalse;
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if (~~(fl & RRF_HASY)) rfalse;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
			if (KOVIsBlockValue(ky)) {
				if (BlkValueCompare(tmp, Y) == 0) rtrue;
			} else {
				if (tmp == Y) rtrue;
			}
			rfalse;
		RELS_ASSERT_TRUE:
			if (at < 0) {
				! create a new forward entry
				at = ~at;
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
				if (fl == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				fl = RRF_USED+RRF_HASY+RRF_ENTKEYX;
				if (kx == ky || ~~(KOVIsBlockValue(kx) || KOVIsBlockValue(ky)))
					fl = fl + RRF_ENTKEYY;
				BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl);
				if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
				BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, X);
				BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, 0);
			} else {
				fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
				if (fl & RRF_HASY) {
					! if the Y we're inserting is already there, we're done
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
					if (KOVIsBlockValue(ky)) {
						if (BlkValueCompare(tmp, Y) == 0) rtrue;
					} else {
						if (tmp == Y) rtrue;
					}
					! it's different, so delete the reverse entry
					at2 = TwoInOneLookUp(rel, ky, tmp, RRF_ENTKEYY);
					if (at2 >= 0) TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
				} else {
					BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl + RRF_HASY);
				}
				! use the existing copy of X
				X = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
			}
			! use the existing copy of Y if there is one
			at2 = TwoInOneLookUp(rel, ky, Y, RRF_ENTKEYY);
			if (KOVIsBlockValue(ky)) {
				if (at2 >= 0)
					Y = BlkValueRead(rel, RRV_DATA_BASE + 4*at2 + 1);
				else
					Y = BlkValueCopy(BlkValueCreate(ky), Y);
			}
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, Y);
			if (at2 >= 0) {
				! delete existing reverse entry (and its own forward entry)
				TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY, 1);
			} else {
				at2 = ~at2;
			}
			! create reverse entry
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at2);
			if (fl == 0)
				BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
			fl = fl | (RRF_USED+RRF_HASX+RRF_ENTKEYY);
			if (kx == ky || ~~(KOVIsBlockValue(kx) || KOVIsBlockValue(ky)))
				fl = fl | RRF_ENTKEYX;
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at2, fl);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 1, Y);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 2, X);
			TwoInOneCheckResize(rel);
			rtrue;
		RELS_ASSERT_FALSE:
			! we only have work to do if the entry exists and has a Y which
			! matches the Y we're deleting
			if (at < 0) rtrue;
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if ((fl & RRF_HASY) == 0) rtrue;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
			if (KOVIsBlockValue(ky)) {
				if (BlkValueCompare(tmp, Y) ~= 0) rtrue;
			} else {
				if (tmp ~= Y) rtrue;
			}
			TwoInOneDelete(rel, at, kx, ky, RRF_ENTKEYX, 1);
			rtrue;
	}
];

[ TwoInOneDelete rel at kx ky ekflag both  fl at2 E i;
!print "[2in1DEL at=", at, " (E=", BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1), ") ekflag=", ekflag, " both=", both, "]^";
	fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
	if (ekflag == RRF_ENTKEYX) {
		if (fl & RRF_HASY) {
			i = RRV_DATA_BASE + 4*at + 3;
			if (both) E = BlkValueRead(rel, i);
			BlkValueWrite(rel, i, 0);
			! delete matching Y<-X entry if needed
			if (both) {
				at2 = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY);
				if (at2 >= 0) TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
				if (at2 == at) fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			}
			fl = fl & ~RRF_HASY;
		}
	} else {
		if (fl & RRF_HASX) {
			i = RRV_DATA_BASE + 4*at + 2;
			if (both) E = BlkValueRead(rel, i);
			BlkValueWrite(rel, i, 0);
			! delete matching X->Y entry if needed
			if (both) {
				at2 = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX);
				if (at2 >= 0) {
					TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYX);
					if (at2 == at) fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
				}
			}
			fl = fl & ~RRF_HASX;
		}
	}
	if ((fl & (RRF_HASX+RRF_HASY)) == 0) {
		! entry is now empty, mark it deleted
		if (((fl & RRF_ENTKEYX) && KOVIsBlockValue(kx)) ||
		    ((ky ~= kx) && (fl & RRF_ENTKEYY) && KOVIsBlockValue(ky))) {
			BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1));
		}
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at, RRF_DELETED);
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, 0);
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, 0);
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, 0);
		BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
	} else {
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl);
	}
];

[ TwoInOneLookUp rel ke E ekflag  hashv i free mask perturb flags;
!print "[2in1LU rel=", rel, " ke=", ke, " E=", E, " ekf=", ekflag, ": ";
	! calculate a hash value for the key
	hashv = GetHashValue(ke, E);
	! look in the first expected slot
	mask = BlkValueRead(rel, RRV_STORAGE);
	i = hashv & mask;
!print "hv=", hashv, ", trying ", i;
	flags = BlkValueRead(rel, RRV_DATA_BASE + 4*i);
	if (flags == 0) {
!print " - not found]^";
		return ~i;
	}
	if ((flags & ekflag) && TwoInOneEntryMatches(rel, i, ke, E)) {
!print " - found]^";
		return i;
	}
	! not here, keep looking in sequence
	free = -1;
	if (flags & RRF_DELETED) free = i;
	perturb = hashv;
	hashv = i;
	for (::) {
		hashv = hashv*5 + perturb + 1;
		i = hashv & mask;
!print ", ", i;
		flags = BlkValueRead(rel, RRV_DATA_BASE + 4*i);
		if (flags == 0) {
!print " - not found]^";
			if (free >= 0) return ~free;
			return ~i;
		}
		if ((flags & ekflag) && TwoInOneEntryMatches(rel, i, ke, E)) {
!print " - found]^";
			return i;
		}
		if ((free < 0) && (flags & RRF_DELETED)) free = i;
		#ifdef TARGET_ZCODE;
		@log_shift perturb (-RRP_PERTURB_SHIFT) -> perturb;
		#ifnot;
		@ushiftr perturb RRP_PERTURB_SHIFT perturb;
		#endif;
	}
];

[ TwoInOneCheckResize rel  filled ext newext temp i at kov kx ky F E X Y;
	filled = BlkValueRead(rel, RRV_FILLED);
	ext = BlkValueRead(rel, RRV_STORAGE) + 1;
	if (filled >= (ext - filled) * RRP_CROWDED_IS) {
		! copy entries to temporary space
		temp = FlexAllocate(ext * (4*WORDSIZE), TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
		for (i=0: i<ext*4: i++)
			BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i), true);
		! resize and clear our data
		if (ext >= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;
		else newext = ext * RRP_RESIZE_SMALL;
		BlkValueSetLBCapacity(rel, RRV_DATA_BASE + newext*4);
		BlkValueWrite(rel, RRV_STORAGE, newext - 1);
		BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
		for (i=0: i<newext*4: i++)
			BlkValueWrite(rel, RRV_DATA_BASE+i, 0);
		! copy entries back from temporary space
		kov = BlkValueRead(rel, RRV_KIND);
		kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
		for (i=0: i<ext: i++) {
			F = BlkValueRead(temp, 4*i, true);
			if (F == 0 || (F & RRF_DELETED)) continue;
			E = BlkValueRead(temp, 4*i + 1, true);
			X = BlkValueRead(temp, 4*i + 2, true);
			Y = BlkValueRead(temp, 4*i + 3, true);
			if (F & RRF_ENTKEYX) at = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX);
			else at = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY);
			if (at >= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }
			at = ~at;
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at, F);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, E);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, Y);
		}
		! done with temporary space
		FlexFree(temp);
	}
];

[ TwoInOneEntryMatches rel at ke E  ce;
	ce = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
	if (KOVIsBlockValue(ke)) {
		if (BlkValueCompare(ce, E) ~= 0) rfalse;
	} else {
		if (ce ~= E) rfalse;
	}
	rtrue;
];


! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! RelationKind.i6t: Empty
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

[ RELATION_TY_Empty rel set  handler;
	handler = RlnGetF(rel, RR_HANDLER);
	return handler(rel, RELS_EMPTY, set);
];


Array ResourceIDsOfFigures --> 0 1 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  0;

Array ResourceIDsOfSounds --> 0  0;



Array BC_0 --> PACKED_TEXT_STORAGE TX_PS_2;
Array BC_1 --> PACKED_TEXT_STORAGE TX_PS_3;
Array BC_2 --> PACKED_TEXT_STORAGE TX_PS_4;
Array BC_3 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_4 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_5 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_6 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_7 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_8 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_9 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_10 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_11 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_12 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_13 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_14 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_15 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_16 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_17 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_18 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_19 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_20 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_21 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_22 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_23 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_24 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_25 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_26 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_27 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_28 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_29 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_30 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_31 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_32 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_33 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_34 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_35 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_36 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_37 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_38 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_39 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_40 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_41 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_42 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_43 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_44 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_45 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_46 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_47 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_48 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_49 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_50 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_51 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_52 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_53 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_54 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_55 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_56 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_57 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_58 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_59 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_60 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_61 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_62 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_63 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_64 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_65 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_66 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_67 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_68 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_69 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_70 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_71 --> PACKED_TEXT_STORAGE TX_PS_6;
Array BC_72 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_73 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_74 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_75 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_76 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_77 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_78 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_79 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_80 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_81 --> PACKED_TEXT_STORAGE TX_PS_7;
Array BC_82 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_134;
Array BC_83 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_84 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_85 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_86 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_87 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_88 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_89 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_90 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_91 --> PACKED_TEXT_STORAGE TX_PS_8;
Array BC_92 --> LIST_CONST_87571 0;
Array BC_93 --> Default_Value_0 0;
Array BC_94 --> Default_Value_1 0;
Array BC_95 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_96 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_97 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_98 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_99 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_100 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_101 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_102 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_103 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_104 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_105 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_106 --> LIST_CONST_87571 0;
Array BC_107 --> Default_Value_0 0;
Array BC_108 --> Default_Value_1 0;
Array BC_109 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_110 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_111 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_112 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_113 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_114 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_115 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_116 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_117 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_118 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_119 --> PACKED_TEXT_STORAGE TX_PS_10;
Array BC_120 --> LIST_CONST_87571 0;
Array BC_121 --> Default_Value_0 0;
Array BC_122 --> Default_Value_1 0;
Array BC_123 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_124 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_125 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_126 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_127 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_128 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_129 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_130 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_131 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_132 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_133 --> PACKED_TEXT_STORAGE TX_PS_11;
Array BC_134 --> LIST_CONST_87571 0;
Array BC_135 --> Default_Value_0 0;
Array BC_136 --> Default_Value_1 0;
Array BC_137 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_138 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_139 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_140 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_141 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_142 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_143 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_144 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_145 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_146 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_147 --> PACKED_TEXT_STORAGE TX_PS_12;
Array BC_148 --> LIST_CONST_87571 0;
Array BC_149 --> Default_Value_0 0;
Array BC_150 --> Default_Value_1 0;
Array BC_151 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_152 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_153 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_154 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_155 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_156 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_157 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_158 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_159 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_160 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_161 --> PACKED_TEXT_STORAGE TX_PS_13;
Array BC_162 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_163 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_164 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_165 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_166 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_167 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_168 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_169 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_170 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_171 --> PACKED_TEXT_STORAGE TX_PS_14;
Array BC_172 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_173 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_174 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_175 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_176 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_177 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_178 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_179 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_180 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_181 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_182 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_183 --> PACKED_TEXT_STORAGE TX_PS_15;
Array BC_184 --> PACKED_TEXT_STORAGE TX_PS_16;
Array BC_185 --> PACKED_TEXT_STORAGE TX_PS_17;
Array BC_186 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_187 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_188 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_189 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_190 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_191 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_192 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_193 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_194 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_195 --> PACKED_TEXT_STORAGE TX_PS_18;
Array BC_196 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_197 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_198 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_199 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_200 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_201 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_202 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_203 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_204 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_205 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_206 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_207 --> PACKED_TEXT_STORAGE TX_PS_19;
Array BC_208 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_209 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_210 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_211 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_212 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_213 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_214 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_215 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_216 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_217 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_218 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_219 --> PACKED_TEXT_STORAGE TX_PS_20;
Array BC_220 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_221 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_222 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_223 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_224 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_225 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_226 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_227 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_228 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_229 --> PACKED_TEXT_STORAGE TX_PS_21;
Array BC_230 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_231 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_232 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_233 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_234 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_235 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_236 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_237 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_238 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_239 --> PACKED_TEXT_STORAGE TX_PS_22;
Array BC_240 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_241 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_242 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_243 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_244 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_245 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_246 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_247 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_248 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_249 --> PACKED_TEXT_STORAGE TX_PS_23;
Array BC_250 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_251 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_252 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_253 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_254 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_255 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_256 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_257 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_258 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_259 --> PACKED_TEXT_STORAGE TX_PS_24;
Array BC_260 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_261 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_262 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_263 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_264 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_265 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_266 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_267 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_268 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_269 --> PACKED_TEXT_STORAGE TX_PS_25;
Array BC_270 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_271 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_272 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_273 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_274 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_275 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_276 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_277 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_278 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_279 --> PACKED_TEXT_STORAGE TX_PS_26;
Array BC_280 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_281 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_282 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_283 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_284 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_285 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_286 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_287 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_288 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_289 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_290 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_291 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_292 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_293 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_294 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_295 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_296 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_297 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_298 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_299 --> PACKED_TEXT_STORAGE TX_PS_28;
Array BC_300 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_301 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_302 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_303 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_304 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_305 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_306 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_307 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_308 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_309 --> PACKED_TEXT_STORAGE TX_PS_29;
Array BC_310 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_311 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_312 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_313 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_314 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_315 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_316 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_317 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_318 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_319 --> PACKED_TEXT_STORAGE TX_PS_30;
Array BC_320 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_321 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_322 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_323 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_324 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_325 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_326 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_327 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_328 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_329 --> PACKED_TEXT_STORAGE TX_PS_31;
Array BC_330 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_331 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_332 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_333 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_334 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_335 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_336 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_337 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_338 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_339 --> PACKED_TEXT_STORAGE TX_PS_32;
Array BC_340 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_341 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_342 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_343 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_344 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_345 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_346 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_347 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_348 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_349 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_350 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_351 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_352 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_353 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_354 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_355 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_356 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_357 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_358 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_359 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_360 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_361 --> PACKED_TEXT_STORAGE TX_PS_34;
Array BC_362 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_363 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_364 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_365 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_366 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_367 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_368 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_369 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_370 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_371 --> PACKED_TEXT_STORAGE TX_PS_35;
Array BC_372 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_373 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_374 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_375 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_376 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_377 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_378 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_379 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_380 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_381 --> PACKED_TEXT_STORAGE TX_PS_36;
Array BC_382 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_383 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_384 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_385 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_386 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_387 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_388 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_389 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_390 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_391 --> PACKED_TEXT_STORAGE TX_PS_38;
Array BC_392 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_393 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_394 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_395 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_396 --> PACKED_TEXT_STORAGE TX_PS_39;
Array BC_397 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_398 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_399 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_400 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_401 --> PACKED_TEXT_STORAGE TX_PS_40;
Array BC_402 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_403 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_404 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_405 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_406 --> PACKED_TEXT_STORAGE TX_PS_41;
Array BC_407 --> Default_Value_2 0;
Array BC_408 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_409 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_410 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_411 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_412 --> PACKED_TEXT_STORAGE TX_PS_42;
Array BC_413 --> Default_Value_2 0;
Array BC_414 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_415 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_416 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_417 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_418 --> PACKED_TEXT_STORAGE TX_PS_43;
Array BC_419 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_420 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_421 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_422 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_423 --> PACKED_TEXT_STORAGE TX_PS_45;
Array BC_424 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_425 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_426 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_427 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_428 --> PACKED_TEXT_STORAGE TX_PS_46;
Array BC_429 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_430 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_431 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_432 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_433 --> PACKED_TEXT_STORAGE TX_PS_47;
Array BC_434 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_435 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_436 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_437 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_438 --> PACKED_TEXT_STORAGE TX_PS_48;
Array BC_439 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_440 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_441 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_442 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_443 --> PACKED_TEXT_STORAGE TX_PS_49;
Array BC_444 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_445 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_446 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_447 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_448 --> PACKED_TEXT_STORAGE TX_PS_50;
Array BC_449 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_450 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_451 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_452 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_453 --> PACKED_TEXT_STORAGE TX_PS_51;
Array BC_454 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_455 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_456 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_457 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_458 --> PACKED_TEXT_STORAGE TX_PS_52;
Array BC_459 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_460 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_461 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_462 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_463 --> PACKED_TEXT_STORAGE TX_PS_53;
Array BC_464 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_465 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_466 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_467 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_468 --> PACKED_TEXT_STORAGE TX_PS_54;
Array BC_469 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_470 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_471 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_472 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_473 --> PACKED_TEXT_STORAGE TX_PS_55;
Array BC_474 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_475 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_476 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_477 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_478 --> PACKED_TEXT_STORAGE TX_PS_56;
Array BC_479 --> PACKED_TEXT_STORAGE TX_PS_57;
Array BC_480 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_481 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_482 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_483 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_484 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_485 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_486 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_487 --> PACKED_TEXT_STORAGE TX_PS_58;
Array BC_488 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_489 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_490 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_491 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_492 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_493 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_494 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_495 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_496 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_497 --> PACKED_TEXT_STORAGE TX_PS_59;
Array BC_498 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_499 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_500 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_501 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_502 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_503 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_504 --> PACKED_TEXT_STORAGE TX_PS_26;
Array BC_505 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_506 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_507 --> PACKED_TEXT_STORAGE TX_PS_60;
Array BC_508 --> PACKED_TEXT_STORAGE TX_PS_61;
Array BC_509 --> PACKED_TEXT_STORAGE TX_PS_62;
Array BC_510 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_511 --> PACKED_TEXT_STORAGE TX_PS_38;
Array BC_512 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_513 --> PACKED_TEXT_STORAGE TX_PS_63;
Array BC_514 --> PACKED_TEXT_STORAGE TX_PS_64;
Array BC_515 --> PACKED_TEXT_STORAGE TX_PS_65;
Array BC_516 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_517 --> PACKED_TEXT_STORAGE TX_PS_38;
Array BC_518 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_519 --> PACKED_TEXT_STORAGE TX_PS_66;
Array BC_520 --> PACKED_TEXT_STORAGE TX_PS_67;
Array BC_521 --> PACKED_TEXT_STORAGE TX_PS_68;
Array BC_522 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_523 --> PACKED_TEXT_STORAGE TX_PS_38;
Array BC_524 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_525 --> PACKED_TEXT_STORAGE TX_PS_69;
Array BC_526 --> PACKED_TEXT_STORAGE TX_PS_70;
Array BC_527 --> PACKED_TEXT_STORAGE TX_PS_71;
Array BC_528 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_529 --> PACKED_TEXT_STORAGE TX_PS_38;
Array BC_530 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_531 --> PACKED_TEXT_STORAGE TX_PS_72;
Array BC_532 --> PACKED_TEXT_STORAGE TX_PS_73;
Array BC_533 --> PACKED_TEXT_STORAGE TX_PS_74;
Array BC_534 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_535 --> PACKED_TEXT_STORAGE TX_PS_38;
Array BC_536 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_537 --> PACKED_TEXT_STORAGE TX_PS_75;
Array BC_538 --> PACKED_TEXT_STORAGE TX_PS_76;
Array BC_539 --> PACKED_TEXT_STORAGE TX_PS_77;
Array BC_540 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_541 --> PACKED_TEXT_STORAGE TX_PS_38;
Array BC_542 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_543 --> PACKED_TEXT_STORAGE TX_PS_78;
Array BC_544 --> PACKED_TEXT_STORAGE TX_PS_79;
Array BC_545 --> PACKED_TEXT_STORAGE TX_PS_80;
Array BC_546 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_547 --> PACKED_TEXT_STORAGE TX_PS_38;
Array BC_548 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_549 --> PACKED_TEXT_STORAGE TX_PS_81;
Array BC_550 --> PACKED_TEXT_STORAGE TX_PS_82;
Array BC_551 --> PACKED_TEXT_STORAGE TX_PS_83;
Array BC_552 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_553 --> PACKED_TEXT_STORAGE TX_PS_38;
Array BC_554 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_555 --> PACKED_TEXT_STORAGE TX_PS_84;
Array BC_556 --> PACKED_TEXT_STORAGE TX_PS_85;
Array BC_557 --> PACKED_TEXT_STORAGE TX_PS_86;
Array BC_558 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_559 --> PACKED_TEXT_STORAGE TX_PS_38;
Array BC_560 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_561 --> PACKED_TEXT_STORAGE TX_PS_87;
Array BC_562 --> PACKED_TEXT_STORAGE TX_PS_88;
Array BC_563 --> PACKED_TEXT_STORAGE TX_PS_89;
Array BC_564 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_565 --> PACKED_TEXT_STORAGE TX_PS_38;
Array BC_566 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_567 --> PACKED_TEXT_STORAGE TX_PS_90;
Array BC_568 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_569 --> PACKED_TEXT_STORAGE TX_PS_40;
Array BC_570 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_571 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_572 --> PACKED_TEXT_STORAGE TX_PS_91;
Array BC_573 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_574 --> PACKED_TEXT_STORAGE TX_PS_40;
Array BC_575 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_576 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_577 --> PACKED_TEXT_STORAGE TX_PS_92;
Array BC_578 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_579 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_580 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_581 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_582 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_583 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_584 --> PACKED_TEXT_STORAGE TX_PS_24;
Array BC_585 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_586 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_587 --> PACKED_TEXT_STORAGE TX_PS_93;
Array BC_588 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_589 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_590 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_591 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_592 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_593 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_594 --> PACKED_TEXT_STORAGE TX_PS_24;
Array BC_595 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_596 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_597 --> PACKED_TEXT_STORAGE TX_PS_94;
Array BC_598 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_599 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_600 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_601 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_602 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_603 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_604 --> PACKED_TEXT_STORAGE TX_PS_24;
Array BC_605 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_606 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_607 --> PACKED_TEXT_STORAGE TX_PS_95;
Array BC_608 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_609 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_610 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_611 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_612 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_613 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_614 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_615 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_616 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_617 --> PACKED_TEXT_STORAGE TX_PS_96;
Array BC_618 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_619 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_620 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_621 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_622 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_623 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_624 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_625 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_626 --> PACKED_TEXT_STORAGE TX_PS_97;
Array BC_627 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_628 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_629 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_630 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_631 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_632 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_633 --> PACKED_TEXT_STORAGE TX_PS_24;
Array BC_634 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_635 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_636 --> PACKED_TEXT_STORAGE TX_PS_98;
Array BC_637 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_638 --> PACKED_TEXT_STORAGE TX_PS_36;
Array BC_639 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_640 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_641 --> PACKED_TEXT_STORAGE TX_PS_99;
Array BC_642 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_643 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_644 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_645 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_646 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_647 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_648 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_649 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_650 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_651 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_652 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_653 --> PACKED_TEXT_STORAGE TX_PS_100;
Array BC_654 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_655 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_656 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_657 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_658 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_659 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_660 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_661 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_662 --> PACKED_TEXT_STORAGE TX_PS_101;
Array BC_663 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_664 --> PACKED_TEXT_STORAGE TX_PS_36;
Array BC_665 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_666 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_667 --> PACKED_TEXT_STORAGE TX_PS_102;
Array BC_668 --> PACKED_TEXT_STORAGE TX_PS_103;
Array BC_669 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_670 --> PACKED_TEXT_STORAGE TX_PS_36;
Array BC_671 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_672 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_673 --> PACKED_TEXT_STORAGE TX_PS_104;
Array BC_674 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_675 --> PACKED_TEXT_STORAGE TX_PS_105;
Array BC_676 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_677 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_678 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_679 --> PACKED_TEXT_STORAGE TX_PS_106;
Array BC_680 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_681 --> PACKED_TEXT_STORAGE TX_PS_107;
Array BC_682 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_683 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_684 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_685 --> PACKED_TEXT_STORAGE TX_PS_108;
Array BC_686 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_687 --> PACKED_TEXT_STORAGE TX_PS_109;
Array BC_688 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_689 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_690 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_691 --> PACKED_TEXT_STORAGE TX_PS_110;
Array BC_692 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_693 --> PACKED_TEXT_STORAGE TX_PS_111;
Array BC_694 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_695 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_696 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_697 --> PACKED_TEXT_STORAGE TX_PS_112;
Array BC_698 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_699 --> PACKED_TEXT_STORAGE TX_PS_113;
Array BC_700 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_701 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_702 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_703 --> PACKED_TEXT_STORAGE TX_PS_114;
Array BC_704 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_705 --> PACKED_TEXT_STORAGE TX_PS_115;
Array BC_706 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_707 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_708 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_709 --> PACKED_TEXT_STORAGE TX_PS_116;
Array BC_710 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_711 --> PACKED_TEXT_STORAGE TX_PS_117;
Array BC_712 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_713 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_714 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_715 --> PACKED_TEXT_STORAGE TX_PS_118;
Array BC_716 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_717 --> PACKED_TEXT_STORAGE TX_PS_119;
Array BC_718 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_719 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_720 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_721 --> PACKED_TEXT_STORAGE TX_PS_120;
Array BC_722 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_723 --> PACKED_TEXT_STORAGE TX_PS_121;
Array BC_724 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_725 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_726 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_727 --> PACKED_TEXT_STORAGE TX_PS_122;
Array BC_728 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_729 --> PACKED_TEXT_STORAGE TX_PS_123;
Array BC_730 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_731 --> PACKED_TEXT_STORAGE TX_PS_37;
Array BC_732 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_733 --> PACKED_TEXT_STORAGE TX_PS_124;
Array BC_734 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_735 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_736 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_737 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_738 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_739 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_740 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_741 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_742 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_743 --> PACKED_TEXT_STORAGE TX_PS_125;
Array BC_744 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_135;
Array BC_745 --> PACKED_TEXT_STORAGE TX_PS_126;
Array BC_746 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_747 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_748 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_749 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_750 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_751 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_752 --> PACKED_TEXT_STORAGE TX_PS_127;
Array BC_753 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_754 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_755 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_756 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_757 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_758 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_759 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_760 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_761 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_762 --> PACKED_TEXT_STORAGE TX_PS_128;
Array BC_763 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_764 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_765 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_766 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_767 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_768 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_769 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_770 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_771 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_772 --> PACKED_TEXT_STORAGE TX_PS_129;
Array BC_773 --> PACKED_TEXT_STORAGE TX_PS_130;
Array BC_774 --> PACKED_TEXT_STORAGE TX_PS_131;
Array BC_775 --> PACKED_TEXT_STORAGE TX_PS_132;
Array BC_776 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_777 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_778 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_779 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_780 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_781 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_782 --> PACKED_TEXT_STORAGE TX_PS_133;
Array BC_783 --> LIST_CONST_87571 0;
Array BC_784 --> Default_Value_0 0;
Array BC_785 --> Default_Value_1 0;
Array BC_786 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_787 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_788 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_789 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_790 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_791 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_792 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_793 --> PACKED_TEXT_STORAGE TX_PS_10;
Array BC_794 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_795 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_796 --> PACKED_TEXT_STORAGE TX_PS_134;
Array BC_797 --> PACKED_TEXT_STORAGE TX_PS_135;
Array BC_798 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_799 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_800 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_801 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_802 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_803 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_804 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_805 --> PACKED_TEXT_STORAGE TX_PS_136;
Array BC_806 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_807 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_808 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_809 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_810 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_811 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_812 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_813 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_814 --> PACKED_TEXT_STORAGE TX_PS_137;
Array BC_815 --> LIST_CONST_87571 0;
Array BC_816 --> Default_Value_0 0;
Array BC_817 --> Default_Value_1 0;
Array BC_818 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_819 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_820 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_821 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_822 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_823 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_824 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_825 --> PACKED_TEXT_STORAGE TX_PS_10;
Array BC_826 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_827 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_828 --> PACKED_TEXT_STORAGE TX_PS_138;
Array BC_829 --> PACKED_TEXT_STORAGE TX_PS_139;
Array BC_830 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_831 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_832 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_833 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_834 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_835 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_836 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_837 --> PACKED_TEXT_STORAGE TX_PS_140;
Array BC_838 --> PACKED_TEXT_STORAGE TX_PS_141;
Array BC_839 --> LIST_CONST_87571 0;
Array BC_840 --> Default_Value_0 0;
Array BC_841 --> Default_Value_1 0;
Array BC_842 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_843 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_844 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_845 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_846 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_847 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_848 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_849 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_850 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_851 --> PACKED_TEXT_STORAGE TX_PS_142;
Array BC_852 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_853 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_854 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_855 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_856 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_857 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_858 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_859 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_860 --> PACKED_TEXT_STORAGE TX_PS_143;
Array BC_861 --> LIST_CONST_87571 0;
Array BC_862 --> Default_Value_0 0;
Array BC_863 --> Default_Value_1 0;
Array BC_864 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_865 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_866 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_867 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_868 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_869 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_870 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_871 --> PACKED_TEXT_STORAGE TX_PS_11;
Array BC_872 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_873 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_874 --> PACKED_TEXT_STORAGE TX_PS_144;
Array BC_875 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_136;
Array BC_876 --> PACKED_TEXT_STORAGE TX_PS_145;
Array BC_877 --> PACKED_TEXT_STORAGE TX_PS_146;
Array BC_878 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_879 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_880 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_881 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_882 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_883 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_884 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_885 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_886 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_887 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_137;
Array BC_888 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_138;
Array BC_889 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_139;
Array BC_890 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_891 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_892 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_893 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_894 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_895 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_896 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_897 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_898 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_899 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_140;
Array BC_900 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_141;
Array BC_901 --> PACKED_TEXT_STORAGE TX_PS_147;
Array BC_902 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_903 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_904 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_905 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_906 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_907 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_908 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_909 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_910 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_911 --> PACKED_TEXT_STORAGE TX_PS_148;
Array BC_912 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_142;
Array BC_913 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_143;
Array BC_914 --> PACKED_TEXT_STORAGE TX_PS_149;
Array BC_915 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_916 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_917 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_918 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_919 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_920 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_921 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_922 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_923 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_924 --> PACKED_TEXT_STORAGE TX_PS_150;
Array BC_925 --> PACKED_TEXT_STORAGE TX_PS_151;
Array BC_926 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_927 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_928 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_929 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_930 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_931 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_932 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_933 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_934 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_935 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_936 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_937 --> PACKED_TEXT_STORAGE TX_PS_152;
Array BC_938 --> PACKED_TEXT_STORAGE TX_PS_153;
Array BC_939 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_940 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_941 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_942 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_943 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_944 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_945 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_946 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_947 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_948 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_949 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_950 --> PACKED_TEXT_STORAGE TX_PS_154;
Array BC_951 --> PACKED_TEXT_STORAGE TX_PS_155;
Array BC_952 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_953 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_954 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_955 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_956 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_957 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_958 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_959 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_960 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_961 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_962 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_963 --> PACKED_TEXT_STORAGE TX_PS_156;
Array BC_964 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_965 --> PACKED_TEXT_STORAGE TX_PS_36;
Array BC_966 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_967 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_968 --> PACKED_TEXT_STORAGE TX_PS_157;
Array BC_969 --> PACKED_TEXT_STORAGE TX_PS_158;
Array BC_970 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_971 --> PACKED_TEXT_STORAGE TX_PS_36;
Array BC_972 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_973 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_974 --> PACKED_TEXT_STORAGE TX_PS_159;
Array BC_975 --> PACKED_TEXT_STORAGE TX_PS_160;
Array BC_976 --> PACKED_TEXT_STORAGE TX_PS_131;
Array BC_977 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_978 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_979 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_980 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_981 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_982 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_983 --> PACKED_TEXT_STORAGE TX_PS_161;
Array BC_984 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_144;
Array BC_985 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_986 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_987 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_988 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_989 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_990 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_991 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_992 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_993 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_145;
Array BC_994 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_146;
Array BC_995 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_147;
Array BC_996 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_997 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_998 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_999 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1000 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1001 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1002 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1003 --> PACKED_TEXT_STORAGE TX_PS_162;
Array BC_1004 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_148;
Array BC_1005 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1006 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1007 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1008 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1009 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1010 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_1011 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1012 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1013 --> PACKED_TEXT_STORAGE TX_PS_163;
Array BC_1014 --> PACKED_TEXT_STORAGE TX_PS_164;
Array BC_1015 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1016 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1017 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1018 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1019 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1020 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_1021 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1022 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1023 --> PACKED_TEXT_STORAGE TX_PS_165;
Array BC_1024 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_149;
Array BC_1025 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1026 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1027 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1028 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1029 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1030 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_1031 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1032 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1033 --> PACKED_TEXT_STORAGE TX_PS_166;
Array BC_1034 --> PACKED_TEXT_STORAGE TX_PS_167;
Array BC_1035 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1036 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1037 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1038 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1039 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1040 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_1041 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1042 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1043 --> PACKED_TEXT_STORAGE TX_PS_168;
Array BC_1044 --> PACKED_TEXT_STORAGE TX_PS_169;
Array BC_1045 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1046 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1047 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1048 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1049 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1050 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1051 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1052 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1053 --> PACKED_TEXT_STORAGE TX_PS_170;
Array BC_1054 --> PACKED_TEXT_STORAGE TX_PS_171;
Array BC_1055 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1056 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1057 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1058 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1059 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1060 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1061 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1062 --> PACKED_TEXT_STORAGE TX_PS_172;
Array BC_1063 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_150;
Array BC_1064 --> PACKED_TEXT_STORAGE TX_PS_173;
Array BC_1065 --> LIST_CONST_87571 0;
Array BC_1066 --> Default_Value_0 0;
Array BC_1067 --> Default_Value_1 0;
Array BC_1068 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1069 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1070 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1071 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1072 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1073 --> PACKED_TEXT_STORAGE TX_PS_10;
Array BC_1074 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1075 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1076 --> PACKED_TEXT_STORAGE TX_PS_174;
Array BC_1077 --> PACKED_TEXT_STORAGE TX_PS_175;
Array BC_1078 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1079 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1080 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1081 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1082 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1083 --> PACKED_TEXT_STORAGE TX_PS_6;
Array BC_1084 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1085 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1086 --> PACKED_TEXT_STORAGE TX_PS_176;
Array BC_1087 --> PACKED_TEXT_STORAGE TX_PS_177;
Array BC_1088 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1089 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1090 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1091 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1092 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1093 --> PACKED_TEXT_STORAGE TX_PS_6;
Array BC_1094 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1095 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1096 --> PACKED_TEXT_STORAGE TX_PS_178;
Array BC_1097 --> PACKED_TEXT_STORAGE TX_PS_179;
Array BC_1098 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1099 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1100 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1101 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1102 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1103 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1104 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1105 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1106 --> PACKED_TEXT_STORAGE TX_PS_180;
Array BC_1107 --> PACKED_TEXT_STORAGE TX_PS_181;
Array BC_1108 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1109 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1110 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1111 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1112 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1113 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1114 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1115 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1116 --> PACKED_TEXT_STORAGE TX_PS_182;
Array BC_1117 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_151;
Array BC_1118 --> PACKED_TEXT_STORAGE TX_PS_183;
Array BC_1119 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1120 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1121 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1122 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1123 --> PACKED_TEXT_STORAGE TX_PS_6;
Array BC_1124 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1125 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1126 --> PACKED_TEXT_STORAGE TX_PS_184;
Array BC_1127 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_152;
Array BC_1128 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1129 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1130 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1131 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1132 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1133 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1134 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1135 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1136 --> PACKED_TEXT_STORAGE TX_PS_185;
Array BC_1137 --> PACKED_TEXT_STORAGE TX_PS_186;
Array BC_1138 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1139 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1140 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1141 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1142 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1143 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1144 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1145 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1146 --> PACKED_TEXT_STORAGE TX_PS_187;
Array BC_1147 --> PACKED_TEXT_STORAGE TX_PS_188;
Array BC_1148 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1149 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1150 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1151 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1152 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1153 --> PACKED_TEXT_STORAGE TX_PS_20;
Array BC_1154 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1155 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1156 --> PACKED_TEXT_STORAGE TX_PS_189;
Array BC_1157 --> PACKED_TEXT_STORAGE TX_PS_190;
Array BC_1158 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1159 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1160 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1161 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1162 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1163 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1164 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1165 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1166 --> PACKED_TEXT_STORAGE TX_PS_191;
Array BC_1167 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_153;
Array BC_1168 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1169 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1170 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1171 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1172 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1173 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1174 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1175 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1176 --> PACKED_TEXT_STORAGE TX_PS_192;
Array BC_1177 --> PACKED_TEXT_STORAGE TX_PS_193;
Array BC_1178 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1179 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1180 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1181 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1182 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1183 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1184 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1185 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1186 --> PACKED_TEXT_STORAGE TX_PS_194;
Array BC_1187 --> PACKED_TEXT_STORAGE TX_PS_195;
Array BC_1188 --> PACKED_TEXT_STORAGE TX_PS_196;
Array BC_1189 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1190 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1191 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1192 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1193 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1194 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1195 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1196 --> PACKED_TEXT_STORAGE TX_PS_197;
Array BC_1197 --> PACKED_TEXT_STORAGE TX_PS_198;
Array BC_1198 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1199 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1200 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1201 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1202 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1203 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1204 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1205 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1206 --> PACKED_TEXT_STORAGE TX_PS_199;
Array BC_1207 --> PACKED_TEXT_STORAGE TX_PS_200;
Array BC_1208 --> PACKED_TEXT_STORAGE TX_PS_201;
Array BC_1209 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1210 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1211 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1212 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1213 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1214 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1215 --> PACKED_TEXT_STORAGE TX_PS_18;
Array BC_1216 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1217 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1218 --> PACKED_TEXT_STORAGE TX_PS_202;
Array BC_1219 --> PACKED_TEXT_STORAGE TX_PS_203;
Array BC_1220 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1221 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1222 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1223 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1224 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1225 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1226 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1227 --> PACKED_TEXT_STORAGE TX_PS_204;
Array BC_1228 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1229 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1230 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1231 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1232 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1233 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1234 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1235 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1236 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1237 --> PACKED_TEXT_STORAGE TX_PS_205;
Array BC_1238 --> PACKED_TEXT_STORAGE TX_PS_206;
Array BC_1239 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1240 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1241 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1242 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1243 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1244 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1245 --> PACKED_TEXT_STORAGE TX_PS_31;
Array BC_1246 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1247 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1248 --> PACKED_TEXT_STORAGE TX_PS_207;
Array BC_1249 --> PACKED_TEXT_STORAGE TX_PS_208;
Array BC_1250 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1251 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1252 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1253 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1254 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1255 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1256 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1257 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1258 --> PACKED_TEXT_STORAGE TX_PS_209;
Array BC_1259 --> PACKED_TEXT_STORAGE TX_PS_210;
Array BC_1260 --> PACKED_TEXT_STORAGE TX_PS_201;
Array BC_1261 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1262 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1263 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1264 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1265 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1266 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1267 --> PACKED_TEXT_STORAGE TX_PS_18;
Array BC_1268 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1269 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1270 --> PACKED_TEXT_STORAGE TX_PS_165;
Array BC_1271 --> PACKED_TEXT_STORAGE TX_PS_211;
Array BC_1272 --> PACKED_TEXT_STORAGE TX_PS_165;
Array BC_1273 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1274 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1275 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1276 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1277 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1278 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1279 --> PACKED_TEXT_STORAGE TX_PS_212;
Array BC_1280 --> PACKED_TEXT_STORAGE TX_PS_213;
Array BC_1281 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1282 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1283 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1284 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1285 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1286 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1287 --> PACKED_TEXT_STORAGE TX_PS_31;
Array BC_1288 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1289 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1290 --> PACKED_TEXT_STORAGE TX_PS_214;
Array BC_1291 --> PACKED_TEXT_STORAGE TX_PS_215;
Array BC_1292 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_154;
Array BC_1293 --> PACKED_TEXT_STORAGE TX_PS_216;
Array BC_1294 --> LIST_CONST_87571 0;
Array BC_1295 --> Default_Value_0 0;
Array BC_1296 --> Default_Value_1 0;
Array BC_1297 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1298 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1299 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1300 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1301 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_1302 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1303 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1304 --> PACKED_TEXT_STORAGE TX_PS_217;
Array BC_1305 --> PACKED_TEXT_STORAGE TX_PS_218;
Array BC_1306 --> PACKED_TEXT_STORAGE TX_PS_131;
Array BC_1307 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1308 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1309 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1310 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1311 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1312 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1313 --> PACKED_TEXT_STORAGE TX_PS_219;
Array BC_1314 --> PACKED_TEXT_STORAGE TX_PS_220;
Array BC_1315 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1316 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1317 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1318 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1319 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1320 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_1321 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1322 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1323 --> PACKED_TEXT_STORAGE TX_PS_221;
Array BC_1324 --> PACKED_TEXT_STORAGE TX_PS_222;
Array BC_1325 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1326 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1327 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1328 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1329 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1330 --> PACKED_TEXT_STORAGE TX_PS_27;
Array BC_1331 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1332 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1333 --> PACKED_TEXT_STORAGE TX_PS_223;
Array BC_1334 --> PACKED_TEXT_STORAGE TX_PS_224;
Array BC_1335 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1336 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1337 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1338 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1339 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1340 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1341 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1342 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1343 --> PACKED_TEXT_STORAGE TX_PS_225;
Array BC_1344 --> PACKED_TEXT_STORAGE TX_PS_226;
Array BC_1345 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1346 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1347 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1348 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1349 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1350 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1351 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1352 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1353 --> PACKED_TEXT_STORAGE TX_PS_227;
Array BC_1354 --> PACKED_TEXT_STORAGE TX_PS_228;
Array BC_1355 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1356 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1357 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1358 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1359 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1360 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1361 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1362 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1363 --> PACKED_TEXT_STORAGE TX_PS_229;
Array BC_1364 --> PACKED_TEXT_STORAGE TX_PS_230;
Array BC_1365 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1366 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1367 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1368 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1369 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1370 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1371 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1372 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1373 --> PACKED_TEXT_STORAGE TX_PS_231;
Array BC_1374 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_155;
Array BC_1375 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_156;
Array BC_1376 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1377 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1378 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1379 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1380 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1381 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1382 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_1383 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1384 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1385 --> PACKED_TEXT_STORAGE TX_PS_232;
Array BC_1386 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1387 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1388 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1389 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1390 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1391 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1392 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1393 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1394 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1395 --> PACKED_TEXT_STORAGE TX_PS_233;
Array BC_1396 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_157;
Array BC_1397 --> PACKED_TEXT_STORAGE TX_PS_234;
Array BC_1398 --> PACKED_TEXT_STORAGE TX_PS_235;
Array BC_1399 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1400 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1401 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1402 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1403 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1404 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1405 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_1406 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1407 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1408 --> PACKED_TEXT_STORAGE TX_PS_236;
Array BC_1409 --> PACKED_TEXT_STORAGE TX_PS_237;
Array BC_1410 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1411 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1412 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1413 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1414 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1415 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1416 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1417 --> PACKED_TEXT_STORAGE TX_PS_238;
Array BC_1418 --> PACKED_TEXT_STORAGE TX_PS_239;
Array BC_1419 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1420 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1421 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1422 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1423 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1424 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1425 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1426 --> PACKED_TEXT_STORAGE TX_PS_240;
Array BC_1427 --> PACKED_TEXT_STORAGE TX_PS_241;
Array BC_1428 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1429 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1430 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1431 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1432 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1433 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1434 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1435 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1436 --> PACKED_TEXT_STORAGE TX_PS_236;
Array BC_1437 --> PACKED_TEXT_STORAGE TX_PS_242;
Array BC_1438 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1439 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1440 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1441 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1442 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1443 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1444 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1445 --> PACKED_TEXT_STORAGE TX_PS_243;
Array BC_1446 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1447 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1448 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1449 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1450 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1451 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1452 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1453 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1454 --> PACKED_TEXT_STORAGE TX_PS_244;
Array BC_1455 --> PACKED_TEXT_STORAGE TX_PS_245;
Array BC_1456 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1457 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1458 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1459 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1460 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1461 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1462 --> PACKED_TEXT_STORAGE TX_PS_31;
Array BC_1463 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1464 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1465 --> PACKED_TEXT_STORAGE TX_PS_246;
Array BC_1466 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1467 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1468 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1469 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1470 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1471 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1472 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1473 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1474 --> PACKED_TEXT_STORAGE TX_PS_247;
Array BC_1475 --> PACKED_TEXT_STORAGE TX_PS_248;
Array BC_1476 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1477 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1478 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1479 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1480 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1481 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1482 --> PACKED_TEXT_STORAGE TX_PS_31;
Array BC_1483 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1484 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1485 --> PACKED_TEXT_STORAGE TX_PS_249;
Array BC_1486 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1487 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1488 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1489 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1490 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1491 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1492 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1493 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1494 --> PACKED_TEXT_STORAGE TX_PS_250;
Array BC_1495 --> PACKED_TEXT_STORAGE TX_PS_251;
Array BC_1496 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1497 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1498 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1499 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1500 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1501 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1502 --> PACKED_TEXT_STORAGE TX_PS_31;
Array BC_1503 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1504 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1505 --> PACKED_TEXT_STORAGE TX_PS_252;
Array BC_1506 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1507 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1508 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1509 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1510 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1511 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1512 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1513 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1514 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1515 --> PACKED_TEXT_STORAGE TX_PS_253;
Array BC_1516 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1517 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1518 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1519 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1520 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1521 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1522 --> PACKED_TEXT_STORAGE TX_PS_25;
Array BC_1523 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1524 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1525 --> PACKED_TEXT_STORAGE TX_PS_254;
Array BC_1526 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1527 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1528 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1529 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1530 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1531 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1532 --> PACKED_TEXT_STORAGE TX_PS_20;
Array BC_1533 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1534 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1535 --> PACKED_TEXT_STORAGE TX_PS_236;
Array BC_1536 --> PACKED_TEXT_STORAGE TX_PS_255;
Array BC_1537 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1538 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1539 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1540 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1541 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1542 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1543 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1544 --> PACKED_TEXT_STORAGE TX_PS_219;
Array BC_1545 --> PACKED_TEXT_STORAGE TX_PS_256;
Array BC_1546 --> PACKED_TEXT_STORAGE TX_PS_219;
Array BC_1547 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1548 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1549 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1550 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1551 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1552 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1553 --> PACKED_TEXT_STORAGE TX_PS_257;
Array BC_1554 --> PACKED_TEXT_STORAGE TX_PS_258;
Array BC_1555 --> PACKED_TEXT_STORAGE TX_PS_259;
Array BC_1556 --> PACKED_TEXT_STORAGE TX_PS_260;
Array BC_1557 --> LIST_CONST_87571 0;
Array BC_1558 --> Default_Value_0 0;
Array BC_1559 --> Default_Value_1 0;
Array BC_1560 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1561 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1562 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1563 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1564 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_1565 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1566 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1567 --> PACKED_TEXT_STORAGE TX_PS_261;
Array BC_1568 --> PACKED_TEXT_STORAGE TX_PS_262;
Array BC_1569 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1570 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1571 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1572 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1573 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1574 --> PACKED_TEXT_STORAGE TX_PS_6;
Array BC_1575 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1576 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1577 --> PACKED_TEXT_STORAGE TX_PS_263;
Array BC_1578 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_158;
Array BC_1579 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1580 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1581 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1582 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1583 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1584 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1585 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1586 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1587 --> PACKED_TEXT_STORAGE TX_PS_264;
Array BC_1588 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_159;
Array BC_1589 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1590 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1591 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1592 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1593 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1594 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1595 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1596 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1597 --> PACKED_TEXT_STORAGE TX_PS_265;
Array BC_1598 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_160;
Array BC_1599 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1600 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1601 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1602 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1603 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1604 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1605 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1606 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1607 --> PACKED_TEXT_STORAGE TX_PS_266;
Array BC_1608 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_161;
Array BC_1609 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1610 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1611 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1612 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1613 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1614 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1615 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1616 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1617 --> PACKED_TEXT_STORAGE TX_PS_267;
Array BC_1618 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_162;
Array BC_1619 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1620 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1621 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1622 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1623 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1624 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1625 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1626 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1627 --> PACKED_TEXT_STORAGE TX_PS_268;
Array BC_1628 --> PACKED_TEXT_STORAGE TX_PS_269;
Array BC_1629 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1630 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1631 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1632 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1633 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1634 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1635 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1636 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1637 --> PACKED_TEXT_STORAGE TX_PS_270;
Array BC_1638 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1639 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1640 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1641 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1642 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1643 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1644 --> PACKED_TEXT_STORAGE TX_PS_20;
Array BC_1645 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1646 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1647 --> PACKED_TEXT_STORAGE TX_PS_271;
Array BC_1648 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1649 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1650 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1651 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1652 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1653 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1654 --> PACKED_TEXT_STORAGE TX_PS_25;
Array BC_1655 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1656 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1657 --> PACKED_TEXT_STORAGE TX_PS_272;
Array BC_1658 --> PACKED_TEXT_STORAGE TX_PS_273;
Array BC_1659 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1660 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1661 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1662 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1663 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1664 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1665 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1666 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1667 --> PACKED_TEXT_STORAGE TX_PS_274;
Array BC_1668 --> PACKED_TEXT_STORAGE TX_PS_275;
Array BC_1669 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1670 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1671 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1672 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1673 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1674 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1675 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1676 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1677 --> PACKED_TEXT_STORAGE TX_PS_276;
Array BC_1678 --> PACKED_TEXT_STORAGE TX_PS_277;
Array BC_1679 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1680 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1681 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1682 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1683 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1684 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1685 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1686 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1687 --> PACKED_TEXT_STORAGE TX_PS_231;
Array BC_1688 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_163;
Array BC_1689 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_164;
Array BC_1690 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1691 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1692 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1693 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1694 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1695 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1696 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_1697 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1698 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1699 --> PACKED_TEXT_STORAGE TX_PS_278;
Array BC_1700 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_165;
Array BC_1701 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_166;
Array BC_1702 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1703 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1704 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1705 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1706 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1707 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1708 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_1709 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1710 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1711 --> PACKED_TEXT_STORAGE TX_PS_279;
Array BC_1712 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1713 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1714 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1715 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1716 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1717 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1718 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1719 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1720 --> PACKED_TEXT_STORAGE TX_PS_280;
Array BC_1721 --> PACKED_TEXT_STORAGE TX_PS_281;
Array BC_1722 --> PACKED_TEXT_STORAGE TX_PS_282;
Array BC_1723 --> LIST_CONST_87571 0;
Array BC_1724 --> Default_Value_0 0;
Array BC_1725 --> Default_Value_1 0;
Array BC_1726 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1727 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1728 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1729 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1730 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1731 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1732 --> PACKED_TEXT_STORAGE TX_PS_8;
Array BC_1733 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1734 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1735 --> PACKED_TEXT_STORAGE TX_PS_283;
Array BC_1736 --> PACKED_TEXT_STORAGE TX_PS_284;
Array BC_1737 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1738 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1739 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1740 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1741 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1742 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1743 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1744 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1745 --> PACKED_TEXT_STORAGE TX_PS_285;
Array BC_1746 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1747 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1748 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1749 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1750 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1751 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1752 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1753 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1754 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1755 --> PACKED_TEXT_STORAGE TX_PS_286;
Array BC_1756 --> PACKED_TEXT_STORAGE TX_PS_287;
Array BC_1757 --> LIST_CONST_87571 0;
Array BC_1758 --> Default_Value_0 0;
Array BC_1759 --> Default_Value_1 0;
Array BC_1760 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1761 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1762 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1763 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1764 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1765 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1766 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_1767 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1768 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1769 --> PACKED_TEXT_STORAGE TX_PS_288;
Array BC_1770 --> PACKED_TEXT_STORAGE TX_PS_289;
Array BC_1771 --> LIST_CONST_87571 0;
Array BC_1772 --> Default_Value_0 0;
Array BC_1773 --> Default_Value_1 0;
Array BC_1774 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1775 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1776 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1777 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1778 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1779 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1780 --> PACKED_TEXT_STORAGE TX_PS_10;
Array BC_1781 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1782 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1783 --> PACKED_TEXT_STORAGE TX_PS_290;
Array BC_1784 --> PACKED_TEXT_STORAGE TX_PS_291;
Array BC_1785 --> LIST_CONST_87571 0;
Array BC_1786 --> Default_Value_0 0;
Array BC_1787 --> Default_Value_1 0;
Array BC_1788 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1789 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1790 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1791 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1792 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1793 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1794 --> PACKED_TEXT_STORAGE TX_PS_11;
Array BC_1795 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1796 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1797 --> PACKED_TEXT_STORAGE TX_PS_292;
Array BC_1798 --> LIST_CONST_87571 0;
Array BC_1799 --> Default_Value_0 0;
Array BC_1800 --> Default_Value_1 0;
Array BC_1801 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1802 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1803 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1804 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1805 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1806 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1807 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1808 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_1809 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1810 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1811 --> PACKED_TEXT_STORAGE TX_PS_293;
Array BC_1812 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1813 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1814 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1815 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1816 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1817 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1818 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1819 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1820 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1821 --> PACKED_TEXT_STORAGE TX_PS_294;
Array BC_1822 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_167;
Array BC_1823 --> PACKED_TEXT_STORAGE TX_PS_295;
Array BC_1824 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1825 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1826 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1827 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1828 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1829 --> PACKED_TEXT_STORAGE TX_PS_32;
Array BC_1830 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1831 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1832 --> PACKED_TEXT_STORAGE TX_PS_296;
Array BC_1833 --> PACKED_TEXT_STORAGE TX_PS_297;
Array BC_1834 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1835 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1836 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1837 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1838 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1839 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1840 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1841 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1842 --> PACKED_TEXT_STORAGE TX_PS_296;
Array BC_1843 --> PACKED_TEXT_STORAGE TX_PS_297;
Array BC_1844 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1845 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1846 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1847 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1848 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1849 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1850 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1851 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1852 --> PACKED_TEXT_STORAGE TX_PS_298;
Array BC_1853 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_168;
Array BC_1854 --> PACKED_TEXT_STORAGE TX_PS_299;
Array BC_1855 --> PACKED_TEXT_STORAGE TX_PS_300;
Array BC_1856 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1857 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1858 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1859 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1860 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1861 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1862 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_1863 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1864 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1865 --> PACKED_TEXT_STORAGE TX_PS_301;
Array BC_1866 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_169;
Array BC_1867 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_170;
Array BC_1868 --> PACKED_TEXT_STORAGE TX_PS_302;
Array BC_1869 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1870 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1871 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1872 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1873 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1874 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1875 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_1876 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1877 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1878 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_171;
Array BC_1879 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_172;
Array BC_1880 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1881 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1882 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1883 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1884 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1885 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1886 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1887 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1888 --> PACKED_TEXT_STORAGE TX_PS_303;
Array BC_1889 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_173;
Array BC_1890 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_174;
Array BC_1891 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1892 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1893 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1894 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1895 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1896 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1897 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_1898 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1899 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1900 --> PACKED_TEXT_STORAGE TX_PS_231;
Array BC_1901 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_175;
Array BC_1902 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_176;
Array BC_1903 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1904 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1905 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1906 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1907 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1908 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1909 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_1910 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1911 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1912 --> PACKED_TEXT_STORAGE TX_PS_304;
Array BC_1913 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_177;
Array BC_1914 --> PACKED_TEXT_STORAGE TX_PS_305;
Array BC_1915 --> PACKED_TEXT_STORAGE TX_PS_306;
Array BC_1916 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1917 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1918 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1919 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1920 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1921 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1922 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_1923 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1924 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1925 --> PACKED_TEXT_STORAGE TX_PS_307;
Array BC_1926 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_178;
Array BC_1927 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1928 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1929 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1930 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1931 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1932 --> PACKED_TEXT_STORAGE TX_PS_13;
Array BC_1933 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1934 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1935 --> PACKED_TEXT_STORAGE TX_PS_308;
Array BC_1936 --> PACKED_TEXT_STORAGE TX_PS_309;
Array BC_1937 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1938 --> PACKED_TEXT_STORAGE TX_PS_40;
Array BC_1939 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1940 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1941 --> PACKED_TEXT_STORAGE TX_PS_310;
Array BC_1942 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1943 --> PACKED_TEXT_STORAGE TX_PS_36;
Array BC_1944 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1945 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1946 --> PACKED_TEXT_STORAGE TX_PS_311;
Array BC_1947 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1948 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1949 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1950 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1951 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1952 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1953 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1954 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1955 --> PACKED_TEXT_STORAGE TX_PS_312;
Array BC_1956 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1957 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1958 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_1959 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1960 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1961 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1962 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1963 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1964 --> PACKED_TEXT_STORAGE TX_PS_313;
Array BC_1965 --> PACKED_TEXT_STORAGE TX_PS_126;
Array BC_1966 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1967 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1968 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1969 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1970 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1971 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1972 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1973 --> PACKED_TEXT_STORAGE TX_PS_314;
Array BC_1974 --> PACKED_TEXT_STORAGE TX_PS_131;
Array BC_1975 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1976 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1977 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1978 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1979 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1980 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1981 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1982 --> PACKED_TEXT_STORAGE TX_PS_315;
Array BC_1983 --> PACKED_TEXT_STORAGE TX_PS_316;
Array BC_1984 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1985 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1986 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1987 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1988 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1989 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1990 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1991 --> PACKED_TEXT_STORAGE TX_PS_317;
Array BC_1992 --> PACKED_TEXT_STORAGE TX_PS_316;
Array BC_1993 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1994 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1995 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1996 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1997 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1998 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_1999 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2000 --> PACKED_TEXT_STORAGE TX_PS_318;
Array BC_2001 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2002 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2003 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2004 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2005 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2006 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2007 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2008 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2009 --> PACKED_TEXT_STORAGE TX_PS_319;
Array BC_2010 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2011 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2012 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2013 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2014 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2015 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2016 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2017 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2018 --> PACKED_TEXT_STORAGE TX_PS_320;
Array BC_2019 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2020 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2021 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2022 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2023 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2024 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2025 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2026 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2027 --> PACKED_TEXT_STORAGE TX_PS_321;
Array BC_2028 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2029 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2030 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2031 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2032 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2033 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2034 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2035 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2036 --> PACKED_TEXT_STORAGE TX_PS_322;
Array BC_2037 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2038 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2039 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2040 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2041 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2042 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2043 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2044 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2045 --> PACKED_TEXT_STORAGE TX_PS_323;
Array BC_2046 --> PACKED_TEXT_STORAGE TX_PS_126;
Array BC_2047 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2048 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2049 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2050 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2051 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2052 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2053 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2054 --> PACKED_TEXT_STORAGE TX_PS_324;
Array BC_2055 --> PACKED_TEXT_STORAGE TX_PS_131;
Array BC_2056 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2057 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2058 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2059 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2060 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2061 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2062 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2063 --> PACKED_TEXT_STORAGE TX_PS_325;
Array BC_2064 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2065 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2066 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2067 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2068 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2069 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2070 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2071 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2072 --> PACKED_TEXT_STORAGE TX_PS_326;
Array BC_2073 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2074 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2075 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2076 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2077 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2078 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2079 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2080 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2081 --> PACKED_TEXT_STORAGE TX_PS_327;
Array BC_2082 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2083 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2084 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2085 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2086 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2087 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2088 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2089 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2090 --> PACKED_TEXT_STORAGE TX_PS_328;
Array BC_2091 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2092 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2093 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2094 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2095 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2096 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2097 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2098 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2099 --> PACKED_TEXT_STORAGE TX_PS_329;
Array BC_2100 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2101 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2102 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2103 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2104 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2105 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2106 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2107 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2108 --> PACKED_TEXT_STORAGE TX_PS_330;
Array BC_2109 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2110 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2111 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2112 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2113 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2114 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2115 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2116 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2117 --> PACKED_TEXT_STORAGE TX_PS_331;
Array BC_2118 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2119 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2120 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2121 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2122 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2123 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2124 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2125 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2126 --> PACKED_TEXT_STORAGE TX_PS_332;
Array BC_2127 --> LIST_CONST_101244 0;
Array BC_2128 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2129 --> PACKED_TEXT_STORAGE TX_PS_41;
Array BC_2130 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2131 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2132 --> PACKED_TEXT_STORAGE TX_PS_333;
Array BC_2133 --> LIST_CONST_101278 0;
Array BC_2134 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2135 --> PACKED_TEXT_STORAGE TX_PS_41;
Array BC_2136 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2137 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2138 --> PACKED_TEXT_STORAGE TX_PS_334;
Array BC_2139 --> LIST_CONST_101312 0;
Array BC_2140 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2141 --> PACKED_TEXT_STORAGE TX_PS_41;
Array BC_2142 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2143 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2144 --> PACKED_TEXT_STORAGE TX_PS_335;
Array BC_2145 --> LIST_CONST_101342 0;
Array BC_2146 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2147 --> PACKED_TEXT_STORAGE TX_PS_41;
Array BC_2148 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2149 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2150 --> PACKED_TEXT_STORAGE TX_PS_336;
Array BC_2151 --> LIST_CONST_101372 0;
Array BC_2152 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2153 --> PACKED_TEXT_STORAGE TX_PS_41;
Array BC_2154 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2155 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2156 --> PACKED_TEXT_STORAGE TX_PS_337;
Array BC_2157 --> LIST_CONST_101402 0;
Array BC_2158 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2159 --> PACKED_TEXT_STORAGE TX_PS_41;
Array BC_2160 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2161 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2162 --> PACKED_TEXT_STORAGE TX_PS_338;
Array BC_2163 --> LIST_CONST_101436 0;
Array BC_2164 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2165 --> PACKED_TEXT_STORAGE TX_PS_41;
Array BC_2166 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2167 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2168 --> PACKED_TEXT_STORAGE TX_PS_339;
Array BC_2169 --> LIST_CONST_101470 0;
Array BC_2170 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2171 --> PACKED_TEXT_STORAGE TX_PS_41;
Array BC_2172 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2173 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2174 --> PACKED_TEXT_STORAGE TX_PS_340;
Array BC_2175 --> LIST_CONST_101504 0;
Array BC_2176 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2177 --> PACKED_TEXT_STORAGE TX_PS_41;
Array BC_2178 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2179 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2180 --> PACKED_TEXT_STORAGE TX_PS_341;
Array BC_2181 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2182 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2183 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2184 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2185 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2186 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2187 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2188 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2189 --> PACKED_TEXT_STORAGE TX_PS_342;
Array BC_2190 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2191 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2192 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2193 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2194 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2195 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2196 --> PACKED_TEXT_STORAGE TX_PS_26;
Array BC_2197 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2198 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2199 --> PACKED_TEXT_STORAGE TX_PS_343;
Array BC_2200 --> PACKED_TEXT_STORAGE TX_PS_344;
Array BC_2201 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2202 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2203 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2204 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2205 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2206 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2207 --> PACKED_TEXT_STORAGE TX_PS_26;
Array BC_2208 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2209 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2210 --> PACKED_TEXT_STORAGE TX_PS_345;
Array BC_2211 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2212 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2213 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2214 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2215 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2216 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2217 --> PACKED_TEXT_STORAGE TX_PS_26;
Array BC_2218 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2219 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2220 --> PACKED_TEXT_STORAGE TX_PS_346;
Array BC_2221 --> PACKED_TEXT_STORAGE TX_PS_347;
Array BC_2222 --> PACKED_TEXT_STORAGE TX_PS_348;
Array BC_2223 --> LIST_CONST_87571 0;
Array BC_2224 --> Default_Value_0 0;
Array BC_2225 --> Default_Value_1 0;
Array BC_2226 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2227 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2228 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2229 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2230 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2231 --> PACKED_TEXT_STORAGE TX_PS_9;
Array BC_2232 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2233 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2234 --> PACKED_TEXT_STORAGE TX_PS_349;
Array BC_2235 --> PACKED_TEXT_STORAGE TX_PS_350;
Array BC_2236 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2237 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2238 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2239 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2240 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2241 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2242 --> PACKED_TEXT_STORAGE TX_PS_28;
Array BC_2243 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2244 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2245 --> PACKED_TEXT_STORAGE TX_PS_351;
Array BC_2246 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2247 --> PACKED_TEXT_STORAGE TX_PS_39;
Array BC_2248 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2249 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2250 --> PACKED_TEXT_STORAGE TX_PS_352;
Array BC_2251 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2252 --> PACKED_TEXT_STORAGE TX_PS_39;
Array BC_2253 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2254 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2255 --> PACKED_TEXT_STORAGE TX_PS_353;
Array BC_2256 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_179;
Array BC_2257 --> PACKED_TEXT_STORAGE TX_PS_354;
Array BC_2258 --> PACKED_TEXT_STORAGE TX_PS_355;
Array BC_2259 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2260 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2261 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2262 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2263 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2264 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2265 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_2266 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2267 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2268 --> PACKED_TEXT_STORAGE TX_PS_356;
Array BC_2269 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_180;
Array BC_2270 --> PACKED_TEXT_STORAGE TX_PS_357;
Array BC_2271 --> PACKED_TEXT_STORAGE TX_PS_358;
Array BC_2272 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2273 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2274 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2275 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2276 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2277 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2278 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_2279 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2280 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2281 --> PACKED_TEXT_STORAGE TX_PS_359;
Array BC_2282 --> PACKED_TEXT_STORAGE TX_PS_360;
Array BC_2283 --> PACKED_TEXT_STORAGE TX_PS_361;
Array BC_2284 --> LIST_CONST_87571 0;
Array BC_2285 --> Default_Value_0 0;
Array BC_2286 --> Default_Value_1 0;
Array BC_2287 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2288 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2289 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2290 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2291 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2292 --> PACKED_TEXT_STORAGE TX_PS_10;
Array BC_2293 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2294 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2295 --> PACKED_TEXT_STORAGE TX_PS_362;
Array BC_2296 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2297 --> PACKED_TEXT_STORAGE TX_PS_36;
Array BC_2298 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2299 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2300 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_181;
Array BC_2301 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_182;
Array BC_2302 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2303 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2304 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2305 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2306 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2307 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2308 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2309 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_183;
Array BC_2310 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_184;
Array BC_2311 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2312 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2313 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2314 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2315 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2316 --> PACKED_TEXT_STORAGE TX_PS_7;
Array BC_2317 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2318 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2319 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_185;
Array BC_2320 --> PACKED_TEXT_STORAGE TX_PS_363;
Array BC_2321 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2322 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2323 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2324 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2325 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2326 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2327 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2328 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2329 --> PACKED_TEXT_STORAGE TX_PS_364;
Array BC_2330 --> PACKED_TEXT_STORAGE TX_PS_365;
Array BC_2331 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2332 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2333 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2334 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2335 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2336 --> PACKED_TEXT_STORAGE TX_PS_6;
Array BC_2337 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2338 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2339 --> PACKED_TEXT_STORAGE TX_PS_366;
Array BC_2340 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_186;
Array BC_2341 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2342 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2343 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2344 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2345 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2346 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2347 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2348 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2349 --> PACKED_TEXT_STORAGE TX_PS_367;
Array BC_2350 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_187;
Array BC_2351 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2352 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2353 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2354 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2355 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2356 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2357 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2358 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2359 --> PACKED_TEXT_STORAGE TX_PS_368;
Array BC_2360 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_188;
Array BC_2361 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2362 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2363 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2364 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2365 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2366 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2367 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2368 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2369 --> PACKED_TEXT_STORAGE TX_PS_369;
Array BC_2370 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_189;
Array BC_2371 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2372 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2373 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2374 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2375 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2376 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2377 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2378 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2379 --> PACKED_TEXT_STORAGE TX_PS_370;
Array BC_2380 --> PACKED_TEXT_STORAGE TX_PS_371;
Array BC_2381 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2382 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2383 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2384 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2385 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2386 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2387 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2388 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2389 --> PACKED_TEXT_STORAGE TX_PS_372;
Array BC_2390 --> PACKED_TEXT_STORAGE TX_PS_373;
Array BC_2391 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2392 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2393 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2394 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2395 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2396 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2397 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2398 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2399 --> PACKED_TEXT_STORAGE TX_PS_374;
Array BC_2400 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_190;
Array BC_2401 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2402 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2403 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2404 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2405 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2406 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2407 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2408 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2409 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2410 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2411 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2412 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2413 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2414 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2415 --> PACKED_TEXT_STORAGE TX_PS_23;
Array BC_2416 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2417 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2418 --> PACKED_TEXT_STORAGE TX_PS_375;
Array BC_2419 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2420 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2421 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2422 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2423 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2424 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2425 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2426 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2427 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2428 --> PACKED_TEXT_STORAGE TX_PS_376;
Array BC_2429 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2430 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2431 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2432 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2433 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2434 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2435 --> PACKED_TEXT_STORAGE TX_PS_28;
Array BC_2436 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2437 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2438 --> PACKED_TEXT_STORAGE TX_PS_377;
Array BC_2439 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2440 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2441 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2442 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2443 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2444 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2445 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2446 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2447 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2448 --> PACKED_TEXT_STORAGE TX_PS_378;
Array BC_2449 --> PACKED_TEXT_STORAGE TX_PS_44;
Array BC_2450 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2451 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2452 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2453 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2454 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2455 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2456 --> PACKED_TEXT_STORAGE TX_PS_29;
Array BC_2457 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2458 --> PACKED_TEXT_STORAGE TX_PS_379;
Array BC_2459 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2460 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2461 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2462 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2463 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2464 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2465 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2466 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2467 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2468 --> PACKED_TEXT_STORAGE TX_PS_380;
Array BC_2469 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_191;
Array BC_2470 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2471 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2472 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2473 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2474 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2475 --> PACKED_TEXT_STORAGE TX_PS_28;
Array BC_2476 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2477 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2478 --> PACKED_TEXT_STORAGE TX_PS_381;
Array BC_2479 --> PACKED_TEXT_STORAGE TX_PS_382;
Array BC_2480 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2481 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2482 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2483 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2484 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2485 --> PACKED_TEXT_STORAGE TX_PS_13;
Array BC_2486 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2487 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2488 --> PACKED_TEXT_STORAGE TX_PS_383;
Array BC_2489 --> PACKED_TEXT_STORAGE TX_PS_384;
Array BC_2490 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2491 --> PACKED_TEXT_STORAGE TX_PS_40;
Array BC_2492 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2493 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2494 --> PACKED_TEXT_STORAGE TX_PS_385;
Array BC_2495 --> PACKED_TEXT_STORAGE TX_PS_386;
Array BC_2496 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2497 --> PACKED_TEXT_STORAGE TX_PS_40;
Array BC_2498 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2499 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2500 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_192;
Array BC_2501 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2502 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2503 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2504 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2505 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2506 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2507 --> PACKED_TEXT_STORAGE TX_PS_13;
Array BC_2508 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2509 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2510 --> PACKED_TEXT_STORAGE TX_PS_387;
Array BC_2511 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_193;
Array BC_2512 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2513 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2514 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2515 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2516 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2517 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2518 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2519 --> PACKED_TEXT_STORAGE TX_PS_388;
Array BC_2520 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2521 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2522 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2523 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2524 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2525 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2526 --> PACKED_TEXT_STORAGE TX_PS_13;
Array BC_2527 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2528 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2529 --> PACKED_TEXT_STORAGE TX_PS_389;
Array BC_2530 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_194;
Array BC_2531 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2532 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2533 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2534 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2535 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2536 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2537 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2538 --> PACKED_TEXT_STORAGE TX_PS_390;
Array BC_2539 --> PACKED_TEXT_STORAGE TX_PS_391;
Array BC_2540 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2541 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2542 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2543 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2544 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2545 --> PACKED_TEXT_STORAGE TX_PS_6;
Array BC_2546 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2547 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2548 --> PACKED_TEXT_STORAGE TX_PS_392;
Array BC_2549 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2550 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2551 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2552 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2553 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2554 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2555 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2556 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2557 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2558 --> PACKED_TEXT_STORAGE TX_PS_393;
Array BC_2559 --> PACKED_TEXT_STORAGE TX_PS_394;
Array BC_2560 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2561 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2562 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2563 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2564 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2565 --> PACKED_TEXT_STORAGE TX_PS_6;
Array BC_2566 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2567 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2568 --> PACKED_TEXT_STORAGE TX_PS_395;
Array BC_2569 --> PACKED_TEXT_STORAGE TX_PS_396;
Array BC_2570 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2571 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2572 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2573 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2574 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2575 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2576 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2577 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2578 --> PACKED_TEXT_STORAGE TX_PS_397;
Array BC_2579 --> PACKED_TEXT_STORAGE TX_PS_398;
Array BC_2580 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2581 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2582 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2583 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2584 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2585 --> PACKED_TEXT_STORAGE TX_PS_6;
Array BC_2586 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2587 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2588 --> PACKED_TEXT_STORAGE TX_PS_399;
Array BC_2589 --> PACKED_TEXT_STORAGE TX_PS_400;
Array BC_2590 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2591 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2592 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2593 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2594 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2595 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2596 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2597 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2598 --> PACKED_TEXT_STORAGE TX_PS_401;
Array BC_2599 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_195;
Array BC_2600 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2601 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2602 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2603 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2604 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2605 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2606 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2607 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2608 --> PACKED_TEXT_STORAGE TX_PS_402;
Array BC_2609 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_196;
Array BC_2610 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2611 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2612 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2613 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2614 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2615 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2616 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2617 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2618 --> PACKED_TEXT_STORAGE TX_PS_403;
Array BC_2619 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_197;
Array BC_2620 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2621 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2622 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2623 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2624 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2625 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2626 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2627 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2628 --> PACKED_TEXT_STORAGE TX_PS_404;
Array BC_2629 --> PACKED_TEXT_STORAGE TX_PS_405;
Array BC_2630 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2631 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2632 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2633 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2634 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2635 --> PACKED_TEXT_STORAGE TX_PS_6;
Array BC_2636 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2637 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2638 --> PACKED_TEXT_STORAGE TX_PS_406;
Array BC_2639 --> PACKED_TEXT_STORAGE TX_PS_407;
Array BC_2640 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2641 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2642 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2643 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2644 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2645 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2646 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2647 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2648 --> PACKED_TEXT_STORAGE TX_PS_408;
Array BC_2649 --> PACKED_TEXT_STORAGE TX_PS_409;
Array BC_2650 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2651 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2652 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2653 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2654 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2655 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2656 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2657 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2658 --> PACKED_TEXT_STORAGE TX_PS_410;
Array BC_2659 --> PACKED_TEXT_STORAGE TX_PS_411;
Array BC_2660 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2661 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2662 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2663 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2664 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2665 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2666 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2667 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2668 --> PACKED_TEXT_STORAGE TX_PS_412;
Array BC_2669 --> PACKED_TEXT_STORAGE TX_PS_413;
Array BC_2670 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2671 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2672 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2673 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2674 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2675 --> PACKED_TEXT_STORAGE TX_PS_20;
Array BC_2676 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2677 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2678 --> PACKED_TEXT_STORAGE TX_PS_414;
Array BC_2679 --> PACKED_TEXT_STORAGE TX_PS_415;
Array BC_2680 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2681 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2682 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2683 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2684 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2685 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2686 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2687 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2688 --> PACKED_TEXT_STORAGE TX_PS_416;
Array BC_2689 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2690 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2691 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2692 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2693 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2694 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2695 --> PACKED_TEXT_STORAGE TX_PS_13;
Array BC_2696 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2697 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2698 --> PACKED_TEXT_STORAGE TX_PS_417;
Array BC_2699 --> PACKED_TEXT_STORAGE TX_PS_418;
Array BC_2700 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2701 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2702 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2703 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2704 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2705 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2706 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2707 --> PACKED_TEXT_STORAGE TX_PS_419;
Array BC_2708 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2709 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2710 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2711 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2712 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2713 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2714 --> PACKED_TEXT_STORAGE TX_PS_20;
Array BC_2715 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2716 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2717 --> PACKED_TEXT_STORAGE TX_PS_420;
Array BC_2718 --> PACKED_TEXT_STORAGE TX_PS_421;
Array BC_2719 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2720 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2721 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2722 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2723 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2724 --> PACKED_TEXT_STORAGE TX_PS_20;
Array BC_2725 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2726 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2727 --> PACKED_TEXT_STORAGE TX_PS_422;
Array BC_2728 --> PACKED_TEXT_STORAGE TX_PS_423;
Array BC_2729 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2730 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2731 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2732 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2733 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2734 --> PACKED_TEXT_STORAGE TX_PS_25;
Array BC_2735 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2736 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2737 --> PACKED_TEXT_STORAGE TX_PS_424;
Array BC_2738 --> PACKED_TEXT_STORAGE TX_PS_425;
Array BC_2739 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2740 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2741 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2742 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2743 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2744 --> PACKED_TEXT_STORAGE TX_PS_6;
Array BC_2745 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2746 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2747 --> PACKED_TEXT_STORAGE TX_PS_426;
Array BC_2748 --> PACKED_TEXT_STORAGE TX_PS_427;
Array BC_2749 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2750 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2751 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2752 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2753 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2754 --> PACKED_TEXT_STORAGE TX_PS_6;
Array BC_2755 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2756 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2757 --> PACKED_TEXT_STORAGE TX_PS_428;
Array BC_2758 --> PACKED_TEXT_STORAGE TX_PS_429;
Array BC_2759 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2760 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2761 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2762 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2763 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2764 --> PACKED_TEXT_STORAGE TX_PS_6;
Array BC_2765 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2766 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2767 --> PACKED_TEXT_STORAGE TX_PS_430;
Array BC_2768 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2769 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2770 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2771 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2772 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2773 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2774 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2775 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2776 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2777 --> PACKED_TEXT_STORAGE TX_PS_431;
Array BC_2778 --> PACKED_TEXT_STORAGE TX_PS_432;
Array BC_2779 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2780 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2781 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2782 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2783 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2784 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2785 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2786 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2787 --> PACKED_TEXT_STORAGE TX_PS_433;
Array BC_2788 --> PACKED_TEXT_STORAGE TX_PS_434;
Array BC_2789 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2790 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2791 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2792 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2793 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2794 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2795 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2796 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2797 --> PACKED_TEXT_STORAGE TX_PS_435;
Array BC_2798 --> PACKED_TEXT_STORAGE TX_PS_436;
Array BC_2799 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2800 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2801 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2802 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2803 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2804 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2805 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2806 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2807 --> PACKED_TEXT_STORAGE TX_PS_437;
Array BC_2808 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2809 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2810 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2811 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2812 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2813 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2814 --> PACKED_TEXT_STORAGE TX_PS_6;
Array BC_2815 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2816 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2817 --> PACKED_TEXT_STORAGE TX_PS_438;
Array BC_2818 --> PACKED_TEXT_STORAGE TX_PS_439;
Array BC_2819 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2820 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2821 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2822 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2823 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2824 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2825 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2826 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2827 --> PACKED_TEXT_STORAGE TX_PS_440;
Array BC_2828 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2829 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2830 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2831 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2832 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2833 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2834 --> PACKED_TEXT_STORAGE TX_PS_20;
Array BC_2835 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2836 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2837 --> PACKED_TEXT_STORAGE TX_PS_441;
Array BC_2838 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2839 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2840 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2841 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2842 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2843 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2844 --> PACKED_TEXT_STORAGE TX_PS_13;
Array BC_2845 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2846 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2847 --> PACKED_TEXT_STORAGE TX_PS_442;
Array BC_2848 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2849 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2850 --> PACKED_TEXT_STORAGE TX_PS_5;
Array BC_2851 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2852 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2853 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2854 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2855 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2856 --> PACKED_TEXT_STORAGE TX_PS_443;
Array BC_2857 --> PACKED_TEXT_STORAGE TX_PS_444;
Array BC_2858 --> PACKED_TEXT_STORAGE TX_PS_445;
Array BC_2859 --> PACKED_TEXT_STORAGE TX_PS_446;
Array BC_2860 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2861 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2862 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2863 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2864 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2865 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2866 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_2867 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2868 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2869 --> PACKED_TEXT_STORAGE TX_PS_447;
Array BC_2870 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_198;
Array BC_2871 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_199;
Array BC_2872 --> PACKED_TEXT_STORAGE TX_PS_448;
Array BC_2873 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2874 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2875 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2876 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2877 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2878 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2879 --> PACKED_TEXT_STORAGE TX_PS_33;
Array BC_2880 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2881 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2882 --> PACKED_TEXT_STORAGE TX_PS_449;
Array BC_2883 --> LIST_CONST_87571 0;
Array BC_2884 --> Default_Value_0 0;
Array BC_2885 --> Default_Value_1 0;
Array BC_2886 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2887 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2888 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2889 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2890 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2891 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2892 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2893 --> PACKED_TEXT_STORAGE TX_PS_8;
Array BC_2894 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2895 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2896 --> PACKED_TEXT_STORAGE TX_PS_450;
Array BC_2897 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2898 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2899 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2900 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2901 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2902 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2903 --> PACKED_TEXT_STORAGE TX_PS_28;
Array BC_2904 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2905 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2906 --> PACKED_TEXT_STORAGE TX_PS_451;
Array BC_2907 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2908 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2909 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2910 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2911 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2912 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2913 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2914 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2915 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2916 --> PACKED_TEXT_STORAGE TX_PS_452;
Array BC_2917 --> PACKED_TEXT_STORAGE TX_PS_4;
Array BC_2918 --> PACKED_TEXT_STORAGE TX_PS_3;
Array BC_2919 --> PACKED_TEXT_STORAGE TX_PS_453;
Array BC_2920 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2921 --> Default_Value_3 0;
Array BC_2922 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2923 --> PACKED_TEXT_STORAGE TX_PS_454;
Array BC_2924 --> PACKED_TEXT_STORAGE TX_PS_455;
Array BC_2925 --> PACKED_TEXT_STORAGE TX_PS_456;
Array BC_2926 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2927 --> Default_Value_0 0;
Array BC_2928 --> LIST_CONST_91656 0;
Array BC_2929 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2930 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2931 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2932 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2933 --> 0 (101449728) STORED_ACTION_TY MAX_POSITIVE_NUMBER ##Wait 0 0 selfobj false 0;
Array BC_2934 --> Default_Value_4 0;
Array BC_2935 --> PACKED_TEXT_STORAGE TX_PS_457;
Array BC_2936 --> PACKED_TEXT_STORAGE TX_PS_458;
Array BC_2937 --> PACKED_TEXT_STORAGE TX_PS_459;
Array BC_2938 --> PACKED_TEXT_STORAGE TX_PS_460;
Array BC_2939 --> PACKED_TEXT_STORAGE TX_PS_461;
Array BC_2940 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_200;
Array BC_2941 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_2942 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_201;
Array BC_2943 --> PACKED_TEXT_STORAGE TX_PS_462;
Array BC_2944 --> PACKED_TEXT_STORAGE TX_PS_61;
Array BC_2945 --> PACKED_TEXT_STORAGE TX_PS_64;
Array BC_2946 --> PACKED_TEXT_STORAGE TX_PS_67;
Array BC_2947 --> PACKED_TEXT_STORAGE TX_PS_70;
Array BC_2948 --> PACKED_TEXT_STORAGE TX_PS_73;
Array BC_2949 --> PACKED_TEXT_STORAGE TX_PS_76;
Array BC_2950 --> PACKED_TEXT_STORAGE TX_PS_79;
Array BC_2951 --> PACKED_TEXT_STORAGE TX_PS_82;
Array BC_2952 --> PACKED_TEXT_STORAGE TX_PS_85;
Array BC_2953 --> PACKED_TEXT_STORAGE TX_PS_88;
Array BC_2954 --> PACKED_TEXT_STORAGE TX_PS_463;
Array BC_2955 --> PACKED_TEXT_STORAGE TX_PS_463;
Array BC_2956 --> PACKED_TEXT_STORAGE TX_PS_464;
Array BC_2957 --> PACKED_TEXT_STORAGE TX_PS_465;
Array BC_2958 --> PACKED_TEXT_STORAGE TX_PS_454;
Array BC_2959 --> PACKED_TEXT_STORAGE TX_PS_454;
Array BC_2960 --> PACKED_TEXT_STORAGE TX_PS_466;
Array BC_2961 --> PACKED_TEXT_STORAGE TX_PS_454;
Array BC_2962 --> PACKED_TEXT_STORAGE TX_PS_467;
Array BC_2963 --> PACKED_TEXT_STORAGE TX_PS_456;
Array BC_2964 --> PACKED_TEXT_STORAGE TX_PS_468;
Array BC_2965 --> PACKED_TEXT_STORAGE TX_PS_466;
Array BC_2966 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_202;
Array BC_2967 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_203;
Array BC_2968 --> PACKED_TEXT_STORAGE TX_PS_466;
Array BC_2969 --> PACKED_TEXT_STORAGE TX_PS_454;
Array BC_2970 --> PACKED_TEXT_STORAGE TX_PS_467;
Array BC_2971 --> PACKED_TEXT_STORAGE TX_PS_456;
Array BC_2972 --> PACKED_TEXT_STORAGE TX_PS_468;
Array BC_2973 --> PACKED_TEXT_STORAGE TX_PS_466;
Array BC_2974 --> PACKED_TEXT_STORAGE TX_PS_456;
Array BC_2975 --> PACKED_TEXT_STORAGE TX_PS_469;
Array BC_2976 --> PACKED_TEXT_STORAGE TX_PS_456;
Array BC_2977 --> PACKED_TEXT_STORAGE TX_PS_456;
Array BC_2978 --> PACKED_TEXT_STORAGE TX_PS_456;
Array BC_2979 --> PACKED_TEXT_STORAGE TX_PS_456;
Array BC_2980 --> PACKED_TEXT_STORAGE TX_PS_468;
Array BC_2981 --> PACKED_TEXT_STORAGE TX_PS_466;
Array BC_2982 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_204;
Array BC_2983 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_205;
Array BC_2984 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_206;
Array BC_2985 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_207;
Array BC_2986 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_208;
Array BC_2987 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_209;
Array BC_2988 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_210;
Array BC_2989 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_211;
Array BC_2990 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_212;
Array BC_2991 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_213;
Array BC_2992 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_214;
Array BC_2993 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_215;
Array BC_2994 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_216;
Array BC_2995 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_217;
Array BC_2996 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_218;
Array BC_2997 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_219;
Array BC_2998 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_220;
Array BC_2999 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_221;
Array BC_3000 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_3001 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_3002 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_222;
Array BC_3003 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_3004 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_223;
Array BC_3005 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_3006 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_224;
Array BC_3007 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_3008 --> PACKED_TEXT_STORAGE TX_PS_470;
Array BC_3009 --> PACKED_TEXT_STORAGE TX_PS_471;
Array BC_3010 --> PACKED_TEXT_STORAGE TX_PS_472;
Array BC_3011 --> PACKED_TEXT_STORAGE TX_PS_473;
Array BC_3012 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_225;
Array BC_3013 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_226;
Array BC_3014 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_227;
Array BC_3015 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_228;
Array BC_3016 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_229;
Array BC_3017 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_230;
Array BC_3018 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_231;
Array BC_3019 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_232;
Array BC_3020 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_233;
Array BC_3021 --> CONSTANT_PACKED_TEXT_STORAGE R_TX_S_234;
Array BC_3022 --> LIST_CONST_91633 0;
Array BC_3023 --> LIST_CONST_93225 0;
Array BC_3024 --> LIST_CONST_91633 0;
Array BC_3025 --> LIST_CONST_93225 0;
Array BC_3026 --> PACKED_TEXT_STORAGE TX_PS_489;
Array BC_3027 --> PACKED_TEXT_STORAGE TX_PS_490;
Array BC_3028 --> PACKED_TEXT_STORAGE TX_PS_491;
Array BC_3029 --> PACKED_TEXT_STORAGE TX_PS_492;
Array BC_3030 --> PACKED_TEXT_STORAGE TX_PS_493;
Array BC_3031 --> PACKED_TEXT_STORAGE TX_PS_494;
Array BC_3032 --> PACKED_TEXT_STORAGE TX_PS_495;
Array BC_3033 --> PACKED_TEXT_STORAGE TX_PS_496;
Array BC_3034 --> PACKED_TEXT_STORAGE TX_PS_497;
Array BC_3035 --> PACKED_TEXT_STORAGE TX_PS_498;
Array BC_3036 --> PACKED_TEXT_STORAGE TX_PS_499;
Array BC_3037 --> PACKED_TEXT_STORAGE TX_PS_499;
Array BC_3038 --> PACKED_TEXT_STORAGE TX_PS_500;
Array BC_3039 --> PACKED_TEXT_STORAGE TX_PS_501;
Array BC_3040 --> PACKED_TEXT_STORAGE TX_PS_500;
Array BC_3041 --> PACKED_TEXT_STORAGE TX_PS_502;
Array BC_3042 --> PACKED_TEXT_STORAGE TX_PS_503;
Array BC_3043 --> PACKED_TEXT_STORAGE TX_PS_504;
Array BC_3044 --> PACKED_TEXT_STORAGE TX_PS_505;
Array BC_3045 --> PACKED_TEXT_STORAGE TX_PS_504;
Array BC_3046 --> PACKED_TEXT_STORAGE TX_PS_506;
Array BC_3047 --> PACKED_TEXT_STORAGE TX_PS_507;
Array BC_3048 --> PACKED_TEXT_STORAGE TX_PS_508;
Array BC_3049 --> PACKED_TEXT_STORAGE TX_PS_509;
Array BC_3050 --> PACKED_TEXT_STORAGE TX_PS_507;
Array BC_3051 --> PACKED_TEXT_STORAGE TX_PS_510;
Array BC_3052 --> PACKED_TEXT_STORAGE TX_PS_510;
Array BC_3053 --> PACKED_TEXT_STORAGE TX_PS_511;
Array BC_3054 --> PACKED_TEXT_STORAGE TX_PS_280;
Array BC_3055 --> PACKED_TEXT_STORAGE TX_PS_512;
Array BC_3056 --> PACKED_TEXT_STORAGE TX_PS_510;
Array BC_3057 --> PACKED_TEXT_STORAGE TX_PS_510;
Array BC_3058 --> PACKED_TEXT_STORAGE TX_PS_511;
Array BC_3059 --> PACKED_TEXT_STORAGE TX_PS_513;
Array BC_3060 --> PACKED_TEXT_STORAGE TX_PS_498;
Array BC_3061 --> PACKED_TEXT_STORAGE TX_PS_514;
Array BC_3062 --> PACKED_TEXT_STORAGE TX_PS_515;
Array BC_3063 --> PACKED_TEXT_STORAGE TX_PS_516;
Array BC_3064 --> PACKED_TEXT_STORAGE TX_PS_517;
Array BC_3065 --> PACKED_TEXT_STORAGE TX_PS_518;
Array BC_3066 --> PACKED_TEXT_STORAGE TX_PS_514;
Array BC_3067 --> PACKED_TEXT_STORAGE TX_PS_515;
Array BC_3068 --> PACKED_TEXT_STORAGE TX_PS_516;
Array BC_3069 --> PACKED_TEXT_STORAGE TX_PS_519;
Array BC_3070 --> PACKED_TEXT_STORAGE TX_PS_518;
Array BC_3071 --> Default_Value_9 0;
Array BC_3072 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_3073 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_3074 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_3075 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_3076 --> LIST_CONST_91633 0;
Array BC_3077 --> LIST_CONST_91633 0;
Array BC_3078 --> LIST_CONST_91633 0;
Array BC_3079 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_3080 --> LIST_CONST_91633 0;
Array BC_3081 --> LIST_CONST_91633 0;
Array BC_3082 --> LIST_CONST_91633 0;
Array BC_3083 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_3084 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_3085 --> LIST_CONST_87784 0;
Array BC_3086 --> Default_Value_11 0;
Array BC_3087 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_3088 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_3089 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_3090 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_3091 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_3092 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_3093 --> PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;
Array BC_3094 --> Default_Value_7 0;
Array BC_3095 --> Default_Value_11 0;




! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====
! Output.i6t: Signing off
! ==== ==== ==== ==== ==== ==== ==== ==== ==== ====

! End of automatically generated I6 source
! --------------------------------------------------------------------------
